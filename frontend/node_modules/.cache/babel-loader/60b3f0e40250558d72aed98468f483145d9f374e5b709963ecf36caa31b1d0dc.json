{"ast":null,"code":"const definitions = require(\"../src/definitions\");\nconst flatMap = require(\"array.prototype.flatmap\");\nconst {\n  typeSignature,\n  mapProps,\n  iterateProps,\n  unique\n} = require(\"./util\");\nconst stdout = process.stdout;\nfunction params(fields) {\n  return mapProps(fields).map(typeSignature).join(\",\");\n}\nfunction generate() {\n  stdout.write(`\n    // @flow\n    /* eslint no-unused-vars: off */\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateTypeDefinitions.js\n  `);\n\n  // generate union types\n  const unionTypes = unique(flatMap(mapProps(definitions).filter(d => d.unionType), d => d.unionType));\n  unionTypes.forEach(unionType => {\n    stdout.write(`type ${unionType} = ` + mapProps(definitions).filter(d => d.unionType && d.unionType.includes(unionType)).map(d => d.name).join(\"|\") + \";\\n\\n\");\n  });\n\n  // generate the type definitions\n  iterateProps(definitions, typeDef => {\n    stdout.write(`type ${typeDef.name} = {\n        ...BaseNode,\n        type: \"${typeDef.name}\",\n        ${params(typeDef.fields)}\n      };\\n\\n`);\n  });\n}\ngenerate();","map":{"version":3,"names":["definitions","require","flatMap","typeSignature","mapProps","iterateProps","unique","stdout","process","params","fields","map","join","generate","write","unionTypes","filter","d","unionType","forEach","includes","name","typeDef"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/scripts/generateTypeDefinitions.js"],"sourcesContent":["const definitions = require(\"../src/definitions\");\nconst flatMap = require(\"array.prototype.flatmap\");\nconst { typeSignature, mapProps, iterateProps, unique } = require(\"./util\");\n\nconst stdout = process.stdout;\n\nfunction params(fields) {\n  return mapProps(fields).map(typeSignature).join(\",\");\n}\n\nfunction generate() {\n  stdout.write(`\n    // @flow\n    /* eslint no-unused-vars: off */\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateTypeDefinitions.js\n  `);\n\n  // generate union types\n  const unionTypes = unique(\n    flatMap(\n      mapProps(definitions).filter((d) => d.unionType),\n      (d) => d.unionType\n    )\n  );\n  unionTypes.forEach((unionType) => {\n    stdout.write(\n      `type ${unionType} = ` +\n        mapProps(definitions)\n          .filter((d) => d.unionType && d.unionType.includes(unionType))\n          .map((d) => d.name)\n          .join(\"|\") +\n        \";\\n\\n\"\n    );\n  });\n\n  // generate the type definitions\n  iterateProps(definitions, (typeDef) => {\n    stdout.write(`type ${typeDef.name} = {\n        ...BaseNode,\n        type: \"${typeDef.name}\",\n        ${params(typeDef.fields)}\n      };\\n\\n`);\n  });\n}\n\ngenerate();\n"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAMC,OAAO,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAClD,MAAM;EAAEE,aAAa;EAAEC,QAAQ;EAAEC,YAAY;EAAEC;AAAO,CAAC,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAE3E,MAAMM,MAAM,GAAGC,OAAO,CAACD,MAAM;AAE7B,SAASE,MAAMA,CAACC,MAAM,EAAE;EACtB,OAAON,QAAQ,CAACM,MAAM,CAAC,CAACC,GAAG,CAACR,aAAa,CAAC,CAACS,IAAI,CAAC,GAAG,CAAC;AACtD;AAEA,SAASC,QAAQA,CAAA,EAAG;EAClBN,MAAM,CAACO,KAAK,CAAE;AAChB;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;;EAEF;EACA,MAAMC,UAAU,GAAGT,MAAM,CACvBJ,OAAO,CACLE,QAAQ,CAACJ,WAAW,CAAC,CAACgB,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,SAAS,CAAC,EAC/CD,CAAC,IAAKA,CAAC,CAACC,SACX,CACF,CAAC;EACDH,UAAU,CAACI,OAAO,CAAED,SAAS,IAAK;IAChCX,MAAM,CAACO,KAAK,CACT,QAAOI,SAAU,KAAI,GACpBd,QAAQ,CAACJ,WAAW,CAAC,CAClBgB,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,SAAS,IAAID,CAAC,CAACC,SAAS,CAACE,QAAQ,CAACF,SAAS,CAAC,CAAC,CAC7DP,GAAG,CAAEM,CAAC,IAAKA,CAAC,CAACI,IAAI,CAAC,CAClBT,IAAI,CAAC,GAAG,CAAC,GACZ,OACJ,CAAC;EACH,CAAC,CAAC;;EAEF;EACAP,YAAY,CAACL,WAAW,EAAGsB,OAAO,IAAK;IACrCf,MAAM,CAACO,KAAK,CAAE,QAAOQ,OAAO,CAACD,IAAK;AACtC;AACA,iBAAiBC,OAAO,CAACD,IAAK;AAC9B,UAAUZ,MAAM,CAACa,OAAO,CAACZ,MAAM,CAAE;AACjC,aAAa,CAAC;EACZ,CAAC,CAAC;AACJ;AAEAG,QAAQ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}