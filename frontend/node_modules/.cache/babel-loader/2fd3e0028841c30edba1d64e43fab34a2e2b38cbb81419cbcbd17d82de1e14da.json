{"ast":null,"code":"// This is a patch for mozilla/source-map#349 -\n// internally, it uses the existence of the `fetch` global to toggle browser behaviours.\n// That check, however, will break when `fetch` polyfills are used for SSR setups.\n// We \"reset\" the polyfill here to ensure it won't interfere with source-map generation.\nconst originalFetch = global.fetch;\ndelete global.fetch;\nconst {\n  getOptions\n} = require('loader-utils');\nconst {\n  validate: validateOptions\n} = require('schema-utils');\nconst {\n  SourceMapConsumer,\n  SourceNode\n} = require('source-map');\nconst {\n  getIdentitySourceMap,\n  getModuleSystem,\n  getRefreshModuleRuntime,\n  normalizeOptions\n} = require('./utils');\nconst schema = require('./options.json');\nconst RefreshRuntimePath = require.resolve('react-refresh').replace(/\\\\/g, '/').replace(/'/g, \"\\\\'\");\n\n/**\n * A simple Webpack loader to inject react-refresh HMR code into modules.\n *\n * [Reference for Loader API](https://webpack.js.org/api/loaders/)\n * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>}\n * @param {string} source The original module source code.\n * @param {import('source-map').RawSourceMap} [inputSourceMap] The source map of the module.\n * @param {*} [meta] The loader metadata passed in.\n * @returns {void}\n */\nfunction ReactRefreshLoader(source, inputSourceMap, meta) {\n  let options = getOptions(this);\n  validateOptions(schema, options, {\n    baseDataPath: 'options',\n    name: 'React Refresh Loader'\n  });\n  options = normalizeOptions(options);\n  const callback = this.async();\n  const {\n    ModuleFilenameHelpers,\n    Template\n  } = this._compiler.webpack || require('webpack');\n  const RefreshSetupRuntimes = {\n    cjs: Template.asString(`__webpack_require__.$Refresh$.runtime = require('${RefreshRuntimePath}');`),\n    esm: Template.asString([`import * as __react_refresh_runtime__ from '${RefreshRuntimePath}';`, `__webpack_require__.$Refresh$.runtime = __react_refresh_runtime__;`])\n  };\n\n  /**\n   * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>}\n   * @param {string} source\n   * @param {import('source-map').RawSourceMap} [inputSourceMap]\n   * @returns {Promise<[string, import('source-map').RawSourceMap]>}\n   */\n  async function _loader(source, inputSourceMap) {\n    /** @type {'esm' | 'cjs'} */\n    const moduleSystem = await getModuleSystem.call(this, ModuleFilenameHelpers, options);\n    const RefreshSetupRuntime = RefreshSetupRuntimes[moduleSystem];\n    const RefreshModuleRuntime = getRefreshModuleRuntime(Template, {\n      const: options.const,\n      moduleSystem\n    });\n    if (this.sourceMap) {\n      let originalSourceMap = inputSourceMap;\n      if (!originalSourceMap) {\n        originalSourceMap = getIdentitySourceMap(source, this.resourcePath);\n      }\n      return SourceMapConsumer.with(originalSourceMap, undefined, consumer => {\n        const node = SourceNode.fromStringWithSourceMap(source, consumer);\n        node.prepend([RefreshSetupRuntime, '\\n\\n']);\n        node.add(['\\n\\n', RefreshModuleRuntime]);\n        const {\n          code,\n          map\n        } = node.toStringWithSourceMap();\n        return [code, map.toJSON()];\n      });\n    } else {\n      return [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\\n\\n'), inputSourceMap];\n    }\n  }\n  _loader.call(this, source, inputSourceMap).then(([code, map]) => {\n    callback(null, code, map, meta);\n  }, error => {\n    callback(error);\n  });\n}\nmodule.exports = ReactRefreshLoader;\n\n// Restore the original value of the `fetch` global, if it exists\nif (originalFetch) {\n  global.fetch = originalFetch;\n}","map":{"version":3,"names":["originalFetch","global","fetch","getOptions","require","validate","validateOptions","SourceMapConsumer","SourceNode","getIdentitySourceMap","getModuleSystem","getRefreshModuleRuntime","normalizeOptions","schema","RefreshRuntimePath","resolve","replace","ReactRefreshLoader","source","inputSourceMap","meta","options","baseDataPath","name","callback","async","ModuleFilenameHelpers","Template","_compiler","webpack","RefreshSetupRuntimes","cjs","asString","esm","_loader","moduleSystem","call","RefreshSetupRuntime","RefreshModuleRuntime","const","sourceMap","originalSourceMap","resourcePath","with","undefined","consumer","node","fromStringWithSourceMap","prepend","add","code","map","toStringWithSourceMap","toJSON","join","then","error","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js"],"sourcesContent":["// This is a patch for mozilla/source-map#349 -\n// internally, it uses the existence of the `fetch` global to toggle browser behaviours.\n// That check, however, will break when `fetch` polyfills are used for SSR setups.\n// We \"reset\" the polyfill here to ensure it won't interfere with source-map generation.\nconst originalFetch = global.fetch;\ndelete global.fetch;\n\nconst { getOptions } = require('loader-utils');\nconst { validate: validateOptions } = require('schema-utils');\nconst { SourceMapConsumer, SourceNode } = require('source-map');\nconst {\n  getIdentitySourceMap,\n  getModuleSystem,\n  getRefreshModuleRuntime,\n  normalizeOptions,\n} = require('./utils');\nconst schema = require('./options.json');\n\nconst RefreshRuntimePath = require\n  .resolve('react-refresh')\n  .replace(/\\\\/g, '/')\n  .replace(/'/g, \"\\\\'\");\n\n/**\n * A simple Webpack loader to inject react-refresh HMR code into modules.\n *\n * [Reference for Loader API](https://webpack.js.org/api/loaders/)\n * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>}\n * @param {string} source The original module source code.\n * @param {import('source-map').RawSourceMap} [inputSourceMap] The source map of the module.\n * @param {*} [meta] The loader metadata passed in.\n * @returns {void}\n */\nfunction ReactRefreshLoader(source, inputSourceMap, meta) {\n  let options = getOptions(this);\n  validateOptions(schema, options, {\n    baseDataPath: 'options',\n    name: 'React Refresh Loader',\n  });\n\n  options = normalizeOptions(options);\n\n  const callback = this.async();\n\n  const { ModuleFilenameHelpers, Template } = this._compiler.webpack || require('webpack');\n\n  const RefreshSetupRuntimes = {\n    cjs: Template.asString(\n      `__webpack_require__.$Refresh$.runtime = require('${RefreshRuntimePath}');`\n    ),\n    esm: Template.asString([\n      `import * as __react_refresh_runtime__ from '${RefreshRuntimePath}';`,\n      `__webpack_require__.$Refresh$.runtime = __react_refresh_runtime__;`,\n    ]),\n  };\n\n  /**\n   * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>}\n   * @param {string} source\n   * @param {import('source-map').RawSourceMap} [inputSourceMap]\n   * @returns {Promise<[string, import('source-map').RawSourceMap]>}\n   */\n  async function _loader(source, inputSourceMap) {\n    /** @type {'esm' | 'cjs'} */\n    const moduleSystem = await getModuleSystem.call(this, ModuleFilenameHelpers, options);\n\n    const RefreshSetupRuntime = RefreshSetupRuntimes[moduleSystem];\n    const RefreshModuleRuntime = getRefreshModuleRuntime(Template, {\n      const: options.const,\n      moduleSystem,\n    });\n\n    if (this.sourceMap) {\n      let originalSourceMap = inputSourceMap;\n      if (!originalSourceMap) {\n        originalSourceMap = getIdentitySourceMap(source, this.resourcePath);\n      }\n\n      return SourceMapConsumer.with(originalSourceMap, undefined, (consumer) => {\n        const node = SourceNode.fromStringWithSourceMap(source, consumer);\n\n        node.prepend([RefreshSetupRuntime, '\\n\\n']);\n        node.add(['\\n\\n', RefreshModuleRuntime]);\n\n        const { code, map } = node.toStringWithSourceMap();\n        return [code, map.toJSON()];\n      });\n    } else {\n      return [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\\n\\n'), inputSourceMap];\n    }\n  }\n\n  _loader.call(this, source, inputSourceMap).then(\n    ([code, map]) => {\n      callback(null, code, map, meta);\n    },\n    (error) => {\n      callback(error);\n    }\n  );\n}\n\nmodule.exports = ReactRefreshLoader;\n\n// Restore the original value of the `fetch` global, if it exists\nif (originalFetch) {\n  global.fetch = originalFetch;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}