{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\nvar _remove = _interopRequireDefault(require(\"./remove\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n  return false;\n}\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n  var answer = false;\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n  return answer;\n}\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n  if (set1.size !== set2.size) {\n    return false;\n  }\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n  return memberExpression.get('object');\n}\nfunction _default(api) {\n  var template = api.template,\n    types = api.types,\n    traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n        return;\n      }\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n              RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n              as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n            var plugin = require(pluginName);\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n              scope = path.scope;\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n              scope = path.scope;\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n            if (!binding) {\n              return;\n            }\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n            var name = path.node.id.name;\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n            var _path$scope$getBindin = path.scope.getBinding(name),\n              referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                  source = _path$node.source,\n                  specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n                  return source.value === library;\n                });\n                if (!found) {\n                  return;\n                }\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                    referencePaths = _path$scope$getBindin2.referencePaths;\n                  return referencePaths.length > 0;\n                });\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_isAnnotatedForRemoval","_interopRequireDefault","require","_isStatelessComponent","_remove","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","isPathReactClass","path","globalOptions","node","matchers","classNameMatchers","matchesPattern","name","test","isReactClass","superClass","scope","answer","className","binding","getBinding","bindingSuperClass","get","areSetsEqual","set1","set2","size","Array","from","some","item","has","memberExpressionRootIdentifier","parent","findParent","p","isMemberExpression","type","memberExpression","object","api","template","types","traverse","nestedIdentifiers","Set","removedPaths","WeakSet","collectNestedIdentifiers","Identifier","root","add","shorthand","visitor","Program","programPath","state","ignoreFilenames","opts","RegExp","join","undefined","visitedKey","Date","now","unsafeWrapTemplate","placeholderPattern","wrapTemplate","_ref","LEFT","RIGHT","options","_options$as","as","right","expression","variableDeclarator","assignmentExpression","Error","mode","removeImport","libraries","additionalLibraries","createReactClassName","plugins","pluginsState","pluginsVisitors","map","pluginOpts","pluginName","plugin","visitors","merge","parentPath","ObjectProperty","exit","computed","currentNode","property","ClassProperty","pathClassDeclaration","AssignmentExpression","left","forceRemoval","isClassDeclaration","skippedIdentifiers","removeNewlyUnusedIdentifiers","VariableDeclarator","block","includes","id","_path$scope$getBindin","referencePaths","hasRemainingReferencePaths","referencePath","found","find","path2","delete","lastNestedIdentifiers","crawl","ImportDeclaration","_path$node","specifiers","library","haveUsedSpecifiers","specifier","importedIdentifierName","local","_path$scope$getBindin2","remove"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\n\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\n\nvar _remove = _interopRequireDefault(require(\"./remove\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  var answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nfunction _default(api) {\n  var template = api.template,\n      types = api.types,\n      traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n                RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n                as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n\n            var plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            var name = path.node.id.name;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            var _path$scope$getBindin = path.scope.getBinding(name),\n                referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                    source = _path$node.source,\n                    specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                      referencePaths = _path$scope$getBindin2.referencePaths;\n\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}