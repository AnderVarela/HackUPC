{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\nfunction findOutermostTransparentParent(path) {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\nconst last = arr => arr[arr.length - 1];\nfunction isSimpleMemberExpression(expression) {\n  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);\n  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n}\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const {\n    scope\n  } = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get(\"object\") : optionalPath.get(\"callee\"));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n    optionalPath = childPath;\n  }\n}\nconst NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);\nconst NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);\nconst NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);\nconst NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);\nfunction transformOptionalChain(path, {\n  pureGetters,\n  noDocumentAll\n}, replacementPath, ifNullish, wrapLast) {\n  const {\n    scope\n  } = path;\n  if (scope.path.isPattern() && needsMemoize(path)) {\n    replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node})()`);\n    return;\n  }\n  const optionals = [];\n  let optionalPath = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath.node.type = \"MemberExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath.node.type = \"CallExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n  if (optionals.length === 0) {\n    return;\n  }\n  const checks = [];\n  let tmpVar;\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n    const isCall = core.types.isCallExpression(node);\n    const chainWithTypes = isCall ? node.callee : node.object;\n    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);\n    let ref;\n    let check;\n    if (isCall && core.types.isIdentifier(chain, {\n      name: \"eval\"\n    })) {\n      check = ref = chain;\n      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      check = ref = node.callee;\n    } else if (scope.isStatic(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      if (!tmpVar || isCall) {\n        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);\n        scope.push({\n          id: core.types.cloneNode(tmpVar)\n        });\n      }\n      ref = tmpVar;\n      check = core.types.assignmentExpression(\"=\", core.types.cloneNode(tmpVar), chainWithTypes);\n      isCall ? node.callee = ref : node.object = ref;\n    }\n    if (isCall && core.types.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        node.callee = chainWithTypes;\n      } else {\n        const {\n          object\n        } = chain;\n        let context;\n        if (core.types.isSuper(object)) {\n          context = core.types.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = core.types.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n        node.arguments.unshift(core.types.cloneNode(context));\n        node.callee = core.types.memberExpression(node.callee, core.types.identifier(\"call\"));\n      }\n    }\n    const data = {\n      check: core.types.cloneNode(check),\n      ref: core.types.cloneNode(ref)\n    };\n    Object.defineProperty(data, \"ref\", {\n      enumerable: false\n    });\n    checks.push(data);\n  }\n  let result = replacementPath.node;\n  if (wrapLast) result = wrapLast(result);\n  const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);\n  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;\n  const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {\n    operator: \"void\"\n  });\n  const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;\n  const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;\n  const logicalOp = ifNullishFalse ? \"&&\" : \"||\";\n  const check = checks.map(tpl).reduce((expr, check) => core.types.logicalExpression(logicalOp, expr, check));\n  replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));\n}\nfunction transform(path, assumptions) {\n  const {\n    scope\n  } = path;\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isUnaryExpression({\n    operator: \"delete\"\n  })) {\n    transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));\n  } else {\n    let wrapLast;\n    if (parentPath.isCallExpression({\n      callee: maybeWrapped.node\n    }) && path.isOptionalMemberExpression()) {\n      wrapLast = replacement => {\n        var _baseRef;\n        const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);\n        let baseRef;\n        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {\n          baseRef = scope.maybeGenerateMemoised(object);\n          if (baseRef) {\n            replacement.object = core.types.assignmentExpression(\"=\", baseRef, object);\n          }\n        }\n        return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier(\"bind\")), [core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n      };\n    }\n    transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);\n  }\n}\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(\"^7.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const {\n    loose = false\n  } = options;\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : loose;\n  return {\n    name: \"transform-optional-chaining\",\n    inherits: api.version[0] === \"8\" ? undefined : require(\"@babel/plugin-syntax-optional-chaining\").default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, {\n          noDocumentAll,\n          pureGetters\n        });\n      }\n    }\n  };\n});\nexports.default = index;\nexports.transform = transform;\nexports.transformOptionalChain = transformOptionalChain;","map":{"version":3,"names":["willPathCastToBoolean","path","maybeWrapped","findOutermostTransparentParent","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","findParent","p","helperSkipTransparentExpressionWrappers","isTransparentExprWrapper","last","arr","isSimpleMemberExpression","expression","skipTransparentExprWrapperNodes","core","types","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","childPath","skipTransparentExprWrappers","get","optional","isStatic","NULLISH_CHECK","template","NULLISH_CHECK_NO_DDA","NULLISH_CHECK_NEG","NULLISH_CHECK_NO_DDA_NEG","transformOptionalChain","pureGetters","noDocumentAll","replacementPath","ifNullish","wrapLast","isPattern","replaceWith","ast","optionals","push","type","checks","tmpVar","i","isCall","isCallExpression","chainWithTypes","callee","chain","ref","check","name","sequenceExpression","numericLiteral","generateUidIdentifierBasedOnNode","id","cloneNode","assignmentExpression","context","thisExpression","memoized","maybeGenerateMemoised","arguments","unshift","memberExpression","identifier","data","Object","defineProperty","enumerable","result","ifNullishBoolean","isBooleanLiteral","ifNullishFalse","value","ifNullishVoid","isEvaluationValueIgnored","isExpressionStatement","parent","isCompletionRecord","tpl","logicalOp","map","reduce","expr","logicalExpression","conditionalExpression","transform","assumptions","booleanLiteral","replacement","_baseRef","baseRef","callExpression","buildUndefinedNode","index","helperPluginUtils","declare","api","options","_api$assumption","_api$assumption2","assertVersion","loose","assumption","inherits","version","undefined","require","default","visitor","OptionalCallExpression|OptionalMemberExpression"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\util.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\transform.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-optional-chaining\\src\\index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport {\n  willPathCastToBoolean,\n  findOutermostTransparentParent,\n} from \"./util.ts\";\n\n// TODO(Babel 9): Use .at(-1)\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isSimpleMemberExpression(\n  expression: t.Expression | t.Super,\n): expression is t.Identifier | t.Super | t.MemberExpression {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n) {\n  let optionalPath: NodePath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childPath = skipTransparentExprWrappers(\n      optionalPath.isOptionalMemberExpression()\n        ? optionalPath.get(\"object\")\n        : optionalPath.get(\"callee\"),\n    );\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nconst NULLISH_CHECK = template.expression(\n  `%%check%% === null || %%ref%% === void 0`,\n);\nconst NULLISH_CHECK_NO_DDA = template.expression(`%%check%% == null`);\nconst NULLISH_CHECK_NEG = template.expression(\n  `%%check%% !== null && %%ref%% !== void 0`,\n);\nconst NULLISH_CHECK_NO_DDA_NEG = template.expression(`%%check%% != null`);\n\ninterface OptionalChainAssumptions {\n  pureGetters: boolean;\n  noDocumentAll: boolean;\n}\n\nexport function transformOptionalChain(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  { pureGetters, noDocumentAll }: OptionalChainAssumptions,\n  replacementPath: NodePath<t.Expression>,\n  ifNullish: t.Expression,\n  wrapLast?: (value: t.Expression) => t.Expression,\n) {\n  const { scope } = path;\n\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(path)) {\n    replacementPath.replaceWith(\n      template.expression.ast`(() => ${replacementPath.node})()`,\n    );\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n\n  const optionals = [];\n\n  let optionalPath = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  if (optionals.length === 0) {\n    // Malformed AST: there was an OptionalMemberExpression node\n    // with no actual optional elements.\n    return;\n  }\n\n  const checks = [];\n\n  let tmpVar;\n\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i] as unknown as\n      | t.MemberExpression\n      | t.CallExpression;\n\n    const isCall = t.isCallExpression(node);\n\n    const chainWithTypes = isCall\n      ? // V8 intrinsics must not be an optional call\n        (node.callee as t.Expression)\n      : node.object;\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node.callee = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = node.callee;\n    } else if (scope.isStatic(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      // We cannot reuse the tmpVar for calls, because we need to\n      // store both the method and the receiver.\n      if (!tmpVar || isCall) {\n        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);\n        scope.push({ id: t.cloneNode(tmpVar) });\n      }\n      ref = tmpVar;\n      check = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(tmpVar),\n        // Here `chainWithTypes` MUST NOT be cloned because it could be\n        // updated when generating the memoised context of a call\n        // expression. It must be an Expression when `ref` is an identifier\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        chainWithTypes as t.Expression,\n      );\n\n      isCall ? (node.callee = ref) : (node.object = ref);\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n        node.callee = chainWithTypes;\n      } else {\n        // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n        const { object } = chain;\n        let context: t.Expression;\n        if (t.isSuper(object)) {\n          context = t.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = t.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n\n        node.arguments.unshift(t.cloneNode(context));\n        // @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain\n        node.callee = t.memberExpression(node.callee, t.identifier(\"call\"));\n      }\n    }\n\n    const data = { check: t.cloneNode(check), ref: t.cloneNode(ref) };\n    // We make `ref` non-enumerable, so that @babel/template doesn't throw\n    // in the noDocumentAll template if it's not used.\n    Object.defineProperty(data, \"ref\", { enumerable: false });\n    checks.push(data);\n  }\n\n  let result = replacementPath.node;\n  if (wrapLast) result = wrapLast(result);\n\n  const ifNullishBoolean = t.isBooleanLiteral(ifNullish);\n  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;\n  const ifNullishVoid =\n    !ifNullishBoolean && t.isUnaryExpression(ifNullish, { operator: \"void\" });\n\n  const isEvaluationValueIgnored =\n    (t.isExpressionStatement(replacementPath.parent) &&\n      !replacementPath.isCompletionRecord()) ||\n    (t.isSequenceExpression(replacementPath.parent) &&\n      last(replacementPath.parent.expressions) !== replacementPath.node);\n\n  // prettier-ignore\n  const tpl = ifNullishFalse\n    ? (noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG)\n    : (noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK);\n  const logicalOp = ifNullishFalse ? \"&&\" : \"||\";\n\n  const check = checks\n    .map(tpl)\n    .reduce((expr, check) => t.logicalExpression(logicalOp, expr, check));\n\n  replacementPath.replaceWith(\n    ifNullishBoolean || (ifNullishVoid && isEvaluationValueIgnored)\n      ? t.logicalExpression(logicalOp, check, result)\n      : t.conditionalExpression(check, ifNullish, result),\n  );\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  assumptions: OptionalChainAssumptions,\n) {\n  const { scope } = path;\n\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    transformOptionalChain(\n      path,\n      assumptions,\n      parentPath,\n      t.booleanLiteral(true),\n    );\n  } else {\n    let wrapLast;\n    if (\n      parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n      // note that the first condition must implies that `path.optional` is `true`,\n      // otherwise the parentPath should be an OptionalCallExpression\n      path.isOptionalMemberExpression()\n    ) {\n      // Ensure (a?.b)() has proper `this`\n      wrapLast = (replacement: t.MemberExpression) => {\n        // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n        // object must not be Super as super?.foo is invalid\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        const object = skipTransparentExprWrapperNodes(\n          replacement.object,\n        ) as t.Expression;\n        let baseRef: t.Expression;\n        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {\n          // memoize the context object when getters are not always pure\n          // or the object is not a simple member expression\n          // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n          baseRef = scope.maybeGenerateMemoised(object);\n          if (baseRef) {\n            replacement.object = t.assignmentExpression(\"=\", baseRef, object);\n          }\n        }\n        return t.callExpression(\n          t.memberExpression(replacement, t.identifier(\"bind\")),\n          [t.cloneNode(baseRef ?? object)],\n        );\n      };\n    }\n\n    transformOptionalChain(\n      path,\n      assumptions,\n      path,\n      willPathCastToBoolean(maybeWrapped)\n        ? t.booleanLiteral(false)\n        : scope.buildUndefinedNode(),\n      wrapLast,\n    );\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { transform, transformOptionalChain } from \"./transform.ts\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { loose = false } = options;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n\n  return {\n    name: \"transform-optional-chaining\",\n    inherits:\n      USE_ESM || IS_STANDALONE || api.version[0] === \"8\"\n        ? undefined\n        : // eslint-disable-next-line no-restricted-globals\n          require(\"@babel/plugin-syntax-optional-chaining\").default,\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(\n        path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n      ) {\n        transform(path, { noDocumentAll, pureGetters });\n      },\n    },\n  };\n});\n\nexport { transform, transformOptionalChain };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}