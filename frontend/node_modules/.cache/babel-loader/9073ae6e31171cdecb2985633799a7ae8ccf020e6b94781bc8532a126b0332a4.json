{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\nvar _cleanupSemantic = require('./cleanupSemantic');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\nconst printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';\nconst printDeleteLine = (line, isFirstOrLast, {\n  aColor,\n  aIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\nconst printInsertLine = (line, isFirstOrLast, {\n  bColor,\n  bIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\nconst printCommonLine = (line, isFirstOrLast, {\n  commonColor,\n  commonIndicator,\n  commonLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder); // In GNU diff format, indexes are one-based instead of zero-based.\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {\n  patchColor\n}) => patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`); // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\nconst joinAlignedDiffsExpand = (diffs, options) => diffs.map((diff, i, diffs) => {\n  const line = diff[1];\n  const isFirstOrLast = i === 0 || i === diffs.length - 1;\n  switch (diff[0]) {\n    case _cleanupSemantic.DIFF_DELETE:\n      return printDeleteLine(line, isFirstOrLast, options);\n    case _cleanupSemantic.DIFF_INSERT:\n      return printInsertLine(line, isFirstOrLast, options);\n    default:\n      return printCommonLine(line, isFirstOrLast, options);\n  }\n}).join('\\n');\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;","map":{"version":3,"names":["Object","defineProperty","exports","value","joinAlignedDiffsNoExpand","joinAlignedDiffsExpand","_cleanupSemantic","require","formatTrailingSpaces","line","trailingSpaceFormatter","replace","match","printDiffLine","isFirstOrLast","color","indicator","emptyFirstOrLastLinePlaceholder","length","printDeleteLine","aColor","aIndicator","changeLineTrailingSpaceColor","printInsertLine","bColor","bIndicator","printCommonLine","commonColor","commonIndicator","commonLineTrailingSpaceColor","createPatchMark","aStart","aEnd","bStart","bEnd","patchColor","diffs","options","iLength","nContextLines","contextLines","nContextLines2","jLength","hasExcessAtStartOrEnd","nExcessesBetweenChanges","i","iStart","DIFF_EQUAL","n","hasPatch","jLast","lines","jPatchMark","push","pushCommonLine","j","pushDeleteLine","pushInsertLine","iCommon","iEnd","nCommon","nOmit","DIFF_DELETE","DIFF_INSERT","join","map","diff"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/globals/node_modules/jest-diff/build/joinAlignedDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) =>\n  line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n  line,\n  isFirstOrLast,\n  color,\n  indicator,\n  trailingSpaceFormatter,\n  emptyFirstOrLastLinePlaceholder\n) =>\n  line.length !== 0\n    ? color(\n        indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)\n      )\n    : indicator !== ' '\n    ? color(indicator)\n    : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n    ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder)\n    : '';\n\nconst printDeleteLine = (\n  line,\n  isFirstOrLast,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printInsertLine = (\n  line,\n  isFirstOrLast,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printCommonLine = (\n  line,\n  isFirstOrLast,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  ); // In GNU diff format, indexes are one-based instead of zero-based.\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {patchColor}) =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n\n  while (i !== iLength) {\n    const iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n  i = 0;\n\n  while (i !== iLength) {\n    let iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n          );\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\n\nconst joinAlignedDiffsExpand = (diffs, options) =>\n  diffs\n    .map((diff, i, diffs) => {\n      const line = diff[1];\n      const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n      switch (diff[0]) {\n        case _cleanupSemantic.DIFF_DELETE:\n          return printDeleteLine(line, isFirstOrLast, options);\n\n        case _cleanupSemantic.DIFF_INSERT:\n          return printInsertLine(line, isFirstOrLast, options);\n\n        default:\n          return printCommonLine(line, isFirstOrLast, options);\n      }\n    })\n    .join('\\n');\n\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}