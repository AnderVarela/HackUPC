{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'consistent-type-assertions',\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    hasSuggestions: true,\n    docs: {\n      description: 'Enforce consistent usage of type assertions',\n      recommended: 'strict'\n    },\n    messages: {\n      as: \"Use 'as {{cast}}' instead of '<{{cast}}>'.\",\n      'angle-bracket': \"Use '<{{cast}}>' instead of 'as {{cast}}'.\",\n      never: 'Do not use any type assertions.',\n      unexpectedObjectTypeAssertion: 'Always prefer const x: T = { ... }.',\n      replaceObjectTypeAssertionWithAnnotation: 'Use const x: {{cast}} = { ... } instead.',\n      replaceObjectTypeAssertionWithSatisfies: 'Use const x = { ... } satisfies {{cast}} instead.'\n    },\n    schema: [{\n      oneOf: [{\n        type: 'object',\n        properties: {\n          assertionStyle: {\n            enum: ['never']\n          }\n        },\n        additionalProperties: false,\n        required: ['assertionStyle']\n      }, {\n        type: 'object',\n        properties: {\n          assertionStyle: {\n            enum: ['as', 'angle-bracket']\n          },\n          objectLiteralTypeAssertions: {\n            enum: ['allow', 'allow-as-parameter', 'never']\n          }\n        },\n        additionalProperties: false,\n        required: ['assertionStyle']\n      }]\n    }]\n  },\n  defaultOptions: [{\n    assertionStyle: 'as',\n    objectLiteralTypeAssertions: 'allow'\n  }],\n  create(context, [options]) {\n    const sourceCode = context.getSourceCode();\n    function isConst(node) {\n      if (node.type !== utils_1.AST_NODE_TYPES.TSTypeReference) {\n        return false;\n      }\n      return node.typeName.type === utils_1.AST_NODE_TYPES.Identifier && node.typeName.name === 'const';\n    }\n    function getTextWithParentheses(node) {\n      // Capture parentheses before and after the node\n      let beforeCount = 0;\n      let afterCount = 0;\n      if (util.isParenthesized(node, sourceCode)) {\n        const bodyOpeningParen = sourceCode.getTokenBefore(node, util.isOpeningParenToken);\n        const bodyClosingParen = sourceCode.getTokenAfter(node, util.isClosingParenToken);\n        beforeCount = node.range[0] - bodyOpeningParen.range[0];\n        afterCount = bodyClosingParen.range[1] - node.range[1];\n      }\n      return sourceCode.getText(node, beforeCount, afterCount);\n    }\n    function reportIncorrectAssertionType(node) {\n      const messageId = options.assertionStyle;\n      // If this node is `as const`, then don't report an error.\n      if (isConst(node.typeAnnotation) && messageId === 'never') {\n        return;\n      }\n      context.report({\n        node,\n        messageId,\n        data: messageId !== 'never' ? {\n          cast: sourceCode.getText(node.typeAnnotation)\n        } : {},\n        fix: messageId === 'as' ? fixer => [fixer.replaceText(node, getTextWithParentheses(node.expression)), fixer.insertTextAfter(node, ` as ${getTextWithParentheses(node.typeAnnotation)}`)] : undefined\n      });\n    }\n    function checkType(node) {\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n          return false;\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n          return (\n            // Ignore `as const` and `<const>`\n            !isConst(node) ||\n            // Allow qualified names which have dots between identifiers, `Foo.Bar`\n            node.typeName.type === utils_1.AST_NODE_TYPES.TSQualifiedName\n          );\n        default:\n          return true;\n      }\n    }\n    function checkExpression(node) {\n      var _a;\n      if (options.assertionStyle === 'never' || options.objectLiteralTypeAssertions === 'allow' || node.expression.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {\n        return;\n      }\n      if (options.objectLiteralTypeAssertions === 'allow-as-parameter' && node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.NewExpression || node.parent.type === utils_1.AST_NODE_TYPES.CallExpression || node.parent.type === utils_1.AST_NODE_TYPES.ThrowStatement || node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern || node.parent.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer)) {\n        return;\n      }\n      if (checkType(node.typeAnnotation) && node.expression.type === utils_1.AST_NODE_TYPES.ObjectExpression) {\n        const suggest = [];\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.VariableDeclarator && !node.parent.id.typeAnnotation) {\n          const {\n            parent\n          } = node;\n          suggest.push({\n            messageId: 'replaceObjectTypeAssertionWithAnnotation',\n            data: {\n              cast: sourceCode.getText(node.typeAnnotation)\n            },\n            fix: fixer => [fixer.insertTextAfter(parent.id, `: ${sourceCode.getText(node.typeAnnotation)}`), fixer.replaceText(node, getTextWithParentheses(node.expression))]\n          });\n        }\n        suggest.push({\n          messageId: 'replaceObjectTypeAssertionWithSatisfies',\n          data: {\n            cast: sourceCode.getText(node.typeAnnotation)\n          },\n          fix: fixer => [fixer.replaceText(node, getTextWithParentheses(node.expression)), fixer.insertTextAfter(node, ` satisfies ${context.getSourceCode().getText(node.typeAnnotation)}`)]\n        });\n        context.report({\n          node,\n          messageId: 'unexpectedObjectTypeAssertion',\n          suggest\n        });\n      }\n    }\n    return {\n      TSTypeAssertion(node) {\n        if (options.assertionStyle !== 'angle-bracket') {\n          reportIncorrectAssertionType(node);\n          return;\n        }\n        checkExpression(node);\n      },\n      TSAsExpression(node) {\n        if (options.assertionStyle !== 'as') {\n          reportIncorrectAssertionType(node);\n          return;\n        }\n        checkExpression(node);\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","fixable","hasSuggestions","docs","description","recommended","messages","as","never","unexpectedObjectTypeAssertion","replaceObjectTypeAssertionWithAnnotation","replaceObjectTypeAssertionWithSatisfies","schema","oneOf","properties","assertionStyle","enum","additionalProperties","required","objectLiteralTypeAssertions","defaultOptions","create","context","options","sourceCode","getSourceCode","isConst","node","AST_NODE_TYPES","TSTypeReference","typeName","Identifier","getTextWithParentheses","beforeCount","afterCount","isParenthesized","bodyOpeningParen","getTokenBefore","isOpeningParenToken","bodyClosingParen","getTokenAfter","isClosingParenToken","range","getText","reportIncorrectAssertionType","messageId","typeAnnotation","report","data","cast","fix","fixer","replaceText","expression","insertTextAfter","undefined","checkType","TSAnyKeyword","TSUnknownKeyword","TSQualifiedName","checkExpression","ObjectExpression","parent","NewExpression","CallExpression","ThrowStatement","AssignmentPattern","JSXExpressionContainer","suggest","_a","VariableDeclarator","id","push","TSTypeAssertion","TSAsExpression"],"sources":["../../src/rules/consistent-type-assertions.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}