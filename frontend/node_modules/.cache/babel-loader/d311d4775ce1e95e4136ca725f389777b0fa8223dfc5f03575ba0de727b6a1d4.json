{"ast":null,"code":"/**\n * @remix-run/router v1.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t((e = \"undefined\" != typeof globalThis ? globalThis : e || self).RemixRouter = {});\n}(this, function (e) {\n  \"use strict\";\n\n  function t() {\n    return t = Object.assign ? Object.assign.bind() : function (e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var r = arguments[t];\n        for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);\n      }\n      return e;\n    }, t.apply(this, arguments);\n  }\n  let r = function (e) {\n    return e.Pop = \"POP\", e.Push = \"PUSH\", e.Replace = \"REPLACE\", e;\n  }({});\n  const a = \"popstate\";\n  function o(e, t) {\n    if (!1 === e || null == e) throw new Error(t);\n  }\n  function n(e, t) {\n    if (!e) {\n      \"undefined\" != typeof console && console.warn(t);\n      try {\n        throw new Error(t);\n      } catch (e) {}\n    }\n  }\n  function i(e, t) {\n    return {\n      usr: e.state,\n      key: e.key,\n      idx: t\n    };\n  }\n  function s(e, r, a, o) {\n    return void 0 === a && (a = null), t({\n      pathname: \"string\" == typeof e ? e : e.pathname,\n      search: \"\",\n      hash: \"\"\n    }, \"string\" == typeof r ? u(r) : r, {\n      state: a,\n      key: r && r.key || o || Math.random().toString(36).substr(2, 8)\n    });\n  }\n  function l(e) {\n    let {\n      pathname: t = \"/\",\n      search: r = \"\",\n      hash: a = \"\"\n    } = e;\n    return r && \"?\" !== r && (t += \"?\" === r.charAt(0) ? r : \"?\" + r), a && \"#\" !== a && (t += \"#\" === a.charAt(0) ? a : \"#\" + a), t;\n  }\n  function u(e) {\n    let t = {};\n    if (e) {\n      let r = e.indexOf(\"#\");\n      r >= 0 && (t.hash = e.substr(r), e = e.substr(0, r));\n      let a = e.indexOf(\"?\");\n      a >= 0 && (t.search = e.substr(a), e = e.substr(0, a)), e && (t.pathname = e);\n    }\n    return t;\n  }\n  function d(e, n, u, d) {\n    void 0 === d && (d = {});\n    let {\n        window: c = document.defaultView,\n        v5Compat: h = !1\n      } = d,\n      f = c.history,\n      p = r.Pop,\n      m = null,\n      y = v();\n    function v() {\n      return (f.state || {\n        idx: null\n      }).idx;\n    }\n    function g() {\n      p = r.Pop;\n      let e = v(),\n        t = null == e ? null : e - y;\n      y = e, m && m({\n        action: p,\n        location: w.location,\n        delta: t\n      });\n    }\n    function b(e) {\n      let t = \"null\" !== c.location.origin ? c.location.origin : c.location.href,\n        r = \"string\" == typeof e ? e : l(e);\n      return r = r.replace(/ $/, \"%20\"), o(t, \"No window.location.(origin|href) available to create URL for href: \" + r), new URL(r, t);\n    }\n    null == y && (y = 0, f.replaceState(t({}, f.state, {\n      idx: y\n    }), \"\"));\n    let w = {\n      get action() {\n        return p;\n      },\n      get location() {\n        return e(c, f);\n      },\n      listen(e) {\n        if (m) throw new Error(\"A history only accepts one active listener\");\n        return c.addEventListener(a, g), m = e, () => {\n          c.removeEventListener(a, g), m = null;\n        };\n      },\n      createHref: e => n(c, e),\n      createURL: b,\n      encodeLocation(e) {\n        let t = b(e);\n        return {\n          pathname: t.pathname,\n          search: t.search,\n          hash: t.hash\n        };\n      },\n      push: function (e, t) {\n        p = r.Push;\n        let a = s(w.location, e, t);\n        u && u(a, e), y = v() + 1;\n        let o = i(a, y),\n          n = w.createHref(a);\n        try {\n          f.pushState(o, \"\", n);\n        } catch (e) {\n          if (e instanceof DOMException && \"DataCloneError\" === e.name) throw e;\n          c.location.assign(n);\n        }\n        h && m && m({\n          action: p,\n          location: w.location,\n          delta: 1\n        });\n      },\n      replace: function (e, t) {\n        p = r.Replace;\n        let a = s(w.location, e, t);\n        u && u(a, e), y = v();\n        let o = i(a, y),\n          n = w.createHref(a);\n        f.replaceState(o, \"\", n), h && m && m({\n          action: p,\n          location: w.location,\n          delta: 0\n        });\n      },\n      go: e => f.go(e)\n    };\n    return w;\n  }\n  let c = function (e) {\n    return e.data = \"data\", e.deferred = \"deferred\", e.redirect = \"redirect\", e.error = \"error\", e;\n  }({});\n  const h = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\n  function f(e, r, a, n) {\n    return void 0 === a && (a = []), void 0 === n && (n = {}), e.map((e, i) => {\n      let s = [...a, i],\n        l = \"string\" == typeof e.id ? e.id : s.join(\"-\");\n      if (o(!0 !== e.index || !e.children, \"Cannot specify children on an index route\"), o(!n[l], 'Found a route id collision on id \"' + l + \"\\\".  Route id's must be globally unique within Data Router usages\"), function (e) {\n        return !0 === e.index;\n      }(e)) {\n        let a = t({}, e, r(e), {\n          id: l\n        });\n        return n[l] = a, a;\n      }\n      {\n        let a = t({}, e, r(e), {\n          id: l,\n          children: void 0\n        });\n        return n[l] = a, e.children && (a.children = f(e.children, r, s, n)), a;\n      }\n    });\n  }\n  function p(e, t, r) {\n    void 0 === r && (r = \"/\");\n    let a = R((\"string\" == typeof t ? u(t) : t).pathname || \"/\", r);\n    if (null == a) return null;\n    let o = y(e);\n    !function (e) {\n      e.sort((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) {\n        return e.length === t.length && e.slice(0, -1).every((e, r) => e === t[r]) ? e[e.length - 1] - t[t.length - 1] : 0;\n      }(e.routesMeta.map(e => e.childrenIndex), t.routesMeta.map(e => e.childrenIndex)));\n    }(o);\n    let n = null;\n    for (let e = 0; null == n && e < o.length; ++e) {\n      let t = E(a);\n      n = D(o[e], t);\n    }\n    return n;\n  }\n  function m(e, t) {\n    let {\n      route: r,\n      pathname: a,\n      params: o\n    } = e;\n    return {\n      id: r.id,\n      pathname: a,\n      params: o,\n      data: t[r.id],\n      handle: r.handle\n    };\n  }\n  function y(e, t, r, a) {\n    void 0 === t && (t = []), void 0 === r && (r = []), void 0 === a && (a = \"\");\n    let n = (e, n, i) => {\n      let s = {\n        relativePath: void 0 === i ? e.path || \"\" : i,\n        caseSensitive: !0 === e.caseSensitive,\n        childrenIndex: n,\n        route: e\n      };\n      s.relativePath.startsWith(\"/\") && (o(s.relativePath.startsWith(a), 'Absolute route path \"' + s.relativePath + '\" nested under path \"' + a + '\" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), s.relativePath = s.relativePath.slice(a.length));\n      let l = j([a, s.relativePath]),\n        u = r.concat(s);\n      e.children && e.children.length > 0 && (o(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path \"' + l + '\".'), y(e.children, t, u, l)), (null != e.path || e.index) && t.push({\n        path: l,\n        score: w(l, e.index),\n        routesMeta: u\n      });\n    };\n    return e.forEach((e, t) => {\n      var r;\n      if (\"\" !== e.path && null != (r = e.path) && r.includes(\"?\")) for (let r of v(e.path)) n(e, t, r);else n(e, t);\n    }), t;\n  }\n  function v(e) {\n    let t = e.split(\"/\");\n    if (0 === t.length) return [];\n    let [r, ...a] = t,\n      o = r.endsWith(\"?\"),\n      n = r.replace(/\\?$/, \"\");\n    if (0 === a.length) return o ? [n, \"\"] : [n];\n    let i = v(a.join(\"/\")),\n      s = [];\n    return s.push(...i.map(e => \"\" === e ? n : [n, e].join(\"/\"))), o && s.push(...i), s.map(t => e.startsWith(\"/\") && \"\" === t ? \"/\" : t);\n  }\n  const g = /^:[\\w-]+$/,\n    b = e => \"*\" === e;\n  function w(e, t) {\n    let r = e.split(\"/\"),\n      a = r.length;\n    return r.some(b) && (a += -2), t && (a += 2), r.filter(e => !b(e)).reduce((e, t) => e + (g.test(t) ? 3 : \"\" === t ? 1 : 10), a);\n  }\n  function D(e, t) {\n    let {\n        routesMeta: r\n      } = e,\n      a = {},\n      o = \"/\",\n      n = [];\n    for (let e = 0; e < r.length; ++e) {\n      let i = r[e],\n        s = e === r.length - 1,\n        l = \"/\" === o ? t : t.slice(o.length) || \"/\",\n        u = S({\n          path: i.relativePath,\n          caseSensitive: i.caseSensitive,\n          end: s\n        }, l);\n      if (!u) return null;\n      Object.assign(a, u.params);\n      let d = i.route;\n      n.push({\n        params: a,\n        pathname: j([o, u.pathname]),\n        pathnameBase: k(j([o, u.pathnameBase])),\n        route: d\n      }), \"/\" !== u.pathnameBase && (o = j([o, u.pathnameBase]));\n    }\n    return n;\n  }\n  function S(e, t) {\n    \"string\" == typeof e && (e = {\n      path: e,\n      caseSensitive: !1,\n      end: !0\n    });\n    let [r, a] = function (e, t, r) {\n        void 0 === t && (t = !1);\n        void 0 === r && (r = !0);\n        n(\"*\" === e || !e.endsWith(\"*\") || e.endsWith(\"/*\"), 'Route path \"' + e + '\" will be treated as if it were \"' + e.replace(/\\*$/, \"/*\") + '\" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to \"' + e.replace(/\\*$/, \"/*\") + '\".');\n        let a = [],\n          o = \"^\" + e.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:([\\w-]+)(\\?)?/g, (e, t, r) => (a.push({\n            paramName: t,\n            isOptional: null != r\n          }), r ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\"));\n        e.endsWith(\"*\") ? (a.push({\n          paramName: \"*\"\n        }), o += \"*\" === e || \"/*\" === e ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\") : r ? o += \"\\\\/*$\" : \"\" !== e && \"/\" !== e && (o += \"(?:(?=\\\\/|$))\");\n        return [new RegExp(o, t ? void 0 : \"i\"), a];\n      }(e.path, e.caseSensitive, e.end),\n      o = t.match(r);\n    if (!o) return null;\n    let i = o[0],\n      s = i.replace(/(.)\\/+$/, \"$1\"),\n      l = o.slice(1);\n    return {\n      params: a.reduce((e, t, r) => {\n        let {\n          paramName: a,\n          isOptional: o\n        } = t;\n        if (\"*\" === a) {\n          let e = l[r] || \"\";\n          s = i.slice(0, i.length - e.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const n = l[r];\n        return e[a] = o && !n ? void 0 : (n || \"\").replace(/%2F/g, \"/\"), e;\n      }, {}),\n      pathname: i,\n      pathnameBase: s,\n      pattern: e\n    };\n  }\n  function E(e) {\n    try {\n      return e.split(\"/\").map(e => decodeURIComponent(e).replace(/\\//g, \"%2F\")).join(\"/\");\n    } catch (t) {\n      return n(!1, 'The URL path \"' + e + '\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + \").\"), e;\n    }\n  }\n  function R(e, t) {\n    if (\"/\" === t) return e;\n    if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;\n    let r = t.endsWith(\"/\") ? t.length - 1 : t.length,\n      a = e.charAt(r);\n    return a && \"/\" !== a ? null : e.slice(r) || \"/\";\n  }\n  function P(e, t) {\n    void 0 === t && (t = \"/\");\n    let {\n        pathname: r,\n        search: a = \"\",\n        hash: o = \"\"\n      } = \"string\" == typeof e ? u(e) : e,\n      n = r ? r.startsWith(\"/\") ? r : function (e, t) {\n        let r = t.replace(/\\/+$/, \"\").split(\"/\");\n        return e.split(\"/\").forEach(e => {\n          \"..\" === e ? r.length > 1 && r.pop() : \".\" !== e && r.push(e);\n        }), r.length > 1 ? r.join(\"/\") : \"/\";\n      }(r, t) : t;\n    return {\n      pathname: n,\n      search: _(a),\n      hash: C(o)\n    };\n  }\n  function x(e, t, r, a) {\n    return \"Cannot include a '\" + e + \"' character in a manually specified `to.\" + t + \"` field [\" + JSON.stringify(a) + \"].  Please separate it out to the `to.\" + r + '` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.';\n  }\n  function L(e) {\n    return e.filter((e, t) => 0 === t || e.route.path && e.route.path.length > 0);\n  }\n  function A(e, t) {\n    let r = L(e);\n    return t ? r.map((t, r) => r === e.length - 1 ? t.pathname : t.pathnameBase) : r.map(e => e.pathnameBase);\n  }\n  function M(e, r, a, n) {\n    let i;\n    void 0 === n && (n = !1), \"string\" == typeof e ? i = u(e) : (i = t({}, e), o(!i.pathname || !i.pathname.includes(\"?\"), x(\"?\", \"pathname\", \"search\", i)), o(!i.pathname || !i.pathname.includes(\"#\"), x(\"#\", \"pathname\", \"hash\", i)), o(!i.search || !i.search.includes(\"#\"), x(\"#\", \"search\", \"hash\", i)));\n    let s,\n      l = \"\" === e || \"\" === i.pathname,\n      d = l ? \"/\" : i.pathname;\n    if (null == d) s = a;else {\n      let e = r.length - 1;\n      if (!n && d.startsWith(\"..\")) {\n        let t = d.split(\"/\");\n        for (; \"..\" === t[0];) t.shift(), e -= 1;\n        i.pathname = t.join(\"/\");\n      }\n      s = e >= 0 ? r[e] : \"/\";\n    }\n    let c = P(i, s),\n      h = d && \"/\" !== d && d.endsWith(\"/\"),\n      f = (l || \".\" === d) && a.endsWith(\"/\");\n    return c.pathname.endsWith(\"/\") || !h && !f || (c.pathname += \"/\"), c;\n  }\n  const j = e => e.join(\"/\").replace(/\\/\\/+/g, \"/\"),\n    k = e => e.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\"),\n    _ = e => e && \"?\" !== e ? e.startsWith(\"?\") ? e : \"?\" + e : \"\",\n    C = e => e && \"#\" !== e ? e.startsWith(\"#\") ? e : \"#\" + e : \"\";\n  class T extends Error {}\n  class U {\n    constructor(e, t) {\n      let r;\n      this.pendingKeysSet = new Set(), this.subscribers = new Set(), this.deferredKeys = [], o(e && \"object\" == typeof e && !Array.isArray(e), \"defer() only accepts plain objects\"), this.abortPromise = new Promise((e, t) => r = t), this.controller = new AbortController();\n      let a = () => r(new T(\"Deferred data aborted\"));\n      this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", a), this.controller.signal.addEventListener(\"abort\", a), this.data = Object.entries(e).reduce((e, t) => {\n        let [r, a] = t;\n        return Object.assign(e, {\n          [r]: this.trackPromise(r, a)\n        });\n      }, {}), this.done && this.unlistenAbortSignal(), this.init = t;\n    }\n    trackPromise(e, t) {\n      if (!(t instanceof Promise)) return t;\n      this.deferredKeys.push(e), this.pendingKeysSet.add(e);\n      let r = Promise.race([t, this.abortPromise]).then(t => this.onSettle(r, e, void 0, t), t => this.onSettle(r, e, t));\n      return r.catch(() => {}), Object.defineProperty(r, \"_tracked\", {\n        get: () => !0\n      }), r;\n    }\n    onSettle(e, t, r, a) {\n      if (this.controller.signal.aborted && r instanceof T) return this.unlistenAbortSignal(), Object.defineProperty(e, \"_error\", {\n        get: () => r\n      }), Promise.reject(r);\n      if (this.pendingKeysSet.delete(t), this.done && this.unlistenAbortSignal(), void 0 === r && void 0 === a) {\n        let r = new Error('Deferred data for key \"' + t + '\" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');\n        return Object.defineProperty(e, \"_error\", {\n          get: () => r\n        }), this.emit(!1, t), Promise.reject(r);\n      }\n      return void 0 === a ? (Object.defineProperty(e, \"_error\", {\n        get: () => r\n      }), this.emit(!1, t), Promise.reject(r)) : (Object.defineProperty(e, \"_data\", {\n        get: () => a\n      }), this.emit(!1, t), a);\n    }\n    emit(e, t) {\n      this.subscribers.forEach(r => r(e, t));\n    }\n    subscribe(e) {\n      return this.subscribers.add(e), () => this.subscribers.delete(e);\n    }\n    cancel() {\n      this.controller.abort(), this.pendingKeysSet.forEach((e, t) => this.pendingKeysSet.delete(t)), this.emit(!0);\n    }\n    async resolveData(e) {\n      let t = !1;\n      if (!this.done) {\n        let r = () => this.cancel();\n        e.addEventListener(\"abort\", r), t = await new Promise(t => {\n          this.subscribe(a => {\n            e.removeEventListener(\"abort\", r), (a || this.done) && t(a);\n          });\n        });\n      }\n      return t;\n    }\n    get done() {\n      return 0 === this.pendingKeysSet.size;\n    }\n    get unwrappedData() {\n      return o(null !== this.data && this.done, \"Can only unwrap data on initialized and settled deferreds\"), Object.entries(this.data).reduce((e, t) => {\n        let [r, a] = t;\n        return Object.assign(e, {\n          [r]: O(a)\n        });\n      }, {});\n    }\n    get pendingKeys() {\n      return Array.from(this.pendingKeysSet);\n    }\n  }\n  function O(e) {\n    if (!function (e) {\n      return e instanceof Promise && !0 === e._tracked;\n    }(e)) return e;\n    if (e._error) throw e._error;\n    return e._data;\n  }\n  const H = function (e, r) {\n    void 0 === r && (r = 302);\n    let a = r;\n    \"number\" == typeof a ? a = {\n      status: a\n    } : void 0 === a.status && (a.status = 302);\n    let o = new Headers(a.headers);\n    return o.set(\"Location\", e), new Response(null, t({}, a, {\n      headers: o\n    }));\n  };\n  class I {\n    constructor(e, t, r, a) {\n      void 0 === a && (a = !1), this.status = e, this.statusText = t || \"\", this.internal = a, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;\n    }\n  }\n  function z(e) {\n    return null != e && \"number\" == typeof e.status && \"string\" == typeof e.statusText && \"boolean\" == typeof e.internal && \"data\" in e;\n  }\n  const B = [\"post\", \"put\", \"patch\", \"delete\"],\n    F = new Set(B),\n    N = [\"get\", ...B],\n    W = new Set(N),\n    $ = new Set([301, 302, 303, 307, 308]),\n    q = new Set([307, 308]),\n    K = {\n      state: \"idle\",\n      location: void 0,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    },\n    Y = {\n      state: \"idle\",\n      data: void 0,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    },\n    J = {\n      state: \"unblocked\",\n      proceed: void 0,\n      reset: void 0,\n      location: void 0\n    },\n    V = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i,\n    X = e => ({\n      hasErrorBoundary: Boolean(e.hasErrorBoundary)\n    }),\n    G = \"remix-router-transitions\";\n  const Q = Symbol(\"deferred\");\n  function Z(e, t, r) {\n    if (r.v7_throwAbortReason && void 0 !== e.signal.reason) throw e.signal.reason;\n    throw new Error((t ? \"queryRoute\" : \"query\") + \"() call aborted: \" + e.method + \" \" + e.url);\n  }\n  function ee(e, t, r, a, o, n, i, s) {\n    let u, d;\n    if (i) {\n      u = [];\n      for (let e of t) if (u.push(e), e.route.id === i) {\n        d = e;\n        break;\n      }\n    } else u = t, d = t[t.length - 1];\n    let c = M(o || \".\", A(u, n), R(e.pathname, r) || e.pathname, \"path\" === s);\n    return null == o && (c.search = e.search, c.hash = e.hash), null != o && \"\" !== o && \".\" !== o || !d || !d.route.index || Te(c.search) || (c.search = c.search ? c.search.replace(/^\\?/, \"?index&\") : \"?index\"), a && \"/\" !== r && (c.pathname = \"/\" === c.pathname ? r : j([r, c.pathname])), l(c);\n  }\n  function te(e, t, r, a) {\n    if (!a || !function (e) {\n      return null != e && (\"formData\" in e && null != e.formData || \"body\" in e && void 0 !== e.body);\n    }(a)) return {\n      path: r\n    };\n    if (a.formMethod && !je(a.formMethod)) return {\n      path: r,\n      error: De(405, {\n        method: a.formMethod\n      })\n    };\n    let n,\n      i,\n      s = () => ({\n        path: r,\n        error: De(400, {\n          type: \"invalid-body\"\n        })\n      }),\n      d = a.formMethod || \"get\",\n      c = e ? d.toUpperCase() : d.toLowerCase(),\n      h = Ee(r);\n    if (void 0 !== a.body) {\n      if (\"text/plain\" === a.formEncType) {\n        if (!ke(c)) return s();\n        let e = \"string\" == typeof a.body ? a.body : a.body instanceof FormData || a.body instanceof URLSearchParams ? Array.from(a.body.entries()).reduce((e, t) => {\n          let [r, a] = t;\n          return \"\" + e + r + \"=\" + a + \"\\n\";\n        }, \"\") : String(a.body);\n        return {\n          path: r,\n          submission: {\n            formMethod: c,\n            formAction: h,\n            formEncType: a.formEncType,\n            formData: void 0,\n            json: void 0,\n            text: e\n          }\n        };\n      }\n      if (\"application/json\" === a.formEncType) {\n        if (!ke(c)) return s();\n        try {\n          let e = \"string\" == typeof a.body ? JSON.parse(a.body) : a.body;\n          return {\n            path: r,\n            submission: {\n              formMethod: c,\n              formAction: h,\n              formEncType: a.formEncType,\n              formData: void 0,\n              json: e,\n              text: void 0\n            }\n          };\n        } catch (e) {\n          return s();\n        }\n      }\n    }\n    if (o(\"function\" == typeof FormData, \"FormData is not available in this environment\"), a.formData) n = fe(a.formData), i = a.formData;else if (a.body instanceof FormData) n = fe(a.body), i = a.body;else if (a.body instanceof URLSearchParams) n = a.body, i = pe(n);else if (null == a.body) n = new URLSearchParams(), i = new FormData();else try {\n      n = new URLSearchParams(a.body), i = pe(n);\n    } catch (e) {\n      return s();\n    }\n    let f = {\n      formMethod: c,\n      formAction: h,\n      formEncType: a && a.formEncType || \"application/x-www-form-urlencoded\",\n      formData: i,\n      json: void 0,\n      text: void 0\n    };\n    if (ke(f.formMethod)) return {\n      path: r,\n      submission: f\n    };\n    let p = u(r);\n    return t && p.search && Te(p.search) && n.append(\"index\", \"\"), p.search = \"?\" + n, {\n      path: l(p),\n      submission: f\n    };\n  }\n  function re(e, t) {\n    let r = e;\n    if (t) {\n      let a = e.findIndex(e => e.route.id === t);\n      a >= 0 && (r = e.slice(0, a));\n    }\n    return r;\n  }\n  function ae(e, r, a, o, n, i, s, l, u, d, c, h, f, m, y, v) {\n    let g = v ? xe(v[1]) ? v[1].error : v[1].data : void 0,\n      b = e.createURL(r.location),\n      w = e.createURL(n),\n      D = v && xe(v[1]) ? v[0] : void 0,\n      S = D ? re(a, D) : a,\n      E = v ? v[1].statusCode : void 0,\n      R = s && E && E >= 400,\n      P = S.filter((e, a) => {\n        let {\n          route: n\n        } = e;\n        if (n.lazy) return !0;\n        if (null == n.loader) return !1;\n        if (i) return !(\"function\" == typeof n.loader && !n.loader.hydrate) || void 0 === r.loaderData[n.id] && (!r.errors || void 0 === r.errors[n.id]);\n        if (function (e, t, r) {\n          let a = !t || r.route.id !== t.route.id,\n            o = void 0 === e[r.route.id];\n          return a || o;\n        }(r.loaderData, r.matches[a], e) || u.some(t => t === e.route.id)) return !0;\n        let s = r.matches[a],\n          d = e;\n        return ne(e, t({\n          currentUrl: b,\n          currentParams: s.params,\n          nextUrl: w,\n          nextParams: d.params\n        }, o, {\n          actionResult: g,\n          unstable_actionStatus: E,\n          defaultShouldRevalidate: !R && (l || b.pathname + b.search === w.pathname + w.search || b.search !== w.search || oe(s, d))\n        }));\n      }),\n      x = [];\n    return h.forEach((e, n) => {\n      if (i || !a.some(t => t.route.id === e.routeId) || c.has(n)) return;\n      let s = p(m, e.path, y);\n      if (!s) return void x.push({\n        key: n,\n        routeId: e.routeId,\n        path: e.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      let u = r.fetchers.get(n),\n        h = Ue(s, e.path),\n        v = !1;\n      v = !f.has(n) && (!!d.includes(n) || (u && \"idle\" !== u.state && void 0 === u.data ? l : ne(h, t({\n        currentUrl: b,\n        currentParams: r.matches[r.matches.length - 1].params,\n        nextUrl: w,\n        nextParams: a[a.length - 1].params\n      }, o, {\n        actionResult: g,\n        unstable_actionStatus: E,\n        defaultShouldRevalidate: !R && l\n      })))), v && x.push({\n        key: n,\n        routeId: e.routeId,\n        path: e.path,\n        matches: s,\n        match: h,\n        controller: new AbortController()\n      });\n    }), [P, x];\n  }\n  function oe(e, t) {\n    let r = e.route.path;\n    return e.pathname !== t.pathname || null != r && r.endsWith(\"*\") && e.params[\"*\"] !== t.params[\"*\"];\n  }\n  function ne(e, t) {\n    if (e.route.shouldRevalidate) {\n      let r = e.route.shouldRevalidate(t);\n      if (\"boolean\" == typeof r) return r;\n    }\n    return t.defaultShouldRevalidate;\n  }\n  async function ie(e, r, a) {\n    if (!e.lazy) return;\n    let i = await e.lazy();\n    if (!e.lazy) return;\n    let s = a[e.id];\n    o(s, \"No route found in manifest\");\n    let l = {};\n    for (let e in i) {\n      let t = void 0 !== s[e] && \"hasErrorBoundary\" !== e;\n      n(!t, 'Route \"' + s.id + '\" has a static property \"' + e + '\" defined but its lazy function is also returning a value for this property. The lazy route property \"' + e + '\" will be ignored.'), t || h.has(e) || (l[e] = i[e]);\n    }\n    Object.assign(s, l), Object.assign(s, t({}, r(s), {\n      lazy: void 0\n    }));\n  }\n  function se(e) {\n    return Promise.all(e.matches.map(e => e.resolve()));\n  }\n  async function le(e, r, a, n, i, s, l, u) {\n    let d = n.reduce((e, t) => e.add(t.route.id), new Set()),\n      h = new Set(),\n      f = await e({\n        matches: i.map(e => {\n          let n = d.has(e.route.id);\n          return t({}, e, {\n            shouldLoad: n,\n            resolve: t => (h.add(e.route.id), n ? async function (e, t, r, a, n, i, s) {\n              let l,\n                u,\n                d = a => {\n                  let o,\n                    n = new Promise((e, t) => o = t);\n                  u = () => o(), t.signal.addEventListener(\"abort\", u);\n                  let l,\n                    d = o => \"function\" != typeof a ? Promise.reject(new Error('You cannot call the handler for a route which defines a boolean \"' + e + '\" [routeId: ' + r.route.id + \"]\")) : a({\n                      request: t,\n                      params: r.params,\n                      context: s\n                    }, ...(void 0 !== o ? [o] : []));\n                  return l = i ? i(e => d(e)) : (async () => {\n                    try {\n                      return {\n                        type: \"data\",\n                        result: await d()\n                      };\n                    } catch (e) {\n                      return {\n                        type: \"error\",\n                        result: e\n                      };\n                    }\n                  })(), Promise.race([l, n]);\n                };\n              try {\n                let i = r.route[e];\n                if (r.route.lazy) {\n                  if (i) {\n                    let e,\n                      [t] = await Promise.all([d(i).catch(t => {\n                        e = t;\n                      }), ie(r.route, n, a)]);\n                    if (void 0 !== e) throw e;\n                    l = t;\n                  } else {\n                    if (await ie(r.route, n, a), i = r.route[e], !i) {\n                      if (\"action\" === e) {\n                        let e = new URL(t.url),\n                          a = e.pathname + e.search;\n                        throw De(405, {\n                          method: t.method,\n                          pathname: a,\n                          routeId: r.route.id\n                        });\n                      }\n                      return {\n                        type: c.data,\n                        result: void 0\n                      };\n                    }\n                    l = await d(i);\n                  }\n                } else {\n                  if (!i) {\n                    let e = new URL(t.url);\n                    throw De(404, {\n                      pathname: e.pathname + e.search\n                    });\n                  }\n                  l = await d(i);\n                }\n                o(void 0 !== l.result, \"You defined \" + (\"action\" === e ? \"an action\" : \"a loader\") + ' for route \"' + r.route.id + \"\\\" but didn't return anything from your `\" + e + \"` function. Please return a value or `null`.\");\n              } catch (e) {\n                return {\n                  type: c.error,\n                  result: e\n                };\n              } finally {\n                u && t.signal.removeEventListener(\"abort\", u);\n              }\n              return l;\n            }(r, a, e, s, l, t, u) : Promise.resolve({\n              type: c.data,\n              result: void 0\n            }))\n          });\n        }),\n        request: a,\n        params: i[0].params,\n        context: u\n      });\n    return i.forEach(e => o(h.has(e.route.id), '`match.resolve()` was not called for route id \"' + e.route.id + '\". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')), f.filter((e, t) => d.has(i[t].route.id));\n  }\n  async function ue(e) {\n    let {\n      result: t,\n      type: r,\n      status: a\n    } = e;\n    if (Me(t)) {\n      let e;\n      try {\n        let r = t.headers.get(\"Content-Type\");\n        e = r && /\\bapplication\\/json\\b/.test(r) ? null == t.body ? null : await t.json() : await t.text();\n      } catch (e) {\n        return {\n          type: c.error,\n          error: e\n        };\n      }\n      return r === c.error ? {\n        type: c.error,\n        error: new I(t.status, t.statusText, e),\n        statusCode: t.status,\n        headers: t.headers\n      } : {\n        type: c.data,\n        data: e,\n        statusCode: t.status,\n        headers: t.headers\n      };\n    }\n    return r === c.error ? {\n      type: c.error,\n      error: t,\n      statusCode: z(t) ? t.status : a\n    } : Ae(t) ? {\n      type: c.deferred,\n      deferredData: t,\n      statusCode: null == (o = t.init) ? void 0 : o.status,\n      headers: (null == (n = t.init) ? void 0 : n.headers) && new Headers(t.init.headers)\n    } : {\n      type: c.data,\n      data: t,\n      statusCode: a\n    };\n    var o, n;\n  }\n  function de(e, t, r, a, n, i) {\n    let s = e.headers.get(\"Location\");\n    if (o(s, \"Redirects returned/thrown from loaders/actions must have a Location header\"), !V.test(s)) {\n      let o = a.slice(0, a.findIndex(e => e.route.id === r) + 1);\n      s = ee(new URL(t.url), o, n, !0, s, i), e.headers.set(\"Location\", s);\n    }\n    return e;\n  }\n  function ce(e, t, r) {\n    if (V.test(e)) {\n      let a = e,\n        o = a.startsWith(\"//\") ? new URL(t.protocol + a) : new URL(a),\n        n = null != R(o.pathname, r);\n      if (o.origin === t.origin && n) return o.pathname + o.search + o.hash;\n    }\n    return e;\n  }\n  function he(e, t, r, a) {\n    let o = e.createURL(Ee(t)).toString(),\n      n = {\n        signal: r\n      };\n    if (a && ke(a.formMethod)) {\n      let {\n        formMethod: e,\n        formEncType: t\n      } = a;\n      n.method = e.toUpperCase(), \"application/json\" === t ? (n.headers = new Headers({\n        \"Content-Type\": t\n      }), n.body = JSON.stringify(a.json)) : \"text/plain\" === t ? n.body = a.text : \"application/x-www-form-urlencoded\" === t && a.formData ? n.body = fe(a.formData) : n.body = a.formData;\n    }\n    return new Request(o, n);\n  }\n  function fe(e) {\n    let t = new URLSearchParams();\n    for (let [r, a] of e.entries()) t.append(r, \"string\" == typeof a ? a : a.name);\n    return t;\n  }\n  function pe(e) {\n    let t = new FormData();\n    for (let [r, a] of e.entries()) t.append(r, a);\n    return t;\n  }\n  function me(e, t, r, a, n, i) {\n    let s,\n      l = {},\n      u = null,\n      d = !1,\n      c = {},\n      h = a && xe(a[1]) ? a[1].error : void 0;\n    return r.forEach((r, a) => {\n      let f = t[a].route.id;\n      if (o(!Le(r), \"Cannot handle redirect results in processLoaderData\"), xe(r)) {\n        let t = r.error;\n        if (void 0 !== h && (t = h, h = void 0), u = u || {}, i) u[f] = t;else {\n          let r = be(e, f);\n          null == u[r.route.id] && (u[r.route.id] = t);\n        }\n        l[f] = void 0, d || (d = !0, s = z(r.error) ? r.error.status : 500), r.headers && (c[f] = r.headers);\n      } else Pe(r) ? (n.set(f, r.deferredData), l[f] = r.deferredData.data, null == r.statusCode || 200 === r.statusCode || d || (s = r.statusCode), r.headers && (c[f] = r.headers)) : (l[f] = r.data, r.statusCode && 200 !== r.statusCode && !d && (s = r.statusCode), r.headers && (c[f] = r.headers));\n    }), void 0 !== h && a && (u = {\n      [a[0]]: h\n    }, l[a[0]] = void 0), {\n      loaderData: l,\n      errors: u,\n      statusCode: s || 200,\n      loaderHeaders: c\n    };\n  }\n  function ye(e, r, a, n, i, s, l, u) {\n    let {\n      loaderData: d,\n      errors: c\n    } = me(r, a, n, i, u, !1);\n    for (let r = 0; r < s.length; r++) {\n      let {\n        key: a,\n        match: n,\n        controller: i\n      } = s[r];\n      o(void 0 !== l && void 0 !== l[r], \"Did not find corresponding fetcher result\");\n      let u = l[r];\n      if (!i || !i.signal.aborted) if (xe(u)) {\n        let r = be(e.matches, null == n ? void 0 : n.route.id);\n        c && c[r.route.id] || (c = t({}, c, {\n          [r.route.id]: u.error\n        })), e.fetchers.delete(a);\n      } else if (Le(u)) o(!1, \"Unhandled fetcher revalidation redirect\");else if (Pe(u)) o(!1, \"Unhandled fetcher deferred data\");else {\n        let t = Be(u.data);\n        e.fetchers.set(a, t);\n      }\n    }\n    return {\n      loaderData: d,\n      errors: c\n    };\n  }\n  function ve(e, r, a, o) {\n    let n = t({}, r);\n    for (let t of a) {\n      let a = t.route.id;\n      if (r.hasOwnProperty(a) ? void 0 !== r[a] && (n[a] = r[a]) : void 0 !== e[a] && t.route.loader && (n[a] = e[a]), o && o.hasOwnProperty(a)) break;\n    }\n    return n;\n  }\n  function ge(e) {\n    return e ? xe(e[1]) ? {\n      actionData: {}\n    } : {\n      actionData: {\n        [e[0]]: e[1].data\n      }\n    } : {};\n  }\n  function be(e, t) {\n    return (t ? e.slice(0, e.findIndex(e => e.route.id === t) + 1) : [...e]).reverse().find(e => !0 === e.route.hasErrorBoundary) || e[0];\n  }\n  function we(e) {\n    let t = 1 === e.length ? e[0] : e.find(e => e.index || !e.path || \"/\" === e.path) || {\n      id: \"__shim-error-route__\"\n    };\n    return {\n      matches: [{\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route: t\n      }],\n      route: t\n    };\n  }\n  function De(e, t) {\n    let {\n        pathname: r,\n        routeId: a,\n        method: o,\n        type: n\n      } = void 0 === t ? {} : t,\n      i = \"Unknown Server Error\",\n      s = \"Unknown @remix-run/router error\";\n    return 400 === e ? (i = \"Bad Request\", o && r && a ? s = \"You made a \" + o + ' request to \"' + r + '\" but did not provide a `loader` for route \"' + a + '\", so there is no way to handle the request.' : \"defer-action\" === n ? s = \"defer() is not supported in actions\" : \"invalid-body\" === n && (s = \"Unable to encode submission body\")) : 403 === e ? (i = \"Forbidden\", s = 'Route \"' + a + '\" does not match URL \"' + r + '\"') : 404 === e ? (i = \"Not Found\", s = 'No route matches URL \"' + r + '\"') : 405 === e && (i = \"Method Not Allowed\", o && r && a ? s = \"You made a \" + o.toUpperCase() + ' request to \"' + r + '\" but did not provide an `action` for route \"' + a + '\", so there is no way to handle the request.' : o && (s = 'Invalid request method \"' + o.toUpperCase() + '\"')), new I(e || 500, i, new Error(s), !0);\n  }\n  function Se(e) {\n    for (let t = e.length - 1; t >= 0; t--) {\n      let r = e[t];\n      if (Le(r)) return {\n        result: r,\n        idx: t\n      };\n    }\n  }\n  function Ee(e) {\n    return l(t({}, \"string\" == typeof e ? u(e) : e, {\n      hash: \"\"\n    }));\n  }\n  function Re(e) {\n    return Me(e.result) && $.has(e.result.status);\n  }\n  function Pe(e) {\n    return e.type === c.deferred;\n  }\n  function xe(e) {\n    return e.type === c.error;\n  }\n  function Le(e) {\n    return (e && e.type) === c.redirect;\n  }\n  function Ae(e) {\n    let t = e;\n    return t && \"object\" == typeof t && \"object\" == typeof t.data && \"function\" == typeof t.subscribe && \"function\" == typeof t.cancel && \"function\" == typeof t.resolveData;\n  }\n  function Me(e) {\n    return null != e && \"number\" == typeof e.status && \"string\" == typeof e.statusText && \"object\" == typeof e.headers && void 0 !== e.body;\n  }\n  function je(e) {\n    return W.has(e.toLowerCase());\n  }\n  function ke(e) {\n    return F.has(e.toLowerCase());\n  }\n  async function _e(e, t, r, a, n, i) {\n    for (let s = 0; s < r.length; s++) {\n      let l = r[s],\n        u = t[s];\n      if (!u) continue;\n      let d = e.find(e => e.route.id === u.route.id),\n        c = null != d && !oe(d, u) && void 0 !== (i && i[u.route.id]);\n      if (Pe(l) && (n || c)) {\n        let e = a[s];\n        o(e, \"Expected an AbortSignal for revalidating fetcher deferred result\"), await Ce(l, e, n).then(e => {\n          e && (r[s] = e || r[s]);\n        });\n      }\n    }\n  }\n  async function Ce(e, t, r) {\n    if (void 0 === r && (r = !1), !(await e.deferredData.resolveData(t))) {\n      if (r) try {\n        return {\n          type: c.data,\n          data: e.deferredData.unwrappedData\n        };\n      } catch (e) {\n        return {\n          type: c.error,\n          error: e\n        };\n      }\n      return {\n        type: c.data,\n        data: e.deferredData.data\n      };\n    }\n  }\n  function Te(e) {\n    return new URLSearchParams(e).getAll(\"index\").some(e => \"\" === e);\n  }\n  function Ue(e, t) {\n    let r = \"string\" == typeof t ? u(t).search : t.search;\n    if (e[e.length - 1].route.index && Te(r || \"\")) return e[e.length - 1];\n    let a = L(e);\n    return a[a.length - 1];\n  }\n  function Oe(e) {\n    let {\n      formMethod: t,\n      formAction: r,\n      formEncType: a,\n      text: o,\n      formData: n,\n      json: i\n    } = e;\n    if (t && r && a) return null != o ? {\n      formMethod: t,\n      formAction: r,\n      formEncType: a,\n      formData: void 0,\n      json: void 0,\n      text: o\n    } : null != n ? {\n      formMethod: t,\n      formAction: r,\n      formEncType: a,\n      formData: n,\n      json: void 0,\n      text: void 0\n    } : void 0 !== i ? {\n      formMethod: t,\n      formAction: r,\n      formEncType: a,\n      formData: void 0,\n      json: i,\n      text: void 0\n    } : void 0;\n  }\n  function He(e, t) {\n    if (t) {\n      return {\n        state: \"loading\",\n        location: e,\n        formMethod: t.formMethod,\n        formAction: t.formAction,\n        formEncType: t.formEncType,\n        formData: t.formData,\n        json: t.json,\n        text: t.text\n      };\n    }\n    return {\n      state: \"loading\",\n      location: e,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n  }\n  function Ie(e, t) {\n    return {\n      state: \"submitting\",\n      location: e,\n      formMethod: t.formMethod,\n      formAction: t.formAction,\n      formEncType: t.formEncType,\n      formData: t.formData,\n      json: t.json,\n      text: t.text\n    };\n  }\n  function ze(e, t) {\n    if (e) {\n      return {\n        state: \"loading\",\n        formMethod: e.formMethod,\n        formAction: e.formAction,\n        formEncType: e.formEncType,\n        formData: e.formData,\n        json: e.json,\n        text: e.text,\n        data: t\n      };\n    }\n    return {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data: t\n    };\n  }\n  function Be(e) {\n    return {\n      state: \"idle\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data: e\n    };\n  }\n  e.AbortedDeferredError = T, e.Action = r, e.IDLE_BLOCKER = J, e.IDLE_FETCHER = Y, e.IDLE_NAVIGATION = K, e.UNSAFE_DEFERRED_SYMBOL = Q, e.UNSAFE_DeferredData = U, e.UNSAFE_ErrorResponseImpl = I, e.UNSAFE_convertRouteMatchToUiMatch = m, e.UNSAFE_convertRoutesToDataRoutes = f, e.UNSAFE_getResolveToMatches = A, e.UNSAFE_invariant = o, e.UNSAFE_warning = n, e.createBrowserHistory = function (e) {\n    return void 0 === e && (e = {}), d(function (e, t) {\n      let {\n        pathname: r,\n        search: a,\n        hash: o\n      } = e.location;\n      return s(\"\", {\n        pathname: r,\n        search: a,\n        hash: o\n      }, t.state && t.state.usr || null, t.state && t.state.key || \"default\");\n    }, function (e, t) {\n      return \"string\" == typeof t ? t : l(t);\n    }, null, e);\n  }, e.createHashHistory = function (e) {\n    return void 0 === e && (e = {}), d(function (e, t) {\n      let {\n        pathname: r = \"/\",\n        search: a = \"\",\n        hash: o = \"\"\n      } = u(e.location.hash.substr(1));\n      return r.startsWith(\"/\") || r.startsWith(\".\") || (r = \"/\" + r), s(\"\", {\n        pathname: r,\n        search: a,\n        hash: o\n      }, t.state && t.state.usr || null, t.state && t.state.key || \"default\");\n    }, function (e, t) {\n      let r = e.document.querySelector(\"base\"),\n        a = \"\";\n      if (r && r.getAttribute(\"href\")) {\n        let t = e.location.href,\n          r = t.indexOf(\"#\");\n        a = -1 === r ? t : t.slice(0, r);\n      }\n      return a + \"#\" + (\"string\" == typeof t ? t : l(t));\n    }, function (e, t) {\n      n(\"/\" === e.pathname.charAt(0), \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(t) + \")\");\n    }, e);\n  }, e.createMemoryHistory = function (e) {\n    void 0 === e && (e = {});\n    let t,\n      {\n        initialEntries: a = [\"/\"],\n        initialIndex: o,\n        v5Compat: i = !1\n      } = e;\n    t = a.map((e, t) => m(e, \"string\" == typeof e ? null : e.state, 0 === t ? \"default\" : void 0));\n    let d = f(null == o ? t.length - 1 : o),\n      c = r.Pop,\n      h = null;\n    function f(e) {\n      return Math.min(Math.max(e, 0), t.length - 1);\n    }\n    function p() {\n      return t[d];\n    }\n    function m(e, r, a) {\n      void 0 === r && (r = null);\n      let o = s(t ? p().pathname : \"/\", e, r, a);\n      return n(\"/\" === o.pathname.charAt(0), \"relative pathnames are not supported in memory history: \" + JSON.stringify(e)), o;\n    }\n    function y(e) {\n      return \"string\" == typeof e ? e : l(e);\n    }\n    return {\n      get index() {\n        return d;\n      },\n      get action() {\n        return c;\n      },\n      get location() {\n        return p();\n      },\n      createHref: y,\n      createURL: e => new URL(y(e), \"http://localhost\"),\n      encodeLocation(e) {\n        let t = \"string\" == typeof e ? u(e) : e;\n        return {\n          pathname: t.pathname || \"\",\n          search: t.search || \"\",\n          hash: t.hash || \"\"\n        };\n      },\n      push(e, a) {\n        c = r.Push;\n        let o = m(e, a);\n        d += 1, t.splice(d, t.length, o), i && h && h({\n          action: c,\n          location: o,\n          delta: 1\n        });\n      },\n      replace(e, a) {\n        c = r.Replace;\n        let o = m(e, a);\n        t[d] = o, i && h && h({\n          action: c,\n          location: o,\n          delta: 0\n        });\n      },\n      go(e) {\n        c = r.Pop;\n        let a = f(d + e),\n          o = t[a];\n        d = a, h && h({\n          action: c,\n          location: o,\n          delta: e\n        });\n      },\n      listen: e => (h = e, () => {\n        h = null;\n      })\n    };\n  }, e.createPath = l, e.createRouter = function (e) {\n    const a = e.window ? e.window : \"undefined\" != typeof window ? window : void 0,\n      i = void 0 !== a && void 0 !== a.document && void 0 !== a.document.createElement,\n      l = !i;\n    let u;\n    if (o(e.routes.length > 0, \"You must provide a non-empty routes array to createRouter\"), e.mapRouteProperties) u = e.mapRouteProperties;else if (e.detectErrorBoundary) {\n      let t = e.detectErrorBoundary;\n      u = e => ({\n        hasErrorBoundary: t(e)\n      });\n    } else u = X;\n    let d,\n      h,\n      y = {},\n      v = f(e.routes, u, void 0, y),\n      g = e.basename || \"/\",\n      b = e.unstable_dataStrategy || se,\n      w = t({\n        v7_fetcherPersist: !1,\n        v7_normalizeFormMethod: !1,\n        v7_partialHydration: !1,\n        v7_prependBasename: !1,\n        v7_relativeSplatPath: !1,\n        unstable_skipActionErrorRevalidation: !1\n      }, e.future),\n      D = null,\n      S = new Set(),\n      E = null,\n      P = null,\n      x = null,\n      L = null != e.hydrationData,\n      A = p(v, e.history.location, g),\n      M = null;\n    if (null == A) {\n      let t = De(404, {\n          pathname: e.history.location.pathname\n        }),\n        {\n          matches: r,\n          route: a\n        } = we(v);\n      A = r, M = {\n        [a.id]: t\n      };\n    }\n    let j,\n      k = A.some(e => e.route.lazy),\n      _ = A.some(e => e.route.loader);\n    if (k) h = !1;else if (_) {\n      if (w.v7_partialHydration) {\n        let t = e.hydrationData ? e.hydrationData.loaderData : null,\n          r = e.hydrationData ? e.hydrationData.errors : null,\n          a = e => !e.route.loader || (\"function\" != typeof e.route.loader || !0 !== e.route.loader.hydrate) && (t && void 0 !== t[e.route.id] || r && void 0 !== r[e.route.id]);\n        if (r) {\n          let e = A.findIndex(e => void 0 !== r[e.route.id]);\n          h = A.slice(0, e + 1).every(a);\n        } else h = A.every(a);\n      } else h = null != e.hydrationData;\n    } else h = !0;\n    let C,\n      T = {\n        historyAction: e.history.action,\n        location: e.history.location,\n        matches: A,\n        initialized: h,\n        navigation: K,\n        restoreScrollPosition: null == e.hydrationData && null,\n        preventScrollReset: !1,\n        revalidation: \"idle\",\n        loaderData: e.hydrationData && e.hydrationData.loaderData || {},\n        actionData: e.hydrationData && e.hydrationData.actionData || null,\n        errors: e.hydrationData && e.hydrationData.errors || M,\n        fetchers: new Map(),\n        blockers: new Map()\n      },\n      U = r.Pop,\n      O = !1,\n      H = !1,\n      I = new Map(),\n      z = null,\n      B = !1,\n      F = !1,\n      N = [],\n      W = [],\n      $ = new Map(),\n      Q = 0,\n      Z = -1,\n      re = new Map(),\n      oe = new Set(),\n      ne = new Map(),\n      ie = new Map(),\n      fe = new Set(),\n      pe = new Map(),\n      me = new Map(),\n      Ee = !1;\n    function Ae(e, r) {\n      void 0 === r && (r = {}), T = t({}, T, e);\n      let a = [],\n        o = [];\n      w.v7_fetcherPersist && T.fetchers.forEach((e, t) => {\n        \"idle\" === e.state && (fe.has(t) ? o.push(t) : a.push(t));\n      }), [...S].forEach(e => e(T, {\n        deletedFetchers: o,\n        unstable_viewTransitionOpts: r.viewTransitionOpts,\n        unstable_flushSync: !0 === r.flushSync\n      })), w.v7_fetcherPersist && (a.forEach(e => T.fetchers.delete(e)), o.forEach(e => Ye(e)));\n    }\n    function Me(a, o, n) {\n      var i, s;\n      let l,\n        {\n          flushSync: u\n        } = void 0 === n ? {} : n,\n        c = null != T.actionData && null != T.navigation.formMethod && ke(T.navigation.formMethod) && \"loading\" === T.navigation.state && !0 !== (null == (i = a.state) ? void 0 : i._isRedirect);\n      l = o.actionData ? Object.keys(o.actionData).length > 0 ? o.actionData : null : c ? T.actionData : null;\n      let h = o.loaderData ? ve(T.loaderData, o.loaderData, o.matches || [], o.errors) : T.loaderData,\n        f = T.blockers;\n      f.size > 0 && (f = new Map(f), f.forEach((e, t) => f.set(t, J)));\n      let p,\n        m = !0 === O || null != T.navigation.formMethod && ke(T.navigation.formMethod) && !0 !== (null == (s = a.state) ? void 0 : s._isRedirect);\n      if (d && (v = d, d = void 0), B || U === r.Pop || (U === r.Push ? e.history.push(a, a.state) : U === r.Replace && e.history.replace(a, a.state)), U === r.Pop) {\n        let e = I.get(T.location.pathname);\n        e && e.has(a.pathname) ? p = {\n          currentLocation: T.location,\n          nextLocation: a\n        } : I.has(a.pathname) && (p = {\n          currentLocation: a,\n          nextLocation: T.location\n        });\n      } else if (H) {\n        let e = I.get(T.location.pathname);\n        e ? e.add(a.pathname) : (e = new Set([a.pathname]), I.set(T.location.pathname, e)), p = {\n          currentLocation: T.location,\n          nextLocation: a\n        };\n      }\n      Ae(t({}, o, {\n        actionData: l,\n        loaderData: h,\n        historyAction: U,\n        location: a,\n        initialized: !0,\n        navigation: K,\n        revalidation: \"idle\",\n        restoreScrollPosition: at(a, o.matches || T.matches),\n        preventScrollReset: m,\n        blockers: f\n      }), {\n        viewTransitionOpts: p,\n        flushSync: !0 === u\n      }), U = r.Pop, O = !1, H = !1, B = !1, F = !1, N = [], W = [];\n    }\n    async function je(a, o, n) {\n      C && C.abort(), C = null, U = a, B = !0 === (n && n.startUninterruptedRevalidation), function (e, t) {\n        if (E && x) {\n          let r = rt(e, t);\n          E[r] = x();\n        }\n      }(T.location, T.matches), O = !0 === (n && n.preventScrollReset), H = !0 === (n && n.enableViewTransition);\n      let i = d || v,\n        s = n && n.overrideNavigation,\n        l = p(i, o, g),\n        u = !0 === (n && n.flushSync);\n      if (!l) {\n        let e = De(404, {\n            pathname: o.pathname\n          }),\n          {\n            matches: t,\n            route: r\n          } = we(i);\n        return tt(), void Me(o, {\n          matches: t,\n          loaderData: {},\n          errors: {\n            [r.id]: e\n          }\n        }, {\n          flushSync: u\n        });\n      }\n      if (T.initialized && !F && function (e, t) {\n        if (e.pathname !== t.pathname || e.search !== t.search) return !1;\n        if (\"\" === e.hash) return \"\" !== t.hash;\n        if (e.hash === t.hash) return !0;\n        if (\"\" !== t.hash) return !0;\n        return !1;\n      }(T.location, o) && !(n && n.submission && ke(n.submission.formMethod))) return void Me(o, {\n        matches: l\n      }, {\n        flushSync: u\n      });\n      C = new AbortController();\n      let h,\n        f = he(e.history, o, C.signal, n && n.submission);\n      if (n && n.pendingError) h = [be(l).route.id, {\n        type: c.error,\n        error: n.pendingError\n      }];else if (n && n.submission && ke(n.submission.formMethod)) {\n        let t = await async function (e, t, a, o, n) {\n          void 0 === n && (n = {});\n          let i;\n          We(), Ae({\n            navigation: Ie(t, a)\n          }, {\n            flushSync: !0 === n.flushSync\n          });\n          let s = Ue(o, t);\n          if (s.route.action || s.route.lazy) {\n            if (i = (await Fe(\"action\", e, [s], o))[0], e.signal.aborted) return {\n              shortCircuited: !0\n            };\n          } else i = {\n            type: c.error,\n            error: De(405, {\n              method: e.method,\n              pathname: t.pathname,\n              routeId: s.route.id\n            })\n          };\n          if (Le(i)) {\n            let t;\n            if (n && null != n.replace) t = n.replace;else {\n              t = ce(i.response.headers.get(\"Location\"), new URL(e.url), g) === T.location.pathname + T.location.search;\n            }\n            return await Te(e, i, {\n              submission: a,\n              replace: t\n            }), {\n              shortCircuited: !0\n            };\n          }\n          if (Pe(i)) throw De(400, {\n            type: \"defer-action\"\n          });\n          if (xe(i)) {\n            let e = be(o, s.route.id);\n            return !0 !== (n && n.replace) && (U = r.Push), {\n              pendingActionResult: [e.route.id, i]\n            };\n          }\n          return {\n            pendingActionResult: [s.route.id, i]\n          };\n        }(f, o, n.submission, l, {\n          replace: n.replace,\n          flushSync: u\n        });\n        if (t.shortCircuited) return;\n        h = t.pendingActionResult, s = He(o, n.submission), u = !1, f = he(e.history, f.url, f.signal);\n      }\n      let {\n        shortCircuited: m,\n        loaderData: y,\n        errors: b\n      } = await async function (r, a, o, n, i, s, l, u, c, h) {\n        let f = n || He(a, i),\n          p = i || s || Oe(f),\n          m = d || v,\n          [y, b] = ae(e.history, T, o, p, a, w.v7_partialHydration && !0 === u, w.unstable_skipActionErrorRevalidation, F, N, W, fe, ne, oe, m, g, h);\n        if (tt(e => !(o && o.some(t => t.route.id === e)) || y && y.some(t => t.route.id === e)), Z = ++Q, 0 === y.length && 0 === b.length) {\n          let e = Xe();\n          return Me(a, t({\n            matches: o,\n            loaderData: {},\n            errors: h && xe(h[1]) ? {\n              [h[0]]: h[1].error\n            } : null\n          }, ge(h), e ? {\n            fetchers: new Map(T.fetchers)\n          } : {}), {\n            flushSync: c\n          }), {\n            shortCircuited: !0\n          };\n        }\n        if (!(B || w.v7_partialHydration && u)) {\n          let e;\n          b.forEach(e => {\n            let t = T.fetchers.get(e.key),\n              r = ze(void 0, t ? t.data : void 0);\n            T.fetchers.set(e.key, r);\n          }), h && !xe(h[1]) ? e = {\n            [h[0]]: h[1].data\n          } : T.actionData && (e = 0 === Object.keys(T.actionData).length ? null : T.actionData), Ae(t({\n            navigation: f\n          }, void 0 !== e ? {\n            actionData: e\n          } : {}, b.length > 0 ? {\n            fetchers: new Map(T.fetchers)\n          } : {}), {\n            flushSync: c\n          });\n        }\n        b.forEach(e => {\n          $.has(e.key) && Je(e.key), e.controller && $.set(e.key, e.controller);\n        });\n        let D = () => b.forEach(e => Je(e.key));\n        C && C.signal.addEventListener(\"abort\", D);\n        let {\n          loaderResults: S,\n          fetcherResults: E\n        } = await Ne(T.matches, o, y, b, r);\n        if (r.signal.aborted) return {\n          shortCircuited: !0\n        };\n        C && C.signal.removeEventListener(\"abort\", D);\n        b.forEach(e => $.delete(e.key));\n        let R = Se([...S, ...E]);\n        if (R) {\n          if (R.idx >= y.length) {\n            let e = b[R.idx - y.length].key;\n            oe.add(e);\n          }\n          return await Te(r, R.result, {\n            replace: l\n          }), {\n            shortCircuited: !0\n          };\n        }\n        let {\n          loaderData: P,\n          errors: x\n        } = ye(T, o, y, S, h, b, E, pe);\n        pe.forEach((e, t) => {\n          e.subscribe(r => {\n            (r || e.done) && pe.delete(t);\n          });\n        }), w.v7_partialHydration && u && T.errors && Object.entries(T.errors).filter(e => {\n          let [t] = e;\n          return !y.some(e => e.route.id === t);\n        }).forEach(e => {\n          let [t, r] = e;\n          x = Object.assign(x || {}, {\n            [t]: r\n          });\n        });\n        let L = Xe(),\n          A = Ge(Z),\n          M = L || A || b.length > 0;\n        return t({\n          loaderData: P,\n          errors: x\n        }, M ? {\n          fetchers: new Map(T.fetchers)\n        } : {});\n      }(f, o, l, s, n && n.submission, n && n.fetcherSubmission, n && n.replace, n && !0 === n.initialHydration, u, h);\n      m || (C = null, Me(o, t({\n        matches: l\n      }, ge(h), {\n        loaderData: y,\n        errors: b\n      })));\n    }\n    async function Te(n, l, u) {\n      let {\n        submission: d,\n        fetcherSubmission: c,\n        replace: h\n      } = void 0 === u ? {} : u;\n      l.response.headers.has(\"X-Remix-Revalidate\") && (F = !0);\n      let f = l.response.headers.get(\"Location\");\n      o(f, \"Expected a Location header on the redirect Response\"), f = ce(f, new URL(n.url), g);\n      let p = s(T.location, f, {\n        _isRedirect: !0\n      });\n      if (i) {\n        let t = !1;\n        if (l.response.headers.has(\"X-Remix-Reload-Document\")) t = !0;else if (V.test(f)) {\n          const r = e.history.createURL(f);\n          t = r.origin !== a.location.origin || null == R(r.pathname, g);\n        }\n        if (t) return void (h ? a.location.replace(f) : a.location.assign(f));\n      }\n      C = null;\n      let m = !0 === h ? r.Replace : r.Push,\n        {\n          formMethod: y,\n          formAction: v,\n          formEncType: b\n        } = T.navigation;\n      !d && !c && y && v && b && (d = Oe(T.navigation));\n      let w = d || c;\n      if (q.has(l.response.status) && w && ke(w.formMethod)) await je(m, p, {\n        submission: t({}, w, {\n          formAction: f\n        }),\n        preventScrollReset: O\n      });else {\n        let e = He(p, d);\n        await je(m, p, {\n          overrideNavigation: e,\n          fetcherSubmission: c,\n          preventScrollReset: O\n        });\n      }\n    }\n    async function Fe(e, t, r, a) {\n      try {\n        let o = await le(b, e, t, r, a, y, u);\n        return await Promise.all(o.map((e, o) => {\n          if (Re(e)) {\n            let n = e.result;\n            return {\n              type: c.redirect,\n              response: de(n, t, r[o].route.id, a, g, w.v7_relativeSplatPath)\n            };\n          }\n          return ue(e);\n        }));\n      } catch (e) {\n        return r.map(() => ({\n          type: c.error,\n          error: e\n        }));\n      }\n    }\n    async function Ne(t, r, a, o, n) {\n      let [i, ...s] = await Promise.all([a.length ? Fe(\"loader\", n, a, r) : [], ...o.map(t => {\n        if (t.matches && t.match && t.controller) {\n          return Fe(\"loader\", he(e.history, t.path, t.controller.signal), [t.match], t.matches).then(e => e[0]);\n        }\n        return Promise.resolve({\n          type: c.error,\n          error: De(404, {\n            pathname: t.path\n          })\n        });\n      })]);\n      return await Promise.all([_e(t, a, i, i.map(() => n.signal), !1, T.loaderData), _e(t, o.map(e => e.match), s, o.map(e => e.controller ? e.controller.signal : null), !0)]), {\n        loaderResults: i,\n        fetcherResults: s\n      };\n    }\n    function We() {\n      F = !0, N.push(...tt()), ne.forEach((e, t) => {\n        $.has(t) && (W.push(t), Je(t));\n      });\n    }\n    function $e(e, t, r) {\n      void 0 === r && (r = {}), T.fetchers.set(e, t), Ae({\n        fetchers: new Map(T.fetchers)\n      }, {\n        flushSync: !0 === (r && r.flushSync)\n      });\n    }\n    function qe(e, t, r, a) {\n      void 0 === a && (a = {});\n      let o = be(T.matches, t);\n      Ye(e), Ae({\n        errors: {\n          [o.route.id]: r\n        },\n        fetchers: new Map(T.fetchers)\n      }, {\n        flushSync: !0 === (a && a.flushSync)\n      });\n    }\n    function Ke(e) {\n      return w.v7_fetcherPersist && (ie.set(e, (ie.get(e) || 0) + 1), fe.has(e) && fe.delete(e)), T.fetchers.get(e) || Y;\n    }\n    function Ye(e) {\n      let t = T.fetchers.get(e);\n      !$.has(e) || t && \"loading\" === t.state && re.has(e) || Je(e), ne.delete(e), re.delete(e), oe.delete(e), fe.delete(e), T.fetchers.delete(e);\n    }\n    function Je(e) {\n      let t = $.get(e);\n      o(t, \"Expected fetch controller: \" + e), t.abort(), $.delete(e);\n    }\n    function Ve(e) {\n      for (let t of e) {\n        let e = Be(Ke(t).data);\n        T.fetchers.set(t, e);\n      }\n    }\n    function Xe() {\n      let e = [],\n        t = !1;\n      for (let r of oe) {\n        let a = T.fetchers.get(r);\n        o(a, \"Expected fetcher: \" + r), \"loading\" === a.state && (oe.delete(r), e.push(r), t = !0);\n      }\n      return Ve(e), t;\n    }\n    function Ge(e) {\n      let t = [];\n      for (let [r, a] of re) if (a < e) {\n        let e = T.fetchers.get(r);\n        o(e, \"Expected fetcher: \" + r), \"loading\" === e.state && (Je(r), re.delete(r), t.push(r));\n      }\n      return Ve(t), t.length > 0;\n    }\n    function Qe(e) {\n      T.blockers.delete(e), me.delete(e);\n    }\n    function Ze(e, t) {\n      let r = T.blockers.get(e) || J;\n      o(\"unblocked\" === r.state && \"blocked\" === t.state || \"blocked\" === r.state && \"blocked\" === t.state || \"blocked\" === r.state && \"proceeding\" === t.state || \"blocked\" === r.state && \"unblocked\" === t.state || \"proceeding\" === r.state && \"unblocked\" === t.state, \"Invalid blocker state transition: \" + r.state + \" -> \" + t.state);\n      let a = new Map(T.blockers);\n      a.set(e, t), Ae({\n        blockers: a\n      });\n    }\n    function et(e) {\n      let {\n        currentLocation: t,\n        nextLocation: r,\n        historyAction: a\n      } = e;\n      if (0 === me.size) return;\n      me.size > 1 && n(!1, \"A router only supports one blocker at a time\");\n      let o = Array.from(me.entries()),\n        [i, s] = o[o.length - 1],\n        l = T.blockers.get(i);\n      return l && \"proceeding\" === l.state ? void 0 : s({\n        currentLocation: t,\n        nextLocation: r,\n        historyAction: a\n      }) ? i : void 0;\n    }\n    function tt(e) {\n      let t = [];\n      return pe.forEach((r, a) => {\n        e && !e(a) || (r.cancel(), t.push(a), pe.delete(a));\n      }), t;\n    }\n    function rt(e, t) {\n      if (P) {\n        return P(e, t.map(e => m(e, T.loaderData))) || e.key;\n      }\n      return e.key;\n    }\n    function at(e, t) {\n      if (E) {\n        let r = rt(e, t),\n          a = E[r];\n        if (\"number\" == typeof a) return a;\n      }\n      return null;\n    }\n    return j = {\n      get basename() {\n        return g;\n      },\n      get future() {\n        return w;\n      },\n      get state() {\n        return T;\n      },\n      get routes() {\n        return v;\n      },\n      get window() {\n        return a;\n      },\n      initialize: function () {\n        if (D = e.history.listen(t => {\n          let {\n            action: r,\n            location: a,\n            delta: o\n          } = t;\n          if (Ee) return void (Ee = !1);\n          n(0 === me.size || null != o, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n          let i = et({\n            currentLocation: T.location,\n            nextLocation: a,\n            historyAction: r\n          });\n          return i && null != o ? (Ee = !0, e.history.go(-1 * o), void Ze(i, {\n            state: \"blocked\",\n            location: a,\n            proceed() {\n              Ze(i, {\n                state: \"proceeding\",\n                proceed: void 0,\n                reset: void 0,\n                location: a\n              }), e.history.go(o);\n            },\n            reset() {\n              let e = new Map(T.blockers);\n              e.set(i, J), Ae({\n                blockers: e\n              });\n            }\n          })) : je(r, a);\n        }), i) {\n          !function (e, t) {\n            try {\n              let r = e.sessionStorage.getItem(G);\n              if (r) {\n                let e = JSON.parse(r);\n                for (let [r, a] of Object.entries(e || {})) a && Array.isArray(a) && t.set(r, new Set(a || []));\n              }\n            } catch (e) {}\n          }(a, I);\n          let e = () => function (e, t) {\n            if (t.size > 0) {\n              let r = {};\n              for (let [e, a] of t) r[e] = [...a];\n              try {\n                e.sessionStorage.setItem(G, JSON.stringify(r));\n              } catch (e) {\n                n(!1, \"Failed to save applied view transitions in sessionStorage (\" + e + \").\");\n              }\n            }\n          }(a, I);\n          a.addEventListener(\"pagehide\", e), z = () => a.removeEventListener(\"pagehide\", e);\n        }\n        return T.initialized || je(r.Pop, T.location, {\n          initialHydration: !0\n        }), j;\n      },\n      subscribe: function (e) {\n        return S.add(e), () => S.delete(e);\n      },\n      enableScrollRestoration: function (e, t, r) {\n        if (E = e, x = t, P = r || null, !L && T.navigation === K) {\n          L = !0;\n          let e = at(T.location, T.matches);\n          null != e && Ae({\n            restoreScrollPosition: e\n          });\n        }\n        return () => {\n          E = null, x = null, P = null;\n        };\n      },\n      navigate: async function a(o, n) {\n        if (\"number\" == typeof o) return void e.history.go(o);\n        let i = ee(T.location, T.matches, g, w.v7_prependBasename, o, w.v7_relativeSplatPath, null == n ? void 0 : n.fromRouteId, null == n ? void 0 : n.relative),\n          {\n            path: l,\n            submission: u,\n            error: d\n          } = te(w.v7_normalizeFormMethod, !1, i, n),\n          c = T.location,\n          h = s(T.location, l, n && n.state);\n        h = t({}, h, e.history.encodeLocation(h));\n        let f = n && null != n.replace ? n.replace : void 0,\n          p = r.Push;\n        !0 === f ? p = r.Replace : !1 === f || null != u && ke(u.formMethod) && u.formAction === T.location.pathname + T.location.search && (p = r.Replace);\n        let m = n && \"preventScrollReset\" in n ? !0 === n.preventScrollReset : void 0,\n          y = !0 === (n && n.unstable_flushSync),\n          v = et({\n            currentLocation: c,\n            nextLocation: h,\n            historyAction: p\n          });\n        if (!v) return await je(p, h, {\n          submission: u,\n          pendingError: d,\n          preventScrollReset: m,\n          replace: n && n.replace,\n          enableViewTransition: n && n.unstable_viewTransition,\n          flushSync: y\n        });\n        Ze(v, {\n          state: \"blocked\",\n          location: h,\n          proceed() {\n            Ze(v, {\n              state: \"proceeding\",\n              proceed: void 0,\n              reset: void 0,\n              location: h\n            }), a(o, n);\n          },\n          reset() {\n            let e = new Map(T.blockers);\n            e.set(v, J), Ae({\n              blockers: e\n            });\n          }\n        });\n      },\n      fetch: function (t, r, a, n) {\n        if (l) throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\");\n        $.has(t) && Je(t);\n        let i = !0 === (n && n.unstable_flushSync),\n          s = d || v,\n          u = ee(T.location, T.matches, g, w.v7_prependBasename, a, w.v7_relativeSplatPath, r, null == n ? void 0 : n.relative),\n          c = p(s, u, g);\n        if (!c) return void qe(t, r, De(404, {\n          pathname: u\n        }), {\n          flushSync: i\n        });\n        let {\n          path: h,\n          submission: f,\n          error: m\n        } = te(w.v7_normalizeFormMethod, !0, u, n);\n        if (m) return void qe(t, r, m, {\n          flushSync: i\n        });\n        let y = Ue(c, h);\n        O = !0 === (n && n.preventScrollReset), f && ke(f.formMethod) ? async function (t, r, a, n, i, s, l) {\n          if (We(), ne.delete(t), !n.route.action && !n.route.lazy) {\n            let e = De(405, {\n              method: l.formMethod,\n              pathname: a,\n              routeId: r\n            });\n            return void qe(t, r, e, {\n              flushSync: s\n            });\n          }\n          let u = T.fetchers.get(t);\n          $e(t, function (e, t) {\n            return {\n              state: \"submitting\",\n              formMethod: e.formMethod,\n              formAction: e.formAction,\n              formEncType: e.formEncType,\n              formData: e.formData,\n              json: e.json,\n              text: e.text,\n              data: t ? t.data : void 0\n            };\n          }(l, u), {\n            flushSync: s\n          });\n          let c = new AbortController(),\n            h = he(e.history, a, c.signal, l);\n          $.set(t, c);\n          let f = Q,\n            m = (await Fe(\"action\", h, [n], i))[0];\n          if (h.signal.aborted) return void ($.get(t) === c && $.delete(t));\n          if (w.v7_fetcherPersist && fe.has(t)) {\n            if (Le(m) || xe(m)) return void $e(t, Be(void 0));\n          } else {\n            if (Le(m)) return $.delete(t), Z > f ? void $e(t, Be(void 0)) : (oe.add(t), $e(t, ze(l)), Te(h, m, {\n              fetcherSubmission: l\n            }));\n            if (xe(m)) return void qe(t, r, m.error);\n          }\n          if (Pe(m)) throw De(400, {\n            type: \"defer-action\"\n          });\n          let y = T.navigation.location || T.location,\n            b = he(e.history, y, c.signal),\n            D = d || v,\n            S = \"idle\" !== T.navigation.state ? p(D, T.navigation.location, g) : T.matches;\n          o(S, \"Didn't find any matches after fetcher action\");\n          let E = ++Q;\n          re.set(t, E);\n          let R = ze(l, m.data);\n          T.fetchers.set(t, R);\n          let [P, x] = ae(e.history, T, S, l, y, !1, w.unstable_skipActionErrorRevalidation, F, N, W, fe, ne, oe, D, g, [n.route.id, m]);\n          x.filter(e => e.key !== t).forEach(e => {\n            let t = e.key,\n              r = T.fetchers.get(t),\n              a = ze(void 0, r ? r.data : void 0);\n            T.fetchers.set(t, a), $.has(t) && Je(t), e.controller && $.set(t, e.controller);\n          }), Ae({\n            fetchers: new Map(T.fetchers)\n          });\n          let L = () => x.forEach(e => Je(e.key));\n          c.signal.addEventListener(\"abort\", L);\n          let {\n            loaderResults: A,\n            fetcherResults: M\n          } = await Ne(T.matches, S, P, x, b);\n          if (c.signal.aborted) return;\n          c.signal.removeEventListener(\"abort\", L), re.delete(t), $.delete(t), x.forEach(e => $.delete(e.key));\n          let j = Se([...A, ...M]);\n          if (j) {\n            if (j.idx >= P.length) {\n              let e = x[j.idx - P.length].key;\n              oe.add(e);\n            }\n            return Te(b, j.result);\n          }\n          let {\n            loaderData: k,\n            errors: _\n          } = ye(T, T.matches, P, A, void 0, x, M, pe);\n          if (T.fetchers.has(t)) {\n            let e = Be(m.data);\n            T.fetchers.set(t, e);\n          }\n          Ge(E), \"loading\" === T.navigation.state && E > Z ? (o(U, \"Expected pending action\"), C && C.abort(), Me(T.navigation.location, {\n            matches: S,\n            loaderData: k,\n            errors: _,\n            fetchers: new Map(T.fetchers)\n          })) : (Ae({\n            errors: _,\n            loaderData: ve(T.loaderData, k, S, _),\n            fetchers: new Map(T.fetchers)\n          }), F = !1);\n        }(t, r, h, y, c, i, f) : (ne.set(t, {\n          routeId: r,\n          path: h\n        }), async function (t, r, a, n, i, s, l) {\n          let u = T.fetchers.get(t);\n          $e(t, ze(l, u ? u.data : void 0), {\n            flushSync: s\n          });\n          let d = new AbortController(),\n            c = he(e.history, a, d.signal);\n          $.set(t, d);\n          let h = Q,\n            f = (await Fe(\"loader\", c, [n], i))[0];\n          Pe(f) && (f = (await Ce(f, c.signal, !0)) || f);\n          $.get(t) === d && $.delete(t);\n          if (c.signal.aborted) return;\n          if (fe.has(t)) return void $e(t, Be(void 0));\n          if (Le(f)) return Z > h ? void $e(t, Be(void 0)) : (oe.add(t), void (await Te(c, f)));\n          if (xe(f)) return void qe(t, r, f.error);\n          o(!Pe(f), \"Unhandled fetcher deferred data\"), $e(t, Be(f.data));\n        }(t, r, h, y, c, i, f));\n      },\n      revalidate: function () {\n        We(), Ae({\n          revalidation: \"loading\"\n        }), \"submitting\" !== T.navigation.state && (\"idle\" !== T.navigation.state ? je(U || T.historyAction, T.navigation.location, {\n          overrideNavigation: T.navigation\n        }) : je(T.historyAction, T.location, {\n          startUninterruptedRevalidation: !0\n        }));\n      },\n      createHref: t => e.history.createHref(t),\n      encodeLocation: t => e.history.encodeLocation(t),\n      getFetcher: Ke,\n      deleteFetcher: function (e) {\n        if (w.v7_fetcherPersist) {\n          let t = (ie.get(e) || 0) - 1;\n          t <= 0 ? (ie.delete(e), fe.add(e)) : ie.set(e, t);\n        } else Ye(e);\n        Ae({\n          fetchers: new Map(T.fetchers)\n        });\n      },\n      dispose: function () {\n        D && D(), z && z(), S.clear(), C && C.abort(), T.fetchers.forEach((e, t) => Ye(t)), T.blockers.forEach((e, t) => Qe(t));\n      },\n      getBlocker: function (e, t) {\n        let r = T.blockers.get(e) || J;\n        return me.get(e) !== t && me.set(e, t), r;\n      },\n      deleteBlocker: Qe,\n      _internalFetchControllers: $,\n      _internalActiveDeferreds: pe,\n      _internalSetRoutes: function (e) {\n        y = {}, d = f(e, u, void 0, y);\n      }\n    }, j;\n  }, e.createStaticHandler = function (e, r) {\n    o(e.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let a,\n      n = {},\n      i = (r ? r.basename : null) || \"/\";\n    if (null != r && r.mapRouteProperties) a = r.mapRouteProperties;else if (null != r && r.detectErrorBoundary) {\n      let e = r.detectErrorBoundary;\n      a = t => ({\n        hasErrorBoundary: e(t)\n      });\n    } else a = X;\n    let u = t({\n        v7_relativeSplatPath: !1,\n        v7_throwAbortReason: !1\n      }, r ? r.future : null),\n      d = f(e, a, void 0, n);\n    async function h(e, r, a, n, i, s, l) {\n      o(e.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n      try {\n        if (ke(e.method.toLowerCase())) {\n          let o = await async function (e, r, a, o, n, i, s) {\n            let l;\n            if (a.route.action || a.route.lazy) {\n              l = (await y(\"action\", e, [a], r, s, o, n))[0], e.signal.aborted && Z(e, s, u);\n            } else {\n              let t = De(405, {\n                method: e.method,\n                pathname: new URL(e.url).pathname,\n                routeId: a.route.id\n              });\n              if (s) throw t;\n              l = {\n                type: c.error,\n                error: t\n              };\n            }\n            if (Le(l)) throw new Response(null, {\n              status: l.response.status,\n              headers: {\n                Location: l.response.headers.get(\"Location\")\n              }\n            });\n            if (Pe(l)) {\n              let e = De(400, {\n                type: \"defer-action\"\n              });\n              if (s) throw e;\n              l = {\n                type: c.error,\n                error: e\n              };\n            }\n            if (s) {\n              if (xe(l)) throw l.error;\n              return {\n                matches: [a],\n                loaderData: {},\n                actionData: {\n                  [a.route.id]: l.data\n                },\n                errors: null,\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n              };\n            }\n            let d = new Request(e.url, {\n              headers: e.headers,\n              redirect: e.redirect,\n              signal: e.signal\n            });\n            if (xe(l)) {\n              let e = i ? a : be(r, a.route.id);\n              return t({}, await m(d, r, o, n, i, null, [e.route.id, l]), {\n                statusCode: z(l.error) ? l.error.status : null != l.statusCode ? l.statusCode : 500,\n                actionData: null,\n                actionHeaders: t({}, l.headers ? {\n                  [a.route.id]: l.headers\n                } : {})\n              });\n            }\n            return t({}, await m(d, r, o, n, i, null), {\n              actionData: {\n                [a.route.id]: l.data\n              }\n            }, l.statusCode ? {\n              statusCode: l.statusCode\n            } : {}, {\n              actionHeaders: l.headers ? {\n                [a.route.id]: l.headers\n              } : {}\n            });\n          }(e, a, l || Ue(a, r), n, i, s, null != l);\n          return o;\n        }\n        let o = await m(e, a, n, i, s, l);\n        return Me(o) ? o : t({}, o, {\n          actionData: null,\n          actionHeaders: {}\n        });\n      } catch (e) {\n        if (function (e) {\n          return null != e && \"object\" == typeof e && \"type\" in e && \"result\" in e && (e.type === c.data || e.type === c.error);\n        }(e) && Me(e.result)) {\n          if (e.type === c.error) throw e.result;\n          return e.result;\n        }\n        if (function (e) {\n          if (!Me(e)) return !1;\n          let t = e.status,\n            r = e.headers.get(\"Location\");\n          return t >= 300 && t <= 399 && null != r;\n        }(e)) return e;\n        throw e;\n      }\n    }\n    async function m(e, r, a, o, n, i, s) {\n      let l = null != i;\n      if (l && (null == i || !i.route.loader) && (null == i || !i.route.lazy)) throw De(400, {\n        method: e.method,\n        pathname: new URL(e.url).pathname,\n        routeId: null == i ? void 0 : i.route.id\n      });\n      let d = (i ? [i] : s && xe(s[1]) ? re(r, s[0]) : r).filter(e => e.route.loader || e.route.lazy);\n      if (0 === d.length) return {\n        matches: r,\n        loaderData: r.reduce((e, t) => Object.assign(e, {\n          [t.route.id]: null\n        }), {}),\n        errors: s && xe(s[1]) ? {\n          [s[0]]: s[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n      let c = await y(\"loader\", e, d, r, l, a, o);\n      e.signal.aborted && Z(e, l, u);\n      let h = new Map(),\n        f = me(r, d, c, s, h, n),\n        p = new Set(d.map(e => e.route.id));\n      return r.forEach(e => {\n        p.has(e.route.id) || (f.loaderData[e.route.id] = null);\n      }), t({}, f, {\n        matches: r,\n        activeDeferreds: h.size > 0 ? Object.fromEntries(h.entries()) : null\n      });\n    }\n    async function y(e, t, r, o, s, l, d) {\n      let c = await le(d || se, e, t, r, o, n, a, l);\n      return await Promise.all(c.map((e, a) => {\n        if (Re(e)) {\n          throw de(e.result, t, r[a].route.id, o, i, u.v7_relativeSplatPath);\n        }\n        if (Me(e.result) && s) throw e;\n        return ue(e);\n      }));\n    }\n    return {\n      dataRoutes: d,\n      query: async function (e, r) {\n        let {\n            requestContext: a,\n            skipLoaderErrorBubbling: o,\n            unstable_dataStrategy: n\n          } = void 0 === r ? {} : r,\n          u = new URL(e.url),\n          c = e.method,\n          f = s(\"\", l(u), null, \"default\"),\n          m = p(d, f, i);\n        if (!je(c) && \"HEAD\" !== c) {\n          let e = De(405, {\n              method: c\n            }),\n            {\n              matches: t,\n              route: r\n            } = we(d);\n          return {\n            basename: i,\n            location: f,\n            matches: t,\n            loaderData: {},\n            actionData: null,\n            errors: {\n              [r.id]: e\n            },\n            statusCode: e.status,\n            loaderHeaders: {},\n            actionHeaders: {},\n            activeDeferreds: null\n          };\n        }\n        if (!m) {\n          let e = De(404, {\n              pathname: f.pathname\n            }),\n            {\n              matches: t,\n              route: r\n            } = we(d);\n          return {\n            basename: i,\n            location: f,\n            matches: t,\n            loaderData: {},\n            actionData: null,\n            errors: {\n              [r.id]: e\n            },\n            statusCode: e.status,\n            loaderHeaders: {},\n            actionHeaders: {},\n            activeDeferreds: null\n          };\n        }\n        let y = await h(e, f, m, a, n || null, !0 === o, null);\n        return Me(y) ? y : t({\n          location: f,\n          basename: i\n        }, y);\n      },\n      queryRoute: async function (e, t) {\n        let {\n            routeId: r,\n            requestContext: a\n          } = void 0 === t ? {} : t,\n          o = new URL(e.url),\n          n = e.method,\n          u = s(\"\", l(o), null, \"default\"),\n          c = p(d, u, i);\n        if (!je(n) && \"HEAD\" !== n && \"OPTIONS\" !== n) throw De(405, {\n          method: n\n        });\n        if (!c) throw De(404, {\n          pathname: u.pathname\n        });\n        let f = r ? c.find(e => e.route.id === r) : Ue(c, u);\n        if (r && !f) throw De(403, {\n          pathname: u.pathname,\n          routeId: r\n        });\n        if (!f) throw De(404, {\n          pathname: u.pathname\n        });\n        let m = await h(e, u, c, a, null, !1, f);\n        if (Me(m)) return m;\n        let y = m.errors ? Object.values(m.errors)[0] : void 0;\n        if (void 0 !== y) throw y;\n        if (m.actionData) return Object.values(m.actionData)[0];\n        if (m.loaderData) {\n          var v;\n          let e = Object.values(m.loaderData)[0];\n          return null != (v = m.activeDeferreds) && v[f.route.id] && (e[Q] = m.activeDeferreds[f.route.id]), e;\n        }\n      }\n    };\n  }, e.defer = function (e, t) {\n    return void 0 === t && (t = {}), new U(e, \"number\" == typeof t ? {\n      status: t\n    } : t);\n  }, e.generatePath = function (e, t) {\n    void 0 === t && (t = {});\n    let r = e;\n    r.endsWith(\"*\") && \"*\" !== r && !r.endsWith(\"/*\") && (n(!1, 'Route path \"' + r + '\" will be treated as if it were \"' + r.replace(/\\*$/, \"/*\") + '\" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to \"' + r.replace(/\\*$/, \"/*\") + '\".'), r = r.replace(/\\*$/, \"/*\"));\n    const a = r.startsWith(\"/\") ? \"/\" : \"\",\n      i = e => null == e ? \"\" : \"string\" == typeof e ? e : String(e);\n    return a + r.split(/\\/+/).map((e, r, a) => {\n      if (r === a.length - 1 && \"*\" === e) {\n        return i(t[\"*\"]);\n      }\n      const n = e.match(/^:([\\w-]+)(\\??)$/);\n      if (n) {\n        const [, e, r] = n;\n        let a = t[e];\n        return o(\"?\" === r || null != a, 'Missing \":' + e + '\" param'), i(a);\n      }\n      return e.replace(/\\?$/g, \"\");\n    }).filter(e => !!e).join(\"/\");\n  }, e.getStaticContextFromError = function (e, r, a) {\n    return t({}, r, {\n      statusCode: z(a) ? a.status : 500,\n      errors: {\n        [r._deepestRenderedBoundaryId || e[0].id]: a\n      }\n    });\n  }, e.getToPathname = function (e) {\n    return \"\" === e || \"\" === e.pathname ? \"/\" : \"string\" == typeof e ? u(e).pathname : e.pathname;\n  }, e.isDeferredData = Ae, e.isRouteErrorResponse = z, e.joinPaths = j, e.json = function (e, r) {\n    void 0 === r && (r = {});\n    let a = \"number\" == typeof r ? {\n        status: r\n      } : r,\n      o = new Headers(a.headers);\n    return o.has(\"Content-Type\") || o.set(\"Content-Type\", \"application/json; charset=utf-8\"), new Response(JSON.stringify(e), t({}, a, {\n      headers: o\n    }));\n  }, e.matchPath = S, e.matchRoutes = p, e.normalizePathname = k, e.parsePath = u, e.redirect = H, e.redirectDocument = (e, t) => {\n    let r = H(e, t);\n    return r.headers.set(\"X-Remix-Reload-Document\", \"true\"), r;\n  }, e.resolvePath = P, e.resolveTo = M, e.stripBasename = R, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"names":["r","e","Pop","Push","Replace","a","o","t","Error","n","console","warn","i","usr","state","key","idx","s","pathname","search","hash","u","Math","random","toString","substr","l","charAt","indexOf","d","window","c","document","defaultView","v5Compat","h","f","history","p","m","y","v","g","action","location","w","delta","b","origin","href","replace","URL","replaceState","listen","addEventListener","removeEventListener","createHref","createURL","encodeLocation","push","pushState","DOMException","name","assign","go","data","deferred","redirect","error","Set","map","id","join","index","children","R","sort","score","length","slice","every","routesMeta","childrenIndex","E","D","route","params","handle","relativePath","path","caseSensitive","startsWith","j","concat","forEach","includes","split","endsWith","some","filter","reduce","test","S","end","Object","pathnameBase","k","paramName","isOptional","RegExp","match","pattern","decodeURIComponent","toLowerCase","P","pop","_","C","x","JSON","stringify","L","A","M","shift","T","U","constructor","pendingKeysSet","subscribers","deferredKeys","Array","isArray","abortPromise","Promise","controller","AbortController","unlistenAbortSignal","signal","entries","trackPromise","done","init","add","race","then","onSettle","catch","defineProperty","get","aborted","reject","delete","emit","subscribe","cancel","abort","resolveData","size","unwrappedData","O","pendingKeys","from","_tracked","_error","_data","H","status","Headers","headers","set","Response","I","statusText","internal","z","B","F","N","W","$","q","K","formMethod","formAction","formEncType","formData","json","text","Y","J","proceed","reset","V","X","hasErrorBoundary","Boolean","G","Q","Symbol","Z","v7_throwAbortReason","reason","method","url","ee","Te","te","body","je","De","type","toUpperCase","Ee","ke","FormData","URLSearchParams","String","submission","parse","fe","pe","append","re","findIndex","ae","xe","statusCode","lazy","loader","hydrate","loaderData","errors","matches","ne","currentUrl","currentParams","nextUrl","nextParams","actionResult","unstable_actionStatus","defaultShouldRevalidate","oe","routeId","has","fetchers","Ue","shouldRevalidate","ie","se","all","resolve","le","shouldLoad","request","context","result","ue","Me","Ae","deferredData","de","ce","protocol","he","Request","me","Le","be","Pe","loaderHeaders","ye","Be","ve","hasOwnProperty","ge","actionData","reverse","find","we","Se","Re","_e","Ce","getAll","Oe","He","Ie","ze","AbortedDeferredError","Action","IDLE_BLOCKER","IDLE_FETCHER","IDLE_NAVIGATION","UNSAFE_DEFERRED_SYMBOL","UNSAFE_DeferredData","UNSAFE_ErrorResponseImpl","UNSAFE_convertRouteMatchToUiMatch","UNSAFE_convertRoutesToDataRoutes","UNSAFE_getResolveToMatches","UNSAFE_invariant","UNSAFE_warning","createBrowserHistory","createHashHistory","querySelector","getAttribute","createMemoryHistory","initialEntries","initialIndex","min","max","splice","createPath","createRouter","createElement","routes","mapRouteProperties","detectErrorBoundary","basename","unstable_dataStrategy","v7_fetcherPersist","v7_normalizeFormMethod","v7_partialHydration","v7_prependBasename","v7_relativeSplatPath","unstable_skipActionErrorRevalidation","future","hydrationData","historyAction","initialized","navigation","restoreScrollPosition","preventScrollReset","revalidation","Map","blockers","deletedFetchers","unstable_viewTransitionOpts","viewTransitionOpts","unstable_flushSync","flushSync","Ye","_isRedirect","keys","currentLocation","nextLocation","at","startUninterruptedRevalidation","rt","enableViewTransition","overrideNavigation","tt","pendingError","We","Fe","shortCircuited","response","pendingActionResult","Xe","Je","loaderResults","fetcherResults","Ne","Ge","fetcherSubmission","initialHydration","$e","qe","Ke","Ve","Qe","Ze","et","initialize","sessionStorage","getItem","setItem","enableScrollRestoration","navigate","fromRouteId","relative","unstable_viewTransition","fetch","revalidate","getFetcher","deleteFetcher","dispose","clear","getBlocker","deleteBlocker","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","createStaticHandler","Location","actionHeaders","activeDeferreds","fromEntries","dataRoutes","query","requestContext","skipLoaderErrorBubbling","queryRoute","values","defer","generatePath","getStaticContextFromError","_deepestRenderedBoundaryId","getToPathname","isDeferredData","isRouteErrorResponse","joinPaths","matchPath","matchRoutes","normalizePathname","parsePath","redirectDocument","resolvePath","resolveTo","stripBasename","value"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@remix-run\\router\\history.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@remix-run\\router\\utils.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@remix-run\\router\\router.ts"],"sourcesContent":["////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n// TODO: (v7) Change the Location generic default from `any` to `unknown` and\n// remove Remix `useLocation` wrapper.\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location<State = any> extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: State;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n\n  /**\n   * The delta between this location and the former location in the history stack\n   */\n  delta: number | null;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. This may be either a URL or the pieces\n * of a URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Returns a URL for the given `to` value\n   *\n   * @param to - The destination URL\n   */\n  createURL(to: To): URL;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n  idx: number;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  function createHref(to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport function warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location, index: number): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n\n  function getIndex(): number {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base =\n      window.location.origin !== \"null\"\n        ? window.location.origin\n        : window.location.href;\n\n    let href = typeof to === \"string\" ? to : createPath(to);\n    // Treating this as a full URL will strip any trailing spaces so we need to\n    // pre-encode them since they might be part of a matching splat param from\n    // an ancestor route\n    href = href.replace(/ $/, \"%20\");\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n","import type { Location, Path, To } from \"./history\";\nimport { invariant, parsePath, warning } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: unknown;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  // We keep the raw Response for redirects so we can return it verbatim\n  response: Response;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: unknown;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\n/**\n * Result from a loader or action called via dataStrategy\n */\nexport interface HandlerResult {\n  type: \"data\" | \"error\";\n  result: unknown; // data, Error, Response, DeferredData\n  status?: number;\n}\n\ntype LowerCaseFormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\ntype UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;\n\n/**\n * Users can specify either lowercase or uppercase form methods on `<Form>`,\n * useSubmit(), `<fetcher.Form>`, etc.\n */\nexport type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\nexport type FormMethod = LowerCaseFormMethod;\nexport type MutationFormMethod = Exclude<FormMethod, \"get\">;\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\nexport type V7_FormMethod = UpperCaseFormMethod;\nexport type V7_MutationFormMethod = Exclude<V7_FormMethod, \"GET\">;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"application/json\"\n  | \"text/plain\";\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport type Submission =\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: FormData;\n      json: undefined;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: JsonValue;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: undefined;\n      text: string;\n    };\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs<Context> {\n  request: Request;\n  params: Params;\n  context?: Context;\n}\n\n// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:\n//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs\n//   Also, make them a type alias instead of an interface\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\ntype DataFunctionValue = Response | NonNullable<unknown> | null;\n\ntype DataFunctionReturnValue = Promise<DataFunctionValue> | DataFunctionValue;\n\n/**\n * Route loader function signature\n */\nexport type LoaderFunction<Context = any> = {\n  (\n    args: LoaderFunctionArgs<Context>,\n    handlerCtx?: unknown\n  ): DataFunctionReturnValue;\n} & { hydrate?: boolean };\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction<Context = any> {\n  (\n    args: ActionFunctionArgs<Context>,\n    handlerCtx?: unknown\n  ): DataFunctionReturnValue;\n}\n\n/**\n * Arguments passed to shouldRevalidate function\n */\nexport interface ShouldRevalidateFunctionArgs {\n  currentUrl: URL;\n  currentParams: AgnosticDataRouteMatch[\"params\"];\n  nextUrl: URL;\n  nextParams: AgnosticDataRouteMatch[\"params\"];\n  formMethod?: Submission[\"formMethod\"];\n  formAction?: Submission[\"formAction\"];\n  formEncType?: Submission[\"formEncType\"];\n  text?: Submission[\"text\"];\n  formData?: Submission[\"formData\"];\n  json?: Submission[\"json\"];\n  unstable_actionStatus?: number;\n  actionResult?: any;\n  defaultShouldRevalidate: boolean;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: ShouldRevalidateFunctionArgs): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\nexport interface DetectErrorBoundaryFunction {\n  (route: AgnosticRouteObject): boolean;\n}\n\nexport interface DataStrategyMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {\n  shouldLoad: boolean;\n  resolve: (\n    handlerOverride?: (\n      handler: (ctx?: unknown) => DataFunctionReturnValue\n    ) => Promise<HandlerResult>\n  ) => Promise<HandlerResult>;\n}\n\nexport interface DataStrategyFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {\n  matches: DataStrategyMatch[];\n}\n\nexport interface DataStrategyFunction {\n  (args: DataStrategyFunctionArgs): Promise<HandlerResult[]>;\n}\n\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\nexport interface MapRoutePropertiesFunction {\n  (route: AgnosticRouteObject): {\n    hasErrorBoundary: boolean;\n  } & Record<string, any>;\n}\n\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nexport type ImmutableRouteKey =\n  | \"lazy\"\n  | \"caseSensitive\"\n  | \"path\"\n  | \"id\"\n  | \"index\"\n  | \"children\";\n\nexport const immutableRouteKeys = new Set<ImmutableRouteKey>([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\",\n]);\n\ntype RequireOne<T, Key = keyof T> = Exclude<\n  {\n    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;\n  }[keyof T],\n  undefined\n>;\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\nexport interface LazyRouteFunction<R extends AgnosticRouteObject> {\n  (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction | boolean;\n  action?: ActionFunction | boolean;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n  lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\nexport type RouteManifest = Record<string, AgnosticDataRouteObject | undefined>;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param extends `${infer Optional}?`\n      ? Optional\n      : Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\nexport type PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\" | \"/*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise, return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if you could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  mapRouteProperties: MapRoutePropertiesFunction,\n  parentPath: number[] = [],\n  manifest: RouteManifest = {}\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n        children: undefined,\n      };\n      manifest[id] = pathOrLayoutRoute;\n\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties,\n          treePath,\n          manifest\n        );\n      }\n\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch<string, RouteObjectType>(branches[i], decoded);\n  }\n\n  return matches;\n}\n\nexport interface UIMatch<Data = unknown, Handle = unknown> {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: Data;\n  handle: Handle;\n}\n\nexport function convertRouteMatchToUiMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UIMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle,\n  };\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string | null;\n  } = {} as any\n): string {\n  let path: string = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n\n  const stringify = (p: any) =>\n    p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n\n  const segments = path\n    .split(/\\/+/)\n    .map((segment, index, array) => {\n      const isLastSegment = index === array.length - 1;\n\n      // only apply the splat if it's the last segment\n      if (isLastSegment && segment === \"*\") {\n        const star = \"*\" as PathParam<Path>;\n        // Apply the splat\n        return stringify(params[star]);\n      }\n\n      const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n      if (keyMatch) {\n        const [, key, optional] = keyMatch;\n        let param = params[key as PathParam<Path>];\n        invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n        return stringify(param);\n      }\n\n      // Remove any optional markers from optional static segments\n      return segment.replace(/\\?$/g, \"\");\n    })\n    // Remove empty segments\n    .filter((segment) => !!segment);\n\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = compiledParams.reduce<Mutable<Params>>(\n    (memo, { paramName, isOptional }, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo[paramName] = undefined;\n      } else {\n        memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n      }\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\ntype CompiledPathParam = { paramName: string; isOptional?: boolean };\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, CompiledPathParam[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let params: CompiledPathParam[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(\n        /\\/:([\\w-]+)(\\?)?/g,\n        (_: string, paramName: string, isOptional) => {\n          params.push({ paramName, isOptional: isOptional != null });\n          return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n        }\n      );\n\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, params];\n}\n\nfunction decodePath(value: string) {\n  try {\n    return value\n      .split(\"/\")\n      .map((v) => decodeURIComponent(v).replace(/\\//g, \"%2F\"))\n      .join(\"/\");\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nexport function getResolveToMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[], v7_relativeSplatPath: boolean) {\n  let pathMatches = getPathContributingMatches(matches);\n\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n  // match so we include splat values for \".\" links.  See:\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) =>\n      idx === matches.length - 1 ? match.pathname : match.pathnameBase\n    );\n  }\n\n  return pathMatches.map((match) => match.pathnameBase);\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    // With relative=\"route\" (the default), each leading .. segment means\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n    // difference from how <a href> works and a major reason we call this a\n    // \"to\" value instead of a \"href\".\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeysSet: Set<string> = new Set<string>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscribers: Set<(aborted: boolean, settledKey?: string) => void> =\n    new Set();\n  data: Record<string, unknown>;\n  init?: ResponseInit;\n  deferredKeys: string[] = [];\n\n  constructor(data: Record<string, unknown>, responseInit?: ResponseInit) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n\n    this.init = responseInit;\n  }\n\n  private trackPromise(\n    key: string,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, undefined, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeysSet.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\n        `Deferred data for key \"${key}\" resolved/rejected with \\`undefined\\`, ` +\n          `you must resolve/reject with a value or \\`null\\`.`\n      );\n      Object.defineProperty(promise, \"_error\", { get: () => undefinedError });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    this.emit(false, key);\n    return data;\n  }\n\n  private emit(aborted: boolean, settledKey?: string) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n\n  subscribe(fn: (aborted: boolean, settledKey?: string) => void) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport type DeferFunction = (\n  data: Record<string, unknown>,\n  init?: number | ResponseInit\n) => DeferredData;\n\nexport const defer: DeferFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  return new DeferredData(data, responseInit);\n};\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirectDocument: RedirectFunction = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n\nexport type ErrorResponse = {\n  status: number;\n  statusText: string;\n  data: any;\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nexport class ErrorResponseImpl implements ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n  private error?: Error;\n  private internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nexport function isRouteErrorResponse(error: any): error is ErrorResponse {\n  return (\n    error != null &&\n    typeof error.status === \"number\" &&\n    typeof error.statusText === \"string\" &&\n    typeof error.internal === \"boolean\" &&\n    \"data\" in error\n  );\n}\n","import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  invariant,\n  parsePath,\n  warning,\n} from \"./history\";\nimport type {\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  DataStrategyMatch,\n  AgnosticRouteObject,\n  DataResult,\n  DataStrategyFunction,\n  DataStrategyFunctionArgs,\n  DeferredData,\n  DeferredResult,\n  DetectErrorBoundaryFunction,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  HTMLFormMethod,\n  HandlerResult,\n  ImmutableRouteKey,\n  MapRoutePropertiesFunction,\n  MutationFormMethod,\n  RedirectResult,\n  RouteData,\n  RouteManifest,\n  ShouldRevalidateFunctionArgs,\n  Submission,\n  SuccessResult,\n  UIMatch,\n  V7_FormMethod,\n  V7_MutationFormMethod,\n} from \"./utils\";\nimport {\n  ErrorResponseImpl,\n  ResultType,\n  convertRouteMatchToUiMatch,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  getResolveToMatches,\n  immutableRouteKeys,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n  stripBasename,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the future config for the router\n   */\n  get future(): FutureConfig;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the window associated with the router\n   */\n  get window(): RouterInit[\"window\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): Promise<void>;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get a navigation blocker\n   * @param key The identifier for the blocker\n   * @param fn The blocker function implementation\n   */\n  getBlocker(key: string, fn: BlockerFunction): Blocker;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete a navigation blocker\n   * @param key The identifier for the blocker\n   */\n  deleteBlocker(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * HMR needs to pass in-flight route updates to React Router\n   * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)\n   */\n  _internalSetRoutes(routes: AgnosticRouteObject[]): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n\n  /**\n   * Map of current blockers\n   */\n  blockers: Map<string, Blocker>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface FutureConfig {\n  v7_fetcherPersist: boolean;\n  v7_normalizeFormMethod: boolean;\n  v7_partialHydration: boolean;\n  v7_prependBasename: boolean;\n  v7_relativeSplatPath: boolean;\n  unstable_skipActionErrorRevalidation: boolean;\n}\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  routes: AgnosticRouteObject[];\n  history: History;\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<FutureConfig>;\n  hydrationData?: HydrationState;\n  window?: Window;\n  unstable_dataStrategy?: DataStrategyFunction;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  activeDeferreds: Record<string, DeferredData> | null;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: {\n      requestContext?: unknown;\n      skipLoaderErrorBubbling?: boolean;\n      unstable_dataStrategy?: DataStrategyFunction;\n    }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: { routeId?: string; requestContext?: unknown }\n  ): Promise<any>;\n}\n\ntype ViewTransitionOpts = {\n  currentLocation: Location;\n  nextLocation: Location;\n};\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (\n    state: RouterState,\n    opts: {\n      deletedFetchers: string[];\n      unstable_viewTransitionOpts?: ViewTransitionOpts;\n      unstable_flushSync: boolean;\n    }\n  ): void;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UIMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\n// Allowed for any navigation or fetch\ntype BaseNavigateOrFetchOptions = {\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  unstable_flushSync?: boolean;\n};\n\n// Only allowed for navigations\ntype BaseNavigateOptions = BaseNavigateOrFetchOptions & {\n  replace?: boolean;\n  state?: any;\n  fromRouteId?: string;\n  unstable_viewTransition?: boolean;\n};\n\n// Only allowed for submission navigations\ntype BaseSubmissionOptions = {\n  formMethod?: HTMLFormMethod;\n  formEncType?: FormEncType;\n} & (\n  | { formData: FormData; body?: undefined }\n  | { formData?: undefined; body: any }\n);\n\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\ntype LinkNavigateOptions = BaseNavigateOptions;\n\n/**\n * Options for a navigate() call for a submission navigation\n */\ntype SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to navigate() for a navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options for a fetch() load\n */\ntype LoadFetchOptions = BaseNavigateOrFetchOptions;\n\n/**\n * Options for a fetch() submission\n */\ntype SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    json: undefined;\n    text: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    text: Submission[\"text\"];\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    text: undefined;\n    formData: undefined;\n    json: undefined;\n    data: TData | undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    data: TData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    text: Submission[\"text\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    data: TData | undefined;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface BlockerBlocked {\n  state: \"blocked\";\n  reset(): void;\n  proceed(): void;\n  location: Location;\n}\n\ninterface BlockerUnblocked {\n  state: \"unblocked\";\n  reset: undefined;\n  proceed: undefined;\n  location: undefined;\n}\n\ninterface BlockerProceeding {\n  state: \"proceeding\";\n  reset: undefined;\n  proceed: undefined;\n  location: Location;\n}\n\nexport type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;\n\nexport type BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ntype PendingActionResult = [string, SuccessResult | ErrorResult];\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Tuple for the returned or thrown value from the current action.  The routeId\n   * is the action route for success and the bubbled boundary route for errors.\n   */\n  pendingActionResult?: PendingActionResult;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\ninterface FetchLoadMatch {\n  routeId: string;\n  path: string;\n}\n\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\ninterface RevalidatingFetcher extends FetchLoadMatch {\n  key: string;\n  match: AgnosticDataRouteMatch | null;\n  matches: AgnosticDataRouteMatch[] | null;\n  controller: AbortController | null;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_BLOCKER: BlockerUnblocked = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined,\n};\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\nconst defaultMapRouteProperties: MapRoutePropertiesFunction = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary),\n});\n\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  const routerWindow = init.window\n    ? init.window\n    : typeof window !== \"undefined\"\n    ? window\n    : undefined;\n  const isBrowser =\n    typeof routerWindow !== \"undefined\" &&\n    typeof routerWindow.document !== \"undefined\" &&\n    typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest: RouteManifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n  let inFlightDataRoutes: AgnosticDataRouteObject[] | undefined;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.unstable_dataStrategy || defaultDataStrategy;\n  // Config driven behavior flags\n  let future: FutureConfig = {\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false,\n    unstable_skipActionErrorRevalidation: false,\n    ...init.future,\n  };\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized: boolean;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    initialized = false;\n  } else if (!hasLoaders) {\n    // If we've got no loaders to run, then we're good to go\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    // If partial hydration is enabled, we're initialized so long as we were\n    // provided with hydrationData for every route with a loader, and no loaders\n    // were marked for explicit hydration\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    let isRouteInitialized = (m: AgnosticDataRouteMatch) => {\n      // No loader, nothing to initialize\n      if (!m.route.loader) {\n        return true;\n      }\n      // Explicitly opting-in to running on hydration\n      if (\n        typeof m.route.loader === \"function\" &&\n        m.route.loader.hydrate === true\n      ) {\n        return false;\n      }\n      // Otherwise, initialized if hydrated with data or an error\n      return (\n        (loaderData && loaderData[m.route.id] !== undefined) ||\n        (errors && errors[m.route.id] !== undefined)\n      );\n    };\n\n    // If errors exist, don't consider routes below the boundary\n    if (errors) {\n      let idx = initialMatches.findIndex(\n        (m) => errors![m.route.id] !== undefined\n      );\n      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);\n    } else {\n      initialized = initialMatches.every(isRouteInitialized);\n    }\n  } else {\n    // Without partial hydration - we're initialized if we were provided any\n    // hydrationData - which is expected to be complete\n    initialized = init.hydrationData != null;\n  }\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions: Map<string, Set<string>> = new Map<\n    string,\n    Set<string>\n  >();\n\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener: (() => void) | null = null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set<string>();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map<string, number>();\n\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set<string>();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map<string, BlockerFunction>();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        // Ignore this event if it was just us resetting the URL from a\n        // blocked POP navigation\n        if (ignoreNextHistoryUpdate) {\n          ignoreNextHistoryUpdate = false;\n          return;\n        }\n\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location \" +\n            \"that was not created by @remix-run/router. This will fail silently in \" +\n            \"production. This can happen if you are navigating outside the router \" +\n            \"via `window.history.pushState`/`window.location.hash` instead of using \" +\n            \"router navigation APIs.  This can also happen if you are using \" +\n            \"createHashRouter and the user manually changes the URL.\"\n        );\n\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction,\n        });\n\n        if (blockerKey && delta != null) {\n          // Restore the URL to match the current UI, but don't update router state\n          ignoreNextHistoryUpdate = true;\n          init.history.go(delta * -1);\n\n          // Put the blocker into a blocked state\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey!, {\n                state: \"proceeding\",\n                proceed: undefined,\n                reset: undefined,\n                location,\n              });\n              // Re-do the same POP navigation we just blocked\n              init.history.go(delta);\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey!, IDLE_BLOCKER);\n              updateState({ blockers });\n            },\n          });\n          return;\n        }\n\n        return startNavigation(historyAction, location);\n      }\n    );\n\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () =>\n        persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () =>\n        routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location, {\n        initialHydration: true,\n      });\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(\n    newState: Partial<RouterState>,\n    opts: {\n      flushSync?: boolean;\n      viewTransitionOpts?: ViewTransitionOpts;\n    } = {}\n  ): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers: string[] = [];\n    let deletedFetchersKeys: string[] = [];\n\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach((subscriber) =>\n      subscriber(state, {\n        deletedFetchers: deletedFetchersKeys,\n        unstable_viewTransitionOpts: opts.viewTransitionOpts,\n        unstable_flushSync: opts.flushSync === true,\n      })\n    );\n\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>,\n    { flushSync }: { flushSync?: boolean } = {}\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset =\n      pendingPreventScrollReset === true ||\n      (state.navigation.formMethod != null &&\n        isMutationMethod(state.navigation.formMethod) &&\n        location.state?._isRedirect !== true);\n\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    let viewTransitionOpts: ViewTransitionOpts | undefined;\n\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === HistoryAction.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location,\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location,\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set<string>([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location,\n      };\n    }\n\n    updateState(\n      {\n        ...newState, // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition: getSavedScrollPosition(\n          location,\n          newState.matches || state.matches\n        ),\n        preventScrollReset,\n        blockers,\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true,\n      }\n    );\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To | null,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      to,\n      future.v7_relativeSplatPath,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      false,\n      normalizedPath,\n      opts\n    );\n\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction,\n    });\n\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey!, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation,\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey!, IDLE_BLOCKER);\n          updateState({ blockers });\n        },\n      });\n      return;\n    }\n\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      initialHydration?: boolean;\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponseImpl;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n      enableViewTransition?: boolean;\n      flushSync?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error,\n          },\n        },\n        { flushSync }\n      );\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (\n      state.initialized &&\n      !isRevalidationRequired &&\n      isHashChangeOnly(state.location, location) &&\n      !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))\n    ) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionResult: PendingActionResult | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingActionResult = [\n        findNearestBoundary(matches).route.id,\n        { type: ResultType.error, error: opts.pendingError },\n      ];\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionResult = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace, flushSync }\n      );\n\n      if (actionResult.shortCircuited) {\n        return;\n      }\n\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n\n      // Create a GET request for the loaders\n      request = createClientSideRequest(\n        init.history,\n        request.url,\n        request.signal\n      );\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionResult\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...getActionDataForCommit(pendingActionResult),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts: { replace?: boolean; flushSync?: boolean } = {}\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        request,\n        [actionMatch],\n        matches\n      );\n      result = results[0];\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        let location = normalizeRedirectLocation(\n          result.response.headers.get(\"Location\")!,\n          new URL(request.url),\n          basename\n        );\n        replace = location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, {\n        submission,\n        replace,\n      });\n      return { shortCircuited: true };\n    }\n\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        pendingActionResult: [boundaryMatch.route.id, result],\n      };\n    }\n\n    return {\n      pendingActionResult: [actionMatch.route.id, result],\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    fetcherSubmission?: Submission,\n    replace?: boolean,\n    initialHydration?: boolean,\n    flushSync?: boolean,\n    pendingActionResult?: PendingActionResult\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation =\n      overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission =\n      submission ||\n      fetcherSubmission ||\n      getSubmissionFromNavigation(loadingNavigation);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      future.v7_partialHydration && initialHydration === true,\n      future.unstable_skipActionErrorRevalidation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionResult\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors:\n            pendingActionResult && isErrorResult(pendingActionResult[1])\n              ? { [pendingActionResult[0]]: pendingActionResult[1].error }\n              : null,\n          ...getActionDataForCommit(pendingActionResult),\n          ...(updatedFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    // If we have partialHydration enabled, then don't update the state for the\n    // initial data load since it's not a \"navigation\"\n    if (\n      !isUninterruptedRevalidation &&\n      (!future.v7_partialHydration || !initialHydration)\n    ) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          fetcher ? fetcher.data : undefined\n        );\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n\n      let actionData: Record<string, RouteData> | null | undefined;\n      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n        // This is cast to `any` currently because `RouteData`uses any and it\n        // would be a breaking change to use any.\n        // TODO: v7 - change `RouteData` to use `unknown` instead of `any`\n        actionData = {\n          [pendingActionResult[0]]: pendingActionResult[1].data as any,\n        };\n      } else if (state.actionData) {\n        if (Object.keys(state.actionData).length === 0) {\n          actionData = null;\n        } else {\n          actionData = state.actionData;\n        }\n      }\n\n      updateState(\n        {\n          navigation: loadingNavigation,\n          ...(actionData !== undefined ? { actionData } : {}),\n          ...(revalidatingFetchers.length > 0\n            ? { fetchers: new Map(state.fetchers) }\n            : {}),\n        },\n        {\n          flushSync,\n        }\n      );\n    }\n\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n\n    let { loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(request, redirect.result, {\n        replace,\n      });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingActionResult,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    // During partial hydration, preserve SSR errors for routes that don't re-run\n    if (future.v7_partialHydration && initialHydration && state.errors) {\n      Object.entries(state.errors)\n        .filter(([id]) => !matchesToLoad.some((m) => m.route.id === id))\n        .forEach(([routeId, error]) => {\n          errors = Object.assign(errors || {}, { [routeId]: error });\n        });\n    }\n\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers =\n      updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n\n    return {\n      loaderData,\n      errors,\n      ...(shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n    };\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      href,\n      future.v7_relativeSplatPath,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      true,\n      normalizedPath,\n      opts\n    );\n\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    let match = getTargetMatch(matches, path);\n\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(\n        key,\n        routeId,\n        path,\n        match,\n        matches,\n        flushSync,\n        submission\n      );\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, { routeId, path });\n    handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      match,\n      matches,\n      flushSync,\n      submission\n    );\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync,\n    });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let actionResults = await callDataStrategy(\n      \"action\",\n      fetchRequest,\n      [match],\n      requestMatches\n    );\n    let actionResult = actionResults[0];\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n    // or redirects processed for unmounted fetchers so we just revert them to\n    // idle\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      }\n      // Let SuccessResult's fall through for revalidation\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          // A new navigation was kicked off after our action started, so that\n          // should take precedence over this redirect navigation.  We already\n          // set isRevalidationRequired so all loaders for the new route should\n          // fire unless opted out via shouldRevalidate\n          updateFetcherState(key, getDoneFetcher(undefined));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, {\n            fetcherSubmission: submission,\n          });\n        }\n      }\n\n      // Process any non-redirect errors thrown\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(routesToUse, state.navigation.location, basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      future.unstable_skipActionErrorRevalidation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      [match.route.id, actionResult]\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter((rf) => rf.key !== key)\n      .forEach((rf) => {\n        let staleKey = rf.key;\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          existingFetcher ? existingFetcher.data : undefined\n        );\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        if (fetchControllers.has(staleKey)) {\n          abortFetcher(staleKey);\n        }\n        if (rf.controller) {\n          fetchControllers.set(staleKey, rf.controller);\n        }\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    let { loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(revalidationRequest, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n\n    abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : undefined\n      ),\n      { flushSync }\n    );\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let results = await callDataStrategy(\n      \"loader\",\n      fetchRequest,\n      [match],\n      matches\n    );\n    let result = results[0];\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // We don't want errors bubbling up or redirects followed for unmounted\n    // fetchers, so short circuit here if it was removed from the UI\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    request: Request,\n    redirect: RedirectResult,\n    {\n      submission,\n      fetcherSubmission,\n      replace,\n    }: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      replace?: boolean;\n    } = {}\n  ) {\n    if (redirect.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n\n    let location = redirect.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(\n      location,\n      new URL(request.url),\n      basename\n    );\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true,\n    });\n\n    if (isBrowser) {\n      let isDocumentReload = false;\n\n      if (redirect.response.headers.has(\"X-Remix-Reload-Document\")) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\n        const url = init.history.createURL(location);\n        isDocumentReload =\n          // Hard reload if it's an absolute URL to a new origin\n          url.origin !== routerWindow.location.origin ||\n          // Hard reload if it's an absolute URL that does not match our basename\n          stripBasename(url.pathname, basename) == null;\n      }\n\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (\n      !submission &&\n      !fetcherSubmission &&\n      formMethod &&\n      formAction &&\n      formEncType\n    ) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.response.status) &&\n      activeSubmission &&\n      isMutationMethod(activeSubmission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: location,\n        },\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    }\n  }\n\n  // Utility wrapper for calling dataStrategy client-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(\n    type: \"loader\" | \"action\",\n    request: Request,\n    matchesToLoad: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[]\n  ): Promise<DataResult[]> {\n    try {\n      let results = await callDataStrategyImpl(\n        dataStrategyImpl,\n        type,\n        request,\n        matchesToLoad,\n        matches,\n        manifest,\n        mapRouteProperties\n      );\n\n      return await Promise.all(\n        results.map((result, i) => {\n          if (isRedirectHandlerResult(result)) {\n            let response = result.result as Response;\n            return {\n              type: ResultType.redirect,\n              response: normalizeRelativeRoutingRedirectResponse(\n                response,\n                request,\n                matchesToLoad[i].route.id,\n                matches,\n                basename,\n                future.v7_relativeSplatPath\n              ),\n            };\n          }\n\n          return convertHandlerResultToDataResult(result);\n        })\n      );\n    } catch (e) {\n      // If the outer dataStrategy method throws, just return the error for all\n      // matches - and it'll naturally bubble to the root\n      return matchesToLoad.map(() => ({\n        type: ResultType.error,\n        error: e,\n      }));\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    let [loaderResults, ...fetcherResults] = await Promise.all([\n      matchesToLoad.length\n        ? callDataStrategy(\"loader\", request, matchesToLoad, matches)\n        : [],\n      ...fetchersToLoad.map((f) => {\n        if (f.matches && f.match && f.controller) {\n          let fetcherRequest = createClientSideRequest(\n            init.history,\n            f.path,\n            f.controller.signal\n          );\n          return callDataStrategy(\n            \"loader\",\n            fetcherRequest,\n            [f.match],\n            f.matches\n          ).then((r) => r[0]);\n        } else {\n          return Promise.resolve<DataResult>({\n            type: ResultType.error,\n            error: getInternalRouterError(404, {\n              pathname: f.path,\n            }),\n          });\n        }\n      }),\n    ]);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        loaderResults.map(() => request.signal),\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map((f) => f.match),\n        fetcherResults,\n        fetchersToLoad.map((f) => (f.controller ? f.controller.signal : null)),\n        true\n      ),\n    ]);\n\n    return {\n      loaderResults,\n      fetcherResults,\n    };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function updateFetcherState(\n    key: string,\n    fetcher: Fetcher,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function setFetcherError(\n    key: string,\n    routeId: string,\n    error: any,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error,\n        },\n        fetchers: new Map(state.fetchers),\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  function deleteFetcher(key: string): void {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (\n      fetchControllers.has(key) &&\n      !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))\n    ) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function deleteFetcherAndUpdateState(key: string): void {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): boolean {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function getBlocker(key: string, fn: BlockerFunction) {\n    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n\n    return blocker;\n  }\n\n  function deleteBlocker(key: string) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key: string, newBlocker: Blocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(\n      (blocker.state === \"unblocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"proceeding\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"unblocked\") ||\n        (blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\"),\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction,\n  }: {\n    currentLocation: Location;\n    nextLocation: Location;\n    historyAction: HistoryAction;\n  }): string | undefined {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function getScrollKey(location: Location, matches: AgnosticDataRouteMatch[]) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  function _internalSetRoutes(newRoutes: AgnosticDataRouteObject[]) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties,\n      undefined,\n      manifest\n    );\n  }\n\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport const UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface StaticHandlerFutureConfig {\n  v7_relativeSplatPath: boolean;\n  v7_throwAbortReason: boolean;\n}\n\nexport interface CreateStaticHandlerOptions {\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<StaticHandlerFutureConfig>;\n}\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: CreateStaticHandlerOptions\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let manifest: RouteManifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (opts?.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts?.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Config driven behavior flags\n  let future: StaticHandlerFutureConfig = {\n    v7_relativeSplatPath: false,\n    v7_throwAbortReason: false,\n    ...(opts ? opts.future : null),\n  };\n\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   *\n   * - `opts.requestContext` is an optional server context that will be passed\n   *   to actions/loaders in the `context` parameter\n   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent\n   *   the bubbling of errors which allows single-fetch-type implementations\n   *   where the client will handle the bubbling and we may need to return data\n   *   for the handling route\n   */\n  async function query(\n    request: Request,\n    {\n      requestContext,\n      skipLoaderErrorBubbling,\n      unstable_dataStrategy,\n    }: {\n      requestContext?: unknown;\n      skipLoaderErrorBubbling?: boolean;\n      unstable_dataStrategy?: DataStrategyFunction;\n    } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      unstable_dataStrategy || null,\n      skipLoaderErrorBubbling === true,\n      null\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   *\n   * - `opts.routeId` allows you to specify the specific route handler to call.\n   *   If not provided the handler will determine the proper route by matching\n   *   against `request.url`\n   * - `opts.requestContext` is an optional server context that will be passed\n   *    to actions/loaders in the `context` parameter\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n    }: { requestContext?: unknown; routeId?: string } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      null,\n      false,\n      match\n    );\n\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n\n    if (result.loaderData) {\n      let data = Object.values(result.loaderData)[0];\n      if (result.activeDeferreds?.[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n\n    return undefined;\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    routeMatch: AgnosticDataRouteMatch | null\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          unstable_dataStrategy,\n          skipLoaderErrorBubbling,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        unstable_dataStrategy,\n        skipLoaderErrorBubbling,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction for a\n      // `queryRoute` call, we throw the `HandlerResult` to bail out early\n      // and then return or throw the raw Response here accordingly\n      if (isHandlerResult(e) && isResponse(e.result)) {\n        if (e.type === ResultType.error) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        request,\n        [actionMatch],\n        matches,\n        isRouteRequest,\n        requestContext,\n        unstable_dataStrategy\n      );\n      result = results[0];\n\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest, future);\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")!,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, { type: \"defer-action\" });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = skipLoaderErrorBubbling\n        ? actionMatch\n        : findNearestBoundary(matches, actionMatch.route.id);\n\n      let context = await loadRouteData(\n        loaderRequest,\n        matches,\n        requestContext,\n        unstable_dataStrategy,\n        skipLoaderErrorBubbling,\n        null,\n        [boundaryMatch.route.id, result]\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : result.statusCode != null\n          ? result.statusCode\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    let context = await loadRouteData(\n      loaderRequest,\n      matches,\n      requestContext,\n      unstable_dataStrategy,\n      skipLoaderErrorBubbling,\n      null\n    );\n\n    return {\n      ...context,\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionHeaders: result.headers\n        ? { [actionMatch.route.id]: result.headers }\n        : {},\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    routeMatch: AgnosticDataRouteMatch | null,\n    pendingActionResult?: PendingActionResult\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (\n      isRouteRequest &&\n      !routeMatch?.route.loader &&\n      !routeMatch?.route.lazy\n    ) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0])\n      : matches;\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors:\n          pendingActionResult && isErrorResult(pendingActionResult[1])\n            ? {\n                [pendingActionResult[0]]: pendingActionResult[1].error,\n              }\n            : null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let results = await callDataStrategy(\n      \"loader\",\n      request,\n      matchesToLoad,\n      matches,\n      isRouteRequest,\n      requestContext,\n      unstable_dataStrategy\n    );\n\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest, future);\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map<string, DeferredData>();\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionResult,\n      activeDeferreds,\n      skipLoaderErrorBubbling\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set<string>(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n      activeDeferreds:\n        activeDeferreds.size > 0\n          ? Object.fromEntries(activeDeferreds.entries())\n          : null,\n    };\n  }\n\n  // Utility wrapper for calling dataStrategy server-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(\n    type: \"loader\" | \"action\",\n    request: Request,\n    matchesToLoad: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    isRouteRequest: boolean,\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null\n  ): Promise<DataResult[]> {\n    let results = await callDataStrategyImpl(\n      unstable_dataStrategy || defaultDataStrategy,\n      type,\n      request,\n      matchesToLoad,\n      matches,\n      manifest,\n      mapRouteProperties,\n      requestContext\n    );\n\n    return await Promise.all(\n      results.map((result, i) => {\n        if (isRedirectHandlerResult(result)) {\n          let response = result.result as Response;\n          // Throw redirects and let the server handle them with an HTTP redirect\n          throw normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            matchesToLoad[i].route.id,\n            matches,\n            basename,\n            future.v7_relativeSplatPath\n          );\n        }\n        if (isResponse(result.result) && isRouteRequest) {\n          // For SSR single-route requests, we want to hand Responses back\n          // directly without unwrapping\n          throw result;\n        }\n\n        return convertHandlerResultToDataResult(result);\n      })\n    );\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction throwStaticHandlerAbortedError(\n  request: Request,\n  isRouteRequest: boolean,\n  future: StaticHandlerFutureConfig\n) {\n  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n    throw request.signal.reason;\n  }\n\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(`${method}() call aborted: ${request.method} ${request.url}`);\n}\n\nfunction isSubmissionNavigation(\n  opts: BaseNavigateOrFetchOptions\n): opts is SubmissionNavigateOptions {\n  return (\n    opts != null &&\n    ((\"formData\" in opts && opts.formData != null) ||\n      (\"body\" in opts && opts.body !== undefined))\n  );\n}\n\nfunction normalizeTo(\n  location: Path,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  prependBasename: boolean,\n  to: To | null,\n  v7_relativeSplatPath: boolean,\n  fromRouteId?: string,\n  relative?: RelativeRoutingType\n) {\n  let contextualMatches: AgnosticDataRouteMatch[];\n  let activeRouteMatch: AgnosticDataRouteMatch | undefined;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches, v7_relativeSplatPath),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if (\n    (to == null || to === \"\" || to === \".\") &&\n    activeRouteMatch &&\n    activeRouteMatch.route.index &&\n    !hasNakedIndexQuery(path.search)\n  ) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  normalizeFormMethod: boolean,\n  isFetcher: boolean,\n  path: string,\n  opts?: BaseNavigateOrFetchOptions\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponseImpl;\n} {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" }),\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod\n    ? (rawFormMethod.toUpperCase() as V7_FormMethod)\n    : (rawFormMethod.toLowerCase() as FormMethod);\n  let formAction = stripHashFromPath(path);\n\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      let text =\n        typeof opts.body === \"string\"\n          ? opts.body\n          : opts.body instanceof FormData ||\n            opts.body instanceof URLSearchParams\n          ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce(\n              (acc, [name, value]) => `${acc}${name}=${value}\\n`,\n              \"\"\n            )\n          : String(opts.body);\n\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text,\n        },\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      try {\n        let json =\n          typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined,\n          },\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n\n  let searchParams: URLSearchParams;\n  let formData: FormData;\n\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n\n  let submission: Submission = {\n    formMethod,\n    formAction,\n    formEncType:\n      (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined,\n  };\n\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  history: History,\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isInitialLoad: boolean,\n  skipActionErrorRevalidation: boolean,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  deletedFetchers: Set<string>,\n  fetchLoadMatches: Map<string, FetchLoadMatch>,\n  fetchRedirectIds: Set<string>,\n  routesToUse: AgnosticDataRouteObject[],\n  basename: string | undefined,\n  pendingActionResult?: PendingActionResult\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingActionResult\n    ? isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[1].error\n      : pendingActionResult[1].data\n    : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId =\n    pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[0]\n      : undefined;\n  let boundaryMatches = boundaryId\n    ? getLoaderMatchesUntilBoundary(matches, boundaryId)\n    : matches;\n\n  // Don't revalidate loaders by default after action 4xx/5xx responses\n  // when the flag is enabled.  They can still opt-into revalidation via\n  // `shouldRevalidate` via `actionResult`\n  let actionStatus = pendingActionResult\n    ? pendingActionResult[1].statusCode\n    : undefined;\n  let shouldSkipRevalidation =\n    skipActionErrorRevalidation && actionStatus && actionStatus >= 400;\n\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let { route } = match;\n    if (route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n\n    if (route.loader == null) {\n      return false;\n    }\n\n    if (isInitialLoad) {\n      if (typeof route.loader !== \"function\" || route.loader.hydrate) {\n        return true;\n      }\n      return (\n        state.loaderData[route.id] === undefined &&\n        // Don't re-run if the loader ran and threw an error\n        (!state.errors || state.errors[route.id] === undefined)\n      );\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (\n      isNewLoader(state.loaderData, state.matches[index], match) ||\n      cancelledDeferredRoutes.some((id) => id === match.route.id)\n    ) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      unstable_actionStatus: actionStatus,\n      defaultShouldRevalidate: shouldSkipRevalidation\n        ? false\n        : // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n          isRevalidationRequired ||\n          currentUrl.pathname + currentUrl.search ===\n            nextUrl.pathname + nextUrl.search ||\n          // Search params affect all loaders\n          currentUrl.search !== nextUrl.search ||\n          isNewRouteInstance(currentRouteMatch, nextRouteMatch),\n    });\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate:\n    //  - on initial load (shouldn't be any fetchers then anyway)\n    //  - if fetcher won't be present in the subsequent render\n    //    - no longer matches the URL (v7_fetcherPersist=false)\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\n    if (\n      isInitialLoad ||\n      !matches.some((m) => m.route.id === f.routeId) ||\n      deletedFetchers.has(key)\n    ) {\n      return;\n    }\n\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null,\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (\n      fetcher &&\n      fetcher.state !== \"idle\" &&\n      fetcher.data === undefined\n    ) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        unstable_actionStatus: actionStatus,\n        defaultShouldRevalidate: shouldSkipRevalidation\n          ? false\n          : isRevalidationRequired,\n      });\n    }\n\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController(),\n      });\n    }\n  });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath != null &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  loaderMatch: AgnosticDataRouteMatch,\n  arg: ShouldRevalidateFunctionArgs\n) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(\n  route: AgnosticDataRouteObject,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  manifest: RouteManifest\n) {\n  if (!route.lazy) {\n    return;\n  }\n\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates: Record<string, any> = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue =\n      routeToUpdate[lazyRouteProperty as keyof typeof routeToUpdate];\n\n    let isPropertyStaticallyDefined =\n      staticRouteValue !== undefined &&\n      // This property isn't static since it should always be updated based\n      // on the route updates\n      lazyRouteProperty !== \"hasErrorBoundary\";\n\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" ` +\n        `defined but its lazy function is also returning a value for this property. ` +\n        `The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n\n    if (\n      !isPropertyStaticallyDefined &&\n      !immutableRouteKeys.has(lazyRouteProperty as ImmutableRouteKey)\n    ) {\n      routeUpdates[lazyRouteProperty] =\n        lazyRoute[lazyRouteProperty as keyof typeof lazyRoute];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided\n    // `mapRouteProperties` (or wrapped `detectErrorBoundary`) function to\n    // set the framework-aware properties (`element`/`hasErrorBoundary`) since\n    // the logic will differ between frameworks.\n    ...mapRouteProperties(routeToUpdate),\n    lazy: undefined,\n  });\n}\n\n// Default implementation of `dataStrategy` which fetches all loaders in parallel\nfunction defaultDataStrategy(\n  opts: DataStrategyFunctionArgs\n): ReturnType<DataStrategyFunction> {\n  return Promise.all(opts.matches.map((m) => m.resolve()));\n}\n\nasync function callDataStrategyImpl(\n  dataStrategyImpl: DataStrategyFunction,\n  type: \"loader\" | \"action\",\n  request: Request,\n  matchesToLoad: AgnosticDataRouteMatch[],\n  matches: AgnosticDataRouteMatch[],\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  requestContext?: unknown\n): Promise<HandlerResult[]> {\n  let routeIdsToLoad = matchesToLoad.reduce(\n    (acc, m) => acc.add(m.route.id),\n    new Set<string>()\n  );\n  let loadedMatches = new Set<string>();\n\n  // Send all matches here to allow for a middleware-type implementation.\n  // handler will be a no-op for unneeded routes and we filter those results\n  // back out below.\n  let results = await dataStrategyImpl({\n    matches: matches.map((match) => {\n      let shouldLoad = routeIdsToLoad.has(match.route.id);\n      // `resolve` encapsulates the route.lazy, executing the\n      // loader/action, and mapping return values/thrown errors to a\n      // HandlerResult.  Users can pass a callback to take fine-grained control\n      // over the execution of the loader/action\n      let resolve: DataStrategyMatch[\"resolve\"] = (handlerOverride) => {\n        loadedMatches.add(match.route.id);\n        return shouldLoad\n          ? callLoaderOrAction(\n              type,\n              request,\n              match,\n              manifest,\n              mapRouteProperties,\n              handlerOverride,\n              requestContext\n            )\n          : Promise.resolve({ type: ResultType.data, result: undefined });\n      };\n\n      return {\n        ...match,\n        shouldLoad,\n        resolve,\n      };\n    }),\n    request,\n    params: matches[0].params,\n    context: requestContext,\n  });\n\n  // Throw if any loadRoute implementations not called since they are what\n  // ensures a route is fully loaded\n  matches.forEach((m) =>\n    invariant(\n      loadedMatches.has(m.route.id),\n      `\\`match.resolve()\\` was not called for route id \"${m.route.id}\". ` +\n        \"You must call `match.resolve()` on every match passed to \" +\n        \"`dataStrategy` to ensure all routes are properly loaded.\"\n    )\n  );\n\n  // Filter out any middleware-only matches for which we didn't need to run handlers\n  return results.filter((_, i) => routeIdsToLoad.has(matches[i].route.id));\n}\n\n// Default logic for calling a loader/action is the user has no specified a dataStrategy\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  handlerOverride: Parameters<DataStrategyMatch[\"resolve\"]>[0],\n  staticContext?: unknown\n): Promise<HandlerResult> {\n  let result: HandlerResult;\n  let onReject: (() => void) | undefined;\n\n  let runHandler = (\n    handler: AgnosticRouteObject[\"loader\"] | AgnosticRouteObject[\"action\"]\n  ): Promise<HandlerResult> => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject: () => void;\n    // This will never resolve so safe to type it as Promise<HandlerResult> to\n    // satisfy the function return value\n    let abortPromise = new Promise<HandlerResult>((_, r) => (reject = r));\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n\n    let actualHandler = (ctx?: unknown) => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(\n          new Error(\n            `You cannot call the handler for a route which defines a boolean ` +\n              `\"${type}\" [routeId: ${match.route.id}]`\n          )\n        );\n      }\n      return handler(\n        {\n          request,\n          params: match.params,\n          context: staticContext,\n        },\n        ...(ctx !== undefined ? [ctx] : [])\n      );\n    };\n\n    let handlerPromise: Promise<HandlerResult>;\n    if (handlerOverride) {\n      handlerPromise = handlerOverride((ctx: unknown) => actualHandler(ctx));\n    } else {\n      handlerPromise = (async () => {\n        try {\n          let val = await actualHandler();\n          return { type: \"data\", result: val };\n        } catch (e) {\n          return { type: \"error\", result: e };\n        }\n      })();\n    }\n\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n\n  try {\n    let handler = match.route[type];\n\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let [value] = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties, manifest),\n        ]);\n        if (handlerError !== undefined) {\n          throw handlerError;\n        }\n        result = value!;\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n\n        handler = match.route[type];\n        if (handler) {\n          // Handler still runs even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id,\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return { type: ResultType.data, result: undefined };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname,\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n\n    invariant(\n      result.result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    // We should already be catching and converting normal handler executions to\n    // HandlerResults and returning them, so anything that throws here is an\n    // unexpected error we still need to wrap\n    return { type: ResultType.error, result: e };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n\n  return result;\n}\n\nasync function convertHandlerResultToDataResult(\n  handlerResult: HandlerResult\n): Promise<DataResult> {\n  let { result, type, status } = handlerResult;\n\n  if (isResponse(result)) {\n    let data: any;\n\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      // Check between word boundaries instead of startsWith() due to the last\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data = null;\n        } else {\n          data = await result.json();\n        }\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return { type: ResultType.error, error: e };\n    }\n\n    if (type === ResultType.error) {\n      return {\n        type: ResultType.error,\n        error: new ErrorResponseImpl(result.status, result.statusText, data),\n        statusCode: result.status,\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (type === ResultType.error) {\n    return {\n      type: ResultType.error,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : status,\n    };\n  }\n\n  if (isDeferredData(result)) {\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: result.init?.status,\n      headers: result.init?.headers && new Headers(result.init.headers),\n    };\n  }\n\n  return { type: ResultType.data, data: result, statusCode: status };\n}\n\n// Support relative routing in internal redirects\nfunction normalizeRelativeRoutingRedirectResponse(\n  response: Response,\n  request: Request,\n  routeId: string,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  v7_relativeSplatPath: boolean\n) {\n  let location = response.headers.get(\"Location\");\n  invariant(\n    location,\n    \"Redirects returned/thrown from loaders/actions must have a Location header\"\n  );\n\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\n    let trimmedMatches = matches.slice(\n      0,\n      matches.findIndex((m) => m.route.id === routeId) + 1\n    );\n    location = normalizeTo(\n      new URL(request.url),\n      trimmedMatches,\n      basename,\n      true,\n      location,\n      v7_relativeSplatPath\n    );\n    response.headers.set(\"Location\", location);\n  }\n\n  return response;\n}\n\nfunction normalizeRedirectLocation(\n  location: string,\n  currentUrl: URL,\n  basename: string\n): string {\n  if (ABSOLUTE_URL_REGEX.test(location)) {\n    // Strip off the protocol+origin for same-origin + same-basename absolute redirects\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\")\n      ? new URL(currentUrl.protocol + normalizedLocation)\n      : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  history: History,\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (\n      formEncType === \"application/x-www-form-urlencoded\" &&\n      submission.formData\n    ) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n\n  return searchParams;\n}\n\nfunction convertSearchParamsToFormData(\n  searchParams: URLSearchParams\n): FormData {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingActionResult: PendingActionResult | undefined,\n  activeDeferreds: Map<string, DeferredData>,\n  skipLoaderErrorBubbling: boolean\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n  let pendingError =\n    pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[1].error\n      : undefined;\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError !== undefined) {\n        error = pendingError;\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        // Look upwards from the matched route for the closest ancestor error\n        // boundary, defaulting to the root match.  Prefer higher error values\n        // if lower errors bubble to the same boundary\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (\n          result.statusCode != null &&\n          result.statusCode !== 200 &&\n          !foundError\n        ) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      } else {\n        loaderData[id] = result.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError !== undefined && pendingActionResult) {\n    errors = { [pendingActionResult[0]]: pendingError };\n    loaderData[pendingActionResult[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingActionResult: PendingActionResult | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingActionResult,\n    activeDeferreds,\n    false // This method is only called client side so we always want to bubble\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let { key, match, controller } = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\nfunction getActionDataForCommit(\n  pendingActionResult: PendingActionResult | undefined\n) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1])\n    ? {\n        // Clear out prior actionData on errors\n        actionData: {},\n      }\n    : {\n        actionData: {\n          [pendingActionResult[0]]: pendingActionResult[1].data,\n        },\n      };\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route =\n    routes.length === 1\n      ? routes[0]\n      : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n          id: `__shim-error-route__`,\n        };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n    type,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n    type?: \"defer-action\" | \"invalid-body\";\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(\n  results: DataResult[]\n): { result: RedirectResult; idx: number } | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return { result, idx: i };\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\n\nfunction isHandlerResult(result: unknown): result is HandlerResult {\n  return (\n    result != null &&\n    typeof result === \"object\" &&\n    \"type\" in result &&\n    \"result\" in result &&\n    (result.type === ResultType.data || result.type === ResultType.error)\n  );\n}\n\nfunction isRedirectHandlerResult(result: HandlerResult) {\n  return (\n    isResponse(result.result) && redirectStatusCodes.has(result.result.status)\n  );\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nexport function isDeferredData(value: any): value is DeferredData {\n  let deferred: DeferredData = value;\n  return (\n    deferred &&\n    typeof deferred === \"object\" &&\n    typeof deferred.data === \"object\" &&\n    typeof deferred.subscribe === \"function\" &&\n    typeof deferred.cancel === \"function\" &&\n    typeof deferred.resolveData === \"function\"\n  );\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isValidMethod(method: string): method is FormMethod | V7_FormMethod {\n  return validRequestMethods.has(method.toLowerCase() as FormMethod);\n}\n\nfunction isMutationMethod(\n  method: string\n): method is MutationFormMethod | V7_MutationFormMethod {\n  return validMutationMethods.has(method.toLowerCase() as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: (AgnosticDataRouteMatch | null)[],\n  results: DataResult[],\n  signals: (AbortSignal | null)[],\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match!.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(\n        signal,\n        \"Expected an AbortSignal for revalidating fetcher deferred result\"\n      );\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n\nfunction getSubmissionFromNavigation(\n  navigation: Navigation\n): Submission | undefined {\n  let { formMethod, formAction, formEncType, text, formData, json } =\n    navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text,\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined,\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined,\n    };\n  }\n}\n\nfunction getLoadingNavigation(\n  location: Location,\n  submission?: Submission\n): NavigationStates[\"Loading\"] {\n  if (submission) {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n    };\n    return navigation;\n  } else {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n    };\n    return navigation;\n  }\n}\n\nfunction getSubmittingNavigation(\n  location: Location,\n  submission: Submission\n): NavigationStates[\"Submitting\"] {\n  let navigation: NavigationStates[\"Submitting\"] = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n  };\n  return navigation;\n}\n\nfunction getLoadingFetcher(\n  submission?: Submission,\n  data?: Fetcher[\"data\"]\n): FetcherStates[\"Loading\"] {\n  if (submission) {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n    };\n    return fetcher;\n  } else {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n    };\n    return fetcher;\n  }\n}\n\nfunction getSubmittingFetcher(\n  submission: Submission,\n  existingFetcher?: Fetcher\n): FetcherStates[\"Submitting\"] {\n  let fetcher: FetcherStates[\"Submitting\"] = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n  };\n  return fetcher;\n}\n\nfunction getDoneFetcher(data: Fetcher[\"data\"]): FetcherStates[\"Idle\"] {\n  let fetcher: FetcherStates[\"Idle\"] = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n  };\n  return fetcher;\n}\n\nfunction restoreAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\n\nfunction persistAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  if (transitions.size > 0) {\n    let json: Record<string, string[]> = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\n\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}