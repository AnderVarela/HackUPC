{"ast":null,"code":"\"use strict\";\n\nconst globalObject = require(\"@sinonjs/commons\").global;\n\n/**\n * @typedef {object} IdleDeadline\n * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n */\n\n/**\n * Queues a function to be called during a browser's idle periods\n *\n * @callback RequestIdleCallback\n * @param {function(IdleDeadline)} callback\n * @param {{timeout: number}} options - an options object\n * @returns {number} the id\n */\n\n/**\n * @callback NextTick\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {void}\n */\n\n/**\n * @callback SetImmediate\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {NodeImmediate}\n */\n\n/**\n * @callback VoidVarArgsFunc\n * @param {...*} callback - the callback to run\n * @returns {void}\n */\n\n/**\n * @typedef RequestAnimationFrame\n * @property {function(number):void} requestAnimationFrame\n * @returns {number} - the id\n */\n\n/**\n * @typedef Performance\n * @property {function(): number} now\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * @typedef {object} Clock\n * @property {number} now - the current time\n * @property {Date} Date - the Date constructor\n * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n * @property {RequestIdleCallback} requestIdleCallback\n * @property {function(number):void} cancelIdleCallback\n * @property {setTimeout} setTimeout\n * @property {clearTimeout} clearTimeout\n * @property {NextTick} nextTick\n * @property {queueMicrotask} queueMicrotask\n * @property {setInterval} setInterval\n * @property {clearInterval} clearInterval\n * @property {SetImmediate} setImmediate\n * @property {function(NodeImmediate):void} clearImmediate\n * @property {function():number} countTimers\n * @property {RequestAnimationFrame} requestAnimationFrame\n * @property {function(number):void} cancelAnimationFrame\n * @property {function():void} runMicrotasks\n * @property {function(string | number): number} tick\n * @property {function(string | number): Promise<number>} tickAsync\n * @property {function(): number} next\n * @property {function(): Promise<number>} nextAsync\n * @property {function(): number} runAll\n * @property {function(): number} runToFrame\n * @property {function(): Promise<number>} runAllAsync\n * @property {function(): number} runToLast\n * @property {function(): Promise<number>} runToLastAsync\n * @property {function(): void} reset\n * @property {function(number | Date): void} setSystemTime\n * @property {Performance} performance\n * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n * @property {function(): void} uninstall Uninstall the clock.\n * @property {Function[]} methods - the methods that are faked\n * @property {boolean} [shouldClearNativeTimers] inherited from config\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/**\n * Configuration object for the `install` method.\n *\n * @typedef {object} Config\n * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n * @property {string[]} [toFake] names of the methods that should be faked.\n * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * The internal structure to describe a scheduled fake timer\n *\n * @typedef {object} Timer\n * @property {Function} func\n * @property {*[]} args\n * @property {number} delay\n * @property {number} callAt\n * @property {number} createdAt\n * @property {boolean} immediate\n * @property {number} id\n * @property {Error} [error]\n */\n\n/**\n * A Node timer\n *\n * @typedef {object} NodeImmediate\n * @property {function(): boolean} hasRef\n * @property {function(): NodeImmediate} ref\n * @property {function(): NodeImmediate} unref\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/* eslint-disable complexity */\n\n/**\n * Mocks available features in the specified global namespace.\n *\n * @param {*} _global Namespace to mock (e.g. `window`)\n * @returns {FakeTimers}\n */\nfunction withGlobal(_global) {\n  const userAgent = _global.navigator && _global.navigator.userAgent;\n  const isRunningInIE = userAgent && userAgent.indexOf(\"MSIE \") > -1;\n  const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n  const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n  const NOOP = function () {\n    return undefined;\n  };\n  const NOOP_ARRAY = function () {\n    return [];\n  };\n  const timeoutResult = _global.setTimeout(NOOP, 0);\n  const addTimerReturnsObject = typeof timeoutResult === \"object\";\n  const hrtimePresent = _global.process && typeof _global.process.hrtime === \"function\";\n  const hrtimeBigintPresent = hrtimePresent && typeof _global.process.hrtime.bigint === \"function\";\n  const nextTickPresent = _global.process && typeof _global.process.nextTick === \"function\";\n  const utilPromisify = _global.process && require(\"util\").promisify;\n  const performancePresent = _global.performance && typeof _global.performance.now === \"function\";\n  const hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/);\n  const queueMicrotaskPresent = _global.hasOwnProperty(\"queueMicrotask\");\n  const requestAnimationFramePresent = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === \"function\";\n  const cancelAnimationFramePresent = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === \"function\";\n  const requestIdleCallbackPresent = _global.requestIdleCallback && typeof _global.requestIdleCallback === \"function\";\n  const cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === \"function\";\n  const setImmediatePresent = _global.setImmediate && typeof _global.setImmediate === \"function\";\n\n  // Make properties writable in IE, as per\n  // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n  /* eslint-disable no-self-assign */\n  if (isRunningInIE) {\n    _global.setTimeout = _global.setTimeout;\n    _global.clearTimeout = _global.clearTimeout;\n    _global.setInterval = _global.setInterval;\n    _global.clearInterval = _global.clearInterval;\n    _global.Date = _global.Date;\n  }\n\n  // setImmediate is not a standard function\n  // avoid adding the prop to the window object if not present\n  if (setImmediatePresent) {\n    _global.setImmediate = _global.setImmediate;\n    _global.clearImmediate = _global.clearImmediate;\n  }\n  /* eslint-enable no-self-assign */\n\n  _global.clearTimeout(timeoutResult);\n  const NativeDate = _global.Date;\n  let uniqueTimerId = idCounterStart;\n\n  /**\n   * @param {number} num\n   * @returns {boolean}\n   */\n  function isNumberFinite(num) {\n    if (Number.isFinite) {\n      return Number.isFinite(num);\n    }\n    return isFinite(num);\n  }\n  let isNearInfiniteLimit = false;\n\n  /**\n   * @param {Clock} clock\n   * @param {number} i\n   */\n  function checkIsNearInfiniteLimit(clock, i) {\n    if (clock.loopLimit && i === clock.loopLimit - 1) {\n      isNearInfiniteLimit = true;\n    }\n  }\n\n  /**\n   *\n   */\n  function resetIsNearInfiniteLimit() {\n    isNearInfiniteLimit = false;\n  }\n\n  /**\n   * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n   * number of milliseconds. This is used to support human-readable strings passed\n   * to clock.tick()\n   *\n   * @param {string} str\n   * @returns {number}\n   */\n  function parseTime(str) {\n    if (!str) {\n      return 0;\n    }\n    const strings = str.split(\":\");\n    const l = strings.length;\n    let i = l;\n    let ms = 0;\n    let parsed;\n    if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n      throw new Error(\"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\");\n    }\n    while (i--) {\n      parsed = parseInt(strings[i], 10);\n      if (parsed >= 60) {\n        throw new Error(`Invalid time ${str}`);\n      }\n      ms += parsed * Math.pow(60, l - i - 1);\n    }\n    return ms * 1000;\n  }\n\n  /**\n   * Get the decimal part of the millisecond value as nanoseconds\n   *\n   * @param {number} msFloat the number of milliseconds\n   * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n   *\n   * Example: nanoRemainer(123.456789) -> 456789\n   */\n  function nanoRemainder(msFloat) {\n    const modulo = 1e6;\n    const remainder = msFloat * 1e6 % modulo;\n    const positiveRemainder = remainder < 0 ? remainder + modulo : remainder;\n    return Math.floor(positiveRemainder);\n  }\n\n  /**\n   * Used to grok the `now` parameter to createClock.\n   *\n   * @param {Date|number} epoch the system time\n   * @returns {number}\n   */\n  function getEpoch(epoch) {\n    if (!epoch) {\n      return 0;\n    }\n    if (typeof epoch.getTime === \"function\") {\n      return epoch.getTime();\n    }\n    if (typeof epoch === \"number\") {\n      return epoch;\n    }\n    throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n  }\n\n  /**\n   * @param {number} from\n   * @param {number} to\n   * @param {Timer} timer\n   * @returns {boolean}\n   */\n  function inRange(from, to, timer) {\n    return timer && timer.callAt >= from && timer.callAt <= to;\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {Timer} job\n   */\n  function getInfiniteLoopError(clock, job) {\n    const infiniteLoopError = new Error(`Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`);\n    if (!job.error) {\n      return infiniteLoopError;\n    }\n\n    // pattern never matched in Node\n    const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n    let clockMethodPattern = new RegExp(String(Object.keys(clock).join(\"|\")));\n    if (addTimerReturnsObject) {\n      // node.js environment\n      clockMethodPattern = new RegExp(`\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`);\n    }\n    let matchedLineIndex = -1;\n    job.error.stack.split(\"\\n\").some(function (line, i) {\n      // If we've matched a computed target line (e.g. setTimeout) then we\n      // don't need to look any further. Return true to stop iterating.\n      const matchedComputedTarget = line.match(computedTargetPattern);\n      /* istanbul ignore if */\n      if (matchedComputedTarget) {\n        matchedLineIndex = i;\n        return true;\n      }\n\n      // If we've matched a clock method line, then there may still be\n      // others further down the trace. Return false to keep iterating.\n      const matchedClockMethod = line.match(clockMethodPattern);\n      if (matchedClockMethod) {\n        matchedLineIndex = i;\n        return false;\n      }\n\n      // If we haven't matched anything on this line, but we matched\n      // previously and set the matched line index, then we can stop.\n      // If we haven't matched previously, then we should keep iterating.\n      return matchedLineIndex >= 0;\n    });\n    const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${job.func.name || \"anonymous\"}\\n${job.error.stack.split(\"\\n\").slice(matchedLineIndex + 1).join(\"\\n\")}`;\n    try {\n      Object.defineProperty(infiniteLoopError, \"stack\", {\n        value: stack\n      });\n    } catch (e) {\n      // noop\n    }\n    return infiniteLoopError;\n  }\n\n  /**\n   * @param {Date} target\n   * @param {Date} source\n   * @returns {Date} the target after modifications\n   */\n  function mirrorDateProperties(target, source) {\n    let prop;\n    for (prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        target[prop] = source[prop];\n      }\n    }\n\n    // set special now implementation\n    if (source.now) {\n      target.now = function now() {\n        return target.clock.now;\n      };\n    } else {\n      delete target.now;\n    }\n\n    // set special toSource implementation\n    if (source.toSource) {\n      target.toSource = function toSource() {\n        return source.toSource();\n      };\n    } else {\n      delete target.toSource;\n    }\n\n    // set special toString implementation\n    target.toString = function toString() {\n      return source.toString();\n    };\n    target.prototype = source.prototype;\n    target.parse = source.parse;\n    target.UTC = source.UTC;\n    target.prototype.toUTCString = source.prototype.toUTCString;\n    return target;\n  }\n\n  //eslint-disable-next-line jsdoc/require-jsdoc\n  function createDate() {\n    /**\n     * @param {number} year\n     * @param {number} month\n     * @param {number} date\n     * @param {number} hour\n     * @param {number} minute\n     * @param {number} second\n     * @param {number} ms\n     *\n     * @returns {Date}\n     */\n    function ClockDate(year, month, date, hour, minute, second, ms) {\n      // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n      // This remains so in the 10th edition of 2019 as well.\n      if (!(this instanceof ClockDate)) {\n        return new NativeDate(ClockDate.clock.now).toString();\n      }\n\n      // if Date is called as a constructor with 'new' keyword\n      // Defensive and verbose to avoid potential harm in passing\n      // explicit undefined when user does not pass argument\n      switch (arguments.length) {\n        case 0:\n          return new NativeDate(ClockDate.clock.now);\n        case 1:\n          return new NativeDate(year);\n        case 2:\n          return new NativeDate(year, month);\n        case 3:\n          return new NativeDate(year, month, date);\n        case 4:\n          return new NativeDate(year, month, date, hour);\n        case 5:\n          return new NativeDate(year, month, date, hour, minute);\n        case 6:\n          return new NativeDate(year, month, date, hour, minute, second);\n        default:\n          return new NativeDate(year, month, date, hour, minute, second, ms);\n      }\n    }\n    return mirrorDateProperties(ClockDate, NativeDate);\n  }\n\n  //eslint-disable-next-line jsdoc/require-jsdoc\n  function enqueueJob(clock, job) {\n    // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n    if (!clock.jobs) {\n      clock.jobs = [];\n    }\n    clock.jobs.push(job);\n  }\n\n  //eslint-disable-next-line jsdoc/require-jsdoc\n  function runJobs(clock) {\n    // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n    if (!clock.jobs) {\n      return;\n    }\n    for (let i = 0; i < clock.jobs.length; i++) {\n      const job = clock.jobs[i];\n      job.func.apply(null, job.args);\n      checkIsNearInfiniteLimit(clock, i);\n      if (clock.loopLimit && i > clock.loopLimit) {\n        throw getInfiniteLoopError(clock, job);\n      }\n    }\n    resetIsNearInfiniteLimit();\n    clock.jobs = [];\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {Timer} timer\n   * @returns {number} id of the created timer\n   */\n  function addTimer(clock, timer) {\n    if (timer.func === undefined) {\n      throw new Error(\"Callback must be provided to timer calls\");\n    }\n    if (addTimerReturnsObject) {\n      // Node.js environment\n      if (typeof timer.func !== \"function\") {\n        throw new TypeError(`[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`);\n      }\n    }\n    if (isNearInfiniteLimit) {\n      timer.error = new Error();\n    }\n    timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n    if (timer.hasOwnProperty(\"delay\")) {\n      if (typeof timer.delay !== \"number\") {\n        timer.delay = parseInt(timer.delay, 10);\n      }\n      if (!isNumberFinite(timer.delay)) {\n        timer.delay = 0;\n      }\n      timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n      timer.delay = Math.max(0, timer.delay);\n    }\n    if (timer.hasOwnProperty(\"interval\")) {\n      timer.type = \"Interval\";\n      timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n    }\n    if (timer.hasOwnProperty(\"animation\")) {\n      timer.type = \"AnimationFrame\";\n      timer.animation = true;\n    }\n    if (timer.hasOwnProperty(\"idleCallback\")) {\n      timer.type = \"IdleCallback\";\n      timer.idleCallback = true;\n    }\n    if (!clock.timers) {\n      clock.timers = {};\n    }\n    timer.id = uniqueTimerId++;\n    timer.createdAt = clock.now;\n    timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n    clock.timers[timer.id] = timer;\n    if (addTimerReturnsObject) {\n      const res = {\n        ref: function () {\n          return res;\n        },\n        unref: function () {\n          return res;\n        },\n        refresh: function () {\n          clearTimeout(timer.id);\n          const args = [timer.func, timer.delay].concat(timer.args);\n          return setTimeout.apply(null, args);\n        },\n        [Symbol.toPrimitive]: function () {\n          return timer.id;\n        }\n      };\n      return res;\n    }\n    return timer.id;\n  }\n\n  /* eslint consistent-return: \"off\" */\n  /**\n   * Timer comparitor\n   *\n   * @param {Timer} a\n   * @param {Timer} b\n   * @returns {number}\n   */\n  function compareTimers(a, b) {\n    // Sort first by absolute timing\n    if (a.callAt < b.callAt) {\n      return -1;\n    }\n    if (a.callAt > b.callAt) {\n      return 1;\n    }\n\n    // Sort next by immediate, immediate timers take precedence\n    if (a.immediate && !b.immediate) {\n      return -1;\n    }\n    if (!a.immediate && b.immediate) {\n      return 1;\n    }\n\n    // Sort next by creation time, earlier-created timers take precedence\n    if (a.createdAt < b.createdAt) {\n      return -1;\n    }\n    if (a.createdAt > b.createdAt) {\n      return 1;\n    }\n\n    // Sort next by id, lower-id timers take precedence\n    if (a.id < b.id) {\n      return -1;\n    }\n    if (a.id > b.id) {\n      return 1;\n    }\n\n    // As timer ids are unique, no fallback `0` is necessary\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {number} from\n   * @param {number} to\n   *\n   * @returns {Timer}\n   */\n  function firstTimerInRange(clock, from, to) {\n    const timers = clock.timers;\n    let timer = null;\n    let id, isInRange;\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        isInRange = inRange(from, to, timers[id]);\n        if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {\n          timer = timers[id];\n        }\n      }\n    }\n    return timer;\n  }\n\n  /**\n   * @param {Clock} clock\n   * @returns {Timer}\n   */\n  function firstTimer(clock) {\n    const timers = clock.timers;\n    let timer = null;\n    let id;\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === 1) {\n          timer = timers[id];\n        }\n      }\n    }\n    return timer;\n  }\n\n  /**\n   * @param {Clock} clock\n   * @returns {Timer}\n   */\n  function lastTimer(clock) {\n    const timers = clock.timers;\n    let timer = null;\n    let id;\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === -1) {\n          timer = timers[id];\n        }\n      }\n    }\n    return timer;\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {Timer} timer\n   */\n  function callTimer(clock, timer) {\n    if (typeof timer.interval === \"number\") {\n      clock.timers[timer.id].callAt += timer.interval;\n    } else {\n      delete clock.timers[timer.id];\n    }\n    if (typeof timer.func === \"function\") {\n      timer.func.apply(null, timer.args);\n    } else {\n      /* eslint no-eval: \"off\" */\n      const eval2 = eval;\n      (function () {\n        eval2(timer.func);\n      })();\n    }\n  }\n\n  /**\n   * Gets clear handler name for a given timer type\n   * @param {string} ttype\n   */\n  function getClearHandler(ttype) {\n    if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n      return `cancel${ttype}`;\n    }\n    return `clear${ttype}`;\n  }\n\n  /**\n   * Gets schedule handler name for a given timer type\n   * @param {string} ttype\n   */\n  function getScheduleHandler(ttype) {\n    if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n      return `request${ttype}`;\n    }\n    return `set${ttype}`;\n  }\n\n  /**\n   * Creates an anonymous function to warn only once\n   */\n  function createWarnOnce() {\n    let calls = 0;\n    return function (msg) {\n      // eslint-disable-next-line\n      !calls++ && console.warn(msg);\n    };\n  }\n  const warnOnce = createWarnOnce();\n\n  /**\n   * @param {Clock} clock\n   * @param {number} timerId\n   * @param {string} ttype\n   */\n  function clearTimer(clock, timerId, ttype) {\n    if (!timerId) {\n      // null appears to be allowed in most browsers, and appears to be\n      // relied upon by some libraries, like Bootstrap carousel\n      return;\n    }\n    if (!clock.timers) {\n      clock.timers = {};\n    }\n\n    // in Node, the ID is stored as the primitive value for `Timeout` objects\n    // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n    const id = Number(timerId);\n    if (Number.isNaN(id) || id < idCounterStart) {\n      const handlerName = getClearHandler(ttype);\n      if (clock.shouldClearNativeTimers === true) {\n        const nativeHandler = clock[`_${handlerName}`];\n        return typeof nativeHandler === \"function\" ? nativeHandler(timerId) : undefined;\n      }\n      warnOnce(`FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` + \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\");\n    }\n    if (clock.timers.hasOwnProperty(id)) {\n      // check that the ID matches a timer of the correct type\n      const timer = clock.timers[id];\n      if (timer.type === ttype || timer.type === \"Timeout\" && ttype === \"Interval\" || timer.type === \"Interval\" && ttype === \"Timeout\") {\n        delete clock.timers[id];\n      } else {\n        const clear = getClearHandler(ttype);\n        const schedule = getScheduleHandler(timer.type);\n        throw new Error(`Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`);\n      }\n    }\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {Config} config\n   * @returns {Timer[]}\n   */\n  function uninstall(clock, config) {\n    let method, i, l;\n    const installedHrTime = \"_hrtime\";\n    const installedNextTick = \"_nextTick\";\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      method = clock.methods[i];\n      if (method === \"hrtime\" && _global.process) {\n        _global.process.hrtime = clock[installedHrTime];\n      } else if (method === \"nextTick\" && _global.process) {\n        _global.process.nextTick = clock[installedNextTick];\n      } else if (method === \"performance\") {\n        const originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, `_${method}`);\n        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n          Object.defineProperty(_global, method, originalPerfDescriptor);\n        } else if (originalPerfDescriptor.configurable) {\n          _global[method] = clock[`_${method}`];\n        }\n      } else {\n        if (_global[method] && _global[method].hadOwnProperty) {\n          _global[method] = clock[`_${method}`];\n        } else {\n          try {\n            delete _global[method];\n          } catch (ignore) {\n            /* eslint no-empty: \"off\" */\n          }\n        }\n      }\n    }\n    if (config.shouldAdvanceTime === true) {\n      _global.clearInterval(clock.attachedInterval);\n    }\n\n    // Prevent multiple executions which will completely remove these props\n    clock.methods = [];\n\n    // return pending timers, to enable checking what timers remained on uninstall\n    if (!clock.timers) {\n      return [];\n    }\n    return Object.keys(clock.timers).map(function mapper(key) {\n      return clock.timers[key];\n    });\n  }\n\n  /**\n   * @param {object} target the target containing the method to replace\n   * @param {string} method the keyname of the method on the target\n   * @param {Clock} clock\n   */\n  function hijackMethod(target, method, clock) {\n    clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);\n    clock[`_${method}`] = target[method];\n    if (method === \"Date\") {\n      const date = mirrorDateProperties(clock[method], target[method]);\n      target[method] = date;\n    } else if (method === \"performance\") {\n      const originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method);\n      // JSDOM has a read only performance field so we have to save/copy it differently\n      if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n        Object.defineProperty(clock, `_${method}`, originalPerfDescriptor);\n        const perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);\n        Object.defineProperty(target, method, perfDescriptor);\n      } else {\n        target[method] = clock[method];\n      }\n    } else {\n      target[method] = function () {\n        return clock[method].apply(clock, arguments);\n      };\n      Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));\n    }\n    target[method].clock = clock;\n  }\n\n  /**\n   * @param {Clock} clock\n   * @param {number} advanceTimeDelta\n   */\n  function doIntervalTick(clock, advanceTimeDelta) {\n    clock.tick(advanceTimeDelta);\n  }\n\n  /**\n   * @typedef {object} Timers\n   * @property {setTimeout} setTimeout\n   * @property {clearTimeout} clearTimeout\n   * @property {setInterval} setInterval\n   * @property {clearInterval} clearInterval\n   * @property {Date} Date\n   * @property {SetImmediate=} setImmediate\n   * @property {function(NodeImmediate): void=} clearImmediate\n   * @property {function(number[]):number[]=} hrtime\n   * @property {NextTick=} nextTick\n   * @property {Performance=} performance\n   * @property {RequestAnimationFrame=} requestAnimationFrame\n   * @property {boolean=} queueMicrotask\n   * @property {function(number): void=} cancelAnimationFrame\n   * @property {RequestIdleCallback=} requestIdleCallback\n   * @property {function(number): void=} cancelIdleCallback\n   */\n\n  /** @type {Timers} */\n  const timers = {\n    setTimeout: _global.setTimeout,\n    clearTimeout: _global.clearTimeout,\n    setInterval: _global.setInterval,\n    clearInterval: _global.clearInterval,\n    Date: _global.Date\n  };\n  if (setImmediatePresent) {\n    timers.setImmediate = _global.setImmediate;\n    timers.clearImmediate = _global.clearImmediate;\n  }\n  if (hrtimePresent) {\n    timers.hrtime = _global.process.hrtime;\n  }\n  if (nextTickPresent) {\n    timers.nextTick = _global.process.nextTick;\n  }\n  if (performancePresent) {\n    timers.performance = _global.performance;\n  }\n  if (requestAnimationFramePresent) {\n    timers.requestAnimationFrame = _global.requestAnimationFrame;\n  }\n  if (queueMicrotaskPresent) {\n    timers.queueMicrotask = true;\n  }\n  if (cancelAnimationFramePresent) {\n    timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n  }\n  if (requestIdleCallbackPresent) {\n    timers.requestIdleCallback = _global.requestIdleCallback;\n  }\n  if (cancelIdleCallbackPresent) {\n    timers.cancelIdleCallback = _global.cancelIdleCallback;\n  }\n  const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n\n  /**\n   * @param {Date|number} [start] the system time - non-integer values are floored\n   * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n   * @returns {Clock}\n   */\n  function createClock(start, loopLimit) {\n    // eslint-disable-next-line no-param-reassign\n    start = Math.floor(getEpoch(start));\n    // eslint-disable-next-line no-param-reassign\n    loopLimit = loopLimit || 1000;\n    let nanos = 0;\n    const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n    if (NativeDate === undefined) {\n      throw new Error(\"The global scope doesn't have a `Date` object\" + \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\");\n    }\n    const clock = {\n      now: start,\n      Date: createDate(),\n      loopLimit: loopLimit\n    };\n    clock.Date.clock = clock;\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function getTimeToNextFrame() {\n      return 16 - (clock.now - start) % 16;\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function hrtime(prev) {\n      const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n      const secsSinceStart = Math.floor(millisSinceStart / 1000);\n      const remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];\n      if (Array.isArray(prev)) {\n        if (prev[1] > 1e9) {\n          throw new TypeError(\"Number of nanoseconds can't exceed a billion\");\n        }\n        const oldSecs = prev[0];\n        let nanoDiff = remainderInNanos - prev[1];\n        let secDiff = secsSinceStart - oldSecs;\n        if (nanoDiff < 0) {\n          nanoDiff += 1e9;\n          secDiff -= 1;\n        }\n        return [secDiff, nanoDiff];\n      }\n      return [secsSinceStart, remainderInNanos];\n    }\n    if (hrtimeBigintPresent) {\n      hrtime.bigint = function () {\n        const parts = hrtime();\n        return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n      };\n    }\n    clock.requestIdleCallback = function requestIdleCallback(func, timeout) {\n      let timeToNextIdlePeriod = 0;\n      if (clock.countTimers() > 0) {\n        timeToNextIdlePeriod = 50; // const for now\n      }\n      const result = addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: typeof timeout === \"undefined\" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),\n        idleCallback: true\n      });\n      return Number(result);\n    };\n    clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n      return clearTimer(clock, timerId, \"IdleCallback\");\n    };\n    clock.setTimeout = function setTimeout(func, timeout) {\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout\n      });\n    };\n    if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n      clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {\n        return new _global.Promise(function setTimeoutExecutor(resolve) {\n          addTimer(clock, {\n            func: resolve,\n            args: [arg],\n            delay: timeout\n          });\n        });\n      };\n    }\n    clock.clearTimeout = function clearTimeout(timerId) {\n      return clearTimer(clock, timerId, \"Timeout\");\n    };\n    clock.nextTick = function nextTick(func) {\n      return enqueueJob(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 1),\n        error: isNearInfiniteLimit ? new Error() : null\n      });\n    };\n    clock.queueMicrotask = function queueMicrotask(func) {\n      return clock.nextTick(func); // explicitly drop additional arguments\n    };\n    clock.setInterval = function setInterval(func, timeout) {\n      // eslint-disable-next-line no-param-reassign\n      timeout = parseInt(timeout, 10);\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout,\n        interval: timeout\n      });\n    };\n    clock.clearInterval = function clearInterval(timerId) {\n      return clearTimer(clock, timerId, \"Interval\");\n    };\n    if (setImmediatePresent) {\n      clock.setImmediate = function setImmediate(func) {\n        return addTimer(clock, {\n          func: func,\n          args: Array.prototype.slice.call(arguments, 1),\n          immediate: true\n        });\n      };\n      if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n        clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {\n          return new _global.Promise(function setImmediateExecutor(resolve) {\n            addTimer(clock, {\n              func: resolve,\n              args: [arg],\n              immediate: true\n            });\n          });\n        };\n      }\n      clock.clearImmediate = function clearImmediate(timerId) {\n        return clearTimer(clock, timerId, \"Immediate\");\n      };\n    }\n    clock.countTimers = function countTimers() {\n      return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;\n    };\n    clock.requestAnimationFrame = function requestAnimationFrame(func) {\n      const result = addTimer(clock, {\n        func: func,\n        delay: getTimeToNextFrame(),\n        args: [clock.now + getTimeToNextFrame()],\n        animation: true\n      });\n      return Number(result);\n    };\n    clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n      return clearTimer(clock, timerId, \"AnimationFrame\");\n    };\n    clock.runMicrotasks = function runMicrotasks() {\n      runJobs(clock);\n    };\n\n    /**\n     * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n     * @param {boolean} isAsync\n     * @param {Function} resolve\n     * @param {Function} reject\n     * @returns {number|undefined} will return the new `now` value or nothing for async\n     */\n    function doTick(tickValue, isAsync, resolve, reject) {\n      const msFloat = typeof tickValue === \"number\" ? tickValue : parseTime(tickValue);\n      const ms = Math.floor(msFloat);\n      const remainder = nanoRemainder(msFloat);\n      let nanosTotal = nanos + remainder;\n      let tickTo = clock.now + ms;\n      if (msFloat < 0) {\n        throw new TypeError(\"Negative ticks are not supported\");\n      }\n\n      // adjust for positive overflow\n      if (nanosTotal >= 1e6) {\n        tickTo += 1;\n        nanosTotal -= 1e6;\n      }\n      nanos = nanosTotal;\n      let tickFrom = clock.now;\n      let previous = clock.now;\n      // ESLint fails to detect this correctly\n      /* eslint-disable prefer-const */\n      let timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;\n      /* eslint-enable prefer-const */\n\n      clock.duringTick = true;\n\n      // perform microtasks\n      oldNow = clock.now;\n      runJobs(clock);\n      if (oldNow !== clock.now) {\n        // compensate for any setSystemTime() call during microtask callback\n        tickFrom += clock.now - oldNow;\n        tickTo += clock.now - oldNow;\n      }\n\n      //eslint-disable-next-line jsdoc/require-jsdoc\n      function doTickInner() {\n        // perform each timer in the requested range\n        timer = firstTimerInRange(clock, tickFrom, tickTo);\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while (timer && tickFrom <= tickTo) {\n          if (clock.timers[timer.id]) {\n            tickFrom = timer.callAt;\n            clock.now = timer.callAt;\n            oldNow = clock.now;\n            try {\n              runJobs(clock);\n              callTimer(clock, timer);\n            } catch (e) {\n              firstException = firstException || e;\n            }\n            if (isAsync) {\n              // finish up after native setImmediate callback to allow\n              // all native es6 promises to process their callbacks after\n              // each timer fires.\n              originalSetTimeout(nextPromiseTick);\n              return;\n            }\n            compensationCheck();\n          }\n          postTimerCall();\n        }\n\n        // perform process.nextTick()s again\n        oldNow = clock.now;\n        runJobs(clock);\n        if (oldNow !== clock.now) {\n          // compensate for any setSystemTime() call during process.nextTick() callback\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n        }\n        clock.duringTick = false;\n\n        // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n        timer = firstTimerInRange(clock, tickFrom, tickTo);\n        if (timer) {\n          try {\n            clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n          } catch (e) {\n            firstException = firstException || e;\n          }\n        } else {\n          // no timers remaining in the requested range: move the clock all the way to the end\n          clock.now = tickTo;\n\n          // update nanos\n          nanos = nanosTotal;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        if (isAsync) {\n          resolve(clock.now);\n        } else {\n          return clock.now;\n        }\n      }\n      nextPromiseTick = isAsync && function () {\n        try {\n          compensationCheck();\n          postTimerCall();\n          doTickInner();\n        } catch (e) {\n          reject(e);\n        }\n      };\n      compensationCheck = function () {\n        // compensate for any setSystemTime() call during timer callback\n        if (oldNow !== clock.now) {\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n          previous += clock.now - oldNow;\n        }\n      };\n      postTimerCall = function () {\n        timer = firstTimerInRange(clock, previous, tickTo);\n        previous = tickFrom;\n      };\n      return doTickInner();\n    }\n\n    /**\n     * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n     * @returns {number} will return the new `now` value\n     */\n    clock.tick = function tick(tickValue) {\n      return doTick(tickValue, false);\n    };\n    if (typeof _global.Promise !== \"undefined\") {\n      /**\n       * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n       * @returns {Promise}\n       */\n      clock.tickAsync = function tickAsync(tickValue) {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              doTick(tickValue, true, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n    clock.next = function next() {\n      runJobs(clock);\n      const timer = firstTimer(clock);\n      if (!timer) {\n        return clock.now;\n      }\n      clock.duringTick = true;\n      try {\n        clock.now = timer.callAt;\n        callTimer(clock, timer);\n        runJobs(clock);\n        return clock.now;\n      } finally {\n        clock.duringTick = false;\n      }\n    };\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.nextAsync = function nextAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              const timer = firstTimer(clock);\n              if (!timer) {\n                resolve(clock.now);\n                return;\n              }\n              let err;\n              clock.duringTick = true;\n              clock.now = timer.callAt;\n              try {\n                callTimer(clock, timer);\n              } catch (e) {\n                err = e;\n              }\n              clock.duringTick = false;\n              originalSetTimeout(function () {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(clock.now);\n                }\n              });\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n    clock.runAll = function runAll() {\n      let numTimers, i;\n      runJobs(clock);\n      for (i = 0; i < clock.loopLimit; i++) {\n        if (!clock.timers) {\n          resetIsNearInfiniteLimit();\n          return clock.now;\n        }\n        numTimers = Object.keys(clock.timers).length;\n        if (numTimers === 0) {\n          resetIsNearInfiniteLimit();\n          return clock.now;\n        }\n        clock.next();\n        checkIsNearInfiniteLimit(clock, i);\n      }\n      const excessJob = firstTimer(clock);\n      throw getInfiniteLoopError(clock, excessJob);\n    };\n    clock.runToFrame = function runToFrame() {\n      return clock.tick(getTimeToNextFrame());\n    };\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runAllAsync = function runAllAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          let i = 0;\n          /**\n           *\n           */\n          function doRun() {\n            originalSetTimeout(function () {\n              try {\n                let numTimers;\n                if (i < clock.loopLimit) {\n                  if (!clock.timers) {\n                    resetIsNearInfiniteLimit();\n                    resolve(clock.now);\n                    return;\n                  }\n                  numTimers = Object.keys(clock.timers).length;\n                  if (numTimers === 0) {\n                    resetIsNearInfiniteLimit();\n                    resolve(clock.now);\n                    return;\n                  }\n                  clock.next();\n                  i++;\n                  doRun();\n                  checkIsNearInfiniteLimit(clock, i);\n                  return;\n                }\n                const excessJob = firstTimer(clock);\n                reject(getInfiniteLoopError(clock, excessJob));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          }\n          doRun();\n        });\n      };\n    }\n    clock.runToLast = function runToLast() {\n      const timer = lastTimer(clock);\n      if (!timer) {\n        runJobs(clock);\n        return clock.now;\n      }\n      return clock.tick(timer.callAt - clock.now);\n    };\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runToLastAsync = function runToLastAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              const timer = lastTimer(clock);\n              if (!timer) {\n                resolve(clock.now);\n              }\n              resolve(clock.tickAsync(timer.callAt));\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n    clock.reset = function reset() {\n      nanos = 0;\n      clock.timers = {};\n      clock.jobs = [];\n      clock.now = start;\n    };\n    clock.setSystemTime = function setSystemTime(systemTime) {\n      // determine time difference\n      const newNow = getEpoch(systemTime);\n      const difference = newNow - clock.now;\n      let id, timer;\n      adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n      adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;\n      // update 'system clock'\n      clock.now = newNow;\n      nanos = 0;\n\n      // update timers and intervals to keep them stable\n      for (id in clock.timers) {\n        if (clock.timers.hasOwnProperty(id)) {\n          timer = clock.timers[id];\n          timer.createdAt += difference;\n          timer.callAt += difference;\n        }\n      }\n    };\n    if (performancePresent) {\n      clock.performance = Object.create(null);\n      if (hasPerformancePrototype) {\n        const proto = _global.Performance.prototype;\n        Object.getOwnPropertyNames(proto).forEach(function (name) {\n          if (name.indexOf(\"getEntries\") === 0) {\n            // match expected return type for getEntries functions\n            clock.performance[name] = NOOP_ARRAY;\n          } else {\n            clock.performance[name] = NOOP;\n          }\n        });\n      }\n      clock.performance.now = function FakeTimersNow() {\n        const hrt = hrtime();\n        const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n        return millis;\n      };\n    }\n    if (hrtimePresent) {\n      clock.hrtime = hrtime;\n    }\n    return clock;\n  }\n\n  /* eslint-disable complexity */\n\n  /**\n   * @param {Config=} [config] Optional config\n   * @returns {Clock}\n   */\n  function install(config) {\n    if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || typeof config === \"number\") {\n      throw new TypeError(`FakeTimers.install called with ${String(config)} install requires an object parameter`);\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    config = typeof config !== \"undefined\" ? config : {};\n    config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n    config.advanceTimeDelta = config.advanceTimeDelta || 20;\n    config.shouldClearNativeTimers = config.shouldClearNativeTimers || false;\n    if (config.target) {\n      throw new TypeError(\"config.target is no longer supported. Use `withGlobal(target)` instead.\");\n    }\n    let i, l;\n    const clock = createClock(config.now, config.loopLimit);\n    clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n    clock.uninstall = function () {\n      return uninstall(clock, config);\n    };\n    clock.methods = config.toFake || [];\n    if (clock.methods.length === 0) {\n      // do not fake nextTick by default - GitHub#126\n      clock.methods = Object.keys(timers).filter(function (key) {\n        return key !== \"nextTick\" && key !== \"queueMicrotask\";\n      });\n    }\n    if (config.shouldAdvanceTime === true) {\n      const intervalTick = doIntervalTick.bind(null, clock, config.advanceTimeDelta);\n      const intervalId = _global.setInterval(intervalTick, config.advanceTimeDelta);\n      clock.attachedInterval = intervalId;\n    }\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      const nameOfMethodToReplace = clock.methods[i];\n      if (nameOfMethodToReplace === \"hrtime\") {\n        if (_global.process && typeof _global.process.hrtime === \"function\") {\n          hijackMethod(_global.process, nameOfMethodToReplace, clock);\n        }\n      } else if (nameOfMethodToReplace === \"nextTick\") {\n        if (_global.process && typeof _global.process.nextTick === \"function\") {\n          hijackMethod(_global.process, nameOfMethodToReplace, clock);\n        }\n      } else {\n        hijackMethod(_global, nameOfMethodToReplace, clock);\n      }\n    }\n    return clock;\n  }\n\n  /* eslint-enable complexity */\n\n  return {\n    timers: timers,\n    createClock: createClock,\n    install: install,\n    withGlobal: withGlobal\n  };\n}\n\n/**\n * @typedef {object} FakeTimers\n * @property {Timers} timers\n * @property {createClock} createClock\n * @property {Function} install\n * @property {withGlobal} withGlobal\n */\n\n/* eslint-enable complexity */\n\n/** @type {FakeTimers} */\nconst defaultImplementation = withGlobal(globalObject);\nexports.timers = defaultImplementation.timers;\nexports.createClock = defaultImplementation.createClock;\nexports.install = defaultImplementation.install;\nexports.withGlobal = withGlobal;","map":{"version":3,"names":["globalObject","require","global","withGlobal","_global","userAgent","navigator","isRunningInIE","indexOf","maxTimeout","Math","pow","idCounterStart","NOOP","undefined","NOOP_ARRAY","timeoutResult","setTimeout","addTimerReturnsObject","hrtimePresent","process","hrtime","hrtimeBigintPresent","bigint","nextTickPresent","nextTick","utilPromisify","promisify","performancePresent","performance","now","hasPerformancePrototype","Performance","match","queueMicrotaskPresent","hasOwnProperty","requestAnimationFramePresent","requestAnimationFrame","cancelAnimationFramePresent","cancelAnimationFrame","requestIdleCallbackPresent","requestIdleCallback","cancelIdleCallbackPresent","cancelIdleCallback","setImmediatePresent","setImmediate","clearTimeout","setInterval","clearInterval","Date","clearImmediate","NativeDate","uniqueTimerId","isNumberFinite","num","Number","isFinite","isNearInfiniteLimit","checkIsNearInfiniteLimit","clock","i","loopLimit","resetIsNearInfiniteLimit","parseTime","str","strings","split","l","length","ms","parsed","test","Error","parseInt","nanoRemainder","msFloat","modulo","remainder","positiveRemainder","floor","getEpoch","epoch","getTime","TypeError","inRange","from","to","timer","callAt","getInfiniteLoopError","job","infiniteLoopError","error","computedTargetPattern","clockMethodPattern","RegExp","String","Object","keys","join","matchedLineIndex","stack","some","line","matchedComputedTarget","matchedClockMethod","type","func","name","slice","defineProperty","value","e","mirrorDateProperties","target","source","prop","toSource","toString","prototype","parse","UTC","toUTCString","createDate","ClockDate","year","month","date","hour","minute","second","arguments","enqueueJob","jobs","push","runJobs","apply","args","addTimer","immediate","delay","max","interval","animation","idleCallback","timers","id","createdAt","duringTick","res","ref","unref","refresh","concat","Symbol","toPrimitive","compareTimers","a","b","firstTimerInRange","isInRange","firstTimer","lastTimer","callTimer","eval2","eval","getClearHandler","ttype","getScheduleHandler","createWarnOnce","calls","msg","console","warn","warnOnce","clearTimer","timerId","isNaN","handlerName","shouldClearNativeTimers","nativeHandler","clear","schedule","uninstall","config","method","installedHrTime","installedNextTick","methods","originalPerfDescriptor","getOwnPropertyDescriptor","get","set","configurable","hadOwnProperty","ignore","shouldAdvanceTime","attachedInterval","map","mapper","key","hijackMethod","call","perfDescriptor","defineProperties","getOwnPropertyDescriptors","doIntervalTick","advanceTimeDelta","tick","queueMicrotask","originalSetTimeout","createClock","start","nanos","adjustedSystemTime","getTimeToNextFrame","prev","millisSinceStart","secsSinceStart","remainderInNanos","Array","isArray","oldSecs","nanoDiff","secDiff","parts","BigInt","timeout","timeToNextIdlePeriod","countTimers","result","min","Promise","custom","promisifiedSetTimeout","arg","setTimeoutExecutor","resolve","promisifiedSetImmediate","setImmediateExecutor","runMicrotasks","doTick","tickValue","isAsync","reject","nanosTotal","tickTo","tickFrom","previous","firstException","oldNow","nextPromiseTick","compensationCheck","postTimerCall","doTickInner","tickAsync","next","nextAsync","err","runAll","numTimers","excessJob","runToFrame","runAllAsync","doRun","runToLast","runToLastAsync","reset","setSystemTime","systemTime","newNow","difference","create","proto","getOwnPropertyNames","forEach","FakeTimersNow","hrt","millis","install","toFake","filter","intervalTick","bind","intervalId","nameOfMethodToReplace","defaultImplementation","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@sinonjs/fake-timers/src/fake-timers-src.js"],"sourcesContent":["\"use strict\";\n\nconst globalObject = require(\"@sinonjs/commons\").global;\n\n/**\n * @typedef {object} IdleDeadline\n * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n */\n\n/**\n * Queues a function to be called during a browser's idle periods\n *\n * @callback RequestIdleCallback\n * @param {function(IdleDeadline)} callback\n * @param {{timeout: number}} options - an options object\n * @returns {number} the id\n */\n\n/**\n * @callback NextTick\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {void}\n */\n\n/**\n * @callback SetImmediate\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {NodeImmediate}\n */\n\n/**\n * @callback VoidVarArgsFunc\n * @param {...*} callback - the callback to run\n * @returns {void}\n */\n\n/**\n * @typedef RequestAnimationFrame\n * @property {function(number):void} requestAnimationFrame\n * @returns {number} - the id\n */\n\n/**\n * @typedef Performance\n * @property {function(): number} now\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * @typedef {object} Clock\n * @property {number} now - the current time\n * @property {Date} Date - the Date constructor\n * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n * @property {RequestIdleCallback} requestIdleCallback\n * @property {function(number):void} cancelIdleCallback\n * @property {setTimeout} setTimeout\n * @property {clearTimeout} clearTimeout\n * @property {NextTick} nextTick\n * @property {queueMicrotask} queueMicrotask\n * @property {setInterval} setInterval\n * @property {clearInterval} clearInterval\n * @property {SetImmediate} setImmediate\n * @property {function(NodeImmediate):void} clearImmediate\n * @property {function():number} countTimers\n * @property {RequestAnimationFrame} requestAnimationFrame\n * @property {function(number):void} cancelAnimationFrame\n * @property {function():void} runMicrotasks\n * @property {function(string | number): number} tick\n * @property {function(string | number): Promise<number>} tickAsync\n * @property {function(): number} next\n * @property {function(): Promise<number>} nextAsync\n * @property {function(): number} runAll\n * @property {function(): number} runToFrame\n * @property {function(): Promise<number>} runAllAsync\n * @property {function(): number} runToLast\n * @property {function(): Promise<number>} runToLastAsync\n * @property {function(): void} reset\n * @property {function(number | Date): void} setSystemTime\n * @property {Performance} performance\n * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n * @property {function(): void} uninstall Uninstall the clock.\n * @property {Function[]} methods - the methods that are faked\n * @property {boolean} [shouldClearNativeTimers] inherited from config\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/**\n * Configuration object for the `install` method.\n *\n * @typedef {object} Config\n * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n * @property {string[]} [toFake] names of the methods that should be faked.\n * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * The internal structure to describe a scheduled fake timer\n *\n * @typedef {object} Timer\n * @property {Function} func\n * @property {*[]} args\n * @property {number} delay\n * @property {number} callAt\n * @property {number} createdAt\n * @property {boolean} immediate\n * @property {number} id\n * @property {Error} [error]\n */\n\n/**\n * A Node timer\n *\n * @typedef {object} NodeImmediate\n * @property {function(): boolean} hasRef\n * @property {function(): NodeImmediate} ref\n * @property {function(): NodeImmediate} unref\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/* eslint-disable complexity */\n\n/**\n * Mocks available features in the specified global namespace.\n *\n * @param {*} _global Namespace to mock (e.g. `window`)\n * @returns {FakeTimers}\n */\nfunction withGlobal(_global) {\n    const userAgent = _global.navigator && _global.navigator.userAgent;\n    const isRunningInIE = userAgent && userAgent.indexOf(\"MSIE \") > -1;\n    const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n    const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n    const NOOP = function () {\n        return undefined;\n    };\n    const NOOP_ARRAY = function () {\n        return [];\n    };\n    const timeoutResult = _global.setTimeout(NOOP, 0);\n    const addTimerReturnsObject = typeof timeoutResult === \"object\";\n    const hrtimePresent =\n        _global.process && typeof _global.process.hrtime === \"function\";\n    const hrtimeBigintPresent =\n        hrtimePresent && typeof _global.process.hrtime.bigint === \"function\";\n    const nextTickPresent =\n        _global.process && typeof _global.process.nextTick === \"function\";\n    const utilPromisify = _global.process && require(\"util\").promisify;\n    const performancePresent =\n        _global.performance && typeof _global.performance.now === \"function\";\n    const hasPerformancePrototype =\n        _global.Performance &&\n        (typeof _global.Performance).match(/^(function|object)$/);\n    const queueMicrotaskPresent = _global.hasOwnProperty(\"queueMicrotask\");\n    const requestAnimationFramePresent =\n        _global.requestAnimationFrame &&\n        typeof _global.requestAnimationFrame === \"function\";\n    const cancelAnimationFramePresent =\n        _global.cancelAnimationFrame &&\n        typeof _global.cancelAnimationFrame === \"function\";\n    const requestIdleCallbackPresent =\n        _global.requestIdleCallback &&\n        typeof _global.requestIdleCallback === \"function\";\n    const cancelIdleCallbackPresent =\n        _global.cancelIdleCallback &&\n        typeof _global.cancelIdleCallback === \"function\";\n    const setImmediatePresent =\n        _global.setImmediate && typeof _global.setImmediate === \"function\";\n\n    // Make properties writable in IE, as per\n    // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n    /* eslint-disable no-self-assign */\n    if (isRunningInIE) {\n        _global.setTimeout = _global.setTimeout;\n        _global.clearTimeout = _global.clearTimeout;\n        _global.setInterval = _global.setInterval;\n        _global.clearInterval = _global.clearInterval;\n        _global.Date = _global.Date;\n    }\n\n    // setImmediate is not a standard function\n    // avoid adding the prop to the window object if not present\n    if (setImmediatePresent) {\n        _global.setImmediate = _global.setImmediate;\n        _global.clearImmediate = _global.clearImmediate;\n    }\n    /* eslint-enable no-self-assign */\n\n    _global.clearTimeout(timeoutResult);\n\n    const NativeDate = _global.Date;\n    let uniqueTimerId = idCounterStart;\n\n    /**\n     * @param {number} num\n     * @returns {boolean}\n     */\n    function isNumberFinite(num) {\n        if (Number.isFinite) {\n            return Number.isFinite(num);\n        }\n\n        return isFinite(num);\n    }\n\n    let isNearInfiniteLimit = false;\n\n    /**\n     * @param {Clock} clock\n     * @param {number} i\n     */\n    function checkIsNearInfiniteLimit(clock, i) {\n        if (clock.loopLimit && i === clock.loopLimit - 1) {\n            isNearInfiniteLimit = true;\n        }\n    }\n\n    /**\n     *\n     */\n    function resetIsNearInfiniteLimit() {\n        isNearInfiniteLimit = false;\n    }\n\n    /**\n     * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n     * number of milliseconds. This is used to support human-readable strings passed\n     * to clock.tick()\n     *\n     * @param {string} str\n     * @returns {number}\n     */\n    function parseTime(str) {\n        if (!str) {\n            return 0;\n        }\n\n        const strings = str.split(\":\");\n        const l = strings.length;\n        let i = l;\n        let ms = 0;\n        let parsed;\n\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n            throw new Error(\n                \"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\"\n            );\n        }\n\n        while (i--) {\n            parsed = parseInt(strings[i], 10);\n\n            if (parsed >= 60) {\n                throw new Error(`Invalid time ${str}`);\n            }\n\n            ms += parsed * Math.pow(60, l - i - 1);\n        }\n\n        return ms * 1000;\n    }\n\n    /**\n     * Get the decimal part of the millisecond value as nanoseconds\n     *\n     * @param {number} msFloat the number of milliseconds\n     * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n     *\n     * Example: nanoRemainer(123.456789) -> 456789\n     */\n    function nanoRemainder(msFloat) {\n        const modulo = 1e6;\n        const remainder = (msFloat * 1e6) % modulo;\n        const positiveRemainder =\n            remainder < 0 ? remainder + modulo : remainder;\n\n        return Math.floor(positiveRemainder);\n    }\n\n    /**\n     * Used to grok the `now` parameter to createClock.\n     *\n     * @param {Date|number} epoch the system time\n     * @returns {number}\n     */\n    function getEpoch(epoch) {\n        if (!epoch) {\n            return 0;\n        }\n        if (typeof epoch.getTime === \"function\") {\n            return epoch.getTime();\n        }\n        if (typeof epoch === \"number\") {\n            return epoch;\n        }\n        throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n    }\n\n    /**\n     * @param {number} from\n     * @param {number} to\n     * @param {Timer} timer\n     * @returns {boolean}\n     */\n    function inRange(from, to, timer) {\n        return timer && timer.callAt >= from && timer.callAt <= to;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} job\n     */\n    function getInfiniteLoopError(clock, job) {\n        const infiniteLoopError = new Error(\n            `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`\n        );\n\n        if (!job.error) {\n            return infiniteLoopError;\n        }\n\n        // pattern never matched in Node\n        const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n        let clockMethodPattern = new RegExp(\n            String(Object.keys(clock).join(\"|\"))\n        );\n\n        if (addTimerReturnsObject) {\n            // node.js environment\n            clockMethodPattern = new RegExp(\n                `\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`\n            );\n        }\n\n        let matchedLineIndex = -1;\n        job.error.stack.split(\"\\n\").some(function (line, i) {\n            // If we've matched a computed target line (e.g. setTimeout) then we\n            // don't need to look any further. Return true to stop iterating.\n            const matchedComputedTarget = line.match(computedTargetPattern);\n            /* istanbul ignore if */\n            if (matchedComputedTarget) {\n                matchedLineIndex = i;\n                return true;\n            }\n\n            // If we've matched a clock method line, then there may still be\n            // others further down the trace. Return false to keep iterating.\n            const matchedClockMethod = line.match(clockMethodPattern);\n            if (matchedClockMethod) {\n                matchedLineIndex = i;\n                return false;\n            }\n\n            // If we haven't matched anything on this line, but we matched\n            // previously and set the matched line index, then we can stop.\n            // If we haven't matched previously, then we should keep iterating.\n            return matchedLineIndex >= 0;\n        });\n\n        const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${\n            job.func.name || \"anonymous\"\n        }\\n${job.error.stack\n            .split(\"\\n\")\n            .slice(matchedLineIndex + 1)\n            .join(\"\\n\")}`;\n\n        try {\n            Object.defineProperty(infiniteLoopError, \"stack\", {\n                value: stack,\n            });\n        } catch (e) {\n            // noop\n        }\n\n        return infiniteLoopError;\n    }\n\n    /**\n     * @param {Date} target\n     * @param {Date} source\n     * @returns {Date} the target after modifications\n     */\n    function mirrorDateProperties(target, source) {\n        let prop;\n        for (prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n\n        // set special now implementation\n        if (source.now) {\n            target.now = function now() {\n                return target.clock.now;\n            };\n        } else {\n            delete target.now;\n        }\n\n        // set special toSource implementation\n        if (source.toSource) {\n            target.toSource = function toSource() {\n                return source.toSource();\n            };\n        } else {\n            delete target.toSource;\n        }\n\n        // set special toString implementation\n        target.toString = function toString() {\n            return source.toString();\n        };\n\n        target.prototype = source.prototype;\n        target.parse = source.parse;\n        target.UTC = source.UTC;\n        target.prototype.toUTCString = source.prototype.toUTCString;\n\n        return target;\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function createDate() {\n        /**\n         * @param {number} year\n         * @param {number} month\n         * @param {number} date\n         * @param {number} hour\n         * @param {number} minute\n         * @param {number} second\n         * @param {number} ms\n         *\n         * @returns {Date}\n         */\n        function ClockDate(year, month, date, hour, minute, second, ms) {\n            // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n            // This remains so in the 10th edition of 2019 as well.\n            if (!(this instanceof ClockDate)) {\n                return new NativeDate(ClockDate.clock.now).toString();\n            }\n\n            // if Date is called as a constructor with 'new' keyword\n            // Defensive and verbose to avoid potential harm in passing\n            // explicit undefined when user does not pass argument\n            switch (arguments.length) {\n                case 0:\n                    return new NativeDate(ClockDate.clock.now);\n                case 1:\n                    return new NativeDate(year);\n                case 2:\n                    return new NativeDate(year, month);\n                case 3:\n                    return new NativeDate(year, month, date);\n                case 4:\n                    return new NativeDate(year, month, date, hour);\n                case 5:\n                    return new NativeDate(year, month, date, hour, minute);\n                case 6:\n                    return new NativeDate(\n                        year,\n                        month,\n                        date,\n                        hour,\n                        minute,\n                        second\n                    );\n                default:\n                    return new NativeDate(\n                        year,\n                        month,\n                        date,\n                        hour,\n                        minute,\n                        second,\n                        ms\n                    );\n            }\n        }\n\n        return mirrorDateProperties(ClockDate, NativeDate);\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function enqueueJob(clock, job) {\n        // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n        if (!clock.jobs) {\n            clock.jobs = [];\n        }\n        clock.jobs.push(job);\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function runJobs(clock) {\n        // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n        if (!clock.jobs) {\n            return;\n        }\n        for (let i = 0; i < clock.jobs.length; i++) {\n            const job = clock.jobs[i];\n            job.func.apply(null, job.args);\n\n            checkIsNearInfiniteLimit(clock, i);\n            if (clock.loopLimit && i > clock.loopLimit) {\n                throw getInfiniteLoopError(clock, job);\n            }\n        }\n        resetIsNearInfiniteLimit();\n        clock.jobs = [];\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} timer\n     * @returns {number} id of the created timer\n     */\n    function addTimer(clock, timer) {\n        if (timer.func === undefined) {\n            throw new Error(\"Callback must be provided to timer calls\");\n        }\n\n        if (addTimerReturnsObject) {\n            // Node.js environment\n            if (typeof timer.func !== \"function\") {\n                throw new TypeError(\n                    `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${\n                        timer.func\n                    } of type ${typeof timer.func}`\n                );\n            }\n        }\n\n        if (isNearInfiniteLimit) {\n            timer.error = new Error();\n        }\n\n        timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n        if (timer.hasOwnProperty(\"delay\")) {\n            if (typeof timer.delay !== \"number\") {\n                timer.delay = parseInt(timer.delay, 10);\n            }\n\n            if (!isNumberFinite(timer.delay)) {\n                timer.delay = 0;\n            }\n            timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n            timer.delay = Math.max(0, timer.delay);\n        }\n\n        if (timer.hasOwnProperty(\"interval\")) {\n            timer.type = \"Interval\";\n            timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n        }\n\n        if (timer.hasOwnProperty(\"animation\")) {\n            timer.type = \"AnimationFrame\";\n            timer.animation = true;\n        }\n\n        if (timer.hasOwnProperty(\"idleCallback\")) {\n            timer.type = \"IdleCallback\";\n            timer.idleCallback = true;\n        }\n\n        if (!clock.timers) {\n            clock.timers = {};\n        }\n\n        timer.id = uniqueTimerId++;\n        timer.createdAt = clock.now;\n        timer.callAt =\n            clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n        clock.timers[timer.id] = timer;\n\n        if (addTimerReturnsObject) {\n            const res = {\n                ref: function () {\n                    return res;\n                },\n                unref: function () {\n                    return res;\n                },\n                refresh: function () {\n                    clearTimeout(timer.id);\n                    const args = [timer.func, timer.delay].concat(timer.args);\n                    return setTimeout.apply(null, args);\n                },\n                [Symbol.toPrimitive]: function () {\n                    return timer.id;\n                },\n            };\n            return res;\n        }\n\n        return timer.id;\n    }\n\n    /* eslint consistent-return: \"off\" */\n    /**\n     * Timer comparitor\n     *\n     * @param {Timer} a\n     * @param {Timer} b\n     * @returns {number}\n     */\n    function compareTimers(a, b) {\n        // Sort first by absolute timing\n        if (a.callAt < b.callAt) {\n            return -1;\n        }\n        if (a.callAt > b.callAt) {\n            return 1;\n        }\n\n        // Sort next by immediate, immediate timers take precedence\n        if (a.immediate && !b.immediate) {\n            return -1;\n        }\n        if (!a.immediate && b.immediate) {\n            return 1;\n        }\n\n        // Sort next by creation time, earlier-created timers take precedence\n        if (a.createdAt < b.createdAt) {\n            return -1;\n        }\n        if (a.createdAt > b.createdAt) {\n            return 1;\n        }\n\n        // Sort next by id, lower-id timers take precedence\n        if (a.id < b.id) {\n            return -1;\n        }\n        if (a.id > b.id) {\n            return 1;\n        }\n\n        // As timer ids are unique, no fallback `0` is necessary\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {number} from\n     * @param {number} to\n     *\n     * @returns {Timer}\n     */\n    function firstTimerInRange(clock, from, to) {\n        const timers = clock.timers;\n        let timer = null;\n        let id, isInRange;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                isInRange = inRange(from, to, timers[id]);\n\n                if (\n                    isInRange &&\n                    (!timer || compareTimers(timer, timers[id]) === 1)\n                ) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @returns {Timer}\n     */\n    function firstTimer(clock) {\n        const timers = clock.timers;\n        let timer = null;\n        let id;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                if (!timer || compareTimers(timer, timers[id]) === 1) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @returns {Timer}\n     */\n    function lastTimer(clock) {\n        const timers = clock.timers;\n        let timer = null;\n        let id;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                if (!timer || compareTimers(timer, timers[id]) === -1) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} timer\n     */\n    function callTimer(clock, timer) {\n        if (typeof timer.interval === \"number\") {\n            clock.timers[timer.id].callAt += timer.interval;\n        } else {\n            delete clock.timers[timer.id];\n        }\n\n        if (typeof timer.func === \"function\") {\n            timer.func.apply(null, timer.args);\n        } else {\n            /* eslint no-eval: \"off\" */\n            const eval2 = eval;\n            (function () {\n                eval2(timer.func);\n            })();\n        }\n    }\n\n    /**\n     * Gets clear handler name for a given timer type\n     * @param {string} ttype\n     */\n    function getClearHandler(ttype) {\n        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n            return `cancel${ttype}`;\n        }\n        return `clear${ttype}`;\n    }\n\n    /**\n     * Gets schedule handler name for a given timer type\n     * @param {string} ttype\n     */\n    function getScheduleHandler(ttype) {\n        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n            return `request${ttype}`;\n        }\n        return `set${ttype}`;\n    }\n\n    /**\n     * Creates an anonymous function to warn only once\n     */\n    function createWarnOnce() {\n        let calls = 0;\n        return function (msg) {\n            // eslint-disable-next-line\n            !calls++ && console.warn(msg);\n        };\n    }\n    const warnOnce = createWarnOnce();\n\n    /**\n     * @param {Clock} clock\n     * @param {number} timerId\n     * @param {string} ttype\n     */\n    function clearTimer(clock, timerId, ttype) {\n        if (!timerId) {\n            // null appears to be allowed in most browsers, and appears to be\n            // relied upon by some libraries, like Bootstrap carousel\n            return;\n        }\n\n        if (!clock.timers) {\n            clock.timers = {};\n        }\n\n        // in Node, the ID is stored as the primitive value for `Timeout` objects\n        // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n        const id = Number(timerId);\n\n        if (Number.isNaN(id) || id < idCounterStart) {\n            const handlerName = getClearHandler(ttype);\n\n            if (clock.shouldClearNativeTimers === true) {\n                const nativeHandler = clock[`_${handlerName}`];\n                return typeof nativeHandler === \"function\"\n                    ? nativeHandler(timerId)\n                    : undefined;\n            }\n            warnOnce(\n                `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` +\n                    \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\"\n            );\n        }\n\n        if (clock.timers.hasOwnProperty(id)) {\n            // check that the ID matches a timer of the correct type\n            const timer = clock.timers[id];\n            if (\n                timer.type === ttype ||\n                (timer.type === \"Timeout\" && ttype === \"Interval\") ||\n                (timer.type === \"Interval\" && ttype === \"Timeout\")\n            ) {\n                delete clock.timers[id];\n            } else {\n                const clear = getClearHandler(ttype);\n                const schedule = getScheduleHandler(timer.type);\n                throw new Error(\n                    `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`\n                );\n            }\n        }\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Config} config\n     * @returns {Timer[]}\n     */\n    function uninstall(clock, config) {\n        let method, i, l;\n        const installedHrTime = \"_hrtime\";\n        const installedNextTick = \"_nextTick\";\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            method = clock.methods[i];\n            if (method === \"hrtime\" && _global.process) {\n                _global.process.hrtime = clock[installedHrTime];\n            } else if (method === \"nextTick\" && _global.process) {\n                _global.process.nextTick = clock[installedNextTick];\n            } else if (method === \"performance\") {\n                const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                    clock,\n                    `_${method}`\n                );\n                if (\n                    originalPerfDescriptor &&\n                    originalPerfDescriptor.get &&\n                    !originalPerfDescriptor.set\n                ) {\n                    Object.defineProperty(\n                        _global,\n                        method,\n                        originalPerfDescriptor\n                    );\n                } else if (originalPerfDescriptor.configurable) {\n                    _global[method] = clock[`_${method}`];\n                }\n            } else {\n                if (_global[method] && _global[method].hadOwnProperty) {\n                    _global[method] = clock[`_${method}`];\n                } else {\n                    try {\n                        delete _global[method];\n                    } catch (ignore) {\n                        /* eslint no-empty: \"off\" */\n                    }\n                }\n            }\n        }\n\n        if (config.shouldAdvanceTime === true) {\n            _global.clearInterval(clock.attachedInterval);\n        }\n\n        // Prevent multiple executions which will completely remove these props\n        clock.methods = [];\n\n        // return pending timers, to enable checking what timers remained on uninstall\n        if (!clock.timers) {\n            return [];\n        }\n        return Object.keys(clock.timers).map(function mapper(key) {\n            return clock.timers[key];\n        });\n    }\n\n    /**\n     * @param {object} target the target containing the method to replace\n     * @param {string} method the keyname of the method on the target\n     * @param {Clock} clock\n     */\n    function hijackMethod(target, method, clock) {\n        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(\n            target,\n            method\n        );\n        clock[`_${method}`] = target[method];\n\n        if (method === \"Date\") {\n            const date = mirrorDateProperties(clock[method], target[method]);\n            target[method] = date;\n        } else if (method === \"performance\") {\n            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                target,\n                method\n            );\n            // JSDOM has a read only performance field so we have to save/copy it differently\n            if (\n                originalPerfDescriptor &&\n                originalPerfDescriptor.get &&\n                !originalPerfDescriptor.set\n            ) {\n                Object.defineProperty(\n                    clock,\n                    `_${method}`,\n                    originalPerfDescriptor\n                );\n\n                const perfDescriptor = Object.getOwnPropertyDescriptor(\n                    clock,\n                    method\n                );\n                Object.defineProperty(target, method, perfDescriptor);\n            } else {\n                target[method] = clock[method];\n            }\n        } else {\n            target[method] = function () {\n                return clock[method].apply(clock, arguments);\n            };\n\n            Object.defineProperties(\n                target[method],\n                Object.getOwnPropertyDescriptors(clock[method])\n            );\n        }\n\n        target[method].clock = clock;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {number} advanceTimeDelta\n     */\n    function doIntervalTick(clock, advanceTimeDelta) {\n        clock.tick(advanceTimeDelta);\n    }\n\n    /**\n     * @typedef {object} Timers\n     * @property {setTimeout} setTimeout\n     * @property {clearTimeout} clearTimeout\n     * @property {setInterval} setInterval\n     * @property {clearInterval} clearInterval\n     * @property {Date} Date\n     * @property {SetImmediate=} setImmediate\n     * @property {function(NodeImmediate): void=} clearImmediate\n     * @property {function(number[]):number[]=} hrtime\n     * @property {NextTick=} nextTick\n     * @property {Performance=} performance\n     * @property {RequestAnimationFrame=} requestAnimationFrame\n     * @property {boolean=} queueMicrotask\n     * @property {function(number): void=} cancelAnimationFrame\n     * @property {RequestIdleCallback=} requestIdleCallback\n     * @property {function(number): void=} cancelIdleCallback\n     */\n\n    /** @type {Timers} */\n    const timers = {\n        setTimeout: _global.setTimeout,\n        clearTimeout: _global.clearTimeout,\n        setInterval: _global.setInterval,\n        clearInterval: _global.clearInterval,\n        Date: _global.Date,\n    };\n\n    if (setImmediatePresent) {\n        timers.setImmediate = _global.setImmediate;\n        timers.clearImmediate = _global.clearImmediate;\n    }\n\n    if (hrtimePresent) {\n        timers.hrtime = _global.process.hrtime;\n    }\n\n    if (nextTickPresent) {\n        timers.nextTick = _global.process.nextTick;\n    }\n\n    if (performancePresent) {\n        timers.performance = _global.performance;\n    }\n\n    if (requestAnimationFramePresent) {\n        timers.requestAnimationFrame = _global.requestAnimationFrame;\n    }\n\n    if (queueMicrotaskPresent) {\n        timers.queueMicrotask = true;\n    }\n\n    if (cancelAnimationFramePresent) {\n        timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n    }\n\n    if (requestIdleCallbackPresent) {\n        timers.requestIdleCallback = _global.requestIdleCallback;\n    }\n\n    if (cancelIdleCallbackPresent) {\n        timers.cancelIdleCallback = _global.cancelIdleCallback;\n    }\n\n    const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n\n    /**\n     * @param {Date|number} [start] the system time - non-integer values are floored\n     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n     * @returns {Clock}\n     */\n    function createClock(start, loopLimit) {\n        // eslint-disable-next-line no-param-reassign\n        start = Math.floor(getEpoch(start));\n        // eslint-disable-next-line no-param-reassign\n        loopLimit = loopLimit || 1000;\n        let nanos = 0;\n        const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n        if (NativeDate === undefined) {\n            throw new Error(\n                \"The global scope doesn't have a `Date` object\" +\n                    \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\"\n            );\n        }\n\n        const clock = {\n            now: start,\n            Date: createDate(),\n            loopLimit: loopLimit,\n        };\n\n        clock.Date.clock = clock;\n\n        //eslint-disable-next-line jsdoc/require-jsdoc\n        function getTimeToNextFrame() {\n            return 16 - ((clock.now - start) % 16);\n        }\n\n        //eslint-disable-next-line jsdoc/require-jsdoc\n        function hrtime(prev) {\n            const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n            const secsSinceStart = Math.floor(millisSinceStart / 1000);\n            const remainderInNanos =\n                (millisSinceStart - secsSinceStart * 1e3) * 1e6 +\n                nanos -\n                adjustedSystemTime[1];\n\n            if (Array.isArray(prev)) {\n                if (prev[1] > 1e9) {\n                    throw new TypeError(\n                        \"Number of nanoseconds can't exceed a billion\"\n                    );\n                }\n\n                const oldSecs = prev[0];\n                let nanoDiff = remainderInNanos - prev[1];\n                let secDiff = secsSinceStart - oldSecs;\n\n                if (nanoDiff < 0) {\n                    nanoDiff += 1e9;\n                    secDiff -= 1;\n                }\n\n                return [secDiff, nanoDiff];\n            }\n            return [secsSinceStart, remainderInNanos];\n        }\n\n        if (hrtimeBigintPresent) {\n            hrtime.bigint = function () {\n                const parts = hrtime();\n                return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n            };\n        }\n\n        clock.requestIdleCallback = function requestIdleCallback(\n            func,\n            timeout\n        ) {\n            let timeToNextIdlePeriod = 0;\n\n            if (clock.countTimers() > 0) {\n                timeToNextIdlePeriod = 50; // const for now\n            }\n\n            const result = addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay:\n                    typeof timeout === \"undefined\"\n                        ? timeToNextIdlePeriod\n                        : Math.min(timeout, timeToNextIdlePeriod),\n                idleCallback: true,\n            });\n\n            return Number(result);\n        };\n\n        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n            return clearTimer(clock, timerId, \"IdleCallback\");\n        };\n\n        clock.setTimeout = function setTimeout(func, timeout) {\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout,\n            });\n        };\n        if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n            clock.setTimeout[\n                utilPromisify.custom\n            ] = function promisifiedSetTimeout(timeout, arg) {\n                return new _global.Promise(function setTimeoutExecutor(\n                    resolve\n                ) {\n                    addTimer(clock, {\n                        func: resolve,\n                        args: [arg],\n                        delay: timeout,\n                    });\n                });\n            };\n        }\n\n        clock.clearTimeout = function clearTimeout(timerId) {\n            return clearTimer(clock, timerId, \"Timeout\");\n        };\n\n        clock.nextTick = function nextTick(func) {\n            return enqueueJob(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 1),\n                error: isNearInfiniteLimit ? new Error() : null,\n            });\n        };\n\n        clock.queueMicrotask = function queueMicrotask(func) {\n            return clock.nextTick(func); // explicitly drop additional arguments\n        };\n\n        clock.setInterval = function setInterval(func, timeout) {\n            // eslint-disable-next-line no-param-reassign\n            timeout = parseInt(timeout, 10);\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout,\n                interval: timeout,\n            });\n        };\n\n        clock.clearInterval = function clearInterval(timerId) {\n            return clearTimer(clock, timerId, \"Interval\");\n        };\n\n        if (setImmediatePresent) {\n            clock.setImmediate = function setImmediate(func) {\n                return addTimer(clock, {\n                    func: func,\n                    args: Array.prototype.slice.call(arguments, 1),\n                    immediate: true,\n                });\n            };\n\n            if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n                clock.setImmediate[\n                    utilPromisify.custom\n                ] = function promisifiedSetImmediate(arg) {\n                    return new _global.Promise(function setImmediateExecutor(\n                        resolve\n                    ) {\n                        addTimer(clock, {\n                            func: resolve,\n                            args: [arg],\n                            immediate: true,\n                        });\n                    });\n                };\n            }\n\n            clock.clearImmediate = function clearImmediate(timerId) {\n                return clearTimer(clock, timerId, \"Immediate\");\n            };\n        }\n\n        clock.countTimers = function countTimers() {\n            return (\n                Object.keys(clock.timers || {}).length +\n                (clock.jobs || []).length\n            );\n        };\n\n        clock.requestAnimationFrame = function requestAnimationFrame(func) {\n            const result = addTimer(clock, {\n                func: func,\n                delay: getTimeToNextFrame(),\n                args: [clock.now + getTimeToNextFrame()],\n                animation: true,\n            });\n\n            return Number(result);\n        };\n\n        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n            return clearTimer(clock, timerId, \"AnimationFrame\");\n        };\n\n        clock.runMicrotasks = function runMicrotasks() {\n            runJobs(clock);\n        };\n\n        /**\n         * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n         * @param {boolean} isAsync\n         * @param {Function} resolve\n         * @param {Function} reject\n         * @returns {number|undefined} will return the new `now` value or nothing for async\n         */\n        function doTick(tickValue, isAsync, resolve, reject) {\n            const msFloat =\n                typeof tickValue === \"number\"\n                    ? tickValue\n                    : parseTime(tickValue);\n            const ms = Math.floor(msFloat);\n            const remainder = nanoRemainder(msFloat);\n            let nanosTotal = nanos + remainder;\n            let tickTo = clock.now + ms;\n\n            if (msFloat < 0) {\n                throw new TypeError(\"Negative ticks are not supported\");\n            }\n\n            // adjust for positive overflow\n            if (nanosTotal >= 1e6) {\n                tickTo += 1;\n                nanosTotal -= 1e6;\n            }\n\n            nanos = nanosTotal;\n            let tickFrom = clock.now;\n            let previous = clock.now;\n            // ESLint fails to detect this correctly\n            /* eslint-disable prefer-const */\n            let timer,\n                firstException,\n                oldNow,\n                nextPromiseTick,\n                compensationCheck,\n                postTimerCall;\n            /* eslint-enable prefer-const */\n\n            clock.duringTick = true;\n\n            // perform microtasks\n            oldNow = clock.now;\n            runJobs(clock);\n            if (oldNow !== clock.now) {\n                // compensate for any setSystemTime() call during microtask callback\n                tickFrom += clock.now - oldNow;\n                tickTo += clock.now - oldNow;\n            }\n\n            //eslint-disable-next-line jsdoc/require-jsdoc\n            function doTickInner() {\n                // perform each timer in the requested range\n                timer = firstTimerInRange(clock, tickFrom, tickTo);\n                // eslint-disable-next-line no-unmodified-loop-condition\n                while (timer && tickFrom <= tickTo) {\n                    if (clock.timers[timer.id]) {\n                        tickFrom = timer.callAt;\n                        clock.now = timer.callAt;\n                        oldNow = clock.now;\n                        try {\n                            runJobs(clock);\n                            callTimer(clock, timer);\n                        } catch (e) {\n                            firstException = firstException || e;\n                        }\n\n                        if (isAsync) {\n                            // finish up after native setImmediate callback to allow\n                            // all native es6 promises to process their callbacks after\n                            // each timer fires.\n                            originalSetTimeout(nextPromiseTick);\n                            return;\n                        }\n\n                        compensationCheck();\n                    }\n\n                    postTimerCall();\n                }\n\n                // perform process.nextTick()s again\n                oldNow = clock.now;\n                runJobs(clock);\n                if (oldNow !== clock.now) {\n                    // compensate for any setSystemTime() call during process.nextTick() callback\n                    tickFrom += clock.now - oldNow;\n                    tickTo += clock.now - oldNow;\n                }\n                clock.duringTick = false;\n\n                // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n                timer = firstTimerInRange(clock, tickFrom, tickTo);\n                if (timer) {\n                    try {\n                        clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n                    } catch (e) {\n                        firstException = firstException || e;\n                    }\n                } else {\n                    // no timers remaining in the requested range: move the clock all the way to the end\n                    clock.now = tickTo;\n\n                    // update nanos\n                    nanos = nanosTotal;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n\n                if (isAsync) {\n                    resolve(clock.now);\n                } else {\n                    return clock.now;\n                }\n            }\n\n            nextPromiseTick =\n                isAsync &&\n                function () {\n                    try {\n                        compensationCheck();\n                        postTimerCall();\n                        doTickInner();\n                    } catch (e) {\n                        reject(e);\n                    }\n                };\n\n            compensationCheck = function () {\n                // compensate for any setSystemTime() call during timer callback\n                if (oldNow !== clock.now) {\n                    tickFrom += clock.now - oldNow;\n                    tickTo += clock.now - oldNow;\n                    previous += clock.now - oldNow;\n                }\n            };\n\n            postTimerCall = function () {\n                timer = firstTimerInRange(clock, previous, tickTo);\n                previous = tickFrom;\n            };\n\n            return doTickInner();\n        }\n\n        /**\n         * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n         * @returns {number} will return the new `now` value\n         */\n        clock.tick = function tick(tickValue) {\n            return doTick(tickValue, false);\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            /**\n             * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n             * @returns {Promise}\n             */\n            clock.tickAsync = function tickAsync(tickValue) {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            doTick(tickValue, true, resolve, reject);\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.next = function next() {\n            runJobs(clock);\n            const timer = firstTimer(clock);\n            if (!timer) {\n                return clock.now;\n            }\n\n            clock.duringTick = true;\n            try {\n                clock.now = timer.callAt;\n                callTimer(clock, timer);\n                runJobs(clock);\n                return clock.now;\n            } finally {\n                clock.duringTick = false;\n            }\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.nextAsync = function nextAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            const timer = firstTimer(clock);\n                            if (!timer) {\n                                resolve(clock.now);\n                                return;\n                            }\n\n                            let err;\n                            clock.duringTick = true;\n                            clock.now = timer.callAt;\n                            try {\n                                callTimer(clock, timer);\n                            } catch (e) {\n                                err = e;\n                            }\n                            clock.duringTick = false;\n\n                            originalSetTimeout(function () {\n                                if (err) {\n                                    reject(err);\n                                } else {\n                                    resolve(clock.now);\n                                }\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.runAll = function runAll() {\n            let numTimers, i;\n            runJobs(clock);\n            for (i = 0; i < clock.loopLimit; i++) {\n                if (!clock.timers) {\n                    resetIsNearInfiniteLimit();\n                    return clock.now;\n                }\n\n                numTimers = Object.keys(clock.timers).length;\n                if (numTimers === 0) {\n                    resetIsNearInfiniteLimit();\n                    return clock.now;\n                }\n\n                clock.next();\n                checkIsNearInfiniteLimit(clock, i);\n            }\n\n            const excessJob = firstTimer(clock);\n            throw getInfiniteLoopError(clock, excessJob);\n        };\n\n        clock.runToFrame = function runToFrame() {\n            return clock.tick(getTimeToNextFrame());\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.runAllAsync = function runAllAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    let i = 0;\n                    /**\n                     *\n                     */\n                    function doRun() {\n                        originalSetTimeout(function () {\n                            try {\n                                let numTimers;\n                                if (i < clock.loopLimit) {\n                                    if (!clock.timers) {\n                                        resetIsNearInfiniteLimit();\n                                        resolve(clock.now);\n                                        return;\n                                    }\n\n                                    numTimers = Object.keys(clock.timers)\n                                        .length;\n                                    if (numTimers === 0) {\n                                        resetIsNearInfiniteLimit();\n                                        resolve(clock.now);\n                                        return;\n                                    }\n\n                                    clock.next();\n\n                                    i++;\n\n                                    doRun();\n                                    checkIsNearInfiniteLimit(clock, i);\n                                    return;\n                                }\n\n                                const excessJob = firstTimer(clock);\n                                reject(getInfiniteLoopError(clock, excessJob));\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                    }\n                    doRun();\n                });\n            };\n        }\n\n        clock.runToLast = function runToLast() {\n            const timer = lastTimer(clock);\n            if (!timer) {\n                runJobs(clock);\n                return clock.now;\n            }\n\n            return clock.tick(timer.callAt - clock.now);\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.runToLastAsync = function runToLastAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            const timer = lastTimer(clock);\n                            if (!timer) {\n                                resolve(clock.now);\n                            }\n\n                            resolve(clock.tickAsync(timer.callAt));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.reset = function reset() {\n            nanos = 0;\n            clock.timers = {};\n            clock.jobs = [];\n            clock.now = start;\n        };\n\n        clock.setSystemTime = function setSystemTime(systemTime) {\n            // determine time difference\n            const newNow = getEpoch(systemTime);\n            const difference = newNow - clock.now;\n            let id, timer;\n\n            adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n            adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;\n            // update 'system clock'\n            clock.now = newNow;\n            nanos = 0;\n\n            // update timers and intervals to keep them stable\n            for (id in clock.timers) {\n                if (clock.timers.hasOwnProperty(id)) {\n                    timer = clock.timers[id];\n                    timer.createdAt += difference;\n                    timer.callAt += difference;\n                }\n            }\n        };\n\n        if (performancePresent) {\n            clock.performance = Object.create(null);\n\n            if (hasPerformancePrototype) {\n                const proto = _global.Performance.prototype;\n\n                Object.getOwnPropertyNames(proto).forEach(function (name) {\n                    if (name.indexOf(\"getEntries\") === 0) {\n                        // match expected return type for getEntries functions\n                        clock.performance[name] = NOOP_ARRAY;\n                    } else {\n                        clock.performance[name] = NOOP;\n                    }\n                });\n            }\n\n            clock.performance.now = function FakeTimersNow() {\n                const hrt = hrtime();\n                const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n                return millis;\n            };\n        }\n\n        if (hrtimePresent) {\n            clock.hrtime = hrtime;\n        }\n\n        return clock;\n    }\n\n    /* eslint-disable complexity */\n\n    /**\n     * @param {Config=} [config] Optional config\n     * @returns {Clock}\n     */\n    function install(config) {\n        if (\n            arguments.length > 1 ||\n            config instanceof Date ||\n            Array.isArray(config) ||\n            typeof config === \"number\"\n        ) {\n            throw new TypeError(\n                `FakeTimers.install called with ${String(\n                    config\n                )} install requires an object parameter`\n            );\n        }\n\n        // eslint-disable-next-line no-param-reassign\n        config = typeof config !== \"undefined\" ? config : {};\n        config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n        config.advanceTimeDelta = config.advanceTimeDelta || 20;\n        config.shouldClearNativeTimers =\n            config.shouldClearNativeTimers || false;\n\n        if (config.target) {\n            throw new TypeError(\n                \"config.target is no longer supported. Use `withGlobal(target)` instead.\"\n            );\n        }\n\n        let i, l;\n        const clock = createClock(config.now, config.loopLimit);\n        clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n\n        clock.uninstall = function () {\n            return uninstall(clock, config);\n        };\n\n        clock.methods = config.toFake || [];\n\n        if (clock.methods.length === 0) {\n            // do not fake nextTick by default - GitHub#126\n            clock.methods = Object.keys(timers).filter(function (key) {\n                return key !== \"nextTick\" && key !== \"queueMicrotask\";\n            });\n        }\n\n        if (config.shouldAdvanceTime === true) {\n            const intervalTick = doIntervalTick.bind(\n                null,\n                clock,\n                config.advanceTimeDelta\n            );\n            const intervalId = _global.setInterval(\n                intervalTick,\n                config.advanceTimeDelta\n            );\n            clock.attachedInterval = intervalId;\n        }\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            const nameOfMethodToReplace = clock.methods[i];\n            if (nameOfMethodToReplace === \"hrtime\") {\n                if (\n                    _global.process &&\n                    typeof _global.process.hrtime === \"function\"\n                ) {\n                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                }\n            } else if (nameOfMethodToReplace === \"nextTick\") {\n                if (\n                    _global.process &&\n                    typeof _global.process.nextTick === \"function\"\n                ) {\n                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                }\n            } else {\n                hijackMethod(_global, nameOfMethodToReplace, clock);\n            }\n        }\n\n        return clock;\n    }\n\n    /* eslint-enable complexity */\n\n    return {\n        timers: timers,\n        createClock: createClock,\n        install: install,\n        withGlobal: withGlobal,\n    };\n}\n\n/**\n * @typedef {object} FakeTimers\n * @property {Timers} timers\n * @property {createClock} createClock\n * @property {Function} install\n * @property {withGlobal} withGlobal\n */\n\n/* eslint-enable complexity */\n\n/** @type {FakeTimers} */\nconst defaultImplementation = withGlobal(globalObject);\n\nexports.timers = defaultImplementation.timers;\nexports.createClock = defaultImplementation.createClock;\nexports.install = defaultImplementation.install;\nexports.withGlobal = withGlobal;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,kBAAkB,CAAC,CAACC,MAAM;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACC,OAAO,EAAE;EACzB,MAAMC,SAAS,GAAGD,OAAO,CAACE,SAAS,IAAIF,OAAO,CAACE,SAAS,CAACD,SAAS;EAClE,MAAME,aAAa,GAAGF,SAAS,IAAIA,SAAS,CAACG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;EAClE,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;EACxC,MAAMC,cAAc,GAAG,IAAI,CAAC,CAAC;EAC7B,MAAMC,IAAI,GAAG,SAAAA,CAAA,EAAY;IACrB,OAAOC,SAAS;EACpB,CAAC;EACD,MAAMC,UAAU,GAAG,SAAAA,CAAA,EAAY;IAC3B,OAAO,EAAE;EACb,CAAC;EACD,MAAMC,aAAa,GAAGZ,OAAO,CAACa,UAAU,CAACJ,IAAI,EAAE,CAAC,CAAC;EACjD,MAAMK,qBAAqB,GAAG,OAAOF,a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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}