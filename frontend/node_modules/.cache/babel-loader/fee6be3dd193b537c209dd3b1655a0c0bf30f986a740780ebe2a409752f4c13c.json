{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForElementToBeRemoved = waitForElementToBeRemoved;\nvar _waitFor = require(\"./wait-for\");\nconst isRemoved = result => !result || Array.isArray(result) && !result.length;\n\n// Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n      while (parent.parentElement) parent = parent.parentElement;\n      return () => parent.contains(element) ? element : null;\n    });\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n  initialCheck(callback());\n  return (0, _waitFor.waitFor)(() => {\n    let result;\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n      throw error;\n    }\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n    return undefined;\n  }, options);\n}\n\n/*\neslint\n  require-await: \"off\"\n*/","map":{"version":3,"names":["Object","defineProperty","exports","value","waitForElementToBeRemoved","_waitFor","require","isRemoved","result","Array","isArray","length","initialCheck","elements","Error","callback","options","timeoutError","getRemainingElements","map","element","parent","parentElement","contains","c","filter","Boolean","waitFor","error","name","undefined"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@testing-library/react/node_modules/@testing-library/dom/dist/wait-for-element-to-be-removed.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForElementToBeRemoved = waitForElementToBeRemoved;\nvar _waitFor = require(\"./wait-for\");\nconst isRemoved = result => !result || Array.isArray(result) && !result.length;\n\n// Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n      while (parent.parentElement) parent = parent.parentElement;\n      return () => parent.contains(element) ? element : null;\n    });\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n  initialCheck(callback());\n  return (0, _waitFor.waitFor)(() => {\n    let result;\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n      throw error;\n    }\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n    return undefined;\n  }, options);\n}\n\n/*\neslint\n  require-await: \"off\"\n*/"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,yBAAyB,GAAGA,yBAAyB;AAC7D,IAAIC,QAAQ,GAAGC,OAAO,CAAC,YAAY,CAAC;AACpC,MAAMC,SAAS,GAAGC,MAAM,IAAI,CAACA,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAI,CAACA,MAAM,CAACG,MAAM;;AAE9E;AACA;AACA,SAASC,YAAYA,CAACC,QAAQ,EAAE;EAC9B,IAAIN,SAAS,CAACM,QAAQ,CAAC,EAAE;IACvB,MAAM,IAAIC,KAAK,CAAC,oKAAoK,CAAC;EACvL;AACF;AACA,eAAeV,yBAAyBA,CAACW,QAAQ,EAAEC,OAAO,EAAE;EAC1D;EACA,MAAMC,YAAY,GAAG,IAAIH,KAAK,CAAC,yCAAyC,CAAC;EACzE,IAAI,OAAOC,QAAQ,KAAK,UAAU,EAAE;IAClCH,YAAY,CAACG,QAAQ,CAAC;IACtB,MAAMF,QAAQ,GAAGJ,KAAK,CAACC,OAAO,CAACK,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC;IAChE,MAAMG,oBAAoB,GAAGL,QAAQ,CAACM,GAAG,CAACC,OAAO,IAAI;MACnD,IAAIC,MAAM,GAAGD,OAAO,CAACE,aAAa;MAClC,IAAID,MAAM,KAAK,IAAI,EAAE,OAAO,MAAM,IAAI;MACtC,OAAOA,MAAM,CAACC,aAAa,EAAED,MAAM,GAAGA,MAAM,CAACC,aAAa;MAC1D,OAAO,MAAMD,MAAM,CAACE,QAAQ,CAACH,OAAO,CAAC,GAAGA,OAAO,GAAG,IAAI;IACxD,CAAC,CAAC;IACFL,QAAQ,GAAGA,CAAA,KAAMG,oBAAoB,CAACC,GAAG,CAACK,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC;EACrE;EACAd,YAAY,CAACG,QAAQ,CAAC,CAAC,CAAC;EACxB,OAAO,CAAC,CAAC,EAAEV,QAAQ,CAACsB,OAAO,EAAE,MAAM;IACjC,IAAInB,MAAM;IACV,IAAI;MACFA,MAAM,GAAGO,QAAQ,CAAC,CAAC;IACrB,CAAC,CAAC,OAAOa,KAAK,EAAE;MACd,IAAIA,KAAK,CAACC,IAAI,KAAK,4BAA4B,EAAE;QAC/C,OAAOC,SAAS;MAClB;MACA,MAAMF,KAAK;IACb;IACA,IAAI,CAACrB,SAAS,CAACC,MAAM,CAAC,EAAE;MACtB,MAAMS,YAAY;IACpB;IACA,OAAOa,SAAS;EAClB,CAAC,EAAEd,OAAO,CAAC;AACb;;AAEA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}