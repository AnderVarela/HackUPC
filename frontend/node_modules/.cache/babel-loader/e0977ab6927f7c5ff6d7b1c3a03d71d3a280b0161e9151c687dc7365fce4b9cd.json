{"ast":null,"code":"var canReorderSingle = require('./reorderable').canReorderSingle;\nvar extractProperties = require('./extract-properties');\nvar isMergeable = require('./is-mergeable');\nvar tidyRuleDuplicates = require('./tidy-rule-duplicates');\nvar Token = require('../../tokenizer/token');\nvar cloneArray = require('../../utils/clone-array');\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\nfunction naturalSorter(a, b) {\n  return a > b ? 1 : -1;\n}\nfunction cloneAndMergeSelectors(propertyA, propertyB) {\n  var cloned = cloneArray(propertyA);\n  cloned[5] = cloned[5].concat(propertyB[5]);\n  return cloned;\n}\nfunction restructure(tokens, context) {\n  var options = context.options;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var mergeLimit = options.compatibility.selectors.mergeLimit;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var specificityCache = context.cache.specificity;\n  var movableTokens = {};\n  var movedProperties = [];\n  var multiPropertyMoveCache = {};\n  var movedToBeDropped = [];\n  var maxCombinationsLevel = 2;\n  var ID_JOIN_CHARACTER = '%';\n  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {\n    for (var i = allFits.length - 1; i >= 0; i--) {\n      var fit = allFits[i][0];\n      var id = addToCache(movedProperty, fit);\n      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {\n        removeAllMatchingFromCache(id);\n        break;\n      }\n    }\n  }\n  function addToCache(movedProperty, fit) {\n    var id = cacheId(fit);\n    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];\n    multiPropertyMoveCache[id].push([movedProperty, fit]);\n    return id;\n  }\n  function removeAllMatchingFromCache(matchId) {\n    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);\n    var forRemoval = [];\n    var i;\n    for (var id in multiPropertyMoveCache) {\n      var selectors = id.split(ID_JOIN_CHARACTER);\n      for (i = selectors.length - 1; i >= 0; i--) {\n        if (matchSelectors.indexOf(selectors[i]) > -1) {\n          forRemoval.push(id);\n          break;\n        }\n      }\n    }\n    for (i = forRemoval.length - 1; i >= 0; i--) {\n      delete multiPropertyMoveCache[forRemoval[i]];\n    }\n  }\n  function cacheId(cachedTokens) {\n    var id = [];\n    for (var i = 0, l = cachedTokens.length; i < l; i++) {\n      id.push(serializeRules(cachedTokens[i][1]));\n    }\n    return id.join(ID_JOIN_CHARACTER);\n  }\n  function tokensToMerge(sourceTokens) {\n    var uniqueTokensWithBody = [];\n    var mergeableTokens = [];\n    for (var i = sourceTokens.length - 1; i >= 0; i--) {\n      if (!isMergeable(serializeRules(sourceTokens[i][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {\n        continue;\n      }\n      mergeableTokens.unshift(sourceTokens[i]);\n      if (sourceTokens[i][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1) {\n        uniqueTokensWithBody.push(sourceTokens[i]);\n      }\n    }\n    return uniqueTokensWithBody.length > 1 ? mergeableTokens : [];\n  }\n  function shortenIfPossible(position, movedProperty) {\n    var name = movedProperty[0];\n    var value = movedProperty[1];\n    var key = movedProperty[4];\n    var valueSize = name.length + value.length + 1;\n    var allSelectors = [];\n    var qualifiedTokens = [];\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) {\n      return;\n    }\n    var allFits = findAllFits(mergeableTokens, valueSize, 1);\n    var bestFit = allFits[0];\n    if (bestFit[1] > 0) {\n      return sendToMultiPropertyMoveCache(position, movedProperty, allFits);\n    }\n    for (var i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);\n  }\n  function fitSorter(fit1, fit2) {\n    return fit1[1] > fit2[1] ? 1 : fit1[1] == fit2[1] ? 0 : -1;\n  }\n  function findAllFits(mergeableTokens, propertySize, propertiesCount) {\n    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);\n    return combinations.sort(fitSorter);\n  }\n  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {\n    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];\n    if (tokensVariant.length > 2 && level > 0) {\n      for (var i = tokensVariant.length - 1; i >= 0; i--) {\n        var subVariant = Array.prototype.slice.call(tokensVariant, 0);\n        subVariant.splice(i, 1);\n        differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));\n      }\n    }\n    return differenceVariants;\n  }\n  function sizeDifference(tokensVariant, propertySize, propertiesCount) {\n    var allSelectorsSize = 0;\n    for (var i = tokensVariant.length - 1; i >= 0; i--) {\n      allSelectorsSize += tokensVariant[i][2].length > propertiesCount ? serializeRules(tokensVariant[i][1]).length : -1;\n    }\n    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;\n  }\n  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {\n    var i, j, k, m;\n    var allProperties = [];\n    for (i = mergeableTokens.length - 1; i >= 0; i--) {\n      var mergeableToken = mergeableTokens[i];\n      for (j = mergeableToken[2].length - 1; j >= 0; j--) {\n        var mergeableProperty = mergeableToken[2][j];\n        for (k = 0, m = properties.length; k < m; k++) {\n          var property = properties[k];\n          var mergeablePropertyName = mergeableProperty[1][1];\n          var propertyName = property[0];\n          var propertyBody = property[4];\n          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {\n            mergeableToken[2].splice(j, 1);\n            break;\n          }\n        }\n      }\n    }\n    for (i = properties.length - 1; i >= 0; i--) {\n      allProperties.unshift(properties[i][3]);\n    }\n    var newToken = [Token.RULE, allSelectors, allProperties];\n    tokens.splice(position, 0, newToken);\n  }\n  function dropPropertiesAt(position, movedProperty) {\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n    if (toMove && toMove.length > 1) {\n      if (!shortenMultiMovesIfPossible(position, movedProperty)) {\n        shortenIfPossible(position, movedProperty);\n      }\n    }\n  }\n  function shortenMultiMovesIfPossible(position, movedProperty) {\n    var candidates = [];\n    var propertiesAndMergableTokens = [];\n    var key = movedProperty[4];\n    var j, k;\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) {\n      return;\n    }\n    movableLoop: for (var value in movableTokens) {\n      var tokensList = movableTokens[value];\n      for (j = mergeableTokens.length - 1; j >= 0; j--) {\n        if (tokensList.indexOf(mergeableTokens[j]) == -1) {\n          continue movableLoop;\n        }\n      }\n      candidates.push(value);\n    }\n    if (candidates.length < 2) {\n      return false;\n    }\n    for (j = candidates.length - 1; j >= 0; j--) {\n      for (k = movedProperties.length - 1; k >= 0; k--) {\n        if (movedProperties[k][4] == candidates[j]) {\n          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);\n          break;\n        }\n      }\n    }\n    return processMultiPropertyMove(position, propertiesAndMergableTokens);\n  }\n  function processMultiPropertyMove(position, propertiesAndMergableTokens) {\n    var valueSize = 0;\n    var properties = [];\n    var property;\n    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {\n      property = propertiesAndMergableTokens[i][0];\n      var fullValue = property[4];\n      valueSize += fullValue.length + (i > 0 ? 1 : 0);\n      properties.push(property);\n    }\n    var mergeableTokens = propertiesAndMergableTokens[0][1];\n    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];\n    if (bestFit[1] > 0) {\n      return false;\n    }\n    var allSelectors = [];\n    var qualifiedTokens = [];\n    for (i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);\n    for (i = properties.length - 1; i >= 0; i--) {\n      property = properties[i];\n      var index = movedProperties.indexOf(property);\n      delete movableTokens[property[4]];\n      if (index > -1 && movedToBeDropped.indexOf(index) == -1) {\n        movedToBeDropped.push(index);\n      }\n    }\n    return true;\n  }\n  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {\n    var propertyName = property[0];\n    var movedPropertyName = movedProperty[0];\n    if (propertyName != movedPropertyName) {\n      return false;\n    }\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n    return toMove && toMove.indexOf(token) > -1;\n  }\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var isRule;\n    var j, k, m;\n    var samePropertyAt;\n    if (token[0] == Token.RULE) {\n      isRule = true;\n    } else if (token[0] == Token.NESTED_BLOCK) {\n      isRule = false;\n    } else {\n      continue;\n    }\n\n    // We cache movedProperties.length as it may change in the loop\n    var movedCount = movedProperties.length;\n    var properties = extractProperties(token);\n    movedToBeDropped = [];\n    var unmovableInCurrentToken = [];\n    for (j = properties.length - 1; j >= 0; j--) {\n      for (k = j - 1; k >= 0; k--) {\n        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {\n          unmovableInCurrentToken.push(j);\n          break;\n        }\n      }\n    }\n    for (j = properties.length - 1; j >= 0; j--) {\n      var property = properties[j];\n      var movedSameProperty = false;\n      for (k = 0; k < movedCount; k++) {\n        var movedProperty = movedProperties[k];\n        if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {\n          dropPropertiesAt(i + 1, movedProperty);\n          if (movedToBeDropped.indexOf(k) == -1) {\n            movedToBeDropped.push(k);\n            delete movableTokens[movedProperty[4]];\n          }\n        }\n        if (!movedSameProperty) {\n          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];\n          if (movedSameProperty) {\n            samePropertyAt = k;\n          }\n        }\n      }\n      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1) {\n        continue;\n      }\n      var key = property[4];\n      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {\n        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);\n        movedProperties.splice(samePropertyAt, 1);\n        movableTokens[key] = [token];\n        movedSameProperty = false;\n      } else {\n        movableTokens[key] = movableTokens[key] || [];\n        movableTokens[key].push(token);\n      }\n      if (movedSameProperty) {\n        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);\n      } else {\n        movedProperties.push(property);\n      }\n    }\n    movedToBeDropped = movedToBeDropped.sort(naturalSorter);\n    for (j = 0, m = movedToBeDropped.length; j < m; j++) {\n      var dropAt = movedToBeDropped[j] - j;\n      movedProperties.splice(dropAt, 1);\n    }\n  }\n  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;\n  for (; position < tokens.length - 1; position++) {\n    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;\n    var isComment = tokens[position][0] === Token.COMMENT;\n    if (!(isImportRule || isComment)) {\n      break;\n    }\n  }\n  for (i = 0; i < movedProperties.length; i++) {\n    dropPropertiesAt(position, movedProperties[i]);\n  }\n}\nmodule.exports = restructure;","map":{"version":3,"names":["canReorderSingle","require","extractProperties","isMergeable","tidyRuleDuplicates","Token","cloneArray","serializeBody","body","serializeRules","rules","naturalSorter","a","b","cloneAndMergeSelectors","propertyA","propertyB","cloned","concat","restructure","tokens","context","options","mergeablePseudoClasses","compatibility","selectors","mergeablePseudoElements","mergeLimit","multiplePseudoMerging","specificityCache","cache","specificity","movableTokens","movedProperties","multiPropertyMoveCache","movedToBeDropped","maxCombinationsLevel","ID_JOIN_CHARACTER","sendToMultiPropertyMoveCache","position","movedProperty","allFits","i","length","fit","id","addToCache","processMultiPropertyMove","removeAllMatchingFromCache","cacheId","push","matchId","matchSelectors","split","forRemoval","indexOf","cachedTokens","l","join","tokensToMerge","sourceTokens","uniqueTokensWithBody","mergeableTokens","unshift","shortenIfPossible","name","value","key","valueSize","allSelectors","qualifiedTokens","findAllFits","bestFit","dropAsNewTokenAt","fitSorter","fit1","fit2","propertySize","propertiesCount","combinations","allCombinations","sort","tokensVariant","level","differenceVariants","sizeDifference","subVariant","Array","prototype","slice","call","splice","allSelectorsSize","properties","j","k","m","allProperties","mergeableToken","mergeableProperty","property","mergeablePropertyName","propertyName","propertyBody","newToken","RULE","dropPropertiesAt","toMove","shortenMultiMovesIfPossible","candidates","propertiesAndMergableTokens","movableLoop","tokensList","fullValue","index","boundToAnotherPropertyInCurrrentToken","token","movedPropertyName","isRule","samePropertyAt","NESTED_BLOCK","movedCount","unmovableInCurrentToken","movedSameProperty","dropAt","AT_RULE","isImportRule","isComment","COMMENT","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/clean-css/lib/optimizer/level-2/restructure.js"],"sourcesContent":["var canReorderSingle = require('./reorderable').canReorderSingle;\nvar extractProperties = require('./extract-properties');\nvar isMergeable = require('./is-mergeable');\nvar tidyRuleDuplicates = require('./tidy-rule-duplicates');\n\nvar Token = require('../../tokenizer/token');\n\nvar cloneArray = require('../../utils/clone-array');\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction naturalSorter(a, b) {\n  return a > b ? 1 : -1;\n}\n\nfunction cloneAndMergeSelectors(propertyA, propertyB) {\n  var cloned = cloneArray(propertyA);\n  cloned[5] = cloned[5].concat(propertyB[5]);\n\n  return cloned;\n}\n\nfunction restructure(tokens, context) {\n  var options = context.options;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var mergeLimit = options.compatibility.selectors.mergeLimit;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var specificityCache = context.cache.specificity;\n  var movableTokens = {};\n  var movedProperties = [];\n  var multiPropertyMoveCache = {};\n  var movedToBeDropped = [];\n  var maxCombinationsLevel = 2;\n  var ID_JOIN_CHARACTER = '%';\n\n  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {\n    for (var i = allFits.length - 1; i >= 0; i--) {\n      var fit = allFits[i][0];\n      var id = addToCache(movedProperty, fit);\n\n      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {\n        removeAllMatchingFromCache(id);\n        break;\n      }\n    }\n  }\n\n  function addToCache(movedProperty, fit) {\n    var id = cacheId(fit);\n    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];\n    multiPropertyMoveCache[id].push([movedProperty, fit]);\n    return id;\n  }\n\n  function removeAllMatchingFromCache(matchId) {\n    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);\n    var forRemoval = [];\n    var i;\n\n    for (var id in multiPropertyMoveCache) {\n      var selectors = id.split(ID_JOIN_CHARACTER);\n      for (i = selectors.length - 1; i >= 0; i--) {\n        if (matchSelectors.indexOf(selectors[i]) > -1) {\n          forRemoval.push(id);\n          break;\n        }\n      }\n    }\n\n    for (i = forRemoval.length - 1; i >= 0; i--) {\n      delete multiPropertyMoveCache[forRemoval[i]];\n    }\n  }\n\n  function cacheId(cachedTokens) {\n    var id = [];\n    for (var i = 0, l = cachedTokens.length; i < l; i++) {\n      id.push(serializeRules(cachedTokens[i][1]));\n    }\n    return id.join(ID_JOIN_CHARACTER);\n  }\n\n  function tokensToMerge(sourceTokens) {\n    var uniqueTokensWithBody = [];\n    var mergeableTokens = [];\n\n    for (var i = sourceTokens.length - 1; i >= 0; i--) {\n      if (!isMergeable(\n        serializeRules(sourceTokens[i][1]),\n        mergeablePseudoClasses,\n        mergeablePseudoElements,\n        multiplePseudoMerging\n      )) {\n        continue;\n      }\n\n      mergeableTokens.unshift(sourceTokens[i]);\n      if (sourceTokens[i][2].length > 0\n        && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1) {\n        uniqueTokensWithBody.push(sourceTokens[i]);\n      }\n    }\n\n    return uniqueTokensWithBody.length > 1\n      ? mergeableTokens\n      : [];\n  }\n\n  function shortenIfPossible(position, movedProperty) {\n    var name = movedProperty[0];\n    var value = movedProperty[1];\n    var key = movedProperty[4];\n    var valueSize = name.length + value.length + 1;\n    var allSelectors = [];\n    var qualifiedTokens = [];\n\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) { return; }\n\n    var allFits = findAllFits(mergeableTokens, valueSize, 1);\n    var bestFit = allFits[0];\n    if (bestFit[1] > 0) { return sendToMultiPropertyMoveCache(position, movedProperty, allFits); }\n\n    for (var i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);\n  }\n\n  function fitSorter(fit1, fit2) {\n    return fit1[1] > fit2[1] ? 1 : (fit1[1] == fit2[1] ? 0 : -1);\n  }\n\n  function findAllFits(mergeableTokens, propertySize, propertiesCount) {\n    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);\n    return combinations.sort(fitSorter);\n  }\n\n  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {\n    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];\n    if (tokensVariant.length > 2 && level > 0) {\n      for (var i = tokensVariant.length - 1; i >= 0; i--) {\n        var subVariant = Array.prototype.slice.call(tokensVariant, 0);\n        subVariant.splice(i, 1);\n        differenceVariants = differenceVariants.concat(\n          allCombinations(subVariant, propertySize, propertiesCount, level - 1)\n        );\n      }\n    }\n\n    return differenceVariants;\n  }\n\n  function sizeDifference(tokensVariant, propertySize, propertiesCount) {\n    var allSelectorsSize = 0;\n    for (var i = tokensVariant.length - 1; i >= 0; i--) {\n      allSelectorsSize += tokensVariant[i][2].length > propertiesCount\n        ? serializeRules(tokensVariant[i][1]).length\n        : -1;\n    }\n    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;\n  }\n\n  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {\n    var i, j, k, m;\n    var allProperties = [];\n\n    for (i = mergeableTokens.length - 1; i >= 0; i--) {\n      var mergeableToken = mergeableTokens[i];\n\n      for (j = mergeableToken[2].length - 1; j >= 0; j--) {\n        var mergeableProperty = mergeableToken[2][j];\n\n        for (k = 0, m = properties.length; k < m; k++) {\n          var property = properties[k];\n\n          var mergeablePropertyName = mergeableProperty[1][1];\n          var propertyName = property[0];\n          var propertyBody = property[4];\n          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {\n            mergeableToken[2].splice(j, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      allProperties.unshift(properties[i][3]);\n    }\n\n    var newToken = [Token.RULE, allSelectors, allProperties];\n    tokens.splice(position, 0, newToken);\n  }\n\n  function dropPropertiesAt(position, movedProperty) {\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n\n    if (toMove && toMove.length > 1) {\n      if (!shortenMultiMovesIfPossible(position, movedProperty)) { shortenIfPossible(position, movedProperty); }\n    }\n  }\n\n  function shortenMultiMovesIfPossible(position, movedProperty) {\n    var candidates = [];\n    var propertiesAndMergableTokens = [];\n    var key = movedProperty[4];\n    var j, k;\n\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) { return; }\n\n    movableLoop:\n    for (var value in movableTokens) {\n      var tokensList = movableTokens[value];\n\n      for (j = mergeableTokens.length - 1; j >= 0; j--) {\n        if (tokensList.indexOf(mergeableTokens[j]) == -1) { continue movableLoop; }\n      }\n\n      candidates.push(value);\n    }\n\n    if (candidates.length < 2) { return false; }\n\n    for (j = candidates.length - 1; j >= 0; j--) {\n      for (k = movedProperties.length - 1; k >= 0; k--) {\n        if (movedProperties[k][4] == candidates[j]) {\n          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);\n          break;\n        }\n      }\n    }\n\n    return processMultiPropertyMove(position, propertiesAndMergableTokens);\n  }\n\n  function processMultiPropertyMove(position, propertiesAndMergableTokens) {\n    var valueSize = 0;\n    var properties = [];\n    var property;\n\n    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {\n      property = propertiesAndMergableTokens[i][0];\n      var fullValue = property[4];\n      valueSize += fullValue.length + (i > 0 ? 1 : 0);\n\n      properties.push(property);\n    }\n\n    var mergeableTokens = propertiesAndMergableTokens[0][1];\n    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];\n    if (bestFit[1] > 0) { return false; }\n\n    var allSelectors = [];\n    var qualifiedTokens = [];\n    for (i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      property = properties[i];\n      var index = movedProperties.indexOf(property);\n\n      delete movableTokens[property[4]];\n\n      if (index > -1 && movedToBeDropped.indexOf(index) == -1) { movedToBeDropped.push(index); }\n    }\n\n    return true;\n  }\n\n  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {\n    var propertyName = property[0];\n    var movedPropertyName = movedProperty[0];\n    if (propertyName != movedPropertyName) { return false; }\n\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n    return toMove && toMove.indexOf(token) > -1;\n  }\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var isRule;\n    var j, k, m;\n    var samePropertyAt;\n\n    if (token[0] == Token.RULE) {\n      isRule = true;\n    } else if (token[0] == Token.NESTED_BLOCK) {\n      isRule = false;\n    } else {\n      continue;\n    }\n\n    // We cache movedProperties.length as it may change in the loop\n    var movedCount = movedProperties.length;\n\n    var properties = extractProperties(token);\n    movedToBeDropped = [];\n\n    var unmovableInCurrentToken = [];\n    for (j = properties.length - 1; j >= 0; j--) {\n      for (k = j - 1; k >= 0; k--) {\n        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {\n          unmovableInCurrentToken.push(j);\n          break;\n        }\n      }\n    }\n\n    for (j = properties.length - 1; j >= 0; j--) {\n      var property = properties[j];\n      var movedSameProperty = false;\n\n      for (k = 0; k < movedCount; k++) {\n        var movedProperty = movedProperties[k];\n\n        if (movedToBeDropped.indexOf(k) == -1 && (\n          !canReorderSingle(property, movedProperty, specificityCache)\n          && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token)\n          || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)\n        ) {\n          dropPropertiesAt(i + 1, movedProperty);\n\n          if (movedToBeDropped.indexOf(k) == -1) {\n            movedToBeDropped.push(k);\n            delete movableTokens[movedProperty[4]];\n          }\n        }\n\n        if (!movedSameProperty) {\n          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];\n\n          if (movedSameProperty) {\n            samePropertyAt = k;\n          }\n        }\n      }\n\n      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1) { continue; }\n\n      var key = property[4];\n\n      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {\n        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);\n        movedProperties.splice(samePropertyAt, 1);\n        movableTokens[key] = [token];\n        movedSameProperty = false;\n      } else {\n        movableTokens[key] = movableTokens[key] || [];\n        movableTokens[key].push(token);\n      }\n\n      if (movedSameProperty) {\n        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);\n      } else {\n        movedProperties.push(property);\n      }\n    }\n\n    movedToBeDropped = movedToBeDropped.sort(naturalSorter);\n    for (j = 0, m = movedToBeDropped.length; j < m; j++) {\n      var dropAt = movedToBeDropped[j] - j;\n      movedProperties.splice(dropAt, 1);\n    }\n  }\n\n  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;\n  for (; position < tokens.length - 1; position++) {\n    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;\n    var isComment = tokens[position][0] === Token.COMMENT;\n    if (!(isImportRule || isComment)) { break; }\n  }\n\n  for (i = 0; i < movedProperties.length; i++) {\n    dropPropertiesAt(position, movedProperties[i]);\n  }\n}\n\nmodule.exports = restructure;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}