{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendVerifyFunction = exports.patchClass = exports.requireFromPathToLinterJS = exports.write = exports.prune = exports.shouldBulkSuppress = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst Guards = __importStar(require(\"./ast-guards\"));\nconst _patch_base_1 = require(\"../_patch-base\");\nconst constants_1 = require(\"./constants\");\nconst bulk_suppressions_file_1 = require(\"./bulk-suppressions-file\");\nconst ESLINTRC_FILENAMES = ['.eslintrc.js', '.eslintrc.cjs'\n// Several other filenames are allowed, but this patch requires that it be loaded via a JS config file,\n// so we only need to check for the JS-based filenames\n];\nconst SUPPRESSION_SYMBOL = Symbol('suppression');\nconst ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE = process.env[constants_1.ESLINT_BULK_SUPPRESS_ENV_VAR_NAME];\nconst SUPPRESS_ALL_RULES = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE === '*';\nconst RULES_TO_SUPPRESS = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE ? new Set(ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE.split(',')) : undefined;\nfunction getNodeName(node) {\n  if (Guards.isClassDeclarationWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isFunctionDeclarationWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isClassExpressionWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isFunctionExpressionWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isNormalVariableDeclaratorWithAnonymousExpressionAssigned(node)) {\n    return node.id.name;\n  } else if (Guards.isNormalObjectPropertyWithAnonymousExpressionAssigned(node)) {\n    return node.key.name;\n  } else if (Guards.isNormalClassPropertyDefinitionWithAnonymousExpressionAssigned(node)) {\n    return node.key.name;\n  } else if (Guards.isNormalAssignmentPatternWithAnonymousExpressionAssigned(node)) {\n    return node.left.name;\n  } else if (Guards.isNormalMethodDefinition(node)) {\n    return node.key.name;\n  } else if (Guards.isTSEnumDeclaration(node)) {\n    return node.id.name;\n  } else if (Guards.isTSInterfaceDeclaration(node)) {\n    return node.id.name;\n  } else if (Guards.isTSTypeAliasDeclaration(node)) {\n    return node.id.name;\n  }\n}\nfunction calculateScopeId(node) {\n  const scopeIds = [];\n  for (let current = node; current; current = current.parent) {\n    const scopeIdForASTNode = getNodeName(current);\n    if (scopeIdForASTNode !== undefined) {\n      scopeIds.unshift(scopeIdForASTNode);\n    }\n  }\n  if (scopeIds.length === 0) {\n    return '.';\n  } else {\n    return '.' + scopeIds.join('.');\n  }\n}\nconst eslintrcPathByFileOrFolderPath = new Map();\nfunction findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFilePath) {\n  const cachedFolderPathForFilePath = eslintrcPathByFileOrFolderPath.get(normalizedFilePath);\n  if (cachedFolderPathForFilePath) {\n    return cachedFolderPathForFilePath;\n  }\n  const normalizedFileFolderPath = normalizedFilePath.substring(0, normalizedFilePath.lastIndexOf('/'));\n  const pathsToCache = [normalizedFilePath];\n  let eslintrcFolderPath;\n  findEslintrcFileLoop: for (let currentFolder = normalizedFileFolderPath; currentFolder;\n  // 'something'.substring(0, -1) is ''\n  currentFolder = currentFolder.substring(0, currentFolder.lastIndexOf('/'))) {\n    const cachedEslintrcFolderPath = eslintrcPathByFileOrFolderPath.get(currentFolder);\n    if (cachedEslintrcFolderPath) {\n      return cachedEslintrcFolderPath;\n    }\n    pathsToCache.push(currentFolder);\n    for (const eslintrcFilename of ESLINTRC_FILENAMES) {\n      if (fs_1.default.existsSync(`${currentFolder}/${eslintrcFilename}`)) {\n        eslintrcFolderPath = currentFolder;\n        break findEslintrcFileLoop;\n      }\n    }\n  }\n  if (eslintrcFolderPath) {\n    for (const checkedFolder of pathsToCache) {\n      eslintrcPathByFileOrFolderPath.set(checkedFolder, eslintrcFolderPath);\n    }\n    return eslintrcFolderPath;\n  } else {\n    throw new Error(`Cannot locate an ESLint configuration file for ${normalizedFilePath}`);\n  }\n}\n// One-line insert into the ruleContext report method to prematurely exit if the ESLint problem has been suppressed\nfunction shouldBulkSuppress(params) {\n  // Use this ENV variable to turn off eslint-bulk-suppressions functionality, default behavior is on\n  if (process.env[constants_1.ESLINT_BULK_ENABLE_ENV_VAR_NAME] === 'false') {\n    return false;\n  }\n  const {\n    filename: fileAbsolutePath,\n    currentNode,\n    ruleId: rule,\n    problem\n  } = params;\n  const normalizedFileAbsolutePath = fileAbsolutePath.replace(/\\\\/g, '/');\n  const eslintrcDirectory = findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFileAbsolutePath);\n  const fileRelativePath = normalizedFileAbsolutePath.substring(eslintrcDirectory.length + 1);\n  const scopeId = calculateScopeId(currentNode);\n  const suppression = {\n    file: fileRelativePath,\n    scopeId,\n    rule\n  };\n  const config = (0, bulk_suppressions_file_1.getSuppressionsConfigForEslintrcFolderPath)(eslintrcDirectory);\n  const serializedSuppression = (0, bulk_suppressions_file_1.serializeSuppression)(suppression);\n  const currentNodeIsSuppressed = config.serializedSuppressions.has(serializedSuppression);\n  if (currentNodeIsSuppressed || SUPPRESS_ALL_RULES || (RULES_TO_SUPPRESS === null || RULES_TO_SUPPRESS === void 0 ? void 0 : RULES_TO_SUPPRESS.has(suppression.rule))) {\n    problem[SUPPRESSION_SYMBOL] = {\n      suppression,\n      serializedSuppression,\n      config\n    };\n  }\n  return process.env[constants_1.ESLINT_BULK_PRUNE_ENV_VAR_NAME] !== '1' && currentNodeIsSuppressed;\n}\nexports.shouldBulkSuppress = shouldBulkSuppress;\nfunction prune() {\n  for (const [eslintrcFolderPath, suppressionsConfig] of (0, bulk_suppressions_file_1.getAllBulkSuppressionsConfigsByEslintrcFolderPath)()) {\n    if (suppressionsConfig) {\n      const {\n        newSerializedSuppressions,\n        newJsonObject\n      } = suppressionsConfig;\n      const newSuppressionsConfig = {\n        serializedSuppressions: newSerializedSuppressions,\n        jsonObject: newJsonObject,\n        newSerializedSuppressions: new Set(),\n        newJsonObject: {\n          suppressions: []\n        }\n      };\n      (0, bulk_suppressions_file_1.writeSuppressionsJsonToFile)(eslintrcFolderPath, newSuppressionsConfig);\n    }\n  }\n}\nexports.prune = prune;\nfunction write() {\n  for (const [eslintrcFolderPath, suppressionsConfig] of (0, bulk_suppressions_file_1.getAllBulkSuppressionsConfigsByEslintrcFolderPath)()) {\n    if (suppressionsConfig) {\n      (0, bulk_suppressions_file_1.writeSuppressionsJsonToFile)(eslintrcFolderPath, suppressionsConfig);\n    }\n  }\n}\nexports.write = write;\n// utility function for linter-patch.js to make require statements that use relative paths in linter.js work in linter-patch.js\nfunction requireFromPathToLinterJS(importPath) {\n  if (!_patch_base_1.eslintFolder) {\n    return require(importPath);\n  }\n  const pathToLinterFolder = `${_patch_base_1.eslintFolder}/lib/linter`;\n  const moduleAbsolutePath = require.resolve(importPath, {\n    paths: [pathToLinterFolder]\n  });\n  return require(moduleAbsolutePath);\n}\nexports.requireFromPathToLinterJS = requireFromPathToLinterJS;\nfunction patchClass(originalClass, patchedClass) {\n  // Get all the property names of the patched class prototype\n  const patchedProperties = Object.getOwnPropertyNames(patchedClass.prototype);\n  // Loop through all the properties\n  for (const prop of patchedProperties) {\n    // Override the property in the original class\n    originalClass.prototype[prop] = patchedClass.prototype[prop];\n  }\n  // Handle getters and setters\n  for (const [prop, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(patchedClass.prototype))) {\n    if (descriptor.get || descriptor.set) {\n      Object.defineProperty(originalClass.prototype, prop, descriptor);\n    }\n  }\n}\nexports.patchClass = patchClass;\n/**\n * This returns a wrapped version of the \"verify\" function from ESLint's Linter class\n * that postprocesses rule violations that weren't suppressed by comments. This postprocessing\n * records suppressions that weren't otherwise suppressed by comments to be used\n * by the \"suppress\" and \"prune\" commands.\n */\nfunction extendVerifyFunction(originalFn) {\n  return function (...args) {\n    const problems = originalFn.apply(this, args);\n    if (problems) {\n      for (const problem of problems) {\n        if (problem[SUPPRESSION_SYMBOL]) {\n          const {\n            serializedSuppression,\n            suppression,\n            config: {\n              newSerializedSuppressions,\n              jsonObject: {\n                suppressions\n              },\n              newJsonObject: {\n                suppressions: newSuppressions\n              }\n            }\n          } = problem[SUPPRESSION_SYMBOL];\n          if (!newSerializedSuppressions.has(serializedSuppression)) {\n            newSerializedSuppressions.add(serializedSuppression);\n            newSuppressions.push(suppression);\n            suppressions.push(suppression);\n          }\n        }\n      }\n    }\n    return problems;\n  };\n}\nexports.extendVerifyFunction = extendVerifyFunction;","map":{"version":3,"names":["fs_1","__importDefault","require","Guards","__importStar","_patch_base_1","constants_1","bulk_suppressions_file_1","ESLINTRC_FILENAMES","SUPPRESSION_SYMBOL","Symbol","ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE","process","env","ESLINT_BULK_SUPPRESS_ENV_VAR_NAME","SUPPRESS_ALL_RULES","RULES_TO_SUPPRESS","Set","split","undefined","getNodeName","node","isClassDeclarationWithName","id","name","isFunctionDeclarationWithName","isClassExpressionWithName","isFunctionExpressionWithName","isNormalVariableDeclaratorWithAnonymousExpressionAssigned","isNormalObjectPropertyWithAnonymousExpressionAssigned","key","isNormalClassPropertyDefinitionWithAnonymousExpressionAssigned","isNormalAssignmentPatternWithAnonymousExpressionAssigned","left","isNormalMethodDefinition","isTSEnumDeclaration","isTSInterfaceDeclaration","isTSTypeAliasDeclaration","calculateScopeId","scopeIds","current","parent","scopeIdForASTNode","unshift","length","join","eslintrcPathByFileOrFolderPath","Map","findEslintrcFolderPathForNormalizedFileAbsolutePath","normalizedFilePath","cachedFolderPathForFilePath","get","normalizedFileFolderPath","substring","lastIndexOf","pathsToCache","eslintrcFolderPath","findEslintrcFileLoop","currentFolder","cachedEslintrcFolderPath","push","eslintrcFilename","default","existsSync","checkedFolder","set","Error","shouldBulkSuppress","params","ESLINT_BULK_ENABLE_ENV_VAR_NAME","filename","fileAbsolutePath","currentNode","ruleId","rule","problem","normalizedFileAbsolutePath","replace","eslintrcDirectory","fileRelativePath","scopeId","suppression","file","config","getSuppressionsConfigForEslintrcFolderPath","serializedSuppression","serializeSuppression","currentNodeIsSuppressed","serializedSuppressions","has","ESLINT_BULK_PRUNE_ENV_VAR_NAME","exports","prune","suppressionsConfig","getAllBulkSuppressionsConfigsByEslintrcFolderPath","newSerializedSuppressions","newJsonObject","newSuppressionsConfig","jsonObject","suppressions","writeSuppressionsJsonToFile","write","requireFromPathToLinterJS","importPath","eslintFolder","pathToLinterFolder","moduleAbsolutePath","resolve","paths","patchClass","originalClass","patchedClass","patchedProperties","Object","getOwnPropertyNames","prototype","prop","descriptor","entries","getOwnPropertyDescriptors","defineProperty","extendVerifyFunction","originalFn","args","problems","apply","newSuppressions","add"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@rushstack\\eslint-patch\\src\\eslint-bulk-suppressions\\bulk-suppressions-patch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { TSESTree } from '@typescript-eslint/types';\nimport fs from 'fs';\n\nimport * as Guards from './ast-guards';\n\nimport { eslintFolder } from '../_patch-base';\nimport {\n  ESLINT_BULK_ENABLE_ENV_VAR_NAME,\n  ESLINT_BULK_PRUNE_ENV_VAR_NAME,\n  ESLINT_BULK_SUPPRESS_ENV_VAR_NAME\n} from './constants';\nimport {\n  getSuppressionsConfigForEslintrcFolderPath,\n  serializeSuppression,\n  type IBulkSuppressionsConfig,\n  type ISuppression,\n  writeSuppressionsJsonToFile,\n  getAllBulkSuppressionsConfigsByEslintrcFolderPath\n} from './bulk-suppressions-file';\n\nconst ESLINTRC_FILENAMES: string[] = [\n  '.eslintrc.js',\n  '.eslintrc.cjs'\n  // Several other filenames are allowed, but this patch requires that it be loaded via a JS config file,\n  // so we only need to check for the JS-based filenames\n];\nconst SUPPRESSION_SYMBOL: unique symbol = Symbol('suppression');\nconst ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE: string | undefined = process.env[ESLINT_BULK_SUPPRESS_ENV_VAR_NAME];\nconst SUPPRESS_ALL_RULES: boolean = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE === '*';\nconst RULES_TO_SUPPRESS: Set<string> | undefined = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE\n  ? new Set(ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE.split(','))\n  : undefined;\n\ninterface IProblem {\n  [SUPPRESSION_SYMBOL]?: {\n    config: IBulkSuppressionsConfig;\n    suppression: ISuppression;\n    serializedSuppression: string;\n  };\n}\n\nfunction getNodeName(node: TSESTree.Node): string | undefined {\n  if (Guards.isClassDeclarationWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isFunctionDeclarationWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isClassExpressionWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isFunctionExpressionWithName(node)) {\n    return node.id.name;\n  } else if (Guards.isNormalVariableDeclaratorWithAnonymousExpressionAssigned(node)) {\n    return node.id.name;\n  } else if (Guards.isNormalObjectPropertyWithAnonymousExpressionAssigned(node)) {\n    return node.key.name;\n  } else if (Guards.isNormalClassPropertyDefinitionWithAnonymousExpressionAssigned(node)) {\n    return node.key.name;\n  } else if (Guards.isNormalAssignmentPatternWithAnonymousExpressionAssigned(node)) {\n    return node.left.name;\n  } else if (Guards.isNormalMethodDefinition(node)) {\n    return node.key.name;\n  } else if (Guards.isTSEnumDeclaration(node)) {\n    return node.id.name;\n  } else if (Guards.isTSInterfaceDeclaration(node)) {\n    return node.id.name;\n  } else if (Guards.isTSTypeAliasDeclaration(node)) {\n    return node.id.name;\n  }\n}\n\ntype NodeWithParent = TSESTree.Node & { parent?: TSESTree.Node };\n\nfunction calculateScopeId(node: NodeWithParent | undefined): string {\n  const scopeIds: string[] = [];\n  for (let current: NodeWithParent | undefined = node; current; current = current.parent) {\n    const scopeIdForASTNode: string | undefined = getNodeName(current);\n    if (scopeIdForASTNode !== undefined) {\n      scopeIds.unshift(scopeIdForASTNode);\n    }\n  }\n\n  if (scopeIds.length === 0) {\n    return '.';\n  } else {\n    return '.' + scopeIds.join('.');\n  }\n}\n\nconst eslintrcPathByFileOrFolderPath: Map<string, string> = new Map();\n\nfunction findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFilePath: string): string {\n  const cachedFolderPathForFilePath: string | undefined =\n    eslintrcPathByFileOrFolderPath.get(normalizedFilePath);\n  if (cachedFolderPathForFilePath) {\n    return cachedFolderPathForFilePath;\n  }\n  const normalizedFileFolderPath: string = normalizedFilePath.substring(\n    0,\n    normalizedFilePath.lastIndexOf('/')\n  );\n\n  const pathsToCache: string[] = [normalizedFilePath];\n  let eslintrcFolderPath: string | undefined;\n  findEslintrcFileLoop: for (\n    let currentFolder: string = normalizedFileFolderPath;\n    currentFolder; // 'something'.substring(0, -1) is ''\n    currentFolder = currentFolder.substring(0, currentFolder.lastIndexOf('/'))\n  ) {\n    const cachedEslintrcFolderPath: string | undefined = eslintrcPathByFileOrFolderPath.get(currentFolder);\n    if (cachedEslintrcFolderPath) {\n      return cachedEslintrcFolderPath;\n    }\n\n    pathsToCache.push(currentFolder);\n    for (const eslintrcFilename of ESLINTRC_FILENAMES) {\n      if (fs.existsSync(`${currentFolder}/${eslintrcFilename}`)) {\n        eslintrcFolderPath = currentFolder;\n        break findEslintrcFileLoop;\n      }\n    }\n  }\n\n  if (eslintrcFolderPath) {\n    for (const checkedFolder of pathsToCache) {\n      eslintrcPathByFileOrFolderPath.set(checkedFolder, eslintrcFolderPath);\n    }\n\n    return eslintrcFolderPath;\n  } else {\n    throw new Error(`Cannot locate an ESLint configuration file for ${normalizedFilePath}`);\n  }\n}\n\n// One-line insert into the ruleContext report method to prematurely exit if the ESLint problem has been suppressed\nexport function shouldBulkSuppress(params: {\n  filename: string;\n  currentNode: TSESTree.Node;\n  ruleId: string;\n  problem: IProblem;\n}): boolean {\n  // Use this ENV variable to turn off eslint-bulk-suppressions functionality, default behavior is on\n  if (process.env[ESLINT_BULK_ENABLE_ENV_VAR_NAME] === 'false') {\n    return false;\n  }\n\n  const { filename: fileAbsolutePath, currentNode, ruleId: rule, problem } = params;\n  const normalizedFileAbsolutePath: string = fileAbsolutePath.replace(/\\\\/g, '/');\n  const eslintrcDirectory: string =\n    findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFileAbsolutePath);\n  const fileRelativePath: string = normalizedFileAbsolutePath.substring(eslintrcDirectory.length + 1);\n  const scopeId: string = calculateScopeId(currentNode);\n  const suppression: ISuppression = { file: fileRelativePath, scopeId, rule };\n\n  const config: IBulkSuppressionsConfig = getSuppressionsConfigForEslintrcFolderPath(eslintrcDirectory);\n  const serializedSuppression: string = serializeSuppression(suppression);\n  const currentNodeIsSuppressed: boolean = config.serializedSuppressions.has(serializedSuppression);\n\n  if (currentNodeIsSuppressed || SUPPRESS_ALL_RULES || RULES_TO_SUPPRESS?.has(suppression.rule)) {\n    problem[SUPPRESSION_SYMBOL] = {\n      suppression,\n      serializedSuppression,\n      config\n    };\n  }\n\n  return process.env[ESLINT_BULK_PRUNE_ENV_VAR_NAME] !== '1' && currentNodeIsSuppressed;\n}\n\nexport function prune(): void {\n  for (const [\n    eslintrcFolderPath,\n    suppressionsConfig\n  ] of getAllBulkSuppressionsConfigsByEslintrcFolderPath()) {\n    if (suppressionsConfig) {\n      const { newSerializedSuppressions, newJsonObject } = suppressionsConfig;\n      const newSuppressionsConfig: IBulkSuppressionsConfig = {\n        serializedSuppressions: newSerializedSuppressions,\n        jsonObject: newJsonObject,\n        newSerializedSuppressions: new Set(),\n        newJsonObject: { suppressions: [] }\n      };\n\n      writeSuppressionsJsonToFile(eslintrcFolderPath, newSuppressionsConfig);\n    }\n  }\n}\n\nexport function write(): void {\n  for (const [\n    eslintrcFolderPath,\n    suppressionsConfig\n  ] of getAllBulkSuppressionsConfigsByEslintrcFolderPath()) {\n    if (suppressionsConfig) {\n      writeSuppressionsJsonToFile(eslintrcFolderPath, suppressionsConfig);\n    }\n  }\n}\n\n// utility function for linter-patch.js to make require statements that use relative paths in linter.js work in linter-patch.js\nexport function requireFromPathToLinterJS(importPath: string): import('eslint').Linter {\n  if (!eslintFolder) {\n    return require(importPath);\n  }\n\n  const pathToLinterFolder: string = `${eslintFolder}/lib/linter`;\n  const moduleAbsolutePath: string = require.resolve(importPath, { paths: [pathToLinterFolder] });\n  return require(moduleAbsolutePath);\n}\n\nexport function patchClass<T, U extends T>(originalClass: new () => T, patchedClass: new () => U): void {\n  // Get all the property names of the patched class prototype\n  const patchedProperties: string[] = Object.getOwnPropertyNames(patchedClass.prototype);\n\n  // Loop through all the properties\n  for (const prop of patchedProperties) {\n    // Override the property in the original class\n    originalClass.prototype[prop] = patchedClass.prototype[prop];\n  }\n\n  // Handle getters and setters\n  for (const [prop, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(patchedClass.prototype))) {\n    if (descriptor.get || descriptor.set) {\n      Object.defineProperty(originalClass.prototype, prop, descriptor);\n    }\n  }\n}\n\n/**\n * This returns a wrapped version of the \"verify\" function from ESLint's Linter class\n * that postprocesses rule violations that weren't suppressed by comments. This postprocessing\n * records suppressions that weren't otherwise suppressed by comments to be used\n * by the \"suppress\" and \"prune\" commands.\n */\nexport function extendVerifyFunction(\n  originalFn: (this: unknown, ...args: unknown[]) => IProblem[] | undefined\n): (this: unknown, ...args: unknown[]) => IProblem[] | undefined {\n  return function (this: unknown, ...args: unknown[]): IProblem[] | undefined {\n    const problems: IProblem[] | undefined = originalFn.apply(this, args);\n    if (problems) {\n      for (const problem of problems) {\n        if (problem[SUPPRESSION_SYMBOL]) {\n          const {\n            serializedSuppression,\n            suppression,\n            config: {\n              newSerializedSuppressions,\n              jsonObject: { suppressions },\n              newJsonObject: { suppressions: newSuppressions }\n            }\n          } = problem[SUPPRESSION_SYMBOL];\n          if (!newSerializedSuppressions.has(serializedSuppression)) {\n            newSerializedSuppressions.add(serializedSuppression);\n            newSuppressions.push(suppression);\n            suppressions.push(suppression);\n          }\n        }\n      }\n    }\n\n    return problems;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}