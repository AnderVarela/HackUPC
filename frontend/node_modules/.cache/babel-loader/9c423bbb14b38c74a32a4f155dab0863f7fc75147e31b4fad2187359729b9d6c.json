{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\nfunction _crypto() {\n  const data = require('crypto');\n  _crypto = function () {\n    return data;\n  };\n  return data;\n}\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n  path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _core() {\n  const data = require('@babel/core');\n  _core = function () {\n    return data;\n  };\n  return data;\n}\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n  return data;\n}\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n  _convertSourceMap = function () {\n    return data;\n  };\n  return data;\n}\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n  return data;\n}\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n  fs = function () {\n    return data;\n  };\n  return data;\n}\nfunction _pirates() {\n  const data = require('pirates');\n  _pirates = function () {\n    return data;\n  };\n  return data;\n}\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n  _slash = function () {\n    return data;\n  };\n  return data;\n}\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n  _writeFileAtomic = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n  _jestHasteMap = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestUtil() {\n  const data = require('jest-util');\n  _jestUtil = function () {\n    return data;\n  };\n  return data;\n}\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Use `require` to avoid TS rootDir\nconst {\n  version: VERSION\n} = require('../package.json');\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\nclass ScriptTransformer {\n  constructor(_config, _cacheFS) {\n    _defineProperty(this, '_cache', void 0);\n    _defineProperty(this, '_transformCache', new Map());\n    _defineProperty(this, '_transformsAreLoaded', false);\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n    this._cache = projectCache;\n  }\n  _buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('md5').update(transformerCacheKey).update(CACHE_VERSION).digest('hex');\n    }\n    return (0, _crypto().createHash)('md5').update(fileData).update(transformOptions.configString).update(transformOptions.instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');\n  }\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n    if (typeof (transformer === null || transformer === void 0 ? void 0 : transformer.getCacheKey) === 'function') {\n      transformerCacheKey = transformer.getCacheKey(fileData, filename, transformOptions);\n    }\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n    if (transformer) {\n      const getCacheKey = transformer.getCacheKeyAsync || transformer.getCacheKey;\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(fileData, filename, transformOptions);\n      }\n    }\n    return this._buildCacheKeyFromFileInfo(fileData, filename, transformOptions, transformerCacheKey);\n  }\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n    const baseCacheDir = HasteMapClass.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n    if (!transformRegExp) {\n      return undefined;\n    }\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n    return undefined;\n  }\n  async loadTransformers() {\n    await Promise.all(this._config.transform.map(async ([, transformPath, transformerConfig]) => {\n      let transformer = await (0, _jestUtil().requireOrImportModule)(transformPath);\n      if (!transformer) {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n      if (typeof transformer.createTransformer === 'function') {\n        transformer = transformer.createTransformer(transformerConfig);\n      }\n      if (typeof transformer.process !== 'function' && typeof transformer.processAsync !== 'function') {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(transformPath));\n      }\n      const res = {\n        transformer,\n        transformerConfig\n      };\n      this._transformCache.set(transformPath, res);\n    }));\n    this._transformsAreLoaded = true;\n  }\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error('Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files');\n    }\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n    const transformPath = this._getTransformPath(filename);\n    if (!transformPath) {\n      return null;\n    }\n    const cached = this._transformCache.get(transformPath);\n    if (cached) {\n      return cached;\n    }\n    throw new Error(`Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`);\n  }\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        extension: false,\n        inputSourceMap: inputMap,\n        useInlineSourceMaps: false\n      }]],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n    if (result && result.code) {\n      return result;\n    }\n    return input;\n  }\n  _buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n    if (transformer && shouldCallTransform) {\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new Error((0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)());\n      }\n    }\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n        invariant(transformPath);\n        console.warn((0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(filename, transformPath));\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument = shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps = transformer != null && map != null || transformer == null;\n      const instrumented = this._instrumentFile(filename, transformed, shouldEmitSourceMaps, options);\n      code = typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n    if (map) {\n      const sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n    let processed = null;\n    let shouldCallTransform = false;\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {\n      transformer,\n      transformerConfig = {}\n    } = this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(filename, content, options);\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n    let processed = null;\n    let shouldCallTransform = false;\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(typeof process === 'function', 'A transformer must always export either a `process` or `processAsync`');\n      processed = await process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n    return this._buildTransformResult(filename, cacheFilePath, content, transformer, shouldCallTransform, options, processed, sourceMapPath);\n  }\n  async _transformAndBuildScriptAsync(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n      this._cacheFS.set(filename, fileContent);\n    }\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    let fileContent = fileSource !== null && fileSource !== void 0 ? fileSource : this._cacheFS.get(filename);\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n      this._cacheFS.set(filename, fileContent);\n    }\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && (transformOptions.instrument || this.shouldTransform(filename));\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, transformOptions);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n  async transformAsync(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n    if (result) {\n      return result;\n    }\n    result = await this._transformAndBuildScriptAsync(filename, options, {\n      ...options,\n      instrument\n    }, fileSource);\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n    return result;\n  }\n  transform(filename, options, fileSource) {\n    const instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n    if (result) {\n      return result;\n    }\n    result = this._transformAndBuildScript(filename, options, {\n      ...options,\n      instrument\n    }, fileSource);\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n    return result;\n  }\n  transformJson(filename, options, fileSource) {\n    const {\n      isInternalModule\n    } = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n    if (willTransform) {\n      const {\n        code: transformedJsonSource\n      } = this.transformSource(filename, fileSource, {\n        ...options,\n        instrument: false\n      });\n      return transformedJsonSource;\n    }\n    return fileSource;\n  }\n  async requireAndTranspileModule(moduleName, callback, options = {\n    applyInteropRequireDefault: true,\n    instrument: false,\n    supportsDynamicImport: false,\n    supportsExportNamespaceFrom: false,\n    supportsStaticESM: false,\n    supportsTopLevelAwait: false\n  }) {\n    let transforming = false;\n    const {\n      applyInteropRequireDefault,\n      ...transformOptions\n    } = options;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return this.transformSource(filename, code, transformOptions).code || code;\n      } finally {\n        transforming = false;\n      }\n    }, {\n      exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n        return this.shouldTransform(filename);\n      }\n    });\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(moduleName, applyInteropRequireDefault);\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n      const cbResult = callback(module);\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n} // TODO: do we need to define the generics twice?\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(resolverPath, applyInteropRequireDefault = false) {\n    const transpiledModule = await transformer.requireAndTranspileModule(resolverPath, () => {}, {\n      applyInteropRequireDefault,\n      instrument: false,\n      supportsDynamicImport: false,\n      // this might be true, depending on node version.\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n    return transpiledModule;\n  };\n}\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n  if (content == null) {\n    return null;\n  }\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && fs().existsSync(cachePath);\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n  let fileData;\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n  return fileData;\n};\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n  const transformRegexp = [];\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n  return transformRegexp;\n};\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(typeof transformer.process === 'function', (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name));\n}\nasync function createScriptTransformer(config, cacheFS = new Map()) {\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","createScriptTransformer","createTranspilingRequire","_crypto","data","require","path","_interopRequireWildcard","_core","_babelPluginIstanbul","_interopRequireDefault","_convertSourceMap","_fastJsonStableStringify","fs","_pirates","_slash","_writeFileAtomic","_jestHasteMap","_jestUtil","_enhanceUnexpectedTokenMessage","_runtimeErrorsAndWarnings","_shouldInstrument","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","version","VERSION","projectCaches","Map","CACHE_VERSION","waitForPromiseWithCleanup","promise","cleanup","ScriptTransformer","constructor","_config","_cacheFS","configString","projectCache","ignorePatternsRegExp","calcIgnorePatternRegExp","transformRegExp","calcTransformRegExp","transformedFiles","_cache","_buildCacheKeyFromFileInfo","fileData","filename","transformOptions","transformerCacheKey","createHash","update","digest","instrument","_getCacheKey","options","transformer","transformerConfig","_getTransformer","undefined","cacheFS","config","getCacheKey","_getCacheKeyAsync","getCacheKeyAsync","_createFolderFromCacheKey","cacheKey","HasteMapClass","getStatic","baseCacheDir","getCacheFilePath","cacheDirectory","name","cacheDir","join","cacheFilenamePrefix","basename","extname","replace","cachePath","createDirectory","_getFileCachePath","content","_getFileCachePathAsync","_getTransformPath","i","length","test","loadTransformers","Promise","all","transform","map","transformPath","requireOrImportModule","Error","makeInvalidTransformerError","createTransformer","process","processAsync","res","_transformCache","_transformsAreLoaded","cached","_instrumentFile","input","canMapToInput","inputCode","code","inputMap","result","transformSync","auxiliaryCommentBefore","babelrc","caller","supportsDynamicImport","supportsExportNamespaceFrom","supportsStaticESM","supportsTopLevelAwait","configFile","plugins","compact","cwd","rootDir","exclude","extension","inputSourceMap","useInlineSourceMaps","sourceMaps","_buildTransformResult","cacheFilePath","shouldCallTransform","processed","sourceMapPath","transformed","makeInvalidReturnValueError","inlineSourceMap","fromSource","toObject","invariant","console","warn","makeInvalidSourceMapWarning","transformWillInstrument","canInstrument","shouldEmitSourceMaps","instrumented","sourceMapContent","JSON","stringify","writeCacheFile","writeCodeCacheFile","originalCode","transformSource","filepath","tryRealpath","readCodeCacheFile","shouldTransform","assertSyncTransformer","transformSourceAsync","_transformAndBuildScriptAsync","fileSource","isInternalModule","fileContent","readFileSync","stripShebang","willTransform","transformedSource","e","_transformAndBuildScript","transformAsync","coverageProvider","scriptCacheKey","getScriptCacheKey","transformJson","transformedJsonSource","requireAndTranspileModule","moduleName","callback","applyInteropRequireDefault","transforming","revertHook","addHook","exts","moduleFileExtensions","ext","ignoreNodeModules","matcher","module","cbResult","isPromise","then","ignoreRegexp","isIgnored","resolverPath","transpiledModule","removeFile","unlinkSync","startsWith","checksum","readCacheFile","substring","sync","encoding","fsync","cacheWriteErrorSafeToIgnore","message","platform","existsSync","mtime","statSync","getTime","transformIgnorePatterns","RegExp","transformRegexp","push","condition","makeInvalidSyncTransformerError"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/transform/build/ScriptTransformer.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createScriptTransformer = createScriptTransformer;\nexports.createTranspilingRequire = createTranspilingRequire;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(\n  require('./enhanceUnexpectedTokenMessage')\n);\n\nvar _runtimeErrorsAndWarnings = require('./runtimeErrorsAndWarnings');\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Use `require` to avoid TS rootDir\nconst {version: VERSION} = require('../package.json');\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\nclass ScriptTransformer {\n  constructor(_config, _cacheFS) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_transformCache', new Map());\n\n    _defineProperty(this, '_transformsAreLoaded', false);\n\n    this._config = _config;\n    this._cacheFS = _cacheFS;\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _buildCacheKeyFromFileInfo(\n    fileData,\n    filename,\n    transformOptions,\n    transformerCacheKey\n  ) {\n    if (transformerCacheKey) {\n      return (0, _crypto().createHash)('md5')\n        .update(transformerCacheKey)\n        .update(CACHE_VERSION)\n        .digest('hex');\n    }\n\n    return (0, _crypto().createHash)('md5')\n      .update(fileData)\n      .update(transformOptions.configString)\n      .update(transformOptions.instrument ? 'instrument' : '')\n      .update(filename)\n      .update(CACHE_VERSION)\n      .digest('hex');\n  }\n\n  _getCacheKey(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (\n      typeof (transformer === null || transformer === void 0\n        ? void 0\n        : transformer.getCacheKey) === 'function'\n    ) {\n      transformerCacheKey = transformer.getCacheKey(\n        fileData,\n        filename,\n        transformOptions\n      );\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  async _getCacheKeyAsync(fileData, filename, options) {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    let transformerCacheKey = undefined;\n    const transformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig\n    };\n\n    if (transformer) {\n      const getCacheKey =\n        transformer.getCacheKeyAsync || transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(\n          fileData,\n          filename,\n          transformOptions\n        );\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey\n    );\n  }\n\n  _createFolderFromCacheKey(filename, cacheKey) {\n    const HasteMapClass = _jestHasteMap().default.getStatic(this._config);\n\n    const baseCacheDir = HasteMapClass.getCacheFilePath(\n      this._config.cacheDirectory,\n      'jest-transform-cache-' + this._config.name,\n      VERSION\n    ); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path()\n      .basename(filename, path().extname(filename))\n      .replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(\n      path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey)\n    );\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getFileCachePath(filename, content, options) {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  async _getFileCachePathAsync(filename, content, options) {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n    return this._createFolderFromCacheKey(filename, cacheKey);\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        return transformRegExp[i][1];\n      }\n    }\n\n    return undefined;\n  }\n\n  async loadTransformers() {\n    await Promise.all(\n      this._config.transform.map(\n        async ([, transformPath, transformerConfig]) => {\n          let transformer = await (0, _jestUtil().requireOrImportModule)(\n            transformPath\n          );\n\n          if (!transformer) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          if (typeof transformer.createTransformer === 'function') {\n            transformer = transformer.createTransformer(transformerConfig);\n          }\n\n          if (\n            typeof transformer.process !== 'function' &&\n            typeof transformer.processAsync !== 'function'\n          ) {\n            throw new Error(\n              (0, _runtimeErrorsAndWarnings.makeInvalidTransformerError)(\n                transformPath\n              )\n            );\n          }\n\n          const res = {\n            transformer,\n            transformerConfig\n          };\n\n          this._transformCache.set(transformPath, res);\n        }\n      )\n    );\n    this._transformsAreLoaded = true;\n  }\n\n  _getTransformer(filename) {\n    if (!this._transformsAreLoaded) {\n      throw new Error(\n        'Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files'\n      );\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const cached = this._transformCache.get(transformPath);\n\n    if (cached) {\n      return cached;\n    }\n\n    throw new Error(\n      `Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`\n    );\n  }\n\n  _instrumentFile(filename, input, canMapToInput, options) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          _babelPluginIstanbul().default,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            extension: false,\n            inputSourceMap: inputMap,\n            useInlineSourceMaps: false\n          }\n        ]\n      ],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  }\n\n  _buildTransformResult(\n    filename,\n    cacheFilePath,\n    content,\n    transformer,\n    shouldCallTransform,\n    options,\n    processed,\n    sourceMapPath\n  ) {\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new Error(\n          (0, _runtimeErrorsAndWarnings.makeInvalidReturnValueError)()\n        );\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(\n          transformed.code\n        );\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        invariant(transformPath);\n        console.warn(\n          (0, _runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(\n            filename,\n            transformPath\n          )\n        );\n      }\n    } // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument =\n      shouldCallTransform && transformer && transformer.canInstrument; // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n    let code;\n\n    if (!transformWillInstrument && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps =\n        (transformer != null && map != null) || transformer == null;\n\n      const instrumented = this._instrumentFile(\n        filename,\n        transformed,\n        shouldEmitSourceMaps,\n        options\n      );\n\n      code =\n        typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent =\n        typeof map === 'string' ? map : JSON.stringify(map);\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  transformSource(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n      processed = transformer.process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async transformSourceAsync(filepath, content, options) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) || {};\n    const cacheFilePath = await this._getFileCachePathAsync(\n      filename,\n      content,\n      options\n    );\n    const sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let processed = null;\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync || transformer.process; // This is probably dead code since `_getTransformerAsync` already asserts this\n\n      invariant(\n        typeof process === 'function',\n        'A transformer must always export either a `process` or `processAsync`'\n      );\n      processed = await process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig\n      });\n    }\n\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath\n    );\n  }\n\n  async _transformAndBuildScriptAsync(\n    filename,\n    options,\n    transformOptions,\n    fileSource\n  ) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  _transformAndBuildScript(filename, options, transformOptions, fileSource) {\n    const {isInternalModule} = options;\n    let fileContent =\n      fileSource !== null && fileSource !== void 0\n        ? fileSource\n        : this._cacheFS.get(filename);\n\n    if (!fileContent) {\n      fileContent = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, fileContent);\n    }\n\n    const content = stripShebang(fileContent);\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          transformOptions\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  async transformAsync(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(filename, options, fileSource) {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      (0, _shouldInstrument.default)(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {isInternalModule} = options;\n    const willTransform = !isInternalModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {code: transformedJsonSource} = this.transformSource(\n        filename,\n        fileSource,\n        {...options, instrument: false}\n      );\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule(\n    moduleName,\n    callback,\n    options = {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    }\n  ) {\n    let transforming = false;\n    const {applyInteropRequireDefault, ...transformOptions} = options;\n    const revertHook = (0, _pirates().addHook)(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return (\n            this.transformSource(filename, code, transformOptions).code || code\n          );\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n\n          return this.shouldTransform(filename);\n        }\n      }\n    );\n\n    try {\n      const module = await (0, _jestUtil().requireOrImportModule)(\n        moduleName,\n        applyInteropRequireDefault\n      );\n\n      if (!callback) {\n        revertHook();\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module\n        );\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return this._config.transform.length !== 0 && !isIgnored;\n  }\n} // TODO: do we need to define the generics twice?\n\nasync function createTranspilingRequire(config) {\n  const transformer = await createScriptTransformer(config);\n  return async function requireAndTranspileModule(\n    resolverPath,\n    applyInteropRequireDefault = false\n  ) {\n    const transpiledModule = await transformer.requireAndTranspileModule(\n      resolverPath,\n      () => {},\n      {\n        applyInteropRequireDefault,\n        instrument: false,\n        supportsDynamicImport: false,\n        // this might be true, depending on node version.\n        supportsExportNamespaceFrom: false,\n        supportsStaticESM: false,\n        supportsTopLevelAwait: false\n      }\n    );\n    return transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substring(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n\n  if (checksum === content.substring(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message =\n      'jest: failed to cache transform results in: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) =>\n  process.platform === 'win32' &&\n  e.code === 'EPERM' &&\n  fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message =\n      'jest: failed to read cache file: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (\n    !config.transformIgnorePatterns ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([\n      new RegExp(config.transform[i][0]),\n      config.transform[i][1],\n      config.transform[i][2]\n    ]);\n  }\n\n  return transformRegexp;\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction assertSyncTransformer(transformer, name) {\n  invariant(name);\n  invariant(\n    typeof transformer.process === 'function',\n    (0, _runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(name)\n  );\n}\n\nasync function createScriptTransformer(config, cacheFS = new Map()) {\n  const transformer = new ScriptTransformer(config, cacheFS);\n  await transformer.loadTransformers();\n  return transformer;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}