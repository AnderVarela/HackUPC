{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\types\\jtd-schema.ts"],"sourcesContent":["/** numeric strings */\ntype NumberType = \"float32\" | \"float64\" | \"int8\" | \"uint8\" | \"int16\" | \"uint16\" | \"int32\" | \"uint32\"\n\n/** string strings */\ntype StringType = \"string\" | \"timestamp\"\n\n/** Generic JTD Schema without inference of the represented type */\nexport type SomeJTDSchemaType = (\n  | // ref\n  {ref: string}\n  // primitives\n  | {type: NumberType | StringType | \"boolean\"}\n  // enum\n  | {enum: string[]}\n  // elements\n  | {elements: SomeJTDSchemaType}\n  // values\n  | {values: SomeJTDSchemaType}\n  // properties\n  | {\n      properties: Record<string, SomeJTDSchemaType>\n      optionalProperties?: Record<string, SomeJTDSchemaType>\n      additionalProperties?: boolean\n    }\n  | {\n      properties?: Record<string, SomeJTDSchemaType>\n      optionalProperties: Record<string, SomeJTDSchemaType>\n      additionalProperties?: boolean\n    }\n  // discriminator\n  | {discriminator: string; mapping: Record<string, SomeJTDSchemaType>}\n  // empty\n  // NOTE see the end of\n  // https://github.com/typescript-eslint/typescript-eslint/issues/2063#issuecomment-675156492\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  | {}\n) & {\n  nullable?: boolean\n  metadata?: Record<string, unknown>\n  definitions?: Record<string, SomeJTDSchemaType>\n}\n\n/** required keys of an object, not undefined */\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: undefined extends T[K] ? never : K\n}[keyof T]\n\n/** optional or undifined-able keys of an object */\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: undefined extends T[K] ? K : never\n}[keyof T]\n\n/** type is true if T is a union type */\ntype IsUnion_<T, U extends T = T> = false extends (\n  T extends unknown ? ([U] extends [T] ? false : true) : never\n)\n  ? false\n  : true\ntype IsUnion<T> = IsUnion_<T>\n\n/** type is true if T is identically E */\ntype TypeEquality<T, E> = [T] extends [E] ? ([E] extends [T] ? true : false) : false\n\n/** type is true if T or null is identically E or null*/\ntype NullTypeEquality<T, E> = TypeEquality<T | null, E | null>\n\n/** gets only the string literals of a type or null if a type isn't a string literal */\ntype EnumString<T> = [T] extends [never]\n  ? null\n  : T extends string\n  ? string extends T\n    ? null\n    : T\n  : null\n\n/** true if type is a union of string literals */\ntype IsEnum<T> = null extends EnumString<T> ? false : true\n\n/** true only if all types are array types (not tuples) */\n// NOTE relies on the fact that tuples don't have an index at 0.5, but arrays\n// have an index at every number\ntype IsElements<T> = false extends IsUnion<T>\n  ? [T] extends [readonly unknown[]]\n    ? undefined extends T[0.5]\n      ? false\n      : true\n    : false\n  : false\n\n/** true if the the type is a values type */\ntype IsValues<T> = false extends IsUnion<T> ? TypeEquality<keyof T, string> : false\n\n/** true if type is a properties type and Union is false, or type is a discriminator type and Union is true */\ntype IsRecord<T, Union extends boolean> = Union extends IsUnion<T>\n  ? null extends EnumString<keyof T>\n    ? false\n    : true\n  : false\n\n/** true if type represents an empty record */\ntype IsEmptyRecord<T> = [T] extends [Record<string, never>]\n  ? [T] extends [never]\n    ? false\n    : true\n  : false\n\n/** actual schema */\nexport type JTDSchemaType<T, D extends Record<string, unknown> = Record<string, never>> = (\n  | // refs - where null wasn't specified, must match exactly\n  (null extends EnumString<keyof D>\n      ? never\n      :\n          | ({[K in keyof D]: [T] extends [D[K]] ? {ref: K} : never}[keyof D] & {nullable?: false})\n          // nulled refs - if ref is nullable and nullable is specified, then it can\n          // match either null or non-null definitions\n          | (null extends T\n              ? {\n                  [K in keyof D]: [Exclude<T, null>] extends [Exclude<D[K], null>]\n                    ? {ref: K}\n                    : never\n                }[keyof D] & {nullable: true}\n              : never))\n  // empty - empty schemas also treat nullable differently in that it's now fully ignored\n  | (unknown extends T ? {nullable?: boolean} : never)\n  // all other types // numbers - only accepts the type number\n  | ((true extends NullTypeEquality<T, number>\n      ? {type: NumberType}\n      : // booleans - accepts the type boolean\n      true extends NullTypeEquality<T, boolean>\n      ? {type: \"boolean\"}\n      : // strings - only accepts the type string\n      true extends NullTypeEquality<T, string>\n      ? {type: StringType}\n      : // strings - only accepts the type Date\n      true extends NullTypeEquality<T, Date>\n      ? {type: \"timestamp\"}\n      : // enums - only accepts union of string literals\n      // TODO we can't actually check that everything in the union was specified\n      true extends IsEnum<Exclude<T, null>>\n      ? {enum: EnumString<Exclude<T, null>>[]}\n      : // arrays - only accepts arrays, could be array of unions to be resolved later\n      true extends IsElements<Exclude<T, null>>\n      ? T extends readonly (infer E)[]\n        ? {\n            elements: JTDSchemaType<E, D>\n          }\n        : never\n      : // empty properties\n      true extends IsEmptyRecord<Exclude<T, null>>\n      ?\n          | {properties: Record<string, never>; optionalProperties?: Record<string, never>}\n          | {optionalProperties: Record<string, never>}\n      : // values\n      true extends IsValues<Exclude<T, null>>\n      ? T extends Record<string, infer V>\n        ? {\n            values: JTDSchemaType<V, D>\n          }\n        : never\n      : // properties\n      true extends IsRecord<Exclude<T, null>, false>\n      ? ([RequiredKeys<Exclude<T, null>>] extends [never]\n          ? {\n              properties?: Record<string, never>\n            }\n          : {\n              properties: {[K in RequiredKeys<T>]: JTDSchemaType<T[K], D>}\n            }) &\n          ([OptionalKeys<Exclude<T, null>>] extends [never]\n            ? {\n                optionalProperties?: Record<string, never>\n              }\n            : {\n                optionalProperties: {\n                  [K in OptionalKeys<T>]: JTDSchemaType<Exclude<T[K], undefined>, D>\n                }\n              }) & {\n            additionalProperties?: boolean\n          }\n      : // discriminator\n      true extends IsRecord<Exclude<T, null>, true>\n      ? {\n          [K in keyof Exclude<T, null>]-?: Exclude<T, null>[K] extends string\n            ? {\n                discriminator: K\n                mapping: {\n                  // TODO currently allows descriminator to be present in schema\n                  [M in Exclude<T, null>[K]]: JTDSchemaType<\n                    Omit<T extends Record<K, M> ? T : never, K>,\n                    D\n                  >\n                }\n              }\n            : never\n        }[keyof Exclude<T, null>]\n      : never) &\n      (null extends T\n        ? {\n            nullable: true\n          }\n        : {nullable?: false}))\n) & {\n  // extra properties\n  metadata?: Record<string, unknown>\n  // TODO these should only be allowed at the top level\n  definitions?: {[K in keyof D]: JTDSchemaType<D[K], D>}\n}\n\ntype JTDDataDef<S, D extends Record<string, unknown>> =\n  | // ref\n  (S extends {ref: string}\n      ? D extends {[K in S[\"ref\"]]: infer V}\n        ? JTDDataDef<V, D>\n        : never\n      : // type\n      S extends {type: NumberType}\n      ? number\n      : S extends {type: \"boolean\"}\n      ? boolean\n      : S extends {type: \"string\"}\n      ? string\n      : S extends {type: \"timestamp\"}\n      ? string | Date\n      : // enum\n      S extends {enum: readonly (infer E)[]}\n      ? string extends E\n        ? never\n        : [E] extends [string]\n        ? E\n        : never\n      : // elements\n      S extends {elements: infer E}\n      ? JTDDataDef<E, D>[]\n      : // properties\n      S extends {\n          properties: Record<string, unknown>\n          optionalProperties?: Record<string, unknown>\n          additionalProperties?: boolean\n        }\n      ? {-readonly [K in keyof S[\"properties\"]]-?: JTDDataDef<S[\"properties\"][K], D>} & {\n          -readonly [K in keyof S[\"optionalProperties\"]]+?: JTDDataDef<\n            S[\"optionalProperties\"][K],\n            D\n          >\n        } & ([S[\"additionalProperties\"]] extends [true] ? Record<string, unknown> : unknown)\n      : S extends {\n          properties?: Record<string, unknown>\n          optionalProperties: Record<string, unknown>\n          additionalProperties?: boolean\n        }\n      ? {-readonly [K in keyof S[\"properties\"]]-?: JTDDataDef<S[\"properties\"][K], D>} & {\n          -readonly [K in keyof S[\"optionalProperties\"]]+?: JTDDataDef<\n            S[\"optionalProperties\"][K],\n            D\n          >\n        } & ([S[\"additionalProperties\"]] extends [true] ? Record<string, unknown> : unknown)\n      : // values\n      S extends {values: infer V}\n      ? Record<string, JTDDataDef<V, D>>\n      : // discriminator\n      S extends {discriminator: infer M; mapping: Record<string, unknown>}\n      ? [M] extends [string]\n        ? {\n            [K in keyof S[\"mapping\"]]: JTDDataDef<S[\"mapping\"][K], D> & {[KM in M]: K}\n          }[keyof S[\"mapping\"]]\n        : never\n      : // empty\n        unknown)\n  | (S extends {nullable: true} ? null : never)\n\nexport type JTDDataType<S> = S extends {definitions: Record<string, unknown>}\n  ? JTDDataDef<S, S[\"definitions\"]>\n  : JTDDataDef<S, Record<string, never>>\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}