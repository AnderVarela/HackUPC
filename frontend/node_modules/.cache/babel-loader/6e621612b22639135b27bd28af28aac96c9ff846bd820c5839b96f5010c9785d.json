{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _core = require(\"@babel/core\");\nconst buildClassDecorator = _core.template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`);\nconst buildClassPrototype = (0, _core.template)(`\n  CLASS_REF.prototype;\n`);\nconst buildGetDescriptor = (0, _core.template)(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`);\nconst buildGetObjectInitializer = (0, _core.template)(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`);\nconst WARNING_CALLS = new WeakSet();\nfunction applyEnsureOrdering(path) {\n  const decorators = (path.isClass() ? [path, ...path.get(\"body.body\")] : path.get(\"properties\")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);\n  const identDecorators = decorators.filter(decorator => !_core.types.isIdentifier(decorator.expression));\n  if (identDecorators.length === 0) return;\n  return _core.types.sequenceExpression(identDecorators.map(decorator => {\n    const expression = decorator.expression;\n    const id = decorator.expression = path.scope.generateDeclaredUidIdentifier(\"dec\");\n    return _core.types.assignmentExpression(\"=\", id, expression);\n  }).concat([path.node]));\n}\nfunction applyClassDecorators(classPath) {\n  if (!hasClassDecorators(classPath.node)) return;\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {\n    return buildClassDecorator({\n      CLASS_REF: _core.types.cloneNode(name),\n      DECORATOR: _core.types.cloneNode(decorator),\n      INNER: acc\n    }).expression;\n  }, classPath.node);\n}\nfunction hasClassDecorators(classNode) {\n  var _classNode$decorators;\n  return !!((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length);\n}\nfunction applyMethodDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n  return applyTargetDecorators(path, state, path.node.body.body);\n}\nfunction hasMethodDecorators(body) {\n  return body.some(node => {\n    var _node$decorators;\n    return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;\n  });\n}\nfunction applyObjectDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n  return applyTargetDecorators(path, state, path.node.properties.filter(prop => prop.type !== \"SpreadElement\"));\n}\nfunction applyTargetDecorators(path, state, decoratedProps) {\n  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? \"class\" : \"obj\");\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    let decorators = [];\n    if (node.decorators != null) {\n      decorators = node.decorators;\n      node.decorators = null;\n    }\n    if (decorators.length === 0) return acc;\n    if (node.computed) {\n      throw path.buildCodeFrameError(\"Computed method/property decorators are not yet supported.\");\n    }\n    const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name);\n    const target = path.isClass() && !node.static ? buildClassPrototype({\n      CLASS_REF: name\n    }).expression : name;\n    if (_core.types.isClassProperty(node, {\n      static: false\n    })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n      const initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();\n      node.value = _core.types.callExpression(state.addHelper(\"initializerWarningHelper\"), [descriptor, _core.types.thisExpression()]);\n      WARNING_CALLS.add(node.value);\n      acc.push(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"configurable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"enumerable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"writable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"initializer\"), initializer)])])));\n    } else {\n      acc.push(_core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, {\n        static: true\n      }) ? buildGetObjectInitializer({\n        TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression : buildGetDescriptor({\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression, _core.types.cloneNode(target)]));\n    }\n    return acc;\n  }, []);\n  return _core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);\n}\nfunction decoratedClassToExpression({\n  node,\n  scope\n}) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n  const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier(\"class\");\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);\n}\nconst visitor = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n    const replacement = decoratedClassToExpression(decl);\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier(\"default\"))])]);\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n    if (replacement) {\n      const [newPath] = path.replaceWith(replacement);\n      const decl = newPath.get(\"declarations.0\");\n      const id = decl.node.id;\n      const binding = path.scope.getOwnBinding(id.name);\n      binding.identifier = id;\n      binding.path = decl;\n    }\n  },\n  ClassExpression(path, state) {\n    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n  ObjectExpression(path, state) {\n    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"left.object\").node), _core.types.stringLiteral(path.get(\"left.property\").node.name || path.get(\"left.property\").node.value), _core.types.cloneNode(path.get(\"right.arguments\")[0].node), _core.types.cloneNode(path.get(\"right.arguments\")[1].node)]));\n  },\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments\")[1].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[1].node)]));\n  }\n};\nvar _default = exports.default = visitor;","map":{"version":3,"names":["_core","require","buildClassDecorator","template","statement","buildClassPrototype","buildGetDescriptor","buildGetObjectInitializer","WARNING_CALLS","WeakSet","applyEnsureOrdering","path","decorators","isClass","get","reduce","acc","prop","concat","node","identDecorators","filter","decorator","types","isIdentifier","expression","length","sequenceExpression","map","id","scope","generateDeclaredUidIdentifier","assignmentExpression","applyClassDecorators","classPath","hasClassDecorators","name","dec","reverse","CLASS_REF","cloneNode","DECORATOR","INNER","classNode","_classNode$decorators","applyMethodDecorators","state","hasMethodDecorators","body","applyTargetDecorators","some","_node$decorators","applyObjectDecorators","properties","type","decoratedProps","exprs","computed","buildCodeFrameError","property","isLiteral","key","stringLiteral","target","static","isClassProperty","descriptor","initializer","value","functionExpression","blockStatement","returnStatement","nullLiteral","callExpression","addHelper","thisExpression","add","push","arrayExpression","objectExpression","objectProperty","identifier","booleanLiteral","isObjectProperty","TEMP","TARGET","PROPERTY","decoratedClassToExpression","ref","generateUidIdentifier","variableDeclaration","variableDeclarator","toExpression","visitor","ExportDefaultDeclaration","decl","isClassDeclaration","replacement","varDeclPath","replaceWithMultiple","exportNamedDeclaration","exportSpecifier","declarations","registerDeclaration","ClassDeclaration","newPath","replaceWith","binding","getOwnBinding","ClassExpression","decoratedClass","ObjectExpression","decoratedObject","AssignmentExpression","has","right","CallExpression","arguments","callee","_default","exports","default"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-proposal-decorators\\src\\transformer-legacy.ts"],"sourcesContent":["// Fork of https://github.com/loganfsmyth/babel-plugin-proposal-decorators-legacy\n\nimport { template, types as t, type PluginPass } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\n\nconst buildClassDecorator = template.statement(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`) as (replacements: {\n  DECORATOR: t.Expression;\n  CLASS_REF: t.Identifier;\n  INNER: t.Expression;\n}) => t.ExpressionStatement;\n\nconst buildClassPrototype = template(`\n  CLASS_REF.prototype;\n`) as (replacements: { CLASS_REF: t.Identifier }) => t.ExpressionStatement;\n\nconst buildGetDescriptor = template(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`) as (replacements: {\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst buildGetObjectInitializer = template(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`) as (replacements: {\n  TEMP: t.Identifier;\n  TARGET: t.Expression;\n  PROPERTY: t.Literal;\n}) => t.ExpressionStatement;\n\nconst WARNING_CALLS = new WeakSet();\n\n// legacy decorator does not support ClassAccessorProperty\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty;\n\n/**\n * If the decorator expressions are non-identifiers, hoist them to before the class so we can be sure\n * that they are evaluated in order.\n */\nfunction applyEnsureOrdering(\n  path: NodePath<t.ClassExpression | t.ObjectExpression>,\n) {\n  // TODO: This should probably also hoist computed properties.\n  const decorators: t.Decorator[] = (\n    path.isClass()\n      ? [\n          path,\n          ...(path.get(\"body.body\") as NodePath<ClassDecoratableElement>[]),\n        ]\n      : path.get(\"properties\")\n  ).reduce(\n    (\n      acc: t.Decorator[],\n      prop: NodePath<\n        t.ObjectMember | t.ClassExpression | ClassDecoratableElement\n      >,\n    ) => acc.concat(prop.node.decorators || []),\n    [],\n  );\n\n  const identDecorators = decorators.filter(\n    decorator => !t.isIdentifier(decorator.expression),\n  );\n  if (identDecorators.length === 0) return;\n\n  return t.sequenceExpression(\n    identDecorators\n      .map((decorator): t.Expression => {\n        const expression = decorator.expression;\n        const id = (decorator.expression =\n          path.scope.generateDeclaredUidIdentifier(\"dec\"));\n        return t.assignmentExpression(\"=\", id, expression);\n      })\n      .concat([path.node]),\n  );\n}\n\n/**\n * Given a class expression with class-level decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyClassDecorators(classPath: NodePath<t.ClassExpression>) {\n  if (!hasClassDecorators(classPath.node)) return;\n\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n\n  return decorators\n    .map(dec => dec.expression)\n    .reverse()\n    .reduce(function (acc, decorator) {\n      return buildClassDecorator({\n        CLASS_REF: t.cloneNode(name),\n        DECORATOR: t.cloneNode(decorator),\n        INNER: acc,\n      }).expression;\n    }, classPath.node);\n}\n\nfunction hasClassDecorators(classNode: t.Class) {\n  return !!classNode.decorators?.length;\n}\n\n/**\n * Given a class expression with method-level decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyMethodDecorators(\n  path: NodePath<t.ClassExpression>,\n  state: PluginPass,\n) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n\n  return applyTargetDecorators(\n    path,\n    state,\n    // @ts-expect-error ClassAccessorProperty is not supported in legacy decorator\n    path.node.body.body,\n  );\n}\n\nfunction hasMethodDecorators(\n  body: t.ClassBody[\"body\"] | t.ObjectExpression[\"properties\"],\n) {\n  return body.some(\n    node =>\n      // @ts-expect-error decorators not in SpreadElement/StaticBlock\n      node.decorators?.length,\n  );\n}\n\n/**\n * Given an object expression with property decorators, create a new expression\n * with the proper decorated behavior.\n */\nfunction applyObjectDecorators(\n  path: NodePath<t.ObjectExpression>,\n  state: PluginPass,\n) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n\n  return applyTargetDecorators(\n    path,\n    state,\n    path.node.properties.filter(\n      (prop): prop is t.ObjectMember => prop.type !== \"SpreadElement\",\n    ),\n  );\n}\n\n/**\n * A helper to pull out property decorators into a sequence expression.\n */\nfunction applyTargetDecorators(\n  path: NodePath<t.ClassExpression | t.ObjectExpression>,\n  state: PluginPass,\n  decoratedProps: (t.ObjectMember | ClassDecoratableElement)[],\n) {\n  const name = path.scope.generateDeclaredUidIdentifier(\n    path.isClass() ? \"class\" : \"obj\",\n  );\n\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    let decorators: t.Decorator[] = [];\n    if (node.decorators != null) {\n      decorators = node.decorators;\n      node.decorators = null;\n    }\n\n    if (decorators.length === 0) return acc;\n\n    if (\n      // @ts-expect-error computed is not in ClassPrivateProperty\n      node.computed\n    ) {\n      throw path.buildCodeFrameError(\n        \"Computed method/property decorators are not yet supported.\",\n      );\n    }\n\n    const property: t.Literal = t.isLiteral(node.key)\n      ? node.key\n      : t.stringLiteral(\n          // @ts-expect-error: should we handle ClassPrivateProperty?\n          node.key.name,\n        );\n\n    const target =\n      path.isClass() && !(node as ClassDecoratableElement).static\n        ? buildClassPrototype({\n            CLASS_REF: name,\n          }).expression\n        : name;\n\n    if (t.isClassProperty(node, { static: false })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n\n      const initializer = node.value\n        ? t.functionExpression(\n            null,\n            [],\n            t.blockStatement([t.returnStatement(node.value)]),\n          )\n        : t.nullLiteral();\n\n      node.value = t.callExpression(\n        state.addHelper(\"initializerWarningHelper\"),\n        [descriptor, t.thisExpression()],\n      );\n\n      WARNING_CALLS.add(node.value);\n\n      acc.push(\n        t.assignmentExpression(\n          \"=\",\n          t.cloneNode(descriptor),\n          t.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [\n            t.cloneNode(target),\n            t.cloneNode(property),\n            t.arrayExpression(\n              decorators.map(dec => t.cloneNode(dec.expression)),\n            ),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier(\"configurable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(\n                t.identifier(\"enumerable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(\n                t.identifier(\"writable\"),\n                t.booleanLiteral(true),\n              ),\n              t.objectProperty(t.identifier(\"initializer\"), initializer),\n            ]),\n          ]),\n        ),\n      );\n    } else {\n      acc.push(\n        t.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [\n          t.cloneNode(target),\n          t.cloneNode(property),\n          t.arrayExpression(decorators.map(dec => t.cloneNode(dec.expression))),\n          t.isObjectProperty(node) || t.isClassProperty(node, { static: true })\n            ? buildGetObjectInitializer({\n                TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n                TARGET: t.cloneNode(target),\n                PROPERTY: t.cloneNode(property),\n              }).expression\n            : buildGetDescriptor({\n                TARGET: t.cloneNode(target),\n                PROPERTY: t.cloneNode(property),\n              }).expression,\n          t.cloneNode(target),\n        ]),\n      );\n    }\n\n    return acc;\n  }, []);\n\n  return t.sequenceExpression([\n    t.assignmentExpression(\"=\", t.cloneNode(name), path.node),\n    t.sequenceExpression(exprs),\n    t.cloneNode(name),\n  ]);\n}\n\nfunction decoratedClassToExpression({ node, scope }: NodePath<t.Class>) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n\n  const ref = node.id\n    ? t.cloneNode(node.id)\n    : scope.generateUidIdentifier(\"class\");\n\n  return t.variableDeclaration(\"let\", [\n    t.variableDeclarator(ref, t.toExpression(node)),\n  ]);\n}\n\nconst visitor: Visitor<PluginPass> = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n\n    const replacement = decoratedClassToExpression(decl);\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([\n        replacement,\n        t.exportNamedDeclaration(null, [\n          t.exportSpecifier(\n            // @ts-expect-error todo(flow->ts) might be add more specific return type for decoratedClassToExpression\n            t.cloneNode(replacement.declarations[0].id),\n            t.identifier(\"default\"),\n          ),\n        ]),\n      ]);\n\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n    if (replacement) {\n      const [newPath] = path.replaceWith(replacement);\n\n      const decl = newPath.get(\"declarations.0\");\n      const id = decl.node.id as t.Identifier;\n\n      // TODO: Maybe add this logic to @babel/traverse\n      const binding = path.scope.getOwnBinding(id.name);\n      binding.identifier = id;\n      binding.path = decl;\n    }\n  },\n  ClassExpression(path, state) {\n    // Create a replacement for the class node if there is one. We do one pass to replace classes with\n    // class decorators, and a second pass to process method decorators.\n    const decoratedClass =\n      applyEnsureOrdering(path) ||\n      applyClassDecorators(path) ||\n      applyMethodDecorators(path, state);\n\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n  ObjectExpression(path, state) {\n    const decoratedObject =\n      applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n\n    path.replaceWith(\n      t.callExpression(state.addHelper(\"initializerDefineProperty\"), [\n        // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n        t.cloneNode(path.get(\"left.object\").node),\n        t.stringLiteral(\n          // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n          path.get(\"left.property\").node.name ||\n            // @ts-expect-error todo(flow->ts) typesafe NodePath.get\n            path.get(\"left.property\").node.value,\n        ),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"right.arguments\")[0].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"right.arguments\")[1].node),\n      ]),\n    );\n  },\n\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n\n    // If the class properties plugin isn't enabled, this line will add an unused helper\n    // to the code. It's not ideal, but it's ok since the configuration is not valid anyway.\n    // @ts-expect-error todo(flow->ts) check that `callee` is Identifier\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n\n    path.replaceWith(\n      t.callExpression(state.addHelper(\"initializerDefineProperty\"), [\n        t.cloneNode(path.get(\"arguments\")[0].node),\n        t.cloneNode(path.get(\"arguments\")[1].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"arguments.2.arguments\")[0].node),\n        // @ts-expect-error todo(flow->ts)\n        t.cloneNode(path.get(\"arguments.2.arguments\")[1].node),\n      ]),\n    );\n  },\n};\n\nexport default visitor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}