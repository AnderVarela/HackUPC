{"ast":null,"code":"const traversed = Symbol('traversed');\nfunction isJSXElementOrReactCreateElement(path) {\n  let visited = false;\n  path.traverse({\n    CallExpression(path2) {\n      const callee = path2.get('callee');\n      if (callee.matchesPattern('React.createElement') || callee.matchesPattern('React.cloneElement') || callee.node.name === 'cloneElement') {\n        visited = true;\n      }\n    },\n    JSXElement() {\n      visited = true;\n    }\n  });\n  return visited;\n}\nfunction isReturningJSXElement(path, iteration = 0) {\n  // Early exit for ArrowFunctionExpressions, there is no ReturnStatement node.\n  if (path.node.init && path.node.init.body && isJSXElementOrReactCreateElement(path)) {\n    return true;\n  }\n  if (iteration > 20) {\n    throw new Error('transform-react-remove-prop-type: infinite loop detected.');\n  }\n  let visited = false;\n  path.traverse({\n    ReturnStatement(path2) {\n      // We have already found what we are looking for.\n      if (visited) {\n        return;\n      }\n      const argument = path2.get('argument');\n\n      // Nothing is returned\n      if (!argument.node) {\n        return;\n      }\n      if (isJSXElementOrReactCreateElement(path2)) {\n        visited = true;\n        return;\n      }\n      if (argument.node.type === 'CallExpression') {\n        const name = argument.get('callee').node.name;\n        const binding = path.scope.getBinding(name);\n        if (!binding) {\n          return;\n        }\n\n        // Prevents infinite traverse loop.\n        if (binding.path[traversed]) {\n          return;\n        }\n        binding.path[traversed] = true;\n        if (isReturningJSXElement(binding.path, iteration + 1)) {\n          visited = true;\n        }\n      }\n    }\n  });\n  return visited;\n}\nconst VALID_POSSIBLE_STATELESS_COMPONENT_TYPES = ['VariableDeclarator', 'FunctionDeclaration'];\n\n// Returns `true` if the path represents a function which returns a JSXElement\nexport default function isStatelessComponent(path) {\n  if (VALID_POSSIBLE_STATELESS_COMPONENT_TYPES.indexOf(path.node.type) === -1) {\n    return false;\n  }\n  if (isReturningJSXElement(path)) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["traversed","Symbol","isJSXElementOrReactCreateElement","path","visited","traverse","CallExpression","path2","callee","get","matchesPattern","node","name","JSXElement","isReturningJSXElement","iteration","init","body","Error","ReturnStatement","argument","type","binding","scope","getBinding","VALID_POSSIBLE_STATELESS_COMPONENT_TYPES","isStatelessComponent","indexOf"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/src/isStatelessComponent.js"],"sourcesContent":["const traversed = Symbol('traversed')\n\nfunction isJSXElementOrReactCreateElement(path) {\n  let visited = false\n\n  path.traverse({\n    CallExpression(path2) {\n      const callee = path2.get('callee')\n\n      if (\n        callee.matchesPattern('React.createElement') ||\n        callee.matchesPattern('React.cloneElement') ||\n        callee.node.name === 'cloneElement'\n      ) {\n        visited = true\n      }\n    },\n    JSXElement() {\n      visited = true\n    },\n  })\n\n  return visited\n}\n\nfunction isReturningJSXElement(path, iteration = 0) {\n  // Early exit for ArrowFunctionExpressions, there is no ReturnStatement node.\n  if (path.node.init && path.node.init.body && isJSXElementOrReactCreateElement(path)) {\n    return true\n  }\n\n  if (iteration > 20) {\n    throw new Error('transform-react-remove-prop-type: infinite loop detected.')\n  }\n\n  let visited = false\n\n  path.traverse({\n    ReturnStatement(path2) {\n      // We have already found what we are looking for.\n      if (visited) {\n        return\n      }\n\n      const argument = path2.get('argument')\n\n      // Nothing is returned\n      if (!argument.node) {\n        return\n      }\n\n      if (isJSXElementOrReactCreateElement(path2)) {\n        visited = true\n        return\n      }\n\n      if (argument.node.type === 'CallExpression') {\n        const name = argument.get('callee').node.name\n        const binding = path.scope.getBinding(name)\n\n        if (!binding) {\n          return\n        }\n\n        // Prevents infinite traverse loop.\n        if (binding.path[traversed]) {\n          return\n        }\n\n        binding.path[traversed] = true\n\n        if (isReturningJSXElement(binding.path, iteration + 1)) {\n          visited = true\n        }\n      }\n    },\n  })\n\n  return visited\n}\n\nconst VALID_POSSIBLE_STATELESS_COMPONENT_TYPES = ['VariableDeclarator', 'FunctionDeclaration']\n\n// Returns `true` if the path represents a function which returns a JSXElement\nexport default function isStatelessComponent(path) {\n  if (VALID_POSSIBLE_STATELESS_COMPONENT_TYPES.indexOf(path.node.type) === -1) {\n    return false\n  }\n\n  if (isReturningJSXElement(path)) {\n    return true\n  }\n\n  return false\n}\n"],"mappings":"AAAA,MAAMA,SAAS,GAAGC,MAAM,CAAC,WAAW,CAAC;AAErC,SAASC,gCAAgCA,CAACC,IAAI,EAAE;EAC9C,IAAIC,OAAO,GAAG,KAAK;EAEnBD,IAAI,CAACE,QAAQ,CAAC;IACZC,cAAcA,CAACC,KAAK,EAAE;MACpB,MAAMC,MAAM,GAAGD,KAAK,CAACE,GAAG,CAAC,QAAQ,CAAC;MAElC,IACED,MAAM,CAACE,cAAc,CAAC,qBAAqB,CAAC,IAC5CF,MAAM,CAACE,cAAc,CAAC,oBAAoB,CAAC,IAC3CF,MAAM,CAACG,IAAI,CAACC,IAAI,KAAK,cAAc,EACnC;QACAR,OAAO,GAAG,IAAI;MAChB;IACF,CAAC;IACDS,UAAUA,CAAA,EAAG;MACXT,OAAO,GAAG,IAAI;IAChB;EACF,CAAC,CAAC;EAEF,OAAOA,OAAO;AAChB;AAEA,SAASU,qBAAqBA,CAACX,IAAI,EAAEY,SAAS,GAAG,CAAC,EAAE;EAClD;EACA,IAAIZ,IAAI,CAACQ,IAAI,CAACK,IAAI,IAAIb,IAAI,CAACQ,IAAI,CAACK,IAAI,CAACC,IAAI,IAAIf,gCAAgC,CAACC,IAAI,CAAC,EAAE;IACnF,OAAO,IAAI;EACb;EAEA,IAAIY,SAAS,GAAG,EAAE,EAAE;IAClB,MAAM,IAAIG,KAAK,CAAC,2DAA2D,CAAC;EAC9E;EAEA,IAAId,OAAO,GAAG,KAAK;EAEnBD,IAAI,CAACE,QAAQ,CAAC;IACZc,eAAeA,CAACZ,KAAK,EAAE;MACrB;MACA,IAAIH,OAAO,EAAE;QACX;MACF;MAEA,MAAMgB,QAAQ,GAAGb,KAAK,CAACE,GAAG,CAAC,UAAU,CAAC;;MAEtC;MACA,IAAI,CAACW,QAAQ,CAACT,IAAI,EAAE;QAClB;MACF;MAEA,IAAIT,gCAAgC,CAACK,KAAK,CAAC,EAAE;QAC3CH,OAAO,GAAG,IAAI;QACd;MACF;MAEA,IAAIgB,QAAQ,CAACT,IAAI,CAACU,IAAI,KAAK,gBAAgB,EAAE;QAC3C,MAAMT,IAAI,GAAGQ,QAAQ,CAACX,GAAG,CAAC,QAAQ,CAAC,CAACE,IAAI,CAACC,IAAI;QAC7C,MAAMU,OAAO,GAAGnB,IAAI,CAACoB,KAAK,CAACC,UAAU,CAACZ,IAAI,CAAC;QAE3C,IAAI,CAACU,OAAO,EAAE;UACZ;QACF;;QAEA;QACA,IAAIA,OAAO,CAACnB,IAAI,CAACH,SAAS,CAAC,EAAE;UAC3B;QACF;QAEAsB,OAAO,CAACnB,IAAI,CAACH,SAAS,CAAC,GAAG,IAAI;QAE9B,IAAIc,qBAAqB,CAACQ,OAAO,CAACnB,IAAI,EAAEY,SAAS,GAAG,CAAC,CAAC,EAAE;UACtDX,OAAO,GAAG,IAAI;QAChB;MACF;IACF;EACF,CAAC,CAAC;EAEF,OAAOA,OAAO;AAChB;AAEA,MAAMqB,wCAAwC,GAAG,CAAC,oBAAoB,EAAE,qBAAqB,CAAC;;AAE9F;AACA,eAAe,SAASC,oBAAoBA,CAACvB,IAAI,EAAE;EACjD,IAAIsB,wCAAwC,CAACE,OAAO,CAACxB,IAAI,CAACQ,IAAI,CAACU,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;IAC3E,OAAO,KAAK;EACd;EAEA,IAAIP,qBAAqB,CAACX,IAAI,CAAC,EAAE;IAC/B,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}