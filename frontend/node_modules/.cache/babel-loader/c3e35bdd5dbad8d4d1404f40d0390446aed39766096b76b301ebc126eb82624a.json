{"ast":null,"code":"const maxDistance = 3;\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(d[i - 1][j] + 1,\n      // deletion\n      d[i][j - 1] + 1,\n      // insertion\n      d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach(candidate => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\nexports.suggestSimilar = suggestSimilar;","map":{"version":3,"names":["maxDistance","editDistance","a","b","Math","abs","length","max","d","i","j","cost","min","suggestSimilar","word","candidates","Array","from","Set","searchingOptions","startsWith","slice","map","candidate","similar","bestDistance","minSimilarity","forEach","distance","similarity","push","sort","localeCompare","join","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/commander/lib/suggestSimilar.js"],"sourcesContent":["const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}