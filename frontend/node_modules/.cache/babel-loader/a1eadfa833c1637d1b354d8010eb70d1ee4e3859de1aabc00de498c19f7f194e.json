{"ast":null,"code":"'use strict';\n\nconst assert = require('chai').assert;\nconst proxyquire = require('proxyquire');\nconst spooks = require('spooks');\nconst modulePath = '../../src/read';\nsuite('read:', () => {\n  test('require does not throw', () => {\n    assert.doesNotThrow(() => {\n      require(modulePath);\n    });\n  });\n  test('require returns function', () => {\n    assert.isFunction(require(modulePath));\n  });\n  suite('require:', () => {\n    let log, results, read;\n    setup(() => {\n      log = {};\n      results = {\n        parse: [{}],\n        createReadStream: [{}]\n      };\n      read = proxyquire(modulePath, {\n        fs: {\n          createReadStream: spooks.fn({\n            name: 'createReadStream',\n            log: log,\n            results: results.createReadStream\n          })\n        },\n        './parse': spooks.fn({\n          name: 'parse',\n          log: log,\n          results: results.parse\n        })\n      });\n    });\n    test('read expects two arguments', () => {\n      assert.lengthOf(read, 2);\n    });\n    test('read does not throw', () => {\n      assert.doesNotThrow(() => {\n        read();\n      });\n    });\n    test('parse was not called', () => {\n      assert.strictEqual(log.counts.parse, 0);\n    });\n    test('fs.createReadStream was not called', () => {\n      assert.strictEqual(log.counts.createReadStream, 0);\n    });\n    suite('read:', () => {\n      let path, options, result;\n      setup(() => {\n        path = {};\n        options = {\n          foo: 'bar',\n          ndjson: true\n        };\n        result = read(path, options);\n      });\n      test('fs.createReadStream was called once', () => {\n        assert.strictEqual(log.counts.createReadStream, 1);\n      });\n      test('fs.createReadStream was called correctly', () => {\n        assert.lengthOf(log.args.createReadStream[0], 2);\n        assert.strictEqual(log.args.createReadStream[0][0], path);\n        assert.lengthOf(Object.keys(log.args.createReadStream[0][0]), 0);\n        assert.strictEqual(log.args.createReadStream[0][1], options);\n        assert.lengthOf(Object.keys(log.args.createReadStream[0][1]), 2);\n      });\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1);\n      });\n      test('parse was called correctly', () => {\n        assert.isUndefined(log.these.parse[0]);\n        assert.lengthOf(log.args.parse[0], 2);\n        assert.strictEqual(log.args.parse[0][0], results.createReadStream[0]);\n        assert.lengthOf(Object.keys(log.args.parse[0][0]), 0);\n        assert.notStrictEqual(log.args.parse[0][1], options);\n        assert.deepEqual(log.args.parse[0][1], {\n          foo: 'bar',\n          ndjson: false\n        });\n      });\n      test('parse result was returned', () => {\n        assert.strictEqual(result, results.parse[0]);\n      });\n    });\n  });\n});","map":{"version":3,"names":["assert","require","proxyquire","spooks","modulePath","suite","test","doesNotThrow","isFunction","log","results","read","setup","parse","createReadStream","fs","fn","name","lengthOf","strictEqual","counts","path","options","result","foo","ndjson","args","Object","keys","isUndefined","these","notStrictEqual","deepEqual"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/test/unit/read.js"],"sourcesContent":["'use strict'\n\nconst assert = require('chai').assert\nconst proxyquire = require('proxyquire')\nconst spooks = require('spooks')\n\nconst modulePath = '../../src/read'\n\nsuite('read:', () => {\n  test('require does not throw', () => {\n    assert.doesNotThrow(() => {\n      require(modulePath)\n    })\n  })\n\n  test('require returns function', () => {\n    assert.isFunction(require(modulePath))\n  })\n\n  suite('require:', () => {\n    let log, results, read\n\n    setup(() => {\n      log = {}\n      results = {\n        parse: [ {} ],\n        createReadStream: [ {} ]\n      }\n      read = proxyquire(modulePath, {\n        fs: {\n          createReadStream: spooks.fn({\n            name: 'createReadStream',\n            log: log,\n            results: results.createReadStream\n          })\n        },\n        './parse': spooks.fn({\n          name: 'parse',\n          log: log,\n          results: results.parse\n        })\n      })\n    })\n\n    test('read expects two arguments', () => {\n      assert.lengthOf(read, 2)\n    })\n\n    test('read does not throw', () => {\n      assert.doesNotThrow(() => {\n        read()\n      })\n    })\n\n    test('parse was not called', () => {\n      assert.strictEqual(log.counts.parse, 0)\n    })\n\n    test('fs.createReadStream was not called', () => {\n      assert.strictEqual(log.counts.createReadStream, 0)\n    })\n\n    suite('read:', () => {\n      let path, options, result\n\n      setup(() => {\n        path = {}\n        options = { foo: 'bar', ndjson: true }\n        result = read(path, options)\n      })\n\n      test('fs.createReadStream was called once', () => {\n        assert.strictEqual(log.counts.createReadStream, 1)\n      })\n\n      test('fs.createReadStream was called correctly', () => {\n        assert.lengthOf(log.args.createReadStream[0], 2)\n        assert.strictEqual(log.args.createReadStream[0][0], path)\n        assert.lengthOf(Object.keys(log.args.createReadStream[0][0]), 0)\n        assert.strictEqual(log.args.createReadStream[0][1], options)\n        assert.lengthOf(Object.keys(log.args.createReadStream[0][1]), 2)\n      })\n\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1)\n      })\n\n      test('parse was called correctly', () => {\n        assert.isUndefined(log.these.parse[0])\n        assert.lengthOf(log.args.parse[0], 2)\n        assert.strictEqual(log.args.parse[0][0], results.createReadStream[0])\n        assert.lengthOf(Object.keys(log.args.parse[0][0]), 0)\n        assert.notStrictEqual(log.args.parse[0][1], options)\n        assert.deepEqual(log.args.parse[0][1], { foo: 'bar', ndjson: false })\n      })\n\n      test('parse result was returned', () => {\n        assert.strictEqual(result, results.parse[0])\n      })\n    })\n  })\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}