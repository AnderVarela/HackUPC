{"ast":null,"code":"const definitions = require(\"../src/definitions\");\nconst flatMap = require(\"array.prototype.flatmap\");\nconst {\n  typeSignature,\n  iterateProps,\n  mapProps,\n  filterProps,\n  unique\n} = require(\"./util\");\nconst stdout = process.stdout;\nconst jsTypes = [\"string\", \"number\", \"boolean\"];\nconst quote = value => `\"${value}\"`;\nfunction params(fields) {\n  const optionalDefault = field => field.default ? ` = ${field.default}` : \"\";\n  return mapProps(fields).map(field => `${typeSignature(field)}${optionalDefault(field)}`).join(\",\");\n}\nfunction assertParamType({\n  assertNodeType,\n  array,\n  name,\n  type\n}) {\n  if (array) {\n    // TODO - assert contents of array?\n    return `assert(typeof ${name} === \"object\" && typeof ${name}.length !== \"undefined\")\\n`;\n  } else {\n    if (jsTypes.includes(type)) {\n      return `assert(\n          typeof ${name} === \"${type}\",\n          \"Argument ${name} must be of type ${type}, given: \" + typeof ${name}\n      )`;\n    }\n    if (assertNodeType === true) {\n      return `assert(\n        ${name}.type === \"${type}\",\n        \"Argument ${name} must be of type ${type}, given: \" + ${name}.type\n      )`;\n    }\n    return \"\";\n  }\n}\nfunction assertParam(meta) {\n  const paramAssertion = assertParamType(meta);\n  if (paramAssertion === \"\") {\n    return \"\";\n  }\n  if (meta.maybe || meta.optional) {\n    return `\n      if (${meta.name} !== null && ${meta.name} !== undefined) {\n        ${paramAssertion};\n      }\n    `;\n  } else {\n    return paramAssertion;\n  }\n}\nfunction assertParams(fields) {\n  return mapProps(fields).map(assertParam).join(\"\\n\");\n}\nfunction buildObject(typeDef) {\n  const optionalField = meta => {\n    if (meta.array) {\n      // omit optional array properties if the constructor function was supplied\n      // with an empty array\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && ${meta.name}.length > 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"Object\") {\n      // omit optional object properties if they have no keys\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && Object.keys(${meta.name}).length !== 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"boolean\") {\n      // omit optional boolean properties if they are not true\n      return `\n        if (${meta.name} === true) {\n          node.${meta.name} = true;\n        }\n      `;\n    } else {\n      return `\n        if (typeof ${meta.name} !== \"undefined\") {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    }\n  };\n  const fields = mapProps(typeDef.fields).filter(f => !f.optional && !f.constant).map(f => f.name);\n  const constants = mapProps(typeDef.fields).filter(f => f.constant).map(f => `${f.name}: \"${f.value}\"`);\n  return `\n    const node: ${typeDef.flowTypeName || typeDef.name} = {\n      type: \"${typeDef.name}\",\n      ${constants.concat(fields).join(\",\")}\n    }\n\n    ${mapProps(typeDef.fields).filter(f => f.optional).map(optionalField).join(\"\")}\n  `;\n}\nfunction lowerCamelCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\nfunction generate() {\n  stdout.write(`\n    // @flow\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateNodeUtils.js\n\n    import { assert } from \"mamacro\";\n\n    function isTypeOf(t: string) {\n      return (n: Node) => n.type === t;\n    }\n\n    function assertTypeOf(t: string) {\n      return (n: Node) => assert(n.type === t);\n    }\n  `);\n\n  // Node builders\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export function ${lowerCamelCase(typeDefinition.name)} (\n        ${params(filterProps(typeDefinition.fields, f => !f.constant))}\n      ): ${typeDefinition.name} {\n\n        ${assertParams(filterProps(typeDefinition.fields, f => !f.constant))}\n        ${buildObject(typeDefinition)} \n\n        return node;\n      }\n    `);\n  });\n\n  // Node testers\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const is${typeDefinition.name}: ((n: Node) => boolean) =\n        isTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // Node union type testers\n  const unionTypes = unique(flatMap(mapProps(definitions).filter(d => d.unionType), d => d.unionType));\n  unionTypes.forEach(unionType => {\n    stdout.write(`\n      export const is${unionType} = (node: Node): boolean => ` + mapProps(definitions).filter(d => d.unionType && d.unionType.includes(unionType)).map(d => `is${d.name}(node) `).join(\"||\") + \";\\n\\n\");\n  });\n\n  // Node assertion\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const assert${typeDefinition.name}: ((n: Node) => void) =\n        assertTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // a map from node type to its set of union types\n  stdout.write(`\n    export const unionTypesMap = {` + mapProps(definitions).filter(d => d.unionType).map(t => `\"${t.name}\": [${t.unionType.map(quote).join(\",\")}]\\n`) + `};\n      `);\n\n  // an array of all node and union types\n  stdout.write(`\n    export const nodeAndUnionTypes = [` + mapProps(definitions).map(t => `\"${t.name}\"`).concat(unionTypes.map(quote)).join(\",\") + `];`);\n}\ngenerate();","map":{"version":3,"names":["definitions","require","flatMap","typeSignature","iterateProps","mapProps","filterProps","unique","stdout","process","jsTypes","quote","value","params","fields","optionalDefault","field","default","map","join","assertParamType","assertNodeType","array","name","type","includes","assertParam","meta","paramAssertion","maybe","optional","assertParams","buildObject","typeDef","optionalField","filter","f","constant","constants","flowTypeName","concat","lowerCamelCase","substring","toLowerCase","generate","write","typeDefinition","unionTypes","d","unionType","forEach","t"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/scripts/generateNodeUtils.js"],"sourcesContent":["const definitions = require(\"../src/definitions\");\nconst flatMap = require(\"array.prototype.flatmap\");\nconst {\n  typeSignature,\n  iterateProps,\n  mapProps,\n  filterProps,\n  unique,\n} = require(\"./util\");\n\nconst stdout = process.stdout;\n\nconst jsTypes = [\"string\", \"number\", \"boolean\"];\n\nconst quote = (value) => `\"${value}\"`;\n\nfunction params(fields) {\n  const optionalDefault = (field) =>\n    field.default ? ` = ${field.default}` : \"\";\n  return mapProps(fields)\n    .map((field) => `${typeSignature(field)}${optionalDefault(field)}`)\n    .join(\",\");\n}\n\nfunction assertParamType({ assertNodeType, array, name, type }) {\n  if (array) {\n    // TODO - assert contents of array?\n    return `assert(typeof ${name} === \"object\" && typeof ${name}.length !== \"undefined\")\\n`;\n  } else {\n    if (jsTypes.includes(type)) {\n      return `assert(\n          typeof ${name} === \"${type}\",\n          \"Argument ${name} must be of type ${type}, given: \" + typeof ${name}\n      )`;\n    }\n\n    if (assertNodeType === true) {\n      return `assert(\n        ${name}.type === \"${type}\",\n        \"Argument ${name} must be of type ${type}, given: \" + ${name}.type\n      )`;\n    }\n\n    return \"\";\n  }\n}\n\nfunction assertParam(meta) {\n  const paramAssertion = assertParamType(meta);\n\n  if (paramAssertion === \"\") {\n    return \"\";\n  }\n\n  if (meta.maybe || meta.optional) {\n    return `\n      if (${meta.name} !== null && ${meta.name} !== undefined) {\n        ${paramAssertion};\n      }\n    `;\n  } else {\n    return paramAssertion;\n  }\n}\n\nfunction assertParams(fields) {\n  return mapProps(fields).map(assertParam).join(\"\\n\");\n}\n\nfunction buildObject(typeDef) {\n  const optionalField = (meta) => {\n    if (meta.array) {\n      // omit optional array properties if the constructor function was supplied\n      // with an empty array\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && ${meta.name}.length > 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"Object\") {\n      // omit optional object properties if they have no keys\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && Object.keys(${meta.name}).length !== 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"boolean\") {\n      // omit optional boolean properties if they are not true\n      return `\n        if (${meta.name} === true) {\n          node.${meta.name} = true;\n        }\n      `;\n    } else {\n      return `\n        if (typeof ${meta.name} !== \"undefined\") {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    }\n  };\n\n  const fields = mapProps(typeDef.fields)\n    .filter((f) => !f.optional && !f.constant)\n    .map((f) => f.name);\n\n  const constants = mapProps(typeDef.fields)\n    .filter((f) => f.constant)\n    .map((f) => `${f.name}: \"${f.value}\"`);\n\n  return `\n    const node: ${typeDef.flowTypeName || typeDef.name} = {\n      type: \"${typeDef.name}\",\n      ${constants.concat(fields).join(\",\")}\n    }\n\n    ${mapProps(typeDef.fields)\n      .filter((f) => f.optional)\n      .map(optionalField)\n      .join(\"\")}\n  `;\n}\n\nfunction lowerCamelCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\n\nfunction generate() {\n  stdout.write(`\n    // @flow\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateNodeUtils.js\n\n    import { assert } from \"mamacro\";\n\n    function isTypeOf(t: string) {\n      return (n: Node) => n.type === t;\n    }\n\n    function assertTypeOf(t: string) {\n      return (n: Node) => assert(n.type === t);\n    }\n  `);\n\n  // Node builders\n  iterateProps(definitions, (typeDefinition) => {\n    stdout.write(`\n      export function ${lowerCamelCase(typeDefinition.name)} (\n        ${params(filterProps(typeDefinition.fields, (f) => !f.constant))}\n      ): ${typeDefinition.name} {\n\n        ${assertParams(filterProps(typeDefinition.fields, (f) => !f.constant))}\n        ${buildObject(typeDefinition)} \n\n        return node;\n      }\n    `);\n  });\n\n  // Node testers\n  iterateProps(definitions, (typeDefinition) => {\n    stdout.write(`\n      export const is${typeDefinition.name}: ((n: Node) => boolean) =\n        isTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // Node union type testers\n  const unionTypes = unique(\n    flatMap(\n      mapProps(definitions).filter((d) => d.unionType),\n      (d) => d.unionType\n    )\n  );\n  unionTypes.forEach((unionType) => {\n    stdout.write(\n      `\n      export const is${unionType} = (node: Node): boolean => ` +\n        mapProps(definitions)\n          .filter((d) => d.unionType && d.unionType.includes(unionType))\n          .map((d) => `is${d.name}(node) `)\n          .join(\"||\") +\n        \";\\n\\n\"\n    );\n  });\n\n  // Node assertion\n  iterateProps(definitions, (typeDefinition) => {\n    stdout.write(`\n      export const assert${typeDefinition.name}: ((n: Node) => void) =\n        assertTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // a map from node type to its set of union types\n  stdout.write(\n    `\n    export const unionTypesMap = {` +\n      mapProps(definitions)\n        .filter((d) => d.unionType)\n        .map((t) => `\"${t.name}\": [${t.unionType.map(quote).join(\",\")}]\\n`) +\n      `};\n      `\n  );\n\n  // an array of all node and union types\n  stdout.write(\n    `\n    export const nodeAndUnionTypes = [` +\n      mapProps(definitions)\n        .map((t) => `\"${t.name}\"`)\n        .concat(unionTypes.map(quote))\n        .join(\",\") +\n      `];`\n  );\n}\n\ngenerate();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}