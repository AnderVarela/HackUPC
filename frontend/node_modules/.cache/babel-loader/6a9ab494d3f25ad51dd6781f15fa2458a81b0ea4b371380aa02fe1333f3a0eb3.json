{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\n// Truthiness utilities\n// #region\nconst isTruthyLiteral = type => (0, tsutils_1.isBooleanLiteralType)(type, true) || (0, tsutils_1.isLiteralType)(type) && !!type.value;\nconst isPossiblyFalsy = type => (0, tsutils_1.unionTypeParts)(type)\n// PossiblyFalsy flag includes literal values, so exclude ones that\n// are definitely truthy\n.filter(t => !isTruthyLiteral(t)).some(type => (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.PossiblyFalsy));\nconst isPossiblyTruthy = type => (0, tsutils_1.unionTypeParts)(type).some(type => !(0, tsutils_1.isFalsyType)(type));\n// Nullish utilities\nconst nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;\nconst isNullishType = type => (0, util_1.isTypeFlagSet)(type, nullishFlag);\nconst isPossiblyNullish = type => (0, tsutils_1.unionTypeParts)(type).some(isNullishType);\nconst isAlwaysNullish = type => (0, tsutils_1.unionTypeParts)(type).every(isNullishType);\n// isLiteralType only covers numbers and strings, this is a more exhaustive check.\nconst isLiteral = type => (0, tsutils_1.isBooleanLiteralType)(type, true) || (0, tsutils_1.isBooleanLiteralType)(type, false) || type.flags === ts.TypeFlags.Undefined || type.flags === ts.TypeFlags.Null || type.flags === ts.TypeFlags.Void || (0, tsutils_1.isLiteralType)(type);\nexports.default = (0, util_1.createRule)({\n  name: 'no-unnecessary-condition',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow conditionals where the type is always truthy or always falsy',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowConstantLoopConditions: {\n          description: 'Whether to ignore constant loop conditions, such as `while (true)`.',\n          type: 'boolean'\n        },\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n          description: 'Whether to not error when running with a tsconfig that has strictNullChecks turned.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code',\n    messages: {\n      alwaysTruthy: 'Unnecessary conditional, value is always truthy.',\n      alwaysFalsy: 'Unnecessary conditional, value is always falsy.',\n      alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',\n      alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',\n      neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',\n      alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',\n      literalBooleanExpression: 'Unnecessary conditional, both sides of the expression are literal values.',\n      noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',\n      never: 'Unnecessary conditional, value is `never`.',\n      neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',\n      noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'\n    }\n  },\n  defaultOptions: [{\n    allowConstantLoopConditions: false,\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false\n  }],\n  create(context, [{\n    allowConstantLoopConditions,\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing\n  }]) {\n    const service = (0, util_1.getParserServices)(context);\n    const checker = service.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    const compilerOptions = service.program.getCompilerOptions();\n    const isStrictNullChecks = (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, 'strictNullChecks');\n    if (!isStrictNullChecks && allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n      context.report({\n        loc: {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        },\n        messageId: 'noStrictNullCheck'\n      });\n    }\n    function getNodeType(node) {\n      const tsNode = service.esTreeNodeToTSNodeMap.get(node);\n      return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);\n    }\n    function nodeIsArrayType(node) {\n      const nodeType = getNodeType(node);\n      return checker.isArrayType(nodeType);\n    }\n    function nodeIsTupleType(node) {\n      const nodeType = getNodeType(node);\n      return checker.isTupleType(nodeType);\n    }\n    function isArrayIndexExpression(node) {\n      return (\n        // Is an index signature\n        node.type === utils_1.AST_NODE_TYPES.MemberExpression && node.computed && (\n        // ...into an array type\n        nodeIsArrayType(node.object) ||\n        // ... or a tuple type\n        nodeIsTupleType(node.object) &&\n        // Exception: literal index into a tuple - will have a sound type\n        node.property.type !== utils_1.AST_NODE_TYPES.Literal)\n      );\n    }\n    /**\n     * Checks if a conditional node is necessary:\n     * if the type of the node is always true or always false, it's not necessary.\n     */\n    function checkNode(node, isUnaryNotArgument = false) {\n      // Check if the node is Unary Negation expression and handle it\n      if (node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!') {\n        return checkNode(node.argument, true);\n      }\n      // Since typescript array index signature types don't represent the\n      //  possibility of out-of-bounds access, if we're indexing into an array\n      //  just skip the check, to avoid false positives\n      if (isArrayIndexExpression(node)) {\n        return;\n      }\n      // When checking logical expressions, only check the right side\n      //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals\n      //\n      // Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict\n      //  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.\n      // In this case it's better to inspect the type of the expression as a whole.\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.operator !== '??') {\n        return checkNode(node.right);\n      }\n      const type = getNodeType(node);\n      // Conditional is always necessary if it involves:\n      //    `any` or `unknown` or a naked type variable\n      if ((0, tsutils_1.unionTypeParts)(type).some(part => (0, util_1.isTypeAnyType)(part) || (0, util_1.isTypeUnknownType)(part) || (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable))) {\n        return;\n      }\n      let messageId = null;\n      if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n        messageId = 'never';\n      } else if (!isPossiblyTruthy(type)) {\n        messageId = !isUnaryNotArgument ? 'alwaysFalsy' : 'alwaysTruthy';\n      } else if (!isPossiblyFalsy(type)) {\n        messageId = !isUnaryNotArgument ? 'alwaysTruthy' : 'alwaysFalsy';\n      }\n      if (messageId) {\n        context.report({\n          node,\n          messageId\n        });\n      }\n    }\n    function checkNodeForNullish(node) {\n      const type = getNodeType(node);\n      // Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter\n      if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.TypeParameter)) {\n        return;\n      }\n      let messageId = null;\n      if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n        messageId = 'never';\n      } else if (!isPossiblyNullish(type)) {\n        // Since typescript array index signature types don't represent the\n        //  possibility of out-of-bounds access, if we're indexing into an array\n        //  just skip the check, to avoid false positives\n        if (!isArrayIndexExpression(node) && !(node.type === utils_1.AST_NODE_TYPES.ChainExpression && node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression && optionChainContainsOptionArrayIndex(node.expression))) {\n          messageId = 'neverNullish';\n        }\n      } else if (isAlwaysNullish(type)) {\n        messageId = 'alwaysNullish';\n      }\n      if (messageId) {\n        context.report({\n          node,\n          messageId\n        });\n      }\n    }\n    /**\n     * Checks that a binary expression is necessarily conditional, reports otherwise.\n     * If both sides of the binary expression are literal values, it's not a necessary condition.\n     *\n     * NOTE: It's also unnecessary if the types that don't overlap at all\n     *    but that case is handled by the Typescript compiler itself.\n     *    Known exceptions:\n     *      * https://github.com/microsoft/TypeScript/issues/32627\n     *      * https://github.com/microsoft/TypeScript/issues/37160 (handled)\n     */\n    const BOOL_OPERATORS = new Set(['<', '>', '<=', '>=', '==', '===', '!=', '!==']);\n    function checkIfBinaryExpressionIsNecessaryConditional(node) {\n      if (!BOOL_OPERATORS.has(node.operator)) {\n        return;\n      }\n      const leftType = getNodeType(node.left);\n      const rightType = getNodeType(node.right);\n      if (isLiteral(leftType) && isLiteral(rightType)) {\n        context.report({\n          node,\n          messageId: 'literalBooleanExpression'\n        });\n        return;\n      }\n      // Workaround for https://github.com/microsoft/TypeScript/issues/37160\n      if (isStrictNullChecks) {\n        const UNDEFINED = ts.TypeFlags.Undefined;\n        const NULL = ts.TypeFlags.Null;\n        const VOID = ts.TypeFlags.Void;\n        const isComparable = (type, flag) => {\n          // Allow comparison to `any`, `unknown` or a naked type parameter.\n          flag |= ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.TypeParameter;\n          // Allow loose comparison to nullish values.\n          if (node.operator === '==' || node.operator === '!=') {\n            flag |= NULL | UNDEFINED | VOID;\n          }\n          return (0, util_1.isTypeFlagSet)(type, flag);\n        };\n        if (leftType.flags === UNDEFINED && !isComparable(rightType, UNDEFINED | VOID) || rightType.flags === UNDEFINED && !isComparable(leftType, UNDEFINED | VOID) || leftType.flags === NULL && !isComparable(rightType, NULL) || rightType.flags === NULL && !isComparable(leftType, NULL)) {\n          context.report({\n            node,\n            messageId: 'noOverlapBooleanExpression'\n          });\n          return;\n        }\n      }\n    }\n    /**\n     * Checks that a logical expression contains a boolean, reports otherwise.\n     */\n    function checkLogicalExpressionForUnnecessaryConditionals(node) {\n      if (node.operator === '??') {\n        checkNodeForNullish(node.left);\n        return;\n      }\n      // Only checks the left side, since the right side might not be \"conditional\" at all.\n      // The right side will be checked if the LogicalExpression is used in a conditional context\n      checkNode(node.left);\n    }\n    /**\n     * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.\n     */\n    function checkIfLoopIsNecessaryConditional(node) {\n      if (node.test == null) {\n        // e.g. `for(;;)`\n        return;\n      }\n      /**\n       * Allow:\n       *   while (true) {}\n       *   for (;true;) {}\n       *   do {} while (true)\n       */\n      if (allowConstantLoopConditions && (0, tsutils_1.isBooleanLiteralType)(getNodeType(node.test), true)) {\n        return;\n      }\n      checkNode(node.test);\n    }\n    const ARRAY_PREDICATE_FUNCTIONS = new Set(['filter', 'find', 'some', 'every']);\n    function isArrayPredicateFunction(node) {\n      const {\n        callee\n      } = node;\n      return (\n        // looks like `something.filter` or `something.find`\n        callee.type === utils_1.AST_NODE_TYPES.MemberExpression && callee.property.type === utils_1.AST_NODE_TYPES.Identifier && ARRAY_PREDICATE_FUNCTIONS.has(callee.property.name) && (\n        // and the left-hand side is an array, according to the types\n        nodeIsArrayType(callee.object) || nodeIsTupleType(callee.object))\n      );\n    }\n    function checkCallExpression(node) {\n      // If this is something like arr.filter(x => /*condition*/), check `condition`\n      if (isArrayPredicateFunction(node) && node.arguments.length) {\n        const callback = node.arguments[0];\n        // Inline defined functions\n        if ((callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) && callback.body) {\n          // Two special cases, where we can directly check the node that's returned:\n          // () => something\n          if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n            return checkNode(callback.body);\n          }\n          // () => { return something; }\n          const callbackBody = callback.body.body;\n          if (callbackBody.length === 1 && callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement && callbackBody[0].argument) {\n            return checkNode(callbackBody[0].argument);\n          }\n          // Potential enhancement: could use code-path analysis to check\n          //   any function with a single return statement\n          // (Value to complexity ratio is dubious however)\n        }\n        // Otherwise just do type analysis on the function as a whole.\n        const returnTypes = (0, tsutils_1.getCallSignaturesOfType)(getNodeType(callback)).map(sig => sig.getReturnType());\n        /* istanbul ignore if */\n        if (returnTypes.length === 0) {\n          // Not a callable function\n          return;\n        }\n        // Predicate is always necessary if it involves `any` or `unknown`\n        if (returnTypes.some(t => (0, util_1.isTypeAnyType)(t) || (0, util_1.isTypeUnknownType)(t))) {\n          return;\n        }\n        if (!returnTypes.some(isPossiblyFalsy)) {\n          return context.report({\n            node: callback,\n            messageId: 'alwaysTruthyFunc'\n          });\n        }\n        if (!returnTypes.some(isPossiblyTruthy)) {\n          return context.report({\n            node: callback,\n            messageId: 'alwaysFalsyFunc'\n          });\n        }\n      }\n    }\n    // Recursively searches an optional chain for an array index expression\n    //  Has to search the entire chain, because an array index will \"infect\" the rest of the types\n    //  Example:\n    //  ```\n    //  [{x: {y: \"z\"} }][n] // type is {x: {y: \"z\"}}\n    //    ?.x // type is {y: \"z\"}\n    //    ?.y // This access is considered \"unnecessary\" according to the types\n    //  ```\n    function optionChainContainsOptionArrayIndex(node) {\n      const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n      if (node.optional && isArrayIndexExpression(lhsNode)) {\n        return true;\n      }\n      if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression || lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        return optionChainContainsOptionArrayIndex(lhsNode);\n      }\n      return false;\n    }\n    function isNullablePropertyType(objType, propertyType) {\n      if (propertyType.isUnion()) {\n        return propertyType.types.some(type => isNullablePropertyType(objType, type));\n      }\n      if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {\n        const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());\n        if (propType) {\n          return (0, util_1.isNullableType)(propType, {\n            allowUndefined: true\n          });\n        }\n      }\n      const typeName = (0, util_1.getTypeName)(checker, propertyType);\n      return !!(typeName === 'string' && checker.getIndexInfoOfType(objType, ts.IndexKind.String) || typeName === 'number' && checker.getIndexInfoOfType(objType, ts.IndexKind.Number));\n    }\n    // Checks whether a member expression is nullable or not regardless of it's previous node.\n    //  Example:\n    //  ```\n    //  // 'bar' is nullable if 'foo' is null.\n    //  // but this function checks regardless of 'foo' type, so returns 'true'.\n    //  declare const foo: { bar : { baz: string } } | null\n    //  foo?.bar;\n    //  ```\n    function isNullableOriginFromPrev(node) {\n      const prevType = getNodeType(node.object);\n      const property = node.property;\n      if (prevType.isUnion() && (0, util_1.isIdentifier)(property)) {\n        const isOwnNullable = prevType.types.some(type => {\n          if (node.computed) {\n            const propertyType = getNodeType(node.property);\n            return isNullablePropertyType(type, propertyType);\n          }\n          const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);\n          if (propType) {\n            return (0, util_1.isNullableType)(propType, {\n              allowUndefined: true\n            });\n          }\n          return !!checker.getIndexInfoOfType(type, ts.IndexKind.String);\n        });\n        return !isOwnNullable && (0, util_1.isNullableType)(prevType, {\n          allowUndefined: true\n        });\n      }\n      return false;\n    }\n    function isOptionableExpression(node) {\n      const type = getNodeType(node);\n      const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression ? !isNullableOriginFromPrev(node) : true;\n      const possiblyVoid = (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Void);\n      return (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown) || isOwnNullable && ((0, util_1.isNullableType)(type, {\n        allowUndefined: true\n      }) || possiblyVoid);\n    }\n    function checkOptionalChain(node, beforeOperator, fix) {\n      // We only care if this step in the chain is optional. If just descend\n      // from an optional chain, then that's fine.\n      if (!node.optional) {\n        return;\n      }\n      // Since typescript array index signature types don't represent the\n      //  possibility of out-of-bounds access, if we're indexing into an array\n      //  just skip the check, to avoid false positives\n      if (optionChainContainsOptionArrayIndex(node)) {\n        return;\n      }\n      const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n      if (isOptionableExpression(nodeToCheck)) {\n        return;\n      }\n      const questionDotOperator = (0, util_1.nullThrows)(sourceCode.getTokenAfter(beforeOperator, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));\n      context.report({\n        node,\n        loc: questionDotOperator.loc,\n        messageId: 'neverOptionalChain',\n        fix(fixer) {\n          return fixer.replaceText(questionDotOperator, fix);\n        }\n      });\n    }\n    function checkOptionalMemberExpression(node) {\n      checkOptionalChain(node, node.object, node.computed ? '' : '.');\n    }\n    function checkOptionalCallExpression(node) {\n      checkOptionalChain(node, node.callee, '');\n    }\n    function checkAssignmentExpression(node) {\n      // Similar to checkLogicalExpressionForUnnecessaryConditionals, since\n      // a ||= b is equivalent to a || (a = b)\n      if (['||=', '&&='].includes(node.operator)) {\n        checkNode(node.left);\n      } else if (node.operator === '??=') {\n        checkNodeForNullish(node.left);\n      }\n    }\n    return {\n      AssignmentExpression: checkAssignmentExpression,\n      BinaryExpression: checkIfBinaryExpressionIsNecessaryConditional,\n      CallExpression: checkCallExpression,\n      ConditionalExpression: node => checkNode(node.test),\n      DoWhileStatement: checkIfLoopIsNecessaryConditional,\n      ForStatement: checkIfLoopIsNecessaryConditional,\n      IfStatement: node => checkNode(node.test),\n      LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,\n      WhileStatement: checkIfLoopIsNecessaryConditional,\n      'MemberExpression[optional = true]': checkOptionalMemberExpression,\n      'CallExpression[optional = true]': checkOptionalCallExpression\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils_1","ts","__importStar","util_1","isTruthyLiteral","type","isBooleanLiteralType","isLiteralType","value","isPossiblyFalsy","unionTypeParts","filter","t","some","isTypeFlagSet","TypeFlags","PossiblyFalsy","isPossiblyTruthy","isFalsyType","nullishFlag","Undefined","Null","isNullishType","isPossiblyNullish","isAlwaysNullish","every","isLiteral","flags","Void","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","schema","properties","allowConstantLoopConditions","allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing","additionalProperties","fixable","messages","alwaysTruthy","alwaysFalsy","alwaysTruthyFunc","alwaysFalsyFunc","neverNullish","alwaysNullish","literalBooleanExpression","noOverlapBooleanExpression","never","neverOptionalChain","noStrictNullCheck","defaultOptions","create","context","service","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","compilerOptions","getCompilerOptions","isStrictNullChecks","isStrictCompilerOptionEnabled","report","loc","start","line","column","end","messageId","getNodeType","node","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","nodeIsArrayType","nodeType","isArrayType","nodeIsTupleType","isTupleType","isArrayIndexExpression","AST_NODE_TYPES","MemberExpression","computed","object","property","Literal","checkNode","isUnaryNotArgument","UnaryExpression","operator","argument","LogicalExpression","right","part","isTypeAnyType","isTypeUnknownType","TypeVariable","Never","checkNodeForNullish","Any","Unknown","TypeParameter","ChainExpression","expression","TSNonNullExpression","optionChainContainsOptionArrayIndex","BOOL_OPERATORS","Set","checkIfBinaryExpressionIsNecessaryConditional","has","leftType","left","rightType","UNDEFINED","NULL","VOID","isComparable","flag","checkLogicalExpressionForUnnecessaryConditionals","checkIfLoopIsNecessaryConditional","test","ARRAY_PREDICATE_FUNCTIONS","isArrayPredicateFunction","callee","Identifier","checkCallExpression","arguments","length","callback","ArrowFunctionExpression","FunctionExpression","body","BlockStatement","callbackBody","ReturnStatement","returnTypes","getCallSignaturesOfType","map","sig","getReturnType","lhsNode","CallExpression","optional","isNullablePropertyType","objType","propertyType","isUnion","types","isNumberLiteral","isStringLiteral","propType","getTypeOfPropertyOfName","toString","isNullableType","allowUndefined","typeName","getTypeName","getIndexInfoOfType","IndexKind","String","Number","isNullableOriginFromPrev","prevType","isIdentifier","isOwnNullable","isOptionableExpression","possiblyVoid","checkOptionalChain","beforeOperator","fix","nodeToCheck","questionDotOperator","nullThrows","getTokenAfter","token","AST_TOKEN_TYPES","Punctuator","NullThrowsReasons","MissingToken","fixer","replaceText","checkOptionalMemberExpression","checkOptionalCallExpression","checkAssignmentExpression","includes","AssignmentExpression","BinaryExpression","ConditionalExpression","DoWhileStatement","ForStatement","IfStatement","WhileStatement"],"sources":["../../src/rules/no-unnecessary-condition.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}