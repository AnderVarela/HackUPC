{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst names_1 = require(\"../../compile/names\");\nconst error = {\n  message: \"must NOT have unevaluated properties\",\n  params: ({\n    params\n  }) => (0, codegen_1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`\n};\nconst def = {\n  keyword: \"unevaluatedProperties\",\n  type: \"object\",\n  schemaType: [\"boolean\", \"object\"],\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      props\n    } = it;\n    if (props instanceof codegen_1.Name) {\n      gen.if((0, codegen_1._)`${props} !== true`, () => gen.forIn(\"key\", data, key => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));\n    } else if (props !== true) {\n      gen.forIn(\"key\", data, key => props === undefined ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));\n    }\n    it.props = true;\n    cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n    function unevaluatedPropCode(key) {\n      if (schema === false) {\n        cxt.setParams({\n          unevaluatedProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n      if (!(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n          keyword: \"unevaluatedProperties\",\n          dataProp: key,\n          dataPropType: util_1.Type.Str\n        }, valid);\n        if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n      }\n    }\n    function unevaluatedDynamic(evaluatedProps, key) {\n      return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;\n    }\n    function unevaluatedStatic(evaluatedProps, key) {\n      const ps = [];\n      for (const p in evaluatedProps) {\n        if (evaluatedProps[p] === true) ps.push((0, codegen_1._)`${key} !== ${p}`);\n      }\n      return (0, codegen_1.and)(...ps);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","names_1","error","message","params","_","unevaluatedProperty","def","keyword","type","schemaType","trackErrors","code","cxt","gen","schema","data","errsCount","it","Error","allErrors","props","Name","if","forIn","key","unevaluatedDynamic","unevaluatedPropCode","undefined","unevaluatedStatic","ok","default","errors","setParams","break","alwaysValidSchema","valid","name","subschema","dataProp","dataPropType","Type","Str","not","evaluatedProps","ps","p","push","and","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\unevaluated\\unevaluatedProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport {_, not, and, Name, Code} from \"../../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../../compile/util\"\nimport N from \"../../compile/names\"\n\nexport type UnevaluatedPropertiesError = ErrorObject<\n  \"unevaluatedProperties\",\n  {unevaluatedProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have unevaluated properties\",\n  params: ({params}) => _`{unevaluatedProperty: ${params.unevaluatedProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"unevaluatedProperties\",\n  type: \"object\",\n  schemaType: [\"boolean\", \"object\"],\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, props} = it\n    if (props instanceof Name) {\n      gen.if(_`${props} !== true`, () =>\n        gen.forIn(\"key\", data, (key: Name) =>\n          gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))\n        )\n      )\n    } else if (props !== true) {\n      gen.forIn(\"key\", data, (key: Name) =>\n        props === undefined\n          ? unevaluatedPropCode(key)\n          : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key))\n      )\n    }\n    it.props = true\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function unevaluatedPropCode(key: Name): void {\n      if (schema === false) {\n        cxt.setParams({unevaluatedProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (!alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        cxt.subschema(\n          {\n            keyword: \"unevaluatedProperties\",\n            dataProp: key,\n            dataPropType: Type.Str,\n          },\n          valid\n        )\n        if (!allErrors) gen.if(not(valid), () => gen.break())\n      }\n    }\n\n    function unevaluatedDynamic(evaluatedProps: Name, key: Name): Code {\n      return _`!${evaluatedProps} || !${evaluatedProps}[${key}]`\n    }\n\n    function unevaluatedStatic(evaluatedProps: {[K in string]?: true}, key: Name): Code {\n      const ps: Code[] = []\n      for (const p in evaluatedProps) {\n        if (evaluatedProps[p] === true) ps.push(_`${key} !== ${p}`)\n      }\n      return and(...ps)\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}