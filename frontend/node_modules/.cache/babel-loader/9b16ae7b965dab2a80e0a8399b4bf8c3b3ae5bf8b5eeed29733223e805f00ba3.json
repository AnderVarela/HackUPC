{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\n/*\nThe AST is always constructed such the first element is always the deepest element.\nI.e. for this code: `foo && foo.bar && foo.bar.baz && foo.bar.baz.buzz`\nThe AST will look like this:\n{\n  left: {\n    left: {\n      left: foo\n      right: foo.bar\n    }\n    right: foo.bar.baz\n  }\n  right: foo.bar.baz.buzz\n}\n*/\nexports.default = util.createRule({\n  name: 'prefer-optional-chain',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects',\n      recommended: 'strict'\n    },\n    hasSuggestions: true,\n    messages: {\n      preferOptionalChain: \"Prefer using an optional chain expression instead, as it's more concise and easier to read.\",\n      optionalChainSuggest: 'Change to an optional chain.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const parserServices = util.getParserServices(context, true);\n    return {\n      'LogicalExpression[operator=\"||\"], LogicalExpression[operator=\"??\"]'(node) {\n        const leftNode = node.left;\n        const rightNode = node.right;\n        const parentNode = node.parent;\n        const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression && rightNode.properties.length === 0;\n        if (!isRightNodeAnEmptyObjectLiteral || !parentNode || parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression || parentNode.optional) {\n          return;\n        }\n        function isLeftSideLowerPrecedence() {\n          const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n          const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);\n          const operator = (0, tsutils_1.isBinaryExpression)(logicalTsNode) ? logicalTsNode.operatorToken.kind : ts.SyntaxKind.Unknown;\n          const leftPrecedence = util.getOperatorPrecedence(leftTsNode.kind, operator);\n          return leftPrecedence < util.OperatorPrecedence.LeftHandSide;\n        }\n        context.report({\n          node: parentNode,\n          messageId: 'optionalChainSuggest',\n          suggest: [{\n            messageId: 'optionalChainSuggest',\n            fix: fixer => {\n              const leftNodeText = sourceCode.getText(leftNode);\n              // Any node that is made of an operator with higher or equal precedence,\n              const maybeWrappedLeftNode = isLeftSideLowerPrecedence() ? `(${leftNodeText})` : leftNodeText;\n              const propertyToBeOptionalText = sourceCode.getText(parentNode.property);\n              const maybeWrappedProperty = parentNode.computed ? `[${propertyToBeOptionalText}]` : propertyToBeOptionalText;\n              return fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);\n            }\n          }]\n        });\n      },\n      [['LogicalExpression[operator=\"||\"] > UnaryExpression[operator=\"!\"] > Identifier', 'LogicalExpression[operator=\"||\"] > UnaryExpression[operator=\"!\"] > MemberExpression', 'LogicalExpression[operator=\"||\"] > UnaryExpression[operator=\"!\"] > ChainExpression > MemberExpression', 'LogicalExpression[operator=\"||\"] > UnaryExpression[operator=\"!\"] > MetaProperty'].join(',')](initialIdentifierOrNotEqualsExpr) {\n        // selector guarantees this cast\n        const initialExpression = (initialIdentifierOrNotEqualsExpr.parent.type === utils_1.AST_NODE_TYPES.ChainExpression ? initialIdentifierOrNotEqualsExpr.parent.parent : initialIdentifierOrNotEqualsExpr.parent).parent;\n        if (initialExpression.left.type !== utils_1.AST_NODE_TYPES.UnaryExpression || initialExpression.left.argument !== initialIdentifierOrNotEqualsExpr) {\n          // the node(identifier or member expression) is not the deepest left node\n          return;\n        }\n        // walk up the tree to figure out how many logical expressions we can include\n        let previous = initialExpression;\n        let current = initialExpression;\n        let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);\n        let optionallyChainedCode = previousLeftText;\n        let expressionCount = 1;\n        while (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n          if (current.right.type !== utils_1.AST_NODE_TYPES.UnaryExpression || !isValidChainTarget(current.right.argument,\n          // only allow unary '!' with identifiers for the first chain - !foo || !foo()\n          expressionCount === 1)) {\n            break;\n          }\n          const {\n            rightText,\n            shouldBreak\n          } = breakIfInvalid({\n            rightNode: current.right.argument,\n            previousLeftText\n          });\n          if (shouldBreak) {\n            break;\n          }\n          let invalidOptionallyChainedPrivateProperty;\n          ({\n            invalidOptionallyChainedPrivateProperty,\n            expressionCount,\n            previousLeftText,\n            optionallyChainedCode,\n            previous,\n            current\n          } = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));\n          if (invalidOptionallyChainedPrivateProperty) {\n            return;\n          }\n        }\n        reportIfMoreThanOne({\n          expressionCount,\n          previous,\n          optionallyChainedCode,\n          sourceCode,\n          context,\n          shouldHandleChainedAnds: false\n        });\n      },\n      [['LogicalExpression[operator=\"&&\"] > Identifier', 'LogicalExpression[operator=\"&&\"] > MemberExpression', 'LogicalExpression[operator=\"&&\"] > ChainExpression > MemberExpression', 'LogicalExpression[operator=\"&&\"] > MetaProperty', 'LogicalExpression[operator=\"&&\"] > BinaryExpression[operator=\"!==\"]', 'LogicalExpression[operator=\"&&\"] > BinaryExpression[operator=\"!=\"]'].join(',')](initialIdentifierOrNotEqualsExpr) {\n        var _a;\n        // selector guarantees this cast\n        const initialExpression = ((_a = initialIdentifierOrNotEqualsExpr.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? initialIdentifierOrNotEqualsExpr.parent.parent : initialIdentifierOrNotEqualsExpr.parent;\n        if (initialExpression.left !== initialIdentifierOrNotEqualsExpr) {\n          // the node(identifier or member expression) is not the deepest left node\n          return;\n        }\n        if (!isValidChainTarget(initialIdentifierOrNotEqualsExpr, true)) {\n          return;\n        }\n        // walk up the tree to figure out how many logical expressions we can include\n        let previous = initialExpression;\n        let current = initialExpression;\n        let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);\n        let optionallyChainedCode = previousLeftText;\n        let expressionCount = 1;\n        while (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n          if (!isValidChainTarget(current.right,\n          // only allow identifiers for the first chain - foo && foo()\n          expressionCount === 1)) {\n            break;\n          }\n          const {\n            rightText,\n            shouldBreak\n          } = breakIfInvalid({\n            rightNode: current.right,\n            previousLeftText\n          });\n          if (shouldBreak) {\n            break;\n          }\n          let invalidOptionallyChainedPrivateProperty;\n          ({\n            invalidOptionallyChainedPrivateProperty,\n            expressionCount,\n            previousLeftText,\n            optionallyChainedCode,\n            previous,\n            current\n          } = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));\n          if (invalidOptionallyChainedPrivateProperty) {\n            return;\n          }\n        }\n        reportIfMoreThanOne({\n          expressionCount,\n          previous,\n          optionallyChainedCode,\n          sourceCode,\n          context,\n          shouldHandleChainedAnds: true\n        });\n      }\n    };\n    function breakIfInvalid({\n      previousLeftText,\n      rightNode\n    }) {\n      let shouldBreak = false;\n      const rightText = getText(rightNode);\n      // can't just use startsWith because of cases like foo && fooBar.baz;\n      const matchRegex = new RegExp(`^${\n      // escape regex characters\n      previousLeftText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}[^a-zA-Z0-9_$]`);\n      if (!matchRegex.test(rightText) &&\n      // handle redundant cases like foo.bar && foo.bar\n      previousLeftText !== rightText) {\n        shouldBreak = true;\n      }\n      return {\n        shouldBreak,\n        leftText: previousLeftText,\n        rightText\n      };\n    }\n    function getText(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n        return getText(\n        // isValidChainTarget ensures this is type safe\n        node.left);\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        const calleeText = getText(\n        // isValidChainTarget ensures this is type safe\n        node.callee);\n        // ensure that the call arguments are left untouched, or else we can break cases that _need_ whitespace:\n        // - JSX: <Foo Needs Space Between Attrs />\n        // - Unary Operators: typeof foo, await bar, delete baz\n        const closingParenToken = util.nullThrows(sourceCode.getLastToken(node), util.NullThrowsReasons.MissingToken('closing parenthesis', node.type));\n        const openingParenToken = util.nullThrows(sourceCode.getFirstTokenBetween(node.callee, closingParenToken, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken('opening parenthesis', node.type));\n        const argumentsText = sourceCode.text.substring(openingParenToken.range[0], closingParenToken.range[1]);\n        return `${calleeText}${argumentsText}`;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n        return node.name;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.MetaProperty) {\n        return `${node.meta.name}.${node.property.name}`;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.ThisExpression) {\n        return 'this';\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        /* istanbul ignore if */if (node.expression.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n          // this shouldn't happen\n          return '';\n        }\n        return getText(node.expression);\n      }\n      if (node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n        // Not supported mixing with TSNonNullExpression\n        return '';\n      }\n      return getMemberExpressionText(node);\n    }\n    /**\n     * Gets a normalized representation of the given MemberExpression\n     */\n    function getMemberExpressionText(node) {\n      let objectText;\n      // cases should match the list in ALLOWED_MEMBER_OBJECT_TYPES\n      switch (node.object.type) {\n        case utils_1.AST_NODE_TYPES.MemberExpression:\n          objectText = getMemberExpressionText(node.object);\n          break;\n        case utils_1.AST_NODE_TYPES.CallExpression:\n        case utils_1.AST_NODE_TYPES.Identifier:\n        case utils_1.AST_NODE_TYPES.MetaProperty:\n        case utils_1.AST_NODE_TYPES.ThisExpression:\n          objectText = getText(node.object);\n          break;\n        /* istanbul ignore next */\n        default:\n          return '';\n      }\n      let propertyText;\n      if (node.computed) {\n        // cases should match the list in ALLOWED_COMPUTED_PROP_TYPES\n        switch (node.property.type) {\n          case utils_1.AST_NODE_TYPES.Identifier:\n            propertyText = getText(node.property);\n            break;\n          case utils_1.AST_NODE_TYPES.Literal:\n          case utils_1.AST_NODE_TYPES.TemplateLiteral:\n          case utils_1.AST_NODE_TYPES.BinaryExpression:\n            propertyText = sourceCode.getText(node.property);\n            break;\n          case utils_1.AST_NODE_TYPES.MemberExpression:\n            propertyText = getMemberExpressionText(node.property);\n            break;\n          /* istanbul ignore next */\n          default:\n            return '';\n        }\n        return `${objectText}${node.optional ? '?.' : ''}[${propertyText}]`;\n      } else {\n        // cases should match the list in ALLOWED_NON_COMPUTED_PROP_TYPES\n        switch (node.property.type) {\n          case utils_1.AST_NODE_TYPES.Identifier:\n            propertyText = getText(node.property);\n            break;\n          case utils_1.AST_NODE_TYPES.PrivateIdentifier:\n            propertyText = '#' + getText(node.property);\n            break;\n          default:\n            propertyText = sourceCode.getText(node.property);\n        }\n        return `${objectText}${node.optional ? '?.' : '.'}${propertyText}`;\n      }\n    }\n  }\n});\nconst ALLOWED_MEMBER_OBJECT_TYPES = new Set([utils_1.AST_NODE_TYPES.CallExpression, utils_1.AST_NODE_TYPES.Identifier, utils_1.AST_NODE_TYPES.MemberExpression, utils_1.AST_NODE_TYPES.ThisExpression, utils_1.AST_NODE_TYPES.MetaProperty]);\nconst ALLOWED_COMPUTED_PROP_TYPES = new Set([utils_1.AST_NODE_TYPES.Identifier, utils_1.AST_NODE_TYPES.Literal, utils_1.AST_NODE_TYPES.MemberExpression, utils_1.AST_NODE_TYPES.TemplateLiteral]);\nconst ALLOWED_NON_COMPUTED_PROP_TYPES = new Set([utils_1.AST_NODE_TYPES.Identifier, utils_1.AST_NODE_TYPES.PrivateIdentifier]);\nfunction reportIfMoreThanOne({\n  expressionCount,\n  previous,\n  optionallyChainedCode,\n  sourceCode,\n  context,\n  shouldHandleChainedAnds\n}) {\n  if (expressionCount > 1) {\n    if (shouldHandleChainedAnds && previous.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n      let operator = previous.right.operator;\n      if (previous.right.operator === '!==' &&\n      // TODO(#4820): Use the type checker to know whether this is `null`\n      previous.right.right.type === utils_1.AST_NODE_TYPES.Literal && previous.right.right.raw === 'null') {\n        // case like foo !== null && foo.bar !== null\n        operator = '!=';\n      }\n      // case like foo && foo.bar !== someValue\n      optionallyChainedCode += ` ${operator} ${sourceCode.getText(previous.right.right)}`;\n    }\n    context.report({\n      node: previous,\n      messageId: 'preferOptionalChain',\n      suggest: [{\n        messageId: 'optionalChainSuggest',\n        fix: fixer => [fixer.replaceText(previous, `${shouldHandleChainedAnds ? '' : '!'}${optionallyChainedCode}`)]\n      }]\n    });\n  }\n}\nfunction normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current) {\n  const leftText = previousLeftText;\n  let invalidOptionallyChainedPrivateProperty = false;\n  // omit weird doubled up expression that make no sense like foo.bar && foo.bar\n  if (rightText !== previousLeftText) {\n    expressionCount += 1;\n    previousLeftText = rightText;\n    /*\n    Diff the left and right text to construct the fix string\n    There are the following cases:\n         1)\n    rightText === 'foo.bar.baz.buzz'\n    leftText === 'foo.bar.baz'\n    diff === '.buzz'\n         2)\n    rightText === 'foo.bar.baz.buzz()'\n    leftText === 'foo.bar.baz'\n    diff === '.buzz()'\n         3)\n    rightText === 'foo.bar.baz.buzz()'\n    leftText === 'foo.bar.baz.buzz'\n    diff === '()'\n         4)\n    rightText === 'foo.bar.baz[buzz]'\n    leftText === 'foo.bar.baz'\n    diff === '[buzz]'\n         5)\n    rightText === 'foo.bar.baz?.buzz'\n    leftText === 'foo.bar.baz'\n    diff === '?.buzz'\n    */\n    const diff = rightText.replace(leftText, '');\n    if (diff.startsWith('.#')) {\n      // Do not handle direct optional chaining on private properties because of a typescript bug (https://github.com/microsoft/TypeScript/issues/42734)\n      // We still allow in computed properties\n      invalidOptionallyChainedPrivateProperty = true;\n    }\n    if (diff.startsWith('?')) {\n      // item was \"pre optional chained\"\n      optionallyChainedCode += diff;\n    } else {\n      const needsDot = diff.startsWith('(') || diff.startsWith('[');\n      optionallyChainedCode += `?${needsDot ? '.' : ''}${diff}`;\n    }\n  }\n  previous = current;\n  current = util.nullThrows(current.parent, util.NullThrowsReasons.MissingParent);\n  return {\n    invalidOptionallyChainedPrivateProperty,\n    expressionCount,\n    previousLeftText,\n    optionallyChainedCode,\n    previous,\n    current\n  };\n}\nfunction isValidChainTarget(node, allowIdentifier) {\n  if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n    return isValidChainTarget(node.expression, allowIdentifier);\n  }\n  if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n    const isObjectValid = ALLOWED_MEMBER_OBJECT_TYPES.has(node.object.type) &&\n    // make sure to validate the expression is of our expected structure\n    isValidChainTarget(node.object, true);\n    const isPropertyValid = node.computed ? ALLOWED_COMPUTED_PROP_TYPES.has(node.property.type) && (\n    // make sure to validate the member expression is of our expected structure\n    node.property.type === utils_1.AST_NODE_TYPES.MemberExpression ? isValidChainTarget(node.property, allowIdentifier) : true) : ALLOWED_NON_COMPUTED_PROP_TYPES.has(node.property.type);\n    return isObjectValid && isPropertyValid;\n  }\n  if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n    return isValidChainTarget(node.callee, allowIdentifier);\n  }\n  if (allowIdentifier && (node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.ThisExpression || node.type === utils_1.AST_NODE_TYPES.MetaProperty)) {\n    return true;\n  }\n  /*\n  special case for the following, where we only want the left\n  - foo !== null\n  - foo != null\n  - foo !== undefined\n  - foo != undefined\n  */\n  return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && ['!==', '!='].includes(node.operator) && isValidChainTarget(node.left, allowIdentifier) && (util.isUndefinedIdentifier(node.right) || util.isNullLiteral(node.right));\n}","map":{"version":3,"names":["utils_1","require","tsutils_1","ts","__importStar","util","exports","default","createRule","name","meta","type","docs","description","recommended","hasSuggestions","messages","preferOptionalChain","optionalChainSuggest","schema","defaultOptions","create","context","sourceCode","getSourceCode","parserServices","getParserServices","LogicalExpression[operator=\"||\"], LogicalExpression[operator=\"??\"]","node","leftNode","left","rightNode","right","parentNode","parent","isRightNodeAnEmptyObjectLiteral","AST_NODE_TYPES","ObjectExpression","properties","length","MemberExpression","optional","isLeftSideLowerPrecedence","logicalTsNode","esTreeNodeToTSNodeMap","get","leftTsNode","operator","isBinaryExpression","operatorToken","kind","SyntaxKind","Unknown","leftPrecedence","getOperatorPrecedence","OperatorPrecedence","LeftHandSide","report","messageId","suggest","fix","fixer","leftNodeText","getText","maybeWrappedLeftNode","propertyToBeOptionalText","property","maybeWrappedProperty","computed","replaceTextRange","range","join","initialIdentifierOrNotEqualsExpr","initialExpression","ChainExpression","UnaryExpression","argument","previous","current","previousLeftText","optionallyChainedCode","expressionCount","LogicalExpression","isValidChainTarget","rightText","shouldBreak","breakIfInvalid","invalidOptionallyChainedPrivateProperty","normalizeRepeatingPatterns","reportIfMoreThanOne","shouldHandleChainedAnds","_a","matchRegex","RegExp","replace","test","leftText","BinaryExpression","CallExpression","calleeText","callee","closingParenToken","nullThrows","getLastToken","NullThrowsReasons","MissingToken","openingParenToken","getFirstTokenBetween","isOpeningParenToken","argumentsText","text","substring","Identifier","PrivateIdentifier","MetaProperty","ThisExpression","expression","TSNonNullExpression","object","getMemberExpressionText","objectText","propertyText","Literal","TemplateLiteral","ALLOWED_MEMBER_OBJECT_TYPES","Set","ALLOWED_COMPUTED_PROP_TYPES","ALLOWED_NON_COMPUTED_PROP_TYPES","raw","replaceText","diff","startsWith","needsDot","MissingParent","allowIdentifier","isObjectValid","has","isPropertyValid","includes","isUndefinedIdentifier","isNullLiteral"],"sources":["../../src/rules/prefer-optional-chain.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}