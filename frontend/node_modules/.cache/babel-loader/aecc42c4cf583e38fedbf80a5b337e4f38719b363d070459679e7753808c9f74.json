{"ast":null,"code":"'use strict';\n\nconst {\n  ArrayPrototypeFind,\n  ObjectEntries,\n  ObjectPrototypeHasOwnProperty: ObjectHasOwn,\n  StringPrototypeCharAt,\n  StringPrototypeIncludes,\n  StringPrototypeStartsWith\n} = require('./internal/primordials');\nconst {\n  validateObject\n} = require('./internal/validators');\n\n// These are internal utilities to make the parsing logic easier to read, and\n// add lots of detail for the curious. They are in a separate file to allow\n// unit testing, although that is not essential (this could be rolled into\n// main file and just tested implicitly via API).\n//\n// These routines are for internal use, not for export to client.\n\n/**\n * Return the named property, but only if it is an own property.\n */\nfunction objectGetOwn(obj, prop) {\n  if (ObjectHasOwn(obj, prop)) return obj[prop];\n}\n\n/**\n * Return the named options property, but only if it is an own property.\n */\nfunction optionsGetOwn(options, longOption, prop) {\n  if (ObjectHasOwn(options, longOption)) return objectGetOwn(options[longOption], prop);\n}\n\n/**\n * Determines if the argument may be used as an option value.\n * @example\n * isOptionValue('V') // returns true\n * isOptionValue('-v') // returns true (greedy)\n * isOptionValue('--foo') // returns true (greedy)\n * isOptionValue(undefined) // returns false\n */\nfunction isOptionValue(value) {\n  if (value == null) return false;\n\n  // Open Group Utility Conventions are that an option-argument\n  // is the argument after the option, and may start with a dash.\n  return true; // greedy!\n}\n\n/**\n * Detect whether there is possible confusion and user may have omitted\n * the option argument, like `--port --verbose` when `port` of type:string.\n * In strict mode we throw errors if value is option-like.\n */\nfunction isOptionLikeValue(value) {\n  if (value == null) return false;\n  return value.length > 1 && StringPrototypeCharAt(value, 0) === '-';\n}\n\n/**\n * Determines if `arg` is just a short option.\n * @example '-f'\n */\nfunction isLoneShortOption(arg) {\n  return arg.length === 2 && StringPrototypeCharAt(arg, 0) === '-' && StringPrototypeCharAt(arg, 1) !== '-';\n}\n\n/**\n * Determines if `arg` is a lone long option.\n * @example\n * isLoneLongOption('a') // returns false\n * isLoneLongOption('-a') // returns false\n * isLoneLongOption('--foo') // returns true\n * isLoneLongOption('--foo=bar') // returns false\n */\nfunction isLoneLongOption(arg) {\n  return arg.length > 2 && StringPrototypeStartsWith(arg, '--') && !StringPrototypeIncludes(arg, '=', 3);\n}\n\n/**\n * Determines if `arg` is a long option and value in the same argument.\n * @example\n * isLongOptionAndValue('--foo') // returns false\n * isLongOptionAndValue('--foo=bar') // returns true\n */\nfunction isLongOptionAndValue(arg) {\n  return arg.length > 2 && StringPrototypeStartsWith(arg, '--') && StringPrototypeIncludes(arg, '=', 3);\n}\n\n/**\n * Determines if `arg` is a short option group.\n *\n * See Guideline 5 of the [Open Group Utility Conventions](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html).\n *   One or more options without option-arguments, followed by at most one\n *   option that takes an option-argument, should be accepted when grouped\n *   behind one '-' delimiter.\n * @example\n * isShortOptionGroup('-a', {}) // returns false\n * isShortOptionGroup('-ab', {}) // returns true\n * // -fb is an option and a value, not a short option group\n * isShortOptionGroup('-fb', {\n *   options: { f: { type: 'string' } }\n * }) // returns false\n * isShortOptionGroup('-bf', {\n *   options: { f: { type: 'string' } }\n * }) // returns true\n * // -bfb is an edge case, return true and caller sorts it out\n * isShortOptionGroup('-bfb', {\n *   options: { f: { type: 'string' } }\n * }) // returns true\n */\nfunction isShortOptionGroup(arg, options) {\n  if (arg.length <= 2) return false;\n  if (StringPrototypeCharAt(arg, 0) !== '-') return false;\n  if (StringPrototypeCharAt(arg, 1) === '-') return false;\n  const firstShort = StringPrototypeCharAt(arg, 1);\n  const longOption = findLongOptionForShort(firstShort, options);\n  return optionsGetOwn(options, longOption, 'type') !== 'string';\n}\n\n/**\n * Determine if arg is a short string option followed by its value.\n * @example\n * isShortOptionAndValue('-a', {}); // returns false\n * isShortOptionAndValue('-ab', {}); // returns false\n * isShortOptionAndValue('-fFILE', {\n *   options: { foo: { short: 'f', type: 'string' }}\n * }) // returns true\n */\nfunction isShortOptionAndValue(arg, options) {\n  validateObject(options, 'options');\n  if (arg.length <= 2) return false;\n  if (StringPrototypeCharAt(arg, 0) !== '-') return false;\n  if (StringPrototypeCharAt(arg, 1) === '-') return false;\n  const shortOption = StringPrototypeCharAt(arg, 1);\n  const longOption = findLongOptionForShort(shortOption, options);\n  return optionsGetOwn(options, longOption, 'type') === 'string';\n}\n\n/**\n * Find the long option associated with a short option. Looks for a configured\n * `short` and returns the short option itself if a long option is not found.\n * @example\n * findLongOptionForShort('a', {}) // returns 'a'\n * findLongOptionForShort('b', {\n *   options: { bar: { short: 'b' } }\n * }) // returns 'bar'\n */\nfunction findLongOptionForShort(shortOption, options) {\n  validateObject(options, 'options');\n  const longOptionEntry = ArrayPrototypeFind(ObjectEntries(options), ({\n    1: optionConfig\n  }) => objectGetOwn(optionConfig, 'short') === shortOption);\n  return longOptionEntry?.[0] ?? shortOption;\n}\n\n/**\n * Check if the given option includes a default value\n * and that option has not been set by the input args.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {object} optionConfig - the option configuration properties\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction useDefaultValueOption(longOption, optionConfig, values) {\n  return objectGetOwn(optionConfig, 'default') !== undefined && values[longOption] === undefined;\n}\nmodule.exports = {\n  findLongOptionForShort,\n  isLoneLongOption,\n  isLoneShortOption,\n  isLongOptionAndValue,\n  isOptionValue,\n  isOptionLikeValue,\n  isShortOptionAndValue,\n  isShortOptionGroup,\n  useDefaultValueOption,\n  objectGetOwn,\n  optionsGetOwn\n};","map":{"version":3,"names":["ArrayPrototypeFind","ObjectEntries","ObjectPrototypeHasOwnProperty","ObjectHasOwn","StringPrototypeCharAt","StringPrototypeIncludes","StringPrototypeStartsWith","require","validateObject","objectGetOwn","obj","prop","optionsGetOwn","options","longOption","isOptionValue","value","isOptionLikeValue","length","isLoneShortOption","arg","isLoneLongOption","isLongOptionAndValue","isShortOptionGroup","firstShort","findLongOptionForShort","isShortOptionAndValue","shortOption","longOptionEntry","optionConfig","useDefaultValueOption","values","undefined","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pkgjs/parseargs/utils.js"],"sourcesContent":["'use strict';\n\nconst {\n  ArrayPrototypeFind,\n  ObjectEntries,\n  ObjectPrototypeHasOwnProperty: ObjectHasOwn,\n  StringPrototypeCharAt,\n  StringPrototypeIncludes,\n  StringPrototypeStartsWith,\n} = require('./internal/primordials');\n\nconst {\n  validateObject,\n} = require('./internal/validators');\n\n// These are internal utilities to make the parsing logic easier to read, and\n// add lots of detail for the curious. They are in a separate file to allow\n// unit testing, although that is not essential (this could be rolled into\n// main file and just tested implicitly via API).\n//\n// These routines are for internal use, not for export to client.\n\n/**\n * Return the named property, but only if it is an own property.\n */\nfunction objectGetOwn(obj, prop) {\n  if (ObjectHasOwn(obj, prop))\n    return obj[prop];\n}\n\n/**\n * Return the named options property, but only if it is an own property.\n */\nfunction optionsGetOwn(options, longOption, prop) {\n  if (ObjectHasOwn(options, longOption))\n    return objectGetOwn(options[longOption], prop);\n}\n\n/**\n * Determines if the argument may be used as an option value.\n * @example\n * isOptionValue('V') // returns true\n * isOptionValue('-v') // returns true (greedy)\n * isOptionValue('--foo') // returns true (greedy)\n * isOptionValue(undefined) // returns false\n */\nfunction isOptionValue(value) {\n  if (value == null) return false;\n\n  // Open Group Utility Conventions are that an option-argument\n  // is the argument after the option, and may start with a dash.\n  return true; // greedy!\n}\n\n/**\n * Detect whether there is possible confusion and user may have omitted\n * the option argument, like `--port --verbose` when `port` of type:string.\n * In strict mode we throw errors if value is option-like.\n */\nfunction isOptionLikeValue(value) {\n  if (value == null) return false;\n\n  return value.length > 1 && StringPrototypeCharAt(value, 0) === '-';\n}\n\n/**\n * Determines if `arg` is just a short option.\n * @example '-f'\n */\nfunction isLoneShortOption(arg) {\n  return arg.length === 2 &&\n    StringPrototypeCharAt(arg, 0) === '-' &&\n    StringPrototypeCharAt(arg, 1) !== '-';\n}\n\n/**\n * Determines if `arg` is a lone long option.\n * @example\n * isLoneLongOption('a') // returns false\n * isLoneLongOption('-a') // returns false\n * isLoneLongOption('--foo') // returns true\n * isLoneLongOption('--foo=bar') // returns false\n */\nfunction isLoneLongOption(arg) {\n  return arg.length > 2 &&\n    StringPrototypeStartsWith(arg, '--') &&\n    !StringPrototypeIncludes(arg, '=', 3);\n}\n\n/**\n * Determines if `arg` is a long option and value in the same argument.\n * @example\n * isLongOptionAndValue('--foo') // returns false\n * isLongOptionAndValue('--foo=bar') // returns true\n */\nfunction isLongOptionAndValue(arg) {\n  return arg.length > 2 &&\n    StringPrototypeStartsWith(arg, '--') &&\n    StringPrototypeIncludes(arg, '=', 3);\n}\n\n/**\n * Determines if `arg` is a short option group.\n *\n * See Guideline 5 of the [Open Group Utility Conventions](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html).\n *   One or more options without option-arguments, followed by at most one\n *   option that takes an option-argument, should be accepted when grouped\n *   behind one '-' delimiter.\n * @example\n * isShortOptionGroup('-a', {}) // returns false\n * isShortOptionGroup('-ab', {}) // returns true\n * // -fb is an option and a value, not a short option group\n * isShortOptionGroup('-fb', {\n *   options: { f: { type: 'string' } }\n * }) // returns false\n * isShortOptionGroup('-bf', {\n *   options: { f: { type: 'string' } }\n * }) // returns true\n * // -bfb is an edge case, return true and caller sorts it out\n * isShortOptionGroup('-bfb', {\n *   options: { f: { type: 'string' } }\n * }) // returns true\n */\nfunction isShortOptionGroup(arg, options) {\n  if (arg.length <= 2) return false;\n  if (StringPrototypeCharAt(arg, 0) !== '-') return false;\n  if (StringPrototypeCharAt(arg, 1) === '-') return false;\n\n  const firstShort = StringPrototypeCharAt(arg, 1);\n  const longOption = findLongOptionForShort(firstShort, options);\n  return optionsGetOwn(options, longOption, 'type') !== 'string';\n}\n\n/**\n * Determine if arg is a short string option followed by its value.\n * @example\n * isShortOptionAndValue('-a', {}); // returns false\n * isShortOptionAndValue('-ab', {}); // returns false\n * isShortOptionAndValue('-fFILE', {\n *   options: { foo: { short: 'f', type: 'string' }}\n * }) // returns true\n */\nfunction isShortOptionAndValue(arg, options) {\n  validateObject(options, 'options');\n\n  if (arg.length <= 2) return false;\n  if (StringPrototypeCharAt(arg, 0) !== '-') return false;\n  if (StringPrototypeCharAt(arg, 1) === '-') return false;\n\n  const shortOption = StringPrototypeCharAt(arg, 1);\n  const longOption = findLongOptionForShort(shortOption, options);\n  return optionsGetOwn(options, longOption, 'type') === 'string';\n}\n\n/**\n * Find the long option associated with a short option. Looks for a configured\n * `short` and returns the short option itself if a long option is not found.\n * @example\n * findLongOptionForShort('a', {}) // returns 'a'\n * findLongOptionForShort('b', {\n *   options: { bar: { short: 'b' } }\n * }) // returns 'bar'\n */\nfunction findLongOptionForShort(shortOption, options) {\n  validateObject(options, 'options');\n  const longOptionEntry = ArrayPrototypeFind(\n    ObjectEntries(options),\n    ({ 1: optionConfig }) => objectGetOwn(optionConfig, 'short') === shortOption\n  );\n  return longOptionEntry?.[0] ?? shortOption;\n}\n\n/**\n * Check if the given option includes a default value\n * and that option has not been set by the input args.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {object} optionConfig - the option configuration properties\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction useDefaultValueOption(longOption, optionConfig, values) {\n  return objectGetOwn(optionConfig, 'default') !== undefined &&\n    values[longOption] === undefined;\n}\n\nmodule.exports = {\n  findLongOptionForShort,\n  isLoneLongOption,\n  isLoneShortOption,\n  isLongOptionAndValue,\n  isOptionValue,\n  isOptionLikeValue,\n  isShortOptionAndValue,\n  isShortOptionGroup,\n  useDefaultValueOption,\n  objectGetOwn,\n  optionsGetOwn,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}