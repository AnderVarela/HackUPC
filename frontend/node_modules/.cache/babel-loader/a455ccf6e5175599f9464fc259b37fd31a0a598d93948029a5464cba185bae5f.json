{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nfunction hasAssignmentBeforeNode(variable, node) {\n  return variable.references.some(ref => ref.isWrite() && ref.identifier.range[1] < node.range[1]) || variable.defs.some(def => isDefinitionWithAssignment(def) && def.node.range[1] < node.range[1]);\n}\nfunction isDefinitionWithAssignment(definition) {\n  if (definition.type !== scope_manager_1.DefinitionType.Variable) {\n    return false;\n  }\n  const variableDeclarator = definition.node;\n  return variableDeclarator.definite === true || variableDeclarator.init != null;\n}\nexports.default = util.createRule({\n  name: 'no-non-null-asserted-nullish-coalescing',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow non-null assertions in the left operand of a nullish coalescing operator',\n      recommended: 'strict'\n    },\n    messages: {\n      noNonNullAssertedNullishCoalescing: 'The nullish coalescing operator is designed to handle undefined and null - using a non-null assertion is not needed.',\n      suggestRemovingNonNull: 'Remove the non-null assertion.'\n    },\n    schema: [],\n    hasSuggestions: true\n  },\n  defaultOptions: [],\n  create(context) {\n    return {\n      'LogicalExpression[operator = \"??\"] > TSNonNullExpression.left'(node) {\n        if (node.expression.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {\n          const scope = context.getScope();\n          const identifier = node.expression;\n          const variable = utils_1.ASTUtils.findVariable(scope, identifier.name);\n          if (variable && !hasAssignmentBeforeNode(variable, node)) {\n            return;\n          }\n        }\n        const sourceCode = context.getSourceCode();\n        context.report({\n          node,\n          messageId: 'noNonNullAssertedNullishCoalescing',\n          /*\n          Use a suggestion instead of a fixer, because this can break type checks.\n          The resulting type of the nullish coalesce is only influenced by the right operand if the left operand can be `null` or `undefined`.\n          After removing the non-null assertion the type of the left operand might contain `null` or `undefined` and then the type of the right operand\n          might change the resulting type of the nullish coalesce.\n          See the following example:\n                     function test(x?: string): string {\n            const bar = x! ?? false; // type analysis reports `bar` has type `string`\n            //          x  ?? false; // type analysis reports `bar` has type `string | false`\n            return bar;\n          }\n          */\n          suggest: [{\n            messageId: 'suggestRemovingNonNull',\n            fix(fixer) {\n              const exclamationMark = util.nullThrows(sourceCode.getLastToken(node, utils_1.ASTUtils.isNonNullAssertionPunctuator), util.NullThrowsReasons.MissingToken('!', 'Non-null Assertion'));\n              return fixer.remove(exclamationMark);\n            }\n          }]\n        });\n      }\n    };\n  }\n});","map":{"version":3,"names":["scope_manager_1","require","utils_1","util","__importStar","hasAssignmentBeforeNode","variable","node","references","some","ref","isWrite","identifier","range","defs","def","isDefinitionWithAssignment","definition","type","DefinitionType","Variable","variableDeclarator","definite","init","exports","default","createRule","name","meta","docs","description","recommended","messages","noNonNullAssertedNullishCoalescing","suggestRemovingNonNull","schema","hasSuggestions","defaultOptions","create","context","LogicalExpression[operator = \"??\"] > TSNonNullExpression.left","expression","TSESTree","AST_NODE_TYPES","Identifier","scope","getScope","ASTUtils","findVariable","sourceCode","getSourceCode","report","messageId","suggest","fix","fixer","exclamationMark","nullThrows","getLastToken","isNonNullAssertionPunctuator","NullThrowsReasons","MissingToken","remove"],"sources":["../../src/rules/no-non-null-asserted-nullish-coalescing.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,eAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAEA,MAAAE,IAAA,GAAAC,YAAA,CAAAH,OAAA;AAEA,SAASI,uBAAuBA,CAC9BC,QAAiC,EACjCC,IAAmB;EAEnB,OACED,QAAQ,CAACE,UAAU,CAACC,IAAI,CACtBC,GAAG,IAAIA,GAAG,CAACC,OAAO,EAAE,IAAID,GAAG,CAACE,UAAU,CAACC,KAAK,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC,CAChE,IACDP,QAAQ,CAACQ,IAAI,CAACL,IAAI,CAChBM,GAAG,IACDC,0BAA0B,CAACD,GAAG,CAAC,IAAIA,GAAG,CAACR,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC,GAAGN,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC,CACvE;AAEL;AAEA,SAASG,0BAA0BA,CAACC,UAAsB;EACxD,IAAIA,UAAU,CAACC,IAAI,KAAKlB,eAAA,CAAAmB,cAAc,CAACC,QAAQ,EAAE;IAC/C,OAAO,KAAK;;EAGd,MAAMC,kBAAkB,GAAGJ,UAAU,CAACV,IAAI;EAC1C,OACEc,kBAAkB,CAACC,QAAQ,KAAK,IAAI,IAAID,kBAAkB,CAACE,IAAI,IAAI,IAAI;AAE3E;AAEAC,OAAA,CAAAC,OAAA,GAAetB,IAAI,CAACuB,UAAU,CAAC;EAC7BC,IAAI,EAAE,yCAAyC;EAC/CC,IAAI,EAAE;IACJV,IAAI,EAAE,SAAS;IACfW,IAAI,EAAE;MACJC,WAAW,EACT,mFAAmF;MACrFC,WAAW,EAAE;KACd;IACDC,QAAQ,EAAE;MACRC,kCAAkC,EAChC,sHAAsH;MACxHC,sBAAsB,EAAE;KACzB;IACDC,MAAM,EAAE,EAAE;IACVC,cAAc,EAAE;GACjB;EACDC,cAAc,EAAE,EAAE;EAClBC,MAAMA,CAACC,OAAO;IACZ,OAAO;MACL,+DAA+DC,CAC7DjC,IAAkC;QAElC,IAAIA,IAAI,CAACkC,UAAU,CAACvB,IAAI,KAAKhB,OAAA,CAAAwC,QAAQ,CAACC,cAAc,CAACC,UAAU,EAAE;UAC/D,MAAMC,KAAK,GAAGN,OAAO,CAACO,QAAQ,EAAE;UAChC,MAAMlC,UAAU,GAAGL,IAAI,CAACkC,UAAU;UAClC,MAAMnC,QAAQ,GAAGJ,OAAA,CAAA6C,QAAQ,CAACC,YAAY,CAACH,KAAK,EAAEjC,UAAU,CAACe,IAAI,CAAC;UAC9D,IAAIrB,QAAQ,IAAI,CAACD,uBAAuB,CAACC,QAAQ,EAAEC,IAAI,CAAC,EAAE;YACxD;;;QAIJ,MAAM0C,UAAU,GAAGV,OAAO,CAACW,aAAa,EAAE;QAE1CX,OAAO,CAACY,MAAM,CAAC;UACb5C,IAAI;UACJ6C,SAAS,EAAE,oCAAoC;UAC/C;;;;;;;;;;;;UAaAC,OAAO,EAAE,CACP;YACED,SAAS,EAAE,wBAAwB;YACnCE,GAAGA,CAACC,KAAK;cACP,MAAMC,eAAe,GAAGrD,IAAI,CAACsD,UAAU,CACrCR,UAAU,CAACS,YAAY,CACrBnD,IAAI,EACJL,OAAA,CAAA6C,QAAQ,CAACY,4BAA4B,CACtC,EACDxD,IAAI,CAACyD,iBAAiB,CAACC,YAAY,CACjC,GAAG,EACH,oBAAoB,CACrB,CACF;cACD,OAAON,KAAK,CAACO,MAAM,CAACN,eAAe,CAAC;YACtC;WACD;SAEJ,CAAC;MACJ;KACD;EACH;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}