{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('block-spacing');\nexports.default = util.createRule({\n  name: 'block-spacing',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Disallow or enforce spaces inside of blocks after opening block and before closing block',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'whitespace',\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: baseRule.meta.schema,\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: ['always'],\n  create(context, [whenToApplyOption]) {\n    const sourceCode = context.getSourceCode();\n    const baseRules = baseRule.create(context);\n    const always = whenToApplyOption !== 'never';\n    const messageId = always ? 'missing' : 'extra';\n    /**\n     * Gets the open brace token from a given node.\n     * @returns The token of the open brace.\n     */\n    function getOpenBrace(node) {\n      // guaranteed for enums\n      // This is the only change made here from the base rule\n      return sourceCode.getFirstToken(node, {\n        filter: token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '{'\n      });\n    }\n    /**\n     * Checks whether or not:\n     *   - given tokens are on same line.\n     *   - there is/isn't a space between given tokens.\n     * @param left A token to check.\n     * @param right The token which is next to `left`.\n     * @returns\n     *    When the option is `\"always\"`, `true` if there are one or more spaces between given tokens.\n     *    When the option is `\"never\"`, `true` if there are not any spaces between given tokens.\n     *    If given tokens are not on same line, it's always `true`.\n     */\n    function isValid(left, right) {\n      return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetween(left, right) === always;\n    }\n    /**\n     * Checks and reports invalid spacing style inside braces.\n     */\n    function checkSpacingInsideBraces(node) {\n      // Gets braces and the first/last token of content.\n      const openBrace = getOpenBrace(node);\n      const closeBrace = sourceCode.getLastToken(node);\n      const firstToken = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      const lastToken = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      // Skip if the node is invalid or empty.\n      if (openBrace.type !== utils_1.AST_TOKEN_TYPES.Punctuator || openBrace.value !== '{' || closeBrace.type !== utils_1.AST_TOKEN_TYPES.Punctuator || closeBrace.value !== '}' || firstToken === closeBrace) {\n        return;\n      }\n      // Skip line comments for option never\n      if (!always && firstToken.type === utils_1.AST_TOKEN_TYPES.Line) {\n        return;\n      }\n      if (!isValid(openBrace, firstToken)) {\n        let loc = openBrace.loc;\n        if (messageId === 'extra') {\n          loc = {\n            start: openBrace.loc.end,\n            end: firstToken.loc.start\n          };\n        }\n        context.report({\n          node,\n          loc,\n          messageId,\n          data: {\n            location: 'after',\n            token: openBrace.value\n          },\n          fix(fixer) {\n            if (always) {\n              return fixer.insertTextBefore(firstToken, ' ');\n            }\n            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n          }\n        });\n      }\n      if (!isValid(lastToken, closeBrace)) {\n        let loc = closeBrace.loc;\n        if (messageId === 'extra') {\n          loc = {\n            start: lastToken.loc.end,\n            end: closeBrace.loc.start\n          };\n        }\n        context.report({\n          node,\n          loc,\n          messageId,\n          data: {\n            location: 'before',\n            token: closeBrace.value\n          },\n          fix(fixer) {\n            if (always) {\n              return fixer.insertTextAfter(lastToken, ' ');\n            }\n            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n          }\n        });\n      }\n    }\n    return Object.assign(Object.assign({}, baseRules), {\n      // This code worked \"out of the box\" for interface and type literal\n      // Enums were very close to match as well, the only reason they are not is that was that enums don't have a body node in the parser\n      // So the opening brace punctuator starts in the middle of the node - `getFirstToken` in\n      // the base rule did not filter for the first opening brace punctuator\n      TSInterfaceBody: baseRules.BlockStatement,\n      TSTypeLiteral: baseRules.BlockStatement,\n      TSEnumDeclaration: checkSpacingInsideBraces\n    });\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","messages","defaultOptions","create","context","whenToApplyOption","sourceCode","getSourceCode","baseRules","always","messageId","getOpenBrace","node","getFirstToken","filter","token","AST_TOKEN_TYPES","Punctuator","value","isValid","left","right","isTokenOnSameLine","isSpaceBetween","checkSpacingInsideBraces","openBrace","closeBrace","getLastToken","firstToken","getTokenAfter","includeComments","lastToken","getTokenBefore","Line","loc","start","end","report","data","location","fix","fixer","insertTextBefore","removeRange","range","insertTextAfter","Object","assign","TSInterfaceBody","BlockStatement","TSTypeLiteral","TSEnumDeclaration"],"sources":["../../src/rules/block-spacing.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}