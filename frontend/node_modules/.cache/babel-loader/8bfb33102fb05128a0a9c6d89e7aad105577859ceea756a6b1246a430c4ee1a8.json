{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n  const s = o.strict;\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? {\n      ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\nclass Ajv {\n  constructor(opts = {}) {\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = {\n      ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n    if (schemaId === \"id\") {\n      _dataRefSchema = {\n        ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n  validate(schemaKeyRef,\n  // key, ref or schema object\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  data // to be validated\n  ) {\n    let v;\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n    async function runCompileAsync(_schema, _meta) {\n      await loadMetaSchema.call(this, _schema.$schema);\n      const sch = this._addSchema(_schema, _meta);\n      return sch.validate || _compileAsync.call(this, sch);\n    }\n    async function loadMetaSchema($ref) {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {\n          $ref\n        }, true);\n      }\n    }\n    async function _compileAsync(sch) {\n      try {\n        return this._compileSchemaEnv(sch);\n      } catch (e) {\n        if (!(e instanceof ref_error_1.default)) throw e;\n        checkLoaded.call(this, e);\n        await loadMissingSchema.call(this, e.missingSchema);\n        return _compileAsync.call(this, sch);\n      }\n    }\n    function checkLoaded({\n      missingSchema: ref,\n      missingRef\n    }) {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n    async function loadMissingSchema(ref) {\n      const _schema = await _loadSchema.call(this, ref);\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n    }\n    async function _loadSchema(ref) {\n      const p = this._loading[ref];\n      if (p) return p;\n      try {\n        return await (this._loading[ref] = loadSchema(ref));\n      } finally {\n        delete this._loading[ref];\n      }\n    }\n  }\n  // Adds schema to the instance\n  addSchema(schema,\n  // If array is passed, `key` will be ignored\n  key,\n  // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta,\n  // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n  _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ) {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n      return this;\n    }\n    let id;\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n    key = (0, resolve_1.normalizeId)(key || id);\n    this._checkUnique(key);\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  }\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(schema, key,\n  // schema key\n  _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ) {\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  }\n  //  Validate schema against its meta-schema\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n    const valid = this.validate($schema, schema);\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n    return valid;\n  }\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema(keyRef) {\n    let sch;\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n      return this;\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n          this._cache.delete(cacheKey);\n          let id = schemaKeyRef[this.opts.schemaId];\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n          return this;\n        }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n    return this;\n  }\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n    checkKeyword.call(this, keyword, def);\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n    keywordMetaschema.call(this, def);\n    const definition = {\n      ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  }\n  // Remove keyword\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n    return this;\n  }\n  // Add format\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n  errorsText(errors = this.errors,\n  // optional array of validation errors\n  {\n    separator = \", \",\n    dataVar = \"data\"\n  } = {} // optional options with properties `separator` and `dataVar`\n  ) {\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n      let keywords = metaSchema;\n      for (const seg of segments) keywords = keywords[seg];\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n    return metaSchema;\n  }\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n  _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n    let sch = this._cache.get(schema);\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n    this._cache.set(sch.schema, sch);\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports.default = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\nfunction getMetaSchemaOptions() {\n  const metaOpts = {\n    ...this.opts\n  };\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n  return metaOpts;\n}\nconst noLogs = {\n  log() {},\n  warn() {},\n  error() {}\n};\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({\n    type: t\n  }) => t === dataType);\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"names":["validate_1","require","Object","defineProperty","exports","enumerable","get","KeywordCxt","codegen_1","_","str","stringify","nil","Name","CodeGen","validation_error_1","ref_error_1","rules_1","compile_1","codegen_2","resolve_1","dataType_1","util_1","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","code","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","MAX_EXPRESSION","requiredOptions","o","s","strict","_optz","_a","optimize","undefined","regExp","_c","_b","uriResolver","_d","default","strictSchema","_f","_e","strictNumbers","_h","_g","strictTypes","_k","_j","strictTuples","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","meta","_s","messages","_t","inlineRefs","_u","schemaId","_v","addUsedSchema","_w","validateSchema","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","Ajv","constructor","opts","schemas","refs","formats","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","logger","getLogger","formatOpt","RULES","getRules","checkOptions","call","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","Error","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","_loadSchema","addSchema","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","warn","message","errorsText","error","keyRef","getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","length","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","ValidationError","MissingRefError","checkOpts","options","log","opt","optsSchemas","defs","metaOpts","noLogs","console","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\core.ts"],"sourcesContent":["export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}