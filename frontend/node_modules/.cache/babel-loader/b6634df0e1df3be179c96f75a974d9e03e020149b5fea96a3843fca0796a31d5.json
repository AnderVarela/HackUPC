{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _core = require(\"@babel/core\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-logical-assignment-operators\",\n    inherits: api.version[0] === \"8\" ? undefined : require(\"@babel/plugin-syntax-logical-assignment-operators\").default,\n    visitor: {\n      AssignmentExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const {\n          operator,\n          left,\n          right\n        } = node;\n        const operatorTrunc = operator.slice(0, -1);\n        if (!_core.types.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          return;\n        }\n        const lhs = _core.types.cloneNode(left);\n        if (_core.types.isMemberExpression(left)) {\n          const {\n            object,\n            property,\n            computed\n          } = left;\n          const memo = scope.maybeGenerateMemoised(object);\n          if (memo) {\n            left.object = memo;\n            lhs.object = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(memo), object);\n          }\n          if (computed) {\n            const memo = scope.maybeGenerateMemoised(property);\n            if (memo) {\n              left.property = memo;\n              lhs.property = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(memo), property);\n            }\n          }\n        }\n        path.replaceWith(_core.types.logicalExpression(operatorTrunc, lhs, _core.types.assignmentExpression(\"=\", left, right)));\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","inherits","version","undefined","visitor","AssignmentExpression","path","node","scope","operator","left","right","operatorTrunc","slice","types","LOGICAL_OPERATORS","includes","lhs","cloneNode","isMemberExpression","object","property","computed","memo","maybeGenerateMemoised","assignmentExpression","replaceWith","logicalExpression"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-logical-assignment-operators\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-logical-assignment-operators\",\n    inherits:\n      USE_ESM || IS_STANDALONE || api.version[0] === \"8\"\n        ? undefined\n        : // eslint-disable-next-line no-restricted-globals\n          require(\"@babel/plugin-syntax-logical-assignment-operators\").default,\n\n    visitor: {\n      AssignmentExpression(path) {\n        const { node, scope } = path;\n        const { operator, left, right } = node;\n        const operatorTrunc = operator.slice(0, -1);\n        if (!t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          return;\n        }\n\n        const lhs = t.cloneNode(left) as t.Identifier | t.MemberExpression;\n        if (t.isMemberExpression(left)) {\n          const { object, property, computed } = left;\n          const memo = scope.maybeGenerateMemoised(object);\n          if (memo) {\n            left.object = memo;\n            (lhs as t.MemberExpression).object = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(memo),\n              // object must not be Super when `memo` is an identifier\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n              object as t.Expression,\n            );\n          }\n\n          if (computed) {\n            const memo = scope.maybeGenerateMemoised(property);\n            if (memo) {\n              left.property = memo;\n              (lhs as t.MemberExpression).property = t.assignmentExpression(\n                \"=\",\n                t.cloneNode(memo),\n                // @ts-expect-error todo(flow->ts): property can be t.PrivateName\n                property,\n              );\n            }\n          }\n        }\n\n        path.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error operatorTrunc has been tested by t.LOGICAL_OPERATORS\n            operatorTrunc,\n            lhs,\n            t.assignmentExpression(\"=\", left, right),\n          ),\n        );\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,IAAAL,kBAAA,CAAAM,OAAO,EAACC,GAAG,IAAI;EAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;EAEtC,OAAO;IACLC,IAAI,EAAE,wCAAwC;IAC9CC,QAAQ,EACsBH,GAAG,CAACI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,GAC9CC,SAAS,GAETX,OAAO,CAAC,mDAAmD,CAAC,CAACI,OAAO;IAE1EQ,OAAO,EAAE;MACPC,oBAAoBA,CAACC,IAAI,EAAE;QACzB,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAGF,IAAI;QAC5B,MAAM;UAAEG,QAAQ;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAGJ,IAAI;QACtC,MAAMK,aAAa,GAAGH,QAAQ,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3C,IAAI,CAACpB,KAAA,CAAAqB,KAAC,CAACC,iBAAiB,CAACC,QAAQ,CAACJ,aAAa,CAAC,EAAE;UAChD;QACF;QAEA,MAAMK,GAAG,GAAGxB,KAAA,CAAAqB,KAAC,CAACI,SAAS,CAACR,IAAI,CAAsC;QAClE,IAAIjB,KAAA,CAAAqB,KAAC,CAACK,kBAAkB,CAACT,IAAI,CAAC,EAAE;UAC9B,MAAM;YAAEU,MAAM;YAAEC,QAAQ;YAAEC;UAAS,CAAC,GAAGZ,IAAI;UAC3C,MAAMa,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACJ,MAAM,CAAC;UAChD,IAAIG,IAAI,EAAE;YACRb,IAAI,CAACU,MAAM,GAAGG,IAAI;YACjBN,GAAG,CAAwBG,MAAM,GAAG3B,KAAA,CAAAqB,KAAC,CAACW,oBAAoB,CACzD,GAAG,EACHhC,KAAA,CAAAqB,KAAC,CAACI,SAAS,CAACK,IAAI,CAAC,EAGjBH,MACF,CAAC;UACH;UAEA,IAAIE,QAAQ,EAAE;YACZ,MAAMC,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACH,QAAQ,CAAC;YAClD,IAAIE,IAAI,EAAE;cACRb,IAAI,CAACW,QAAQ,GAAGE,IAAI;cACnBN,GAAG,CAAwBI,QAAQ,GAAG5B,KAAA,CAAAqB,KAAC,CAACW,oBAAoB,CAC3D,GAAG,EACHhC,KAAA,CAAAqB,KAAC,CAACI,SAAS,CAACK,IAAI,CAAC,EAEjBF,QACF,CAAC;YACH;UACF;QACF;QAEAf,IAAI,CAACoB,WAAW,CACdjC,KAAA,CAAAqB,KAAC,CAACa,iBAAiB,CAEjBf,aAAa,EACbK,GAAG,EACHxB,KAAA,CAAAqB,KAAC,CAACW,oBAAoB,CAAC,GAAG,EAAEf,IAAI,EAAEC,KAAK,CACzC,CACF,CAAC;MACH;IACF;EACF,CAAC;AACH,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}