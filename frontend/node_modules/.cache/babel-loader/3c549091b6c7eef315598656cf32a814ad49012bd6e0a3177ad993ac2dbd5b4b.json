{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this.type === this.assertToken || this.type === tt._with) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this.type === this.assertToken || this.type === tt._with) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this.type === this.assertToken || this.type == tt._with) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n\n        // parse AssertionKey : IdentifierName, StringLiteral\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tokTypes","tt","TokenType","constructor","args","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","parenR","finishNode","parseExport","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","_with","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/acorn-import-assertions/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this.type === this.assertToken || this.type === tt._with) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this.type === this.assertToken || this.type === tt._with) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this.type === this.assertToken || this.type == tt._with) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n\n        // parse AssertionKey : IdentifierName, StringLiteral\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}