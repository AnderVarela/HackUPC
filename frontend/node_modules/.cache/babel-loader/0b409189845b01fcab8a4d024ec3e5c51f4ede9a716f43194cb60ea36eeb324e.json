{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-unnecessary-type-assertion',\n  meta: {\n    docs: {\n      description: 'Disallow type assertions that do not change the type of an expression',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryAssertion: 'This assertion is unnecessary since it does not change the type of the expression.',\n      contextuallyUnnecessary: 'This assertion is unnecessary since the receiver accepts the original type of the expression.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        typesToIgnore: {\n          description: 'A list of type names to ignore.',\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      }\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{}],\n  create(context, [options]) {\n    const sourceCode = context.getSourceCode();\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const compilerOptions = parserServices.program.getCompilerOptions();\n    /**\n     * Sometimes tuple types don't have ObjectFlags.Tuple set, like when they're being matched against an inferred type.\n     * So, in addition, check if there are integer properties 0..n and no other numeric keys\n     */\n    function couldBeTupleType(type) {\n      const properties = type.getProperties();\n      if (properties.length === 0) {\n        return false;\n      }\n      let i = 0;\n      for (; i < properties.length; ++i) {\n        const name = properties[i].name;\n        if (String(i) !== name) {\n          if (i === 0) {\n            // if there are no integer properties, this is not a tuple\n            return false;\n          }\n          break;\n        }\n      }\n      for (; i < properties.length; ++i) {\n        if (String(+properties[i].name) === properties[i].name) {\n          return false; // if there are any other numeric properties, this is not a tuple\n        }\n      }\n      return true;\n    }\n    /**\n     * Returns true if there's a chance the variable has been used before a value has been assigned to it\n     */\n    function isPossiblyUsedBeforeAssigned(node) {\n      const declaration = util.getDeclaration(checker, node);\n      if (!declaration) {\n        // don't know what the declaration is for some reason, so just assume the worst\n        return true;\n      }\n      if (\n      // non-strict mode doesn't care about used before assigned errors\n      (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, 'strictNullChecks') &&\n      // ignore class properties as they are compile time guarded\n      // also ignore function arguments as they can't be used before defined\n      (0, tsutils_1.isVariableDeclaration)(declaration) &&\n      // is it `const x!: number`\n      declaration.initializer === undefined && declaration.exclamationToken === undefined && declaration.type !== undefined) {\n        // check if the defined variable type has changed since assignment\n        const declarationType = checker.getTypeFromTypeNode(declaration.type);\n        const type = util.getConstrainedTypeAtLocation(checker, node);\n        if (declarationType === type) {\n          // possibly used before assigned, so just skip it\n          // better to false negative and skip it, than false positive and fix to compile erroring code\n          //\n          // no better way to figure this out right now\n          // https://github.com/Microsoft/TypeScript/issues/31124\n          return true;\n        }\n      }\n      return false;\n    }\n    function isConstAssertion(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSTypeReference && node.typeName.type === utils_1.AST_NODE_TYPES.Identifier && node.typeName.name === 'const';\n    }\n    return {\n      TSNonNullExpression(node) {\n        var _a;\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.AssignmentExpression && node.parent.operator === '=') {\n          if (node.parent.left === node) {\n            context.report({\n              node,\n              messageId: 'contextuallyUnnecessary',\n              fix(fixer) {\n                return fixer.removeRange([node.expression.range[1], node.range[1]]);\n              }\n            });\n          }\n          // for all other = assignments we ignore non-null checks\n          // this is because non-null assertions can change the type-flow of the code\n          // so whilst they might be unnecessary for the assignment - they are necessary\n          // for following code\n          return;\n        }\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = util.getConstrainedTypeAtLocation(checker, originalNode.expression);\n        if (!util.isNullableType(type)) {\n          if (isPossiblyUsedBeforeAssigned(originalNode.expression)) {\n            return;\n          }\n          context.report({\n            node,\n            messageId: 'unnecessaryAssertion',\n            fix(fixer) {\n              return fixer.removeRange([node.expression.range[1], node.range[1]]);\n            }\n          });\n        } else {\n          // we know it's a nullable type\n          // so figure out if the variable is used in a place that accepts nullable types\n          const contextualType = util.getContextualType(checker, originalNode);\n          if (contextualType) {\n            // in strict mode you can't assign null to undefined, so we have to make sure that\n            // the two types share a nullable type\n            const typeIncludesUndefined = util.isTypeFlagSet(type, ts.TypeFlags.Undefined);\n            const typeIncludesNull = util.isTypeFlagSet(type, ts.TypeFlags.Null);\n            const contextualTypeIncludesUndefined = util.isTypeFlagSet(contextualType, ts.TypeFlags.Undefined);\n            const contextualTypeIncludesNull = util.isTypeFlagSet(contextualType, ts.TypeFlags.Null);\n            // make sure that the parent accepts the same types\n            // i.e. assigning `string | null | undefined` to `string | undefined` is invalid\n            const isValidUndefined = typeIncludesUndefined ? contextualTypeIncludesUndefined : true;\n            const isValidNull = typeIncludesNull ? contextualTypeIncludesNull : true;\n            if (isValidUndefined && isValidNull) {\n              context.report({\n                node,\n                messageId: 'contextuallyUnnecessary',\n                fix(fixer) {\n                  return fixer.removeRange([node.expression.range[1], node.range[1]]);\n                }\n              });\n            }\n          }\n        }\n      },\n      'TSAsExpression, TSTypeAssertion'(node) {\n        var _a;\n        if (((_a = options.typesToIgnore) === null || _a === void 0 ? void 0 : _a.includes(sourceCode.getText(node.typeAnnotation))) || isConstAssertion(node.typeAnnotation)) {\n          return;\n        }\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const castType = checker.getTypeAtLocation(originalNode);\n        if ((0, tsutils_1.isTypeFlagSet)(castType, ts.TypeFlags.Literal) || (0, tsutils_1.isObjectType)(castType) && ((0, tsutils_1.isObjectFlagSet)(castType, ts.ObjectFlags.Tuple) || couldBeTupleType(castType))) {\n          // It's not always safe to remove a cast to a literal type or tuple\n          // type, as those types are sometimes widened without the cast.\n          return;\n        }\n        const uncastType = checker.getTypeAtLocation(originalNode.expression);\n        if (uncastType === castType) {\n          context.report({\n            node,\n            messageId: 'unnecessaryAssertion',\n            fix(fixer) {\n              if (originalNode.kind === ts.SyntaxKind.TypeAssertionExpression) {\n                const closingAngleBracket = sourceCode.getTokenAfter(node.typeAnnotation);\n                return (closingAngleBracket === null || closingAngleBracket === void 0 ? void 0 : closingAngleBracket.value) === '>' ? fixer.removeRange([node.range[0], closingAngleBracket.range[1]]) : null;\n              }\n              return fixer.removeRange([node.expression.range[1] + 1, node.range[1]]);\n            }\n          });\n        }\n        // TODO - add contextually unnecessary check for this\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils_1","ts","__importStar","util","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryAssertion","contextuallyUnnecessary","schema","type","properties","typesToIgnore","items","defaultOptions","create","context","options","sourceCode","getSourceCode","parserServices","getParserServices","checker","program","getTypeChecker","compilerOptions","getCompilerOptions","couldBeTupleType","getProperties","length","i","String","isPossiblyUsedBeforeAssigned","node","declaration","getDeclaration","isStrictCompilerOptionEnabled","isVariableDeclaration","initializer","undefined","exclamationToken","declarationType","getTypeFromTypeNode","getConstrainedTypeAtLocation","isConstAssertion","AST_NODE_TYPES","TSTypeReference","typeName","Identifier","TSNonNullExpression","_a","parent","AssignmentExpression","operator","left","report","messageId","fix","fixer","removeRange","expression","range","originalNode","esTreeNodeToTSNodeMap","get","isNullableType","contextualType","getContextualType","typeIncludesUndefined","isTypeFlagSet","TypeFlags","Undefined","typeIncludesNull","Null","contextualTypeIncludesUndefined","contextualTypeIncludesNull","isValidUndefined","isValidNull","TSAsExpression, TSTypeAssertion","includes","getText","typeAnnotation","castType","getTypeAtLocation","Literal","isObjectType","isObjectFlagSet","ObjectFlags","Tuple","uncastType","kind","SyntaxKind","TypeAssertionExpression","closingAngleBracket","getTokenAfter","value"],"sources":["../../src/rules/no-unnecessary-type-assertion.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}