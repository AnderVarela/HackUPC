{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\nconst DataStream = require('./datastream');\nconst events = require('./events');\nconst Hoopy = require('hoopy');\nconst jsonpath = require('jsonpath');\nconst walk = require('./walk');\nconst DEFAULT_BUFFER_LENGTH = 1024;\nmodule.exports = match;\n\n/**\n * Public function `match`.\n *\n * Asynchronously parses a stream of JSON data, returning a stream of items\n * that match the argument. Note that if a value is `null`, it won't be matched\n * because `null` is used to signify end-of-stream in node.\n *\n * @param stream:         Readable instance representing the incoming JSON.\n *\n * @param selector:       Regular expression, string or predicate function used to\n *                        identify matches. If a regular expression or string is\n *                        passed, only property keys are tested. If a predicate is\n *                        passed, both the key and the value are passed to it as\n *                        arguments.\n *\n * @option minDepth:      Number indicating the minimum depth to apply the selector\n *                        to. The default is `0`, but setting it to a higher value\n *                        can improve performance and reduce memory usage by\n *                        eliminating the need to actualise top-level items.\n *\n * @option numbers:       Boolean, indicating whether numerical keys (e.g. array\n *                        indices) should be coerced to strings before testing the\n *                        match. Only applies if the `selector` argument is a string\n *                        or regular expression.\n *\n * @option ndjson:        Set this to true to parse newline-delimited JSON,\n *                        default is `false`.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the match buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction match(stream, selector, options = {}) {\n  const keys = [];\n  const scopes = [];\n  const properties = [];\n  const emitter = walk(stream, options);\n  const matches = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH);\n  let streamOptions;\n  const {\n    highWaterMark\n  } = options;\n  if (highWaterMark) {\n    streamOptions = {\n      highWaterMark\n    };\n  }\n  const results = new DataStream(read, streamOptions);\n  let selectorFunction, selectorPath, selectorString, resume;\n  let coerceNumbers = false;\n  let awaitPush = true;\n  let isEnded = false;\n  let length = 0;\n  let index = 0;\n  const minDepth = options.minDepth || 0;\n  check.assert.greaterOrEqual(minDepth, 0);\n  if (check.function(selector)) {\n    selectorFunction = selector;\n    selector = null;\n  } else if (check.string(selector)) {\n    check.assert.nonEmptyString(selector);\n    if (selector.startsWith('$.')) {\n      selectorPath = jsonpath.parse(selector);\n      check.assert.identical(selectorPath.shift(), {\n        expression: {\n          type: 'root',\n          value: '$'\n        }\n      });\n      selectorPath.forEach(part => {\n        check.assert.equal(part.scope, 'child');\n      });\n    } else {\n      selectorString = selector;\n      coerceNumbers = !!options.numbers;\n    }\n    selector = null;\n  } else {\n    check.assert.instanceStrict(selector, RegExp);\n    coerceNumbers = !!options.numbers;\n  }\n  emitter.on(events.array, array);\n  emitter.on(events.object, object);\n  emitter.on(events.property, property);\n  emitter.on(events.endArray, endScope);\n  emitter.on(events.endObject, endScope);\n  emitter.on(events.string, value);\n  emitter.on(events.number, value);\n  emitter.on(events.literal, value);\n  emitter.on(events.end, end);\n  emitter.on(events.error, error);\n  emitter.on(events.dataError, dataError);\n  return results;\n  function read() {\n    if (awaitPush) {\n      awaitPush = false;\n      if (isEnded) {\n        if (length > 0) {\n          after();\n        }\n        return endResults();\n      }\n    }\n    if (resume) {\n      const resumeCopy = resume;\n      resume = null;\n      resumeCopy();\n      after();\n    }\n  }\n  function after() {\n    if (awaitPush || resume) {\n      return;\n    }\n    let i;\n    for (i = 0; i < length && !resume; ++i) {\n      if (!results.push(matches[i + index])) {\n        pause();\n      }\n    }\n    if (i === length) {\n      index = length = 0;\n    } else {\n      length -= i;\n      index += i;\n    }\n  }\n  function pause() {\n    resume = emitter.pause();\n  }\n  function endResults() {\n    if (!awaitPush) {\n      results.push(null);\n    }\n  }\n  function array() {\n    scopes.push([]);\n  }\n  function object() {\n    scopes.push({});\n  }\n  function property(name) {\n    keys.push(name);\n    if (scopes.length < minDepth) {\n      return;\n    }\n    properties.push(name);\n  }\n  function endScope() {\n    if (selectorPath) {\n      keys.pop();\n    }\n    value(scopes.pop());\n  }\n  function value(v) {\n    let key;\n    if (scopes.length < minDepth) {\n      return;\n    }\n    if (scopes.length > 0) {\n      const scope = scopes[scopes.length - 1];\n      if (Array.isArray(scope)) {\n        key = scope.length;\n      } else {\n        key = properties.pop();\n      }\n      scope[key] = v;\n    }\n    if (v === null) {\n      return;\n    }\n    if (selectorFunction) {\n      if (selectorFunction(key, v, scopes.length)) {\n        push(v);\n      }\n    } else if (selectorPath) {\n      if (isSelectorPathSatisfied([...keys, key])) {\n        push(v);\n      }\n    } else {\n      if (coerceNumbers && typeof key === 'number') {\n        key = key.toString();\n      }\n      if (selectorString && selectorString === key || selector && selector.test(key)) {\n        push(v);\n      }\n    }\n  }\n  function isSelectorPathSatisfied(path) {\n    if (selectorPath.length !== path.length) {\n      return false;\n    }\n    return selectorPath.every(({\n      expression,\n      operation\n    }, i) => {\n      if (operation === 'member' && expression.type === 'identifier' || operation === 'subscript' && (expression.type === 'string_literal' || expression.type === 'numeric_literal')) {\n        return path[i] === expression.value;\n      }\n      if (operation === 'subscript' && expression.type === 'wildcard' && expression.value === '*') {\n        return true;\n      }\n      return false;\n    });\n  }\n  function push(v) {\n    if (length + 1 === matches.length) {\n      pause();\n    }\n    matches[index + length++] = v;\n    after();\n  }\n  function end() {\n    isEnded = true;\n    endResults();\n  }\n  function error(e) {\n    results.emit('error', e);\n  }\n  function dataError(e) {\n    results.emit('dataError', e);\n  }\n}","map":{"version":3,"names":["check","require","DataStream","events","Hoopy","jsonpath","walk","DEFAULT_BUFFER_LENGTH","module","exports","match","stream","selector","options","keys","scopes","properties","emitter","matches","bufferLength","streamOptions","highWaterMark","results","read","selectorFunction","selectorPath","selectorString","resume","coerceNumbers","awaitPush","isEnded","length","index","minDepth","assert","greaterOrEqual","function","string","nonEmptyString","startsWith","parse","identical","shift","expression","type","value","forEach","part","equal","scope","numbers","instanceStrict","RegExp","on","array","object","property","endArray","endScope","endObject","number","literal","end","error","dataError","after","endResults","resumeCopy","i","push","pause","name","pop","v","key","Array","isArray","isSelectorPathSatisfied","toString","test","path","every","operation","e","emit"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/src/match.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst DataStream = require('./datastream')\nconst events = require('./events')\nconst Hoopy = require('hoopy')\nconst jsonpath = require('jsonpath')\nconst walk = require('./walk')\n\nconst DEFAULT_BUFFER_LENGTH = 1024\n\nmodule.exports = match\n\n/**\n * Public function `match`.\n *\n * Asynchronously parses a stream of JSON data, returning a stream of items\n * that match the argument. Note that if a value is `null`, it won't be matched\n * because `null` is used to signify end-of-stream in node.\n *\n * @param stream:         Readable instance representing the incoming JSON.\n *\n * @param selector:       Regular expression, string or predicate function used to\n *                        identify matches. If a regular expression or string is\n *                        passed, only property keys are tested. If a predicate is\n *                        passed, both the key and the value are passed to it as\n *                        arguments.\n *\n * @option minDepth:      Number indicating the minimum depth to apply the selector\n *                        to. The default is `0`, but setting it to a higher value\n *                        can improve performance and reduce memory usage by\n *                        eliminating the need to actualise top-level items.\n *\n * @option numbers:       Boolean, indicating whether numerical keys (e.g. array\n *                        indices) should be coerced to strings before testing the\n *                        match. Only applies if the `selector` argument is a string\n *                        or regular expression.\n *\n * @option ndjson:        Set this to true to parse newline-delimited JSON,\n *                        default is `false`.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the match buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction match (stream, selector, options = {}) {\n  const keys = []\n  const scopes = []\n  const properties = []\n  const emitter = walk(stream, options)\n  const matches = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH)\n  let streamOptions\n  const { highWaterMark } = options\n  if (highWaterMark) {\n    streamOptions = { highWaterMark }\n  }\n  const results = new DataStream(read, streamOptions)\n\n  let selectorFunction, selectorPath, selectorString, resume\n  let coerceNumbers = false\n  let awaitPush = true\n  let isEnded = false\n  let length = 0\n  let index = 0\n\n  const minDepth = options.minDepth || 0\n  check.assert.greaterOrEqual(minDepth, 0)\n\n  if (check.function(selector)) {\n    selectorFunction = selector\n    selector = null\n  } else if (check.string(selector)) {\n    check.assert.nonEmptyString(selector)\n\n    if (selector.startsWith('$.')) {\n      selectorPath = jsonpath.parse(selector)\n      check.assert.identical(selectorPath.shift(), {\n        expression: {\n          type: 'root',\n          value: '$',\n        },\n      })\n      selectorPath.forEach((part) => {\n        check.assert.equal(part.scope, 'child')\n      })\n    } else {\n      selectorString = selector\n      coerceNumbers = !! options.numbers\n    }\n\n    selector = null\n  } else {\n    check.assert.instanceStrict(selector, RegExp)\n    coerceNumbers = !! options.numbers\n  }\n\n  emitter.on(events.array, array)\n  emitter.on(events.object, object)\n  emitter.on(events.property, property)\n  emitter.on(events.endArray, endScope)\n  emitter.on(events.endObject, endScope)\n  emitter.on(events.string, value)\n  emitter.on(events.number, value)\n  emitter.on(events.literal, value)\n  emitter.on(events.end, end)\n  emitter.on(events.error, error)\n  emitter.on(events.dataError, dataError)\n\n  return results\n\n  function read () {\n    if (awaitPush) {\n      awaitPush = false\n\n      if (isEnded) {\n        if (length > 0) {\n          after()\n        }\n\n        return endResults()\n      }\n    }\n\n    if (resume) {\n      const resumeCopy = resume\n      resume = null\n      resumeCopy()\n      after()\n    }\n  }\n\n  function after () {\n    if (awaitPush || resume) {\n      return\n    }\n\n    let i\n\n    for (i = 0; i < length && ! resume; ++i) {\n      if (! results.push(matches[i + index])) {\n        pause()\n      }\n    }\n\n    if (i === length) {\n      index = length = 0\n    } else {\n      length -= i\n      index += i\n    }\n  }\n\n  function pause () {\n    resume = emitter.pause()\n  }\n\n  function endResults () {\n    if (! awaitPush) {\n      results.push(null)\n    }\n  }\n\n  function array () {\n    scopes.push([])\n  }\n\n  function object () {\n    scopes.push({})\n  }\n\n  function property (name) {\n    keys.push(name)\n\n    if (scopes.length < minDepth) {\n      return\n    }\n\n    properties.push(name)\n  }\n\n  function endScope () {\n    if (selectorPath) {\n      keys.pop()\n    }\n    value(scopes.pop())\n  }\n\n  function value (v) {\n    let key\n\n    if (scopes.length < minDepth) {\n      return\n    }\n\n    if (scopes.length > 0) {\n      const scope = scopes[scopes.length - 1]\n\n      if (Array.isArray(scope)) {\n        key = scope.length\n      } else {\n        key = properties.pop()\n      }\n\n      scope[key] = v\n    }\n\n    if (v === null) {\n      return\n    }\n\n    if (selectorFunction) {\n      if (selectorFunction(key, v, scopes.length)) {\n        push(v)\n      }\n    } else if (selectorPath) {\n      if (isSelectorPathSatisfied([ ...keys, key ])) {\n        push(v)\n      }\n    } else {\n      if (coerceNumbers && typeof key === 'number') {\n        key = key.toString()\n      }\n\n      if ((selectorString && selectorString === key) || (selector && selector.test(key))) {\n        push(v)\n      }\n    }\n  }\n\n  function isSelectorPathSatisfied (path) {\n    if (selectorPath.length !== path.length) {\n      return false\n    }\n\n    return selectorPath.every(({ expression, operation }, i) => {\n      if (\n        (operation === 'member' && expression.type === 'identifier') ||\n        (operation === 'subscript' && (\n          expression.type === 'string_literal' ||\n          expression.type === 'numeric_literal'\n        ))\n      ) {\n        return path[i] === expression.value\n      }\n\n      if (\n        operation === 'subscript' &&\n        expression.type === 'wildcard' &&\n        expression.value === '*'\n      ) {\n        return true\n      }\n\n      return false\n    })\n  }\n\n  function push (v) {\n    if (length + 1 === matches.length) {\n      pause()\n    }\n\n    matches[index + length++] = v\n\n    after()\n  }\n\n  function end () {\n    isEnded = true\n    endResults()\n  }\n\n  function error (e) {\n    results.emit('error', e)\n  }\n\n  function dataError (e) {\n    results.emit('dataError', e)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}