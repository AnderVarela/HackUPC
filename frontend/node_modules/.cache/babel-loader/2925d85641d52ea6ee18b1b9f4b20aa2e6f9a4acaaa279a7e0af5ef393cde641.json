{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, {\n  keyword,\n  schemaProp,\n  schema,\n  schemaPath,\n  errSchemaPath,\n  topSchemaRef\n}) {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`\n    };\n  }\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, {\n  dataProp,\n  dataPropType: dpType,\n  data,\n  dataTypes,\n  propertyName\n}) {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n  const {\n    gen\n  } = it;\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n    dataContextProps(nextData);\n    subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n    subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName;\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n  if (dataTypes) subschema.dataTypes = dataTypes;\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, {\n  jtdDiscriminator,\n  jtdMetadata,\n  compositeRule,\n  createErrors,\n  allErrors\n}) {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;","map":{"version":3,"names":["codegen_1","require","util_1","getSubschema","it","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","undefined","Error","sch","_","getProperty","escapeFragment","exports","extendSubschemaData","subschema","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","dataContextProps","str","getErrorPath","jsPropertySyntax","parentDataProperty","Name","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","extendSubschemaMode","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\compile\\validate\\subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}