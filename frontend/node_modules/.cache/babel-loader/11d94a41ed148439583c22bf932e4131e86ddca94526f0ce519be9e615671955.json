{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryByLabelText = exports.queryAllByLabelText = exports.getByLabelText = exports.getAllByLabelText = exports.findByLabelText = exports.findAllByLabelText = void 0;\nvar _config = require(\"../config\");\nvar _helpers = require(\"../helpers\");\nvar _labelHelpers = require(\"../label-helpers\");\nvar _allUtils = require(\"./all-utils\");\nfunction queryAllLabels(container) {\n  return Array.from(container.querySelectorAll('label,input')).map(node => {\n    return {\n      node,\n      textToMatch: (0, _labelHelpers.getLabelContent)(node)\n    };\n  }).filter(({\n    textToMatch\n  }) => textToMatch !== null);\n}\nconst queryAllLabelsByText = (container, text, {\n  exact = true,\n  trim,\n  collapseWhitespace,\n  normalizer\n} = {}) => {\n  const matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;\n  const matchNormalizer = (0, _allUtils.makeNormalizer)({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const textToMatchByLabels = queryAllLabels(container);\n  return textToMatchByLabels.filter(({\n    node,\n    textToMatch\n  }) => matcher(textToMatch, node, text, matchNormalizer)).map(({\n    node\n  }) => node);\n};\nconst queryAllByLabelText = (container, text, {\n  selector = '*',\n  exact = true,\n  collapseWhitespace,\n  trim,\n  normalizer\n} = {}) => {\n  (0, _helpers.checkContainerType)(container);\n  const matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;\n  const matchNormalizer = (0, _allUtils.makeNormalizer)({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const matchingLabelledElements = Array.from(container.querySelectorAll('*')).filter(element => {\n    return (0, _labelHelpers.getRealLabels)(element).length || element.hasAttribute('aria-labelledby');\n  }).reduce((labelledElements, labelledElement) => {\n    const labelList = (0, _labelHelpers.getLabels)(container, labelledElement, {\n      selector\n    });\n    labelList.filter(label => Boolean(label.formControl)).forEach(label => {\n      if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {\n        labelledElements.push(label.formControl);\n      }\n    });\n    const labelsValue = labelList.filter(label => Boolean(label.content)).map(label => label.content);\n    if (matcher(labelsValue.join(' '), labelledElement, text, matchNormalizer)) {\n      labelledElements.push(labelledElement);\n    }\n    if (labelsValue.length > 1) {\n      labelsValue.forEach((labelValue, index) => {\n        if (matcher(labelValue, labelledElement, text, matchNormalizer)) {\n          labelledElements.push(labelledElement);\n        }\n        const labelsFiltered = [...labelsValue];\n        labelsFiltered.splice(index, 1);\n        if (labelsFiltered.length > 1) {\n          if (matcher(labelsFiltered.join(' '), labelledElement, text, matchNormalizer)) {\n            labelledElements.push(labelledElement);\n          }\n        }\n      });\n    }\n    return labelledElements;\n  }, []).concat((0, _allUtils.queryAllByAttribute)('aria-label', container, text, {\n    exact,\n    normalizer: matchNormalizer\n  }));\n  return Array.from(new Set(matchingLabelledElements)).filter(element => element.matches(selector));\n};\n\n// the getAll* query would normally look like this:\n// const getAllByLabelText = makeGetAllQuery(\n//   queryAllByLabelText,\n//   (c, text) => `Unable to find a label with the text of: ${text}`,\n// )\n// however, we can give a more helpful error message than the generic one,\n// so we're writing this one out by hand.\nconst getAllByLabelText = (container, text, ...rest) => {\n  const els = queryAllByLabelText(container, text, ...rest);\n  if (!els.length) {\n    const labels = queryAllLabelsByText(container, text, ...rest);\n    if (labels.length) {\n      const tagNames = labels.map(label => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter(tagName => !!tagName);\n      if (tagNames.length) {\n        throw (0, _config.getConfig)().getElementError(tagNames.map(tagName => `Found a label with the text of: ${text}, however the element associated with this label (<${tagName} />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <${tagName} />, you can use aria-label or aria-labelledby instead.`).join('\\n\\n'), container);\n      } else {\n        throw (0, _config.getConfig)().getElementError(`Found a label with the text of: ${text}, however no form control was found associated to that label. Make sure you're using the \"for\" attribute or \"aria-labelledby\" attribute correctly.`, container);\n      }\n    } else {\n      throw (0, _config.getConfig)().getElementError(`Unable to find a label with the text of: ${text}`, container);\n    }\n  }\n  return els;\n};\nfunction getTagNameOfElementAssociatedWithLabelViaFor(container, label) {\n  const htmlFor = label.getAttribute('for');\n  if (!htmlFor) {\n    return null;\n  }\n  const element = container.querySelector(`[id=\"${htmlFor}\"]`);\n  return element ? element.tagName.toLowerCase() : null;\n}\n\n// the reason mentioned above is the same reason we're not using buildQueries\nconst getMultipleError = (c, text) => `Found multiple elements with the text of: ${text}`;\nconst queryByLabelText = exports.queryByLabelText = (0, _allUtils.wrapSingleQueryWithSuggestion)((0, _allUtils.makeSingleQuery)(queryAllByLabelText, getMultipleError), queryAllByLabelText.name, 'query');\nconst getByLabelText = (0, _allUtils.makeSingleQuery)(getAllByLabelText, getMultipleError);\nconst findAllByLabelText = exports.findAllByLabelText = (0, _allUtils.makeFindQuery)((0, _allUtils.wrapAllByQueryWithSuggestion)(getAllByLabelText, getAllByLabelText.name, 'findAll'));\nconst findByLabelText = exports.findByLabelText = (0, _allUtils.makeFindQuery)((0, _allUtils.wrapSingleQueryWithSuggestion)(getByLabelText, getAllByLabelText.name, 'find'));\nconst getAllByLabelTextWithSuggestions = exports.getAllByLabelText = (0, _allUtils.wrapAllByQueryWithSuggestion)(getAllByLabelText, getAllByLabelText.name, 'getAll');\nconst getByLabelTextWithSuggestions = exports.getByLabelText = (0, _allUtils.wrapSingleQueryWithSuggestion)(getByLabelText, getAllByLabelText.name, 'get');\nconst queryAllByLabelTextWithSuggestions = exports.queryAllByLabelText = (0, _allUtils.wrapAllByQueryWithSuggestion)(queryAllByLabelText, queryAllByLabelText.name, 'queryAll');","map":{"version":3,"names":["Object","defineProperty","exports","value","queryByLabelText","queryAllByLabelText","getByLabelText","getAllByLabelText","findByLabelText","findAllByLabelText","_config","require","_helpers","_labelHelpers","_allUtils","queryAllLabels","container","Array","from","querySelectorAll","map","node","textToMatch","getLabelContent","filter","queryAllLabelsByText","text","exact","trim","collapseWhitespace","normalizer","matcher","matches","fuzzyMatches","matchNormalizer","makeNormalizer","textToMatchByLabels","selector","checkContainerType","matchingLabelledElements","element","getRealLabels","length","hasAttribute","reduce","labelledElements","labelledElement","labelList","getLabels","label","Boolean","formControl","forEach","content","push","labelsValue","join","labelValue","index","labelsFiltered","splice","concat","queryAllByAttribute","Set","rest","els","labels","tagNames","getTagNameOfElementAssociatedWithLabelViaFor","tagName","getConfig","getElementError","htmlFor","getAttribute","querySelector","toLowerCase","getMultipleError","c","wrapSingleQueryWithSuggestion","makeSingleQuery","name","makeFindQuery","wrapAllByQueryWithSuggestion","getAllByLabelTextWithSuggestions","getByLabelTextWithSuggestions","queryAllByLabelTextWithSuggestions"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@testing-library/dom/dist/queries/label-text.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryByLabelText = exports.queryAllByLabelText = exports.getByLabelText = exports.getAllByLabelText = exports.findByLabelText = exports.findAllByLabelText = void 0;\nvar _config = require(\"../config\");\nvar _helpers = require(\"../helpers\");\nvar _labelHelpers = require(\"../label-helpers\");\nvar _allUtils = require(\"./all-utils\");\nfunction queryAllLabels(container) {\n  return Array.from(container.querySelectorAll('label,input')).map(node => {\n    return {\n      node,\n      textToMatch: (0, _labelHelpers.getLabelContent)(node)\n    };\n  }).filter(({\n    textToMatch\n  }) => textToMatch !== null);\n}\nconst queryAllLabelsByText = (container, text, {\n  exact = true,\n  trim,\n  collapseWhitespace,\n  normalizer\n} = {}) => {\n  const matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;\n  const matchNormalizer = (0, _allUtils.makeNormalizer)({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const textToMatchByLabels = queryAllLabels(container);\n  return textToMatchByLabels.filter(({\n    node,\n    textToMatch\n  }) => matcher(textToMatch, node, text, matchNormalizer)).map(({\n    node\n  }) => node);\n};\nconst queryAllByLabelText = (container, text, {\n  selector = '*',\n  exact = true,\n  collapseWhitespace,\n  trim,\n  normalizer\n} = {}) => {\n  (0, _helpers.checkContainerType)(container);\n  const matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;\n  const matchNormalizer = (0, _allUtils.makeNormalizer)({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  const matchingLabelledElements = Array.from(container.querySelectorAll('*')).filter(element => {\n    return (0, _labelHelpers.getRealLabels)(element).length || element.hasAttribute('aria-labelledby');\n  }).reduce((labelledElements, labelledElement) => {\n    const labelList = (0, _labelHelpers.getLabels)(container, labelledElement, {\n      selector\n    });\n    labelList.filter(label => Boolean(label.formControl)).forEach(label => {\n      if (matcher(label.content, label.formControl, text, matchNormalizer) && label.formControl) {\n        labelledElements.push(label.formControl);\n      }\n    });\n    const labelsValue = labelList.filter(label => Boolean(label.content)).map(label => label.content);\n    if (matcher(labelsValue.join(' '), labelledElement, text, matchNormalizer)) {\n      labelledElements.push(labelledElement);\n    }\n    if (labelsValue.length > 1) {\n      labelsValue.forEach((labelValue, index) => {\n        if (matcher(labelValue, labelledElement, text, matchNormalizer)) {\n          labelledElements.push(labelledElement);\n        }\n        const labelsFiltered = [...labelsValue];\n        labelsFiltered.splice(index, 1);\n        if (labelsFiltered.length > 1) {\n          if (matcher(labelsFiltered.join(' '), labelledElement, text, matchNormalizer)) {\n            labelledElements.push(labelledElement);\n          }\n        }\n      });\n    }\n    return labelledElements;\n  }, []).concat((0, _allUtils.queryAllByAttribute)('aria-label', container, text, {\n    exact,\n    normalizer: matchNormalizer\n  }));\n  return Array.from(new Set(matchingLabelledElements)).filter(element => element.matches(selector));\n};\n\n// the getAll* query would normally look like this:\n// const getAllByLabelText = makeGetAllQuery(\n//   queryAllByLabelText,\n//   (c, text) => `Unable to find a label with the text of: ${text}`,\n// )\n// however, we can give a more helpful error message than the generic one,\n// so we're writing this one out by hand.\nconst getAllByLabelText = (container, text, ...rest) => {\n  const els = queryAllByLabelText(container, text, ...rest);\n  if (!els.length) {\n    const labels = queryAllLabelsByText(container, text, ...rest);\n    if (labels.length) {\n      const tagNames = labels.map(label => getTagNameOfElementAssociatedWithLabelViaFor(container, label)).filter(tagName => !!tagName);\n      if (tagNames.length) {\n        throw (0, _config.getConfig)().getElementError(tagNames.map(tagName => `Found a label with the text of: ${text}, however the element associated with this label (<${tagName} />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <${tagName} />, you can use aria-label or aria-labelledby instead.`).join('\\n\\n'), container);\n      } else {\n        throw (0, _config.getConfig)().getElementError(`Found a label with the text of: ${text}, however no form control was found associated to that label. Make sure you're using the \"for\" attribute or \"aria-labelledby\" attribute correctly.`, container);\n      }\n    } else {\n      throw (0, _config.getConfig)().getElementError(`Unable to find a label with the text of: ${text}`, container);\n    }\n  }\n  return els;\n};\nfunction getTagNameOfElementAssociatedWithLabelViaFor(container, label) {\n  const htmlFor = label.getAttribute('for');\n  if (!htmlFor) {\n    return null;\n  }\n  const element = container.querySelector(`[id=\"${htmlFor}\"]`);\n  return element ? element.tagName.toLowerCase() : null;\n}\n\n// the reason mentioned above is the same reason we're not using buildQueries\nconst getMultipleError = (c, text) => `Found multiple elements with the text of: ${text}`;\nconst queryByLabelText = exports.queryByLabelText = (0, _allUtils.wrapSingleQueryWithSuggestion)((0, _allUtils.makeSingleQuery)(queryAllByLabelText, getMultipleError), queryAllByLabelText.name, 'query');\nconst getByLabelText = (0, _allUtils.makeSingleQuery)(getAllByLabelText, getMultipleError);\nconst findAllByLabelText = exports.findAllByLabelText = (0, _allUtils.makeFindQuery)((0, _allUtils.wrapAllByQueryWithSuggestion)(getAllByLabelText, getAllByLabelText.name, 'findAll'));\nconst findByLabelText = exports.findByLabelText = (0, _allUtils.makeFindQuery)((0, _allUtils.wrapSingleQueryWithSuggestion)(getByLabelText, getAllByLabelText.name, 'find'));\nconst getAllByLabelTextWithSuggestions = exports.getAllByLabelText = (0, _allUtils.wrapAllByQueryWithSuggestion)(getAllByLabelText, getAllByLabelText.name, 'getAll');\nconst getByLabelTextWithSuggestions = exports.getByLabelText = (0, _allUtils.wrapSingleQueryWithSuggestion)(getByLabelText, getAllByLabelText.name, 'get');\nconst queryAllByLabelTextWithSuggestions = exports.queryAllByLabelText = (0, _allUtils.wrapAllByQueryWithSuggestion)(queryAllByLabelText, queryAllByLabelText.name, 'queryAll');"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}