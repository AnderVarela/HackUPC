{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\nvar t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\nfunction transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n  if (!typeInstructions.length) {\n    return;\n  }\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n    return signature;\n  }\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n      Func.toString = function () {\n        return _Func.toString();\n      };\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","transform","t","require","ast","typeInstructions","traverse","TypeInstruction","_ref","node","push","length","denormalizeSignature","signature","type","identifier","typeInstruction","find","id","Error","concat","JSON","stringify","functype","signatureRef","_typeInstruction","Func","_Func","_x","apply","arguments","toString","_ref2","CallIndirectInstruction","_ref3"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/lib/transform/denormalize-type-references/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\n\nfunction transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n\n  if (!typeInstructions.length) {\n    return;\n  }\n\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n\n    return signature;\n  }\n\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,SAAS,GAAGA,SAAS;AAE7B,IAAIC,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASF,SAASA,CAACG,GAAG,EAAE;EACtB,IAAIC,gBAAgB,GAAG,EAAE;EACzBH,CAAC,CAACI,QAAQ,CAACF,GAAG,EAAE;IACdG,eAAe,EAAE,SAASA,eAAeA,CAACC,IAAI,EAAE;MAC9C,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAI;MACpBJ,gBAAgB,CAACK,IAAI,CAACD,IAAI,CAAC;IAC7B;EACF,CAAC,CAAC;EAEF,IAAI,CAACJ,gBAAgB,CAACM,MAAM,EAAE;IAC5B;EACF;EAEA,SAASC,oBAAoBA,CAACC,SAAS,EAAE;IACvC;IACA,IAAIA,SAAS,CAACC,IAAI,KAAK,YAAY,EAAE;MACnC,IAAIC,UAAU,GAAGF,SAAS;MAC1B,IAAIG,eAAe,GAAGX,gBAAgB,CAACY,IAAI,CAAC,UAAUf,CAAC,EAAE;QACvD,OAAOA,CAAC,CAACgB,EAAE,CAACJ,IAAI,KAAKC,UAAU,CAACD,IAAI,IAAIZ,CAAC,CAACgB,EAAE,CAAClB,KAAK,KAAKe,UAAU,CAACf,KAAK;MACzE,CAAC,CAAC;MAEF,IAAI,CAACgB,eAAe,EAAE;QACpB,MAAM,IAAIG,KAAK,CAAC,6CAA6C,CAACC,MAAM,CAACC,IAAI,CAACC,SAAS,CAACT,SAAS,CAAC,CAAC,CAAC;MAClG;MAEA,OAAOG,eAAe,CAACO,QAAQ;IACjC,CAAC,CAAC;;IAGF,IAAIV,SAAS,CAACC,IAAI,KAAK,eAAe,EAAE;MACtC,IAAIU,YAAY,GAAGX,SAAS;MAC5B,IAAIY,gBAAgB,GAAGpB,gBAAgB,CAACmB,YAAY,CAACxB,KAAK,CAAC;MAC3D,OAAOyB,gBAAgB,CAACF,QAAQ;IAClC;IAEA,OAAOV,SAAS;EAClB;EAEAX,CAAC,CAACI,QAAQ,CAACF,GAAG,EAAE;IACdsB,IAAI,EAAE,UAAUC,KAAK,EAAE;MACrB,SAASD,IAAIA,CAACE,EAAE,EAAE;QAChB,OAAOD,KAAK,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACrC;MAEAJ,IAAI,CAACK,QAAQ,GAAG,YAAY;QAC1B,OAAOJ,KAAK,CAACI,QAAQ,CAAC,CAAC;MACzB,CAAC;MAED,OAAOL,IAAI;IACb,CAAC,CAAC,UAAUM,KAAK,EAAE;MACjB,IAAIvB,IAAI,GAAGuB,KAAK,CAACvB,IAAI;MACrBA,IAAI,CAACI,SAAS,GAAGD,oBAAoB,CAACH,IAAI,CAACI,SAAS,CAAC;IACvD,CAAC,CAAC;IACFoB,uBAAuB,EAAE,SAASA,uBAAuBA,CAACC,KAAK,EAAE;MAC/D,IAAIzB,IAAI,GAAGyB,KAAK,CAACzB,IAAI;MACrBA,IAAI,CAACI,SAAS,GAAGD,oBAAoB,CAACH,IAAI,CAACI,SAAS,CAAC;IACvD;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}