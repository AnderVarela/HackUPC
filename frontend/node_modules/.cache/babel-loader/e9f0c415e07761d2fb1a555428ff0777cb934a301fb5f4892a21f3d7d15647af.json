{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('space-infix-ops');\nconst UNIONS = ['|', '&'];\nexports.default = util.createRule({\n  name: 'space-infix-ops',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require spacing around infix operators',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: baseRule.meta.fixable,\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: baseRule.meta.schema,\n    messages: Object.assign({\n      // @ts-expect-error -- we report on this messageId so we need to ensure it's there in case ESLint changes in future\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }, baseRule.meta.messages)\n  },\n  defaultOptions: [{\n    int32Hint: false\n  }],\n  create(context) {\n    const rules = baseRule.create(context);\n    const sourceCode = context.getSourceCode();\n    function report(operator) {\n      context.report({\n        node: operator,\n        messageId: 'missingSpace',\n        data: {\n          operator: operator.value\n        },\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(operator);\n          const afterToken = sourceCode.getTokenAfter(operator);\n          let fixString = '';\n          if (operator.range[0] - previousToken.range[1] === 0) {\n            fixString = ' ';\n          }\n          fixString += operator.value;\n          if (afterToken.range[0] - operator.range[1] === 0) {\n            fixString += ' ';\n          }\n          return fixer.replaceText(operator, fixString);\n        }\n      });\n    }\n    function isSpaceChar(token) {\n      return token.type === utils_1.AST_TOKEN_TYPES.Punctuator && /^[=?:]$/.test(token.value);\n    }\n    function checkAndReportAssignmentSpace(leftNode, rightNode) {\n      if (!rightNode || !leftNode) {\n        return;\n      }\n      const operator = sourceCode.getFirstTokenBetween(leftNode, rightNode, isSpaceChar);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n      if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) {\n        report(operator);\n      }\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n    function checkForEnumAssignmentSpace(node) {\n      checkAndReportAssignmentSpace(node.id, node.initializer);\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n    function checkForPropertyDefinitionAssignmentSpace(node) {\n      var _a;\n      const leftNode = node.optional && !node.typeAnnotation ? sourceCode.getTokenAfter(node.key) : (_a = node.typeAnnotation) !== null && _a !== void 0 ? _a : node.key;\n      checkAndReportAssignmentSpace(leftNode, node.value);\n    }\n    /**\n     * Check if it is missing spaces between type annotations chaining\n     * @param typeAnnotation TypeAnnotations list\n     */\n    function checkForTypeAnnotationSpace(typeAnnotation) {\n      const types = typeAnnotation.types;\n      types.forEach(type => {\n        const skipFunctionParenthesis = type.type === utils_1.TSESTree.AST_NODE_TYPES.TSFunctionType ? util.isNotOpeningParenToken : 0;\n        const operator = sourceCode.getTokenBefore(type, skipFunctionParenthesis);\n        if (operator != null && UNIONS.includes(operator.value)) {\n          const prev = sourceCode.getTokenBefore(operator);\n          const next = sourceCode.getTokenAfter(operator);\n          if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) {\n            report(operator);\n          }\n        }\n      });\n    }\n    /**\n     * Check if it has an assignment char and report if it's faulty\n     * @param node The node to report\n     */\n    function checkForTypeAliasAssignment(node) {\n      var _a;\n      checkAndReportAssignmentSpace((_a = node.typeParameters) !== null && _a !== void 0 ? _a : node.id, node.typeAnnotation);\n    }\n    function checkForTypeConditional(node) {\n      checkAndReportAssignmentSpace(node.extendsType, node.trueType);\n      checkAndReportAssignmentSpace(node.trueType, node.falseType);\n    }\n    return Object.assign(Object.assign({}, rules), {\n      TSEnumMember: checkForEnumAssignmentSpace,\n      PropertyDefinition: checkForPropertyDefinitionAssignmentSpace,\n      TSTypeAliasDeclaration: checkForTypeAliasAssignment,\n      TSUnionType: checkForTypeAnnotationSpace,\n      TSIntersectionType: checkForTypeAnnotationSpace,\n      TSConditionalType: checkForTypeConditional\n    });\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","UNIONS","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","messages","Object","assign","missingSpace","defaultOptions","int32Hint","create","context","rules","sourceCode","getSourceCode","report","operator","node","messageId","data","value","fix","fixer","previousToken","getTokenBefore","afterToken","getTokenAfter","fixString","range","replaceText","isSpaceChar","token","AST_TOKEN_TYPES","Punctuator","test","checkAndReportAssignmentSpace","leftNode","rightNode","getFirstTokenBetween","prev","next","isSpaceBetween","checkForEnumAssignmentSpace","id","initializer","checkForPropertyDefinitionAssignmentSpace","optional","typeAnnotation","key","_a","checkForTypeAnnotationSpace","types","forEach","skipFunctionParenthesis","TSESTree","AST_NODE_TYPES","TSFunctionType","isNotOpeningParenToken","includes","checkForTypeAliasAssignment","typeParameters","checkForTypeConditional","extendsType","trueType","falseType","TSEnumMember","PropertyDefinition","TSTypeAliasDeclaration","TSUnionType","TSIntersectionType","TSConditionalType"],"sources":["../../src/rules/space-infix-ops.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}