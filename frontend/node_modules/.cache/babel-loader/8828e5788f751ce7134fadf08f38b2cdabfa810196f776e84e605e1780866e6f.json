{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperCompilationTargets = require(\"@babel/helper-compilation-targets\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\nvar _core = require(\"@babel/core\");\nvar _globals = require(\"globals\");\nvar _transformClass = require(\"./transformClass.js\");\nconst getBuiltinClasses = category => Object.keys(_globals[category]).filter(name => /^[A-Z]/.test(name));\nconst builtinClasses = new Set([...getBuiltinClasses(\"builtin\"), ...getBuiltinClasses(\"browser\")]);\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  const setClassMethods = (_api$assumption = api.assumption(\"setClassMethods\")) != null ? _api$assumption : loose;\n  const constantSuper = (_api$assumption2 = api.assumption(\"constantSuper\")) != null ? _api$assumption2 : loose;\n  const superIsCallableConstructor = (_api$assumption3 = api.assumption(\"superIsCallableConstructor\")) != null ? _api$assumption3 : loose;\n  const noClassCalls = (_api$assumption4 = api.assumption(\"noClassCalls\")) != null ? _api$assumption4 : loose;\n  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)(\"transform-unicode-escapes\", api.targets());\n  const VISITED = new WeakSet();\n  return {\n    name: \"transform-classes\",\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        if (!path.get(\"declaration\").isClassDeclaration()) return;\n        (0, _helperSplitExportDeclaration.default)(path);\n      },\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n        const ref = node.id || path.scope.generateUidIdentifier(\"class\");\n        path.replaceWith(_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));\n      },\n      ClassExpression(path, state) {\n        const {\n          node\n        } = path;\n        if (VISITED.has(node)) return;\n        const inferred = (0, _helperFunctionName.default)(path, undefined, supportUnicodeId);\n        if (inferred && inferred !== node) {\n          path.replaceWith(inferred);\n          return;\n        }\n        VISITED.add(node);\n        const [replacedPath] = path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {\n          setClassMethods,\n          constantSuper,\n          superIsCallableConstructor,\n          noClassCalls\n        }, supportUnicodeId));\n        if (replacedPath.isCallExpression()) {\n          (0, _helperAnnotateAsPure.default)(replacedPath);\n          const callee = replacedPath.get(\"callee\");\n          if (callee.isArrowFunctionExpression()) {\n            callee.arrowFunctionToExpression();\n          }\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperCompilationTargets","_helperAnnotateAsPure","_helperFunctionName","_helperSplitExportDeclaration","_core","_globals","_transformClass","getBuiltinClasses","category","Object","keys","filter","name","test","builtinClasses","Set","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","_api$assumption3","_api$assumption4","assertVersion","loose","setClassMethods","assumption","constantSuper","superIsCallableConstructor","noClassCalls","supportUnicodeId","isRequired","targets","VISITED","WeakSet","visitor","ExportDefaultDeclaration","path","get","isClassDeclaration","ClassDeclaration","node","ref","id","scope","generateUidIdentifier","replaceWith","types","variableDeclaration","variableDeclarator","toExpression","ClassExpression","state","has","inferred","undefined","add","replacedPath","file","isCallExpression","callee","isArrowFunctionExpression","arrowFunctionToExpression"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-classes\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport { types as t } from \"@babel/core\";\nimport globals from \"globals\";\nimport transformClass from \"./transformClass.ts\";\n\nconst getBuiltinClasses = (category: keyof typeof globals) =>\n  Object.keys(globals[category]).filter(name => /^[A-Z]/.test(name));\n\nconst builtinClasses = new Set([\n  ...getBuiltinClasses(\"builtin\"),\n  ...getBuiltinClasses(\"browser\"),\n]);\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { loose = false } = options;\n\n  const setClassMethods = api.assumption(\"setClassMethods\") ?? loose;\n  const constantSuper = api.assumption(\"constantSuper\") ?? loose;\n  const superIsCallableConstructor =\n    api.assumption(\"superIsCallableConstructor\") ?? loose;\n  const noClassCalls = api.assumption(\"noClassCalls\") ?? loose;\n  const supportUnicodeId = !isRequired(\n    \"transform-unicode-escapes\",\n    api.targets(),\n  );\n\n  // todo: investigate traversal requeueing\n  const VISITED = new WeakSet();\n\n  return {\n    name: \"transform-classes\",\n\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        if (!path.get(\"declaration\").isClassDeclaration()) return;\n        splitExportDeclaration(path);\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n\n        const ref = node.id || path.scope.generateUidIdentifier(\"class\");\n\n        path.replaceWith(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(ref, t.toExpression(node)),\n          ]),\n        );\n      },\n\n      ClassExpression(path, state) {\n        const { node } = path;\n        if (VISITED.has(node)) return;\n\n        const inferred = nameFunction(path, undefined, supportUnicodeId);\n        if (inferred && inferred !== node) {\n          path.replaceWith(inferred);\n          return;\n        }\n\n        VISITED.add(node);\n\n        const [replacedPath] = path.replaceWith(\n          transformClass(\n            path,\n            state.file,\n            builtinClasses,\n            loose,\n            {\n              setClassMethods,\n              constantSuper,\n              superIsCallableConstructor,\n              noClassCalls,\n            },\n            supportUnicodeId,\n          ),\n        );\n\n        if (replacedPath.isCallExpression()) {\n          annotateAsPure(replacedPath);\n          const callee = replacedPath.get(\"callee\");\n          if (callee.isArrowFunctionExpression()) {\n            // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n            callee.arrowFunctionToExpression();\n          }\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}