{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'unified-signatures',\n  meta: {\n    docs: {\n      description: 'Disallow two overloads that could be unified into one with a union or an optional/rest parameter',\n      // too opinionated to be recommended\n      recommended: 'strict'\n    },\n    type: 'suggestion',\n    messages: {\n      omittingRestParameter: '{{failureStringStart}} with a rest parameter.',\n      omittingSingleParameter: '{{failureStringStart}} with an optional parameter.',\n      singleParameterDifference: '{{failureStringStart}} taking `{{type1}} | {{type2}}`.'\n    },\n    schema: [{\n      additionalProperties: false,\n      properties: {\n        ignoreDifferentlyNamedParameters: {\n          description: 'Whether two parameters with different names at the same index should be considered different even if their types are the same.',\n          type: 'boolean'\n        }\n      },\n      type: 'object'\n    }]\n  },\n  defaultOptions: [{\n    ignoreDifferentlyNamedParameters: false\n  }],\n  create(context, [{\n    ignoreDifferentlyNamedParameters\n  }]) {\n    const sourceCode = context.getSourceCode();\n    //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n    function failureStringStart(otherLine) {\n      // For only 2 overloads we don't need to specify which is the other one.\n      const overloads = otherLine === undefined ? 'These overloads' : `This overload and the one on line ${otherLine}`;\n      return `${overloads} can be combined into one signature`;\n    }\n    function addFailures(failures) {\n      for (const failure of failures) {\n        const {\n          unify,\n          only2\n        } = failure;\n        switch (unify.kind) {\n          case 'single-parameter-difference':\n            {\n              const {\n                p0,\n                p1\n              } = unify;\n              const lineOfOtherOverload = only2 ? undefined : p0.loc.start.line;\n              const typeAnnotation0 = isTSParameterProperty(p0) ? p0.parameter.typeAnnotation : p0.typeAnnotation;\n              const typeAnnotation1 = isTSParameterProperty(p1) ? p1.parameter.typeAnnotation : p1.typeAnnotation;\n              context.report({\n                loc: p1.loc,\n                messageId: 'singleParameterDifference',\n                data: {\n                  failureStringStart: failureStringStart(lineOfOtherOverload),\n                  type1: sourceCode.getText(typeAnnotation0 === null || typeAnnotation0 === void 0 ? void 0 : typeAnnotation0.typeAnnotation),\n                  type2: sourceCode.getText(typeAnnotation1 === null || typeAnnotation1 === void 0 ? void 0 : typeAnnotation1.typeAnnotation)\n                },\n                node: p1\n              });\n              break;\n            }\n          case 'extra-parameter':\n            {\n              const {\n                extraParameter,\n                otherSignature\n              } = unify;\n              const lineOfOtherOverload = only2 ? undefined : otherSignature.loc.start.line;\n              context.report({\n                loc: extraParameter.loc,\n                messageId: extraParameter.type === utils_1.AST_NODE_TYPES.RestElement ? 'omittingRestParameter' : 'omittingSingleParameter',\n                data: {\n                  failureStringStart: failureStringStart(lineOfOtherOverload)\n                },\n                node: extraParameter\n              });\n            }\n        }\n      }\n    }\n    function checkOverloads(signatures, typeParameters) {\n      const result = [];\n      const isTypeParameter = getIsTypeParameter(typeParameters);\n      for (const overloads of signatures) {\n        forEachPair(overloads, (a, b) => {\n          var _a, _b;\n          const signature0 = (_a = a.value) !== null && _a !== void 0 ? _a : a;\n          const signature1 = (_b = b.value) !== null && _b !== void 0 ? _b : b;\n          const unify = compareSignatures(signature0, signature1, isTypeParameter);\n          if (unify !== undefined) {\n            result.push({\n              unify,\n              only2: overloads.length === 2\n            });\n          }\n        });\n      }\n      return result;\n    }\n    function compareSignatures(a, b, isTypeParameter) {\n      if (!signaturesCanBeUnified(a, b, isTypeParameter)) {\n        return undefined;\n      }\n      return a.params.length === b.params.length ? signaturesDifferBySingleParameter(a.params, b.params) : signaturesDifferByOptionalOrRestParameter(a, b);\n    }\n    function signaturesCanBeUnified(a, b, isTypeParameter) {\n      // Must return the same type.\n      const aTypeParams = a.typeParameters !== undefined ? a.typeParameters.params : undefined;\n      const bTypeParams = b.typeParameters !== undefined ? b.typeParameters.params : undefined;\n      if (ignoreDifferentlyNamedParameters) {\n        const commonParamsLength = Math.min(a.params.length, b.params.length);\n        for (let i = 0; i < commonParamsLength; i += 1) {\n          if (a.params[i].type === b.params[i].type && getStaticParameterName(a.params[i]) !== getStaticParameterName(b.params[i])) {\n            return false;\n          }\n        }\n      }\n      return typesAreEqual(a.returnType, b.returnType) &&\n      // Must take the same type parameters.\n      // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.\n      util.arraysAreEqual(aTypeParams, bTypeParams, typeParametersAreEqual) && signatureUsesTypeParameter(a, isTypeParameter) === signatureUsesTypeParameter(b, isTypeParameter);\n    }\n    /** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */\n    function signaturesDifferBySingleParameter(types1, types2) {\n      const index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);\n      if (index === undefined) {\n        return undefined;\n      }\n      // If remaining arrays are equal, the signatures differ by just one parameter type\n      if (!util.arraysAreEqual(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {\n        return undefined;\n      }\n      const a = types1[index];\n      const b = types2[index];\n      // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.\n      // See https://github.com/Microsoft/TypeScript/issues/5077\n      return parametersHaveEqualSigils(a, b) && a.type !== utils_1.AST_NODE_TYPES.RestElement ? {\n        kind: 'single-parameter-difference',\n        p0: a,\n        p1: b\n      } : undefined;\n    }\n    /**\n     * Detect `a(): void` and `a(x: number): void`.\n     * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.\n     */\n    function signaturesDifferByOptionalOrRestParameter(a, b) {\n      const sig1 = a.params;\n      const sig2 = b.params;\n      const minLength = Math.min(sig1.length, sig2.length);\n      const longer = sig1.length < sig2.length ? sig2 : sig1;\n      const shorter = sig1.length < sig2.length ? sig1 : sig2;\n      const shorterSig = sig1.length < sig2.length ? a : b;\n      // If one is has 2+ parameters more than the other, they must all be optional/rest.\n      // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)\n      // Not allowed: f() and f(x, y)\n      for (let i = minLength + 1; i < longer.length; i++) {\n        if (!parameterMayBeMissing(longer[i])) {\n          return undefined;\n        }\n      }\n      for (let i = 0; i < minLength; i++) {\n        const sig1i = sig1[i];\n        const sig2i = sig2[i];\n        const typeAnnotation1 = isTSParameterProperty(sig1i) ? sig1i.parameter.typeAnnotation : sig1i.typeAnnotation;\n        const typeAnnotation2 = isTSParameterProperty(sig2i) ? sig2i.parameter.typeAnnotation : sig2i.typeAnnotation;\n        if (!typesAreEqual(typeAnnotation1, typeAnnotation2)) {\n          return undefined;\n        }\n      }\n      if (minLength > 0 && shorter[minLength - 1].type === utils_1.AST_NODE_TYPES.RestElement) {\n        return undefined;\n      }\n      return {\n        extraParameter: longer[longer.length - 1],\n        kind: 'extra-parameter',\n        otherSignature: shorterSig\n      };\n    }\n    /** Given type parameters, returns a function to test whether a type is one of those parameters. */\n    function getIsTypeParameter(typeParameters) {\n      if (typeParameters === undefined) {\n        return () => false;\n      }\n      const set = new Set();\n      for (const t of typeParameters.params) {\n        set.add(t.name.name);\n      }\n      return typeName => set.has(typeName);\n    }\n    /** True if any of the outer type parameters are used in a signature. */\n    function signatureUsesTypeParameter(sig, isTypeParameter) {\n      return sig.params.some(p => typeContainsTypeParameter(isTSParameterProperty(p) ? p.parameter.typeAnnotation : p.typeAnnotation));\n      function typeContainsTypeParameter(type) {\n        if (!type) {\n          return false;\n        }\n        if (type.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n          const typeName = type.typeName;\n          if (isIdentifier(typeName) && isTypeParameter(typeName.name)) {\n            return true;\n          }\n        }\n        return typeContainsTypeParameter(type.typeAnnotation || type.elementType);\n      }\n    }\n    function isTSParameterProperty(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSParameterProperty;\n    }\n    function parametersAreEqual(a, b) {\n      const typeAnnotationA = isTSParameterProperty(a) ? a.parameter.typeAnnotation : a.typeAnnotation;\n      const typeAnnotationB = isTSParameterProperty(b) ? b.parameter.typeAnnotation : b.typeAnnotation;\n      return parametersHaveEqualSigils(a, b) && typesAreEqual(typeAnnotationA, typeAnnotationB);\n    }\n    /** True for optional/rest parameters. */\n    function parameterMayBeMissing(p) {\n      const optional = isTSParameterProperty(p) ? p.parameter.optional : p.optional;\n      return p.type === utils_1.AST_NODE_TYPES.RestElement || optional;\n    }\n    /** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */\n    function parametersHaveEqualSigils(a, b) {\n      const optionalA = isTSParameterProperty(a) ? a.parameter.optional : a.optional;\n      const optionalB = isTSParameterProperty(b) ? b.parameter.optional : b.optional;\n      return a.type === utils_1.AST_NODE_TYPES.RestElement === (b.type === utils_1.AST_NODE_TYPES.RestElement) && optionalA !== undefined === (optionalB !== undefined);\n    }\n    function typeParametersAreEqual(a, b) {\n      return a.name.name === b.name.name && constraintsAreEqual(a.constraint, b.constraint);\n    }\n    function typesAreEqual(a, b) {\n      return a === b || a !== undefined && b !== undefined && sourceCode.getText(a.typeAnnotation) === sourceCode.getText(b.typeAnnotation);\n    }\n    function constraintsAreEqual(a, b) {\n      return a === b || a !== undefined && b !== undefined && a.type === b.type;\n    }\n    /* Returns the first index where `a` and `b` differ. */\n    function getIndexOfFirstDifference(a, b, equal) {\n      for (let i = 0; i < a.length && i < b.length; i++) {\n        if (!equal(a[i], b[i])) {\n          return i;\n        }\n      }\n      return undefined;\n    }\n    /** Calls `action` for every pair of values in `values`. */\n    function forEachPair(values, action) {\n      for (let i = 0; i < values.length; i++) {\n        for (let j = i + 1; j < values.length; j++) {\n          action(values[i], values[j]);\n        }\n      }\n    }\n    const scopes = [];\n    let currentScope = {\n      overloads: new Map()\n    };\n    function createScope(parent, typeParameters) {\n      currentScope && scopes.push(currentScope);\n      currentScope = {\n        overloads: new Map(),\n        parent,\n        typeParameters\n      };\n    }\n    function checkScope() {\n      const failures = checkOverloads(Array.from(currentScope.overloads.values()), currentScope.typeParameters);\n      addFailures(failures);\n      currentScope = scopes.pop();\n    }\n    function addOverload(signature, key, containingNode) {\n      key = key !== null && key !== void 0 ? key : getOverloadKey(signature);\n      if (currentScope && (containingNode || signature).parent === currentScope.parent) {\n        const overloads = currentScope.overloads.get(key);\n        if (overloads !== undefined) {\n          overloads.push(signature);\n        } else {\n          currentScope.overloads.set(key, [signature]);\n        }\n      }\n    }\n    //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n    return {\n      Program: createScope,\n      TSModuleBlock: createScope,\n      TSInterfaceDeclaration(node) {\n        createScope(node.body, node.typeParameters);\n      },\n      ClassDeclaration(node) {\n        createScope(node.body, node.typeParameters);\n      },\n      TSTypeLiteral: createScope,\n      // collect overloads\n      TSDeclareFunction(node) {\n        var _a, _b;\n        const exportingNode = getExportingNode(node);\n        addOverload(node, (_b = (_a = node.id) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : exportingNode === null || exportingNode === void 0 ? void 0 : exportingNode.type, exportingNode);\n      },\n      TSCallSignatureDeclaration: addOverload,\n      TSConstructSignatureDeclaration: addOverload,\n      TSMethodSignature: addOverload,\n      TSAbstractMethodDefinition(node) {\n        if (!node.value.body) {\n          addOverload(node);\n        }\n      },\n      MethodDefinition(node) {\n        if (!node.value.body) {\n          addOverload(node);\n        }\n      },\n      // validate scopes\n      'Program:exit': checkScope,\n      'TSModuleBlock:exit': checkScope,\n      'TSInterfaceDeclaration:exit': checkScope,\n      'ClassDeclaration:exit': checkScope,\n      'TSTypeLiteral:exit': checkScope\n    };\n  }\n});\nfunction getExportingNode(node) {\n  return node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration || node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) ? node.parent : undefined;\n}\nfunction getOverloadKey(node) {\n  const info = getOverloadInfo(node);\n  return (node.computed ? '0' : '1') + (node.static ? '0' : '1') + info;\n}\nfunction getOverloadInfo(node) {\n  switch (node.type) {\n    case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n      return 'constructor';\n    case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n      return '()';\n    default:\n      {\n        const {\n          key\n        } = node;\n        return isIdentifier(key) ? key.name : key.raw;\n      }\n  }\n}\nfunction getStaticParameterName(param) {\n  switch (param.type) {\n    case utils_1.AST_NODE_TYPES.Identifier:\n      return param.name;\n    case utils_1.AST_NODE_TYPES.RestElement:\n      return getStaticParameterName(param.argument);\n    default:\n      return undefined;\n  }\n}\nfunction isIdentifier(node) {\n  return node.type === utils_1.AST_NODE_TYPES.Identifier;\n}","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","docs","description","recommended","type","messages","omittingRestParameter","omittingSingleParameter","singleParameterDifference","schema","additionalProperties","properties","ignoreDifferentlyNamedParameters","defaultOptions","create","context","sourceCode","getSourceCode","failureStringStart","otherLine","overloads","undefined","addFailures","failures","failure","unify","only2","kind","p0","p1","lineOfOtherOverload","loc","start","line","typeAnnotation0","isTSParameterProperty","parameter","typeAnnotation","typeAnnotation1","report","messageId","data","type1","getText","type2","node","extraParameter","otherSignature","AST_NODE_TYPES","RestElement","checkOverloads","signatures","typeParameters","result","isTypeParameter","getIsTypeParameter","forEachPair","a","b","signature0","_a","value","signature1","_b","compareSignatures","push","length","signaturesCanBeUnified","params","signaturesDifferBySingleParameter","signaturesDifferByOptionalOrRestParameter","aTypeParams","bTypeParams","commonParamsLength","Math","min","i","getStaticParameterName","typesAreEqual","returnType","arraysAreEqual","typeParametersAreEqual","signatureUsesTypeParameter","types1","types2","index","getIndexOfFirstDifference","parametersAreEqual","slice","parametersHaveEqualSigils","sig1","sig2","minLength","longer","shorter","shorterSig","parameterMayBeMissing","sig1i","sig2i","typeAnnotation2","set","Set","t","add","typeName","has","sig","some","p","typeContainsTypeParameter","TSTypeReference","isIdentifier","elementType","TSParameterProperty","typeAnnotationA","typeAnnotationB","optional","optionalA","optionalB","constraintsAreEqual","constraint","equal","values","action","j","scopes","currentScope","Map","createScope","parent","checkScope","Array","from","pop","addOverload","signature","key","containingNode","getOverloadKey","get","Program","TSModuleBlock","TSInterfaceDeclaration","body","ClassDeclaration","TSTypeLiteral","TSDeclareFunction","exportingNode","getExportingNode","id","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","TSMethodSignature","TSAbstractMethodDefinition","MethodDefinition","ExportNamedDeclaration","ExportDefaultDeclaration","info","getOverloadInfo","computed","static","raw","param","Identifier","argument"],"sources":["../../src/rules/unified-signatures.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAEA,MAAAC,IAAA,GAAAC,YAAA,CAAAF,OAAA;AA4DAG,OAAA,CAAAC,OAAA,GAAeH,IAAI,CAACI,UAAU,CAAsB;EAClDC,IAAI,EAAE,oBAAoB;EAC1BC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EACT,kGAAkG;MACpG;MACAC,WAAW,EAAE;KACd;IACDC,IAAI,EAAE,YAAY;IAClBC,QAAQ,EAAE;MACRC,qBAAqB,EAAE,+CAA+C;MACtEC,uBAAuB,EACrB,oDAAoD;MACtDC,yBAAyB,EACvB;KACH;IACDC,MAAM,EAAE,CACN;MACEC,oBAAoB,EAAE,KAAK;MAC3BC,UAAU,EAAE;QACVC,gCAAgC,EAAE;UAChCV,WAAW,EACT,gIAAgI;UAClIE,IAAI,EAAE;;OAET;MACDA,IAAI,EAAE;KACP;GAEJ;EACDS,cAAc,EAAE,CACd;IACED,gCAAgC,EAAE;GACnC,CACF;EACDE,MAAMA,CAACC,OAAO,EAAE,CAAC;IAAEH;EAAgC,CAAE,CAAC;IACpD,MAAMI,UAAU,GAAGD,OAAO,CAACE,aAAa,EAAE;IAE1C;IACA;IACA;IAEA,SAASC,kBAAkBA,CAACC,SAAkB;MAC5C;MACA,MAAMC,SAAS,GACbD,SAAS,KAAKE,SAAS,GACnB,iBAAiB,GACjB,qCAAqCF,SAAS,EAAE;MACtD,OAAO,GAAGC,SAAS,qCAAqC;IAC1D;IAEA,SAASE,WAAWA,CAACC,QAAmB;MACtC,KAAK,MAAMC,OAAO,IAAID,QAAQ,EAAE;QAC9B,MAAM;UAAEE,KAAK;UAAEC;QAAK,CAAE,GAAGF,OAAO;QAChC,QAAQC,KAAK,CAACE,IAAI;UAChB,KAAK,6BAA6B;YAAE;cAClC,MAAM;gBAAEC,EAAE;gBAAEC;cAAE,CAAE,GAAGJ,KAAK;cACxB,MAAMK,mBAAmB,GAAGJ,KAAK,GAAGL,SAAS,GAAGO,EAAE,CAACG,GAAG,CAACC,KAAK,CAACC,IAAI;cAEjE,MAAMC,eAAe,GAAGC,qBAAqB,CAACP,EAAE,CAAC,GAC7CA,EAAE,CAACQ,SAAS,CAACC,cAAc,GAC3BT,EAAE,CAACS,cAAc;cACrB,MAAMC,eAAe,GAAGH,qBAAqB,CAACN,EAAE,CAAC,GAC7CA,EAAE,CAACO,SAAS,CAACC,cAAc,GAC3BR,EAAE,CAACQ,cAAc;cAErBtB,OAAO,CAACwB,MAAM,CAAC;gBACbR,GAAG,EAAEF,EAAE,CAACE,GAAG;gBACXS,SAAS,EAAE,2BAA2B;gBACtCC,IAAI,EAAE;kBACJvB,kBAAkB,EAAEA,kBAAkB,CAACY,mBAAmB,CAAC;kBAC3DY,KAAK,EAAE1B,UAAU,CAAC2B,OAAO,CAACT,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEG,cAAc,CAAC;kBAC1DO,KAAK,EAAE5B,UAAU,CAAC2B,OAAO,CAACL,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAED,cAAc;iBAC1D;gBACDQ,IAAI,EAAEhB;eACP,CAAC;cACF;;UAEF,KAAK,iBAAiB;YAAE;cACtB,MAAM;gBAAEiB,cAAc;gBAAEC;cAAc,CAAE,GAAGtB,KAAK;cAChD,MAAMK,mBAAmB,GAAGJ,KAAK,GAC7BL,SAAS,GACT0B,cAAc,CAAChB,GAAG,CAACC,KAAK,CAACC,IAAI;cAEjClB,OAAO,CAACwB,MAAM,CAAC;gBACbR,GAAG,EAAEe,cAAc,CAACf,GAAG;gBACvBS,SAAS,EACPM,cAAc,CAAC1C,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,GAC9C,uBAAuB,GACvB,yBAAyB;gBAC/BR,IAAI,EAAE;kBACJvB,kBAAkB,EAAEA,kBAAkB,CAACY,mBAAmB;iBAC3D;gBACDe,IAAI,EAAEC;eACP,CAAC;;;;IAIV;IAEA,SAASI,cAAcA,CACrBC,UAAqC,EACrCC,cAAoD;MAEpD,MAAMC,MAAM,GAAc,EAAE;MAC5B,MAAMC,eAAe,GAAGC,kBAAkB,CAACH,cAAc,CAAC;MAC1D,KAAK,MAAMhC,SAAS,IAAI+B,UAAU,EAAE;QAClCK,WAAW,CAACpC,SAAS,EAAE,CAACqC,CAAC,EAAEC,CAAC,KAAI;;UAC9B,MAAMC,UAAU,GAAG,CAAAC,EAAA,GAACH,CAAsB,CAACI,KAAK,cAAAD,EAAA,cAAAA,EAAA,GAAIH,CAAC;UACrD,MAAMK,UAAU,GAAG,CAAAC,EAAA,GAACL,CAAsB,CAACG,KAAK,cAAAE,EAAA,cAAAA,EAAA,GAAIL,CAAC;UAErD,MAAMjC,KAAK,GAAGuC,iBAAiB,CAC7BL,UAAU,EACVG,UAAU,EACVR,eAAe,CAChB;UACD,IAAI7B,KAAK,KAAKJ,SAAS,EAAE;YACvBgC,MAAM,CAACY,IAAI,CAAC;cAAExC,KAAK;cAAEC,KAAK,EAAEN,SAAS,CAAC8C,MAAM,KAAK;YAAC,CAAE,CAAC;;QAEzD,CAAC,CAAC;;MAEJ,OAAOb,MAAM;IACf;IAEA,SAASW,iBAAiBA,CACxBP,CAAsB,EACtBC,CAAsB,EACtBJ,eAAgC;MAEhC,IAAI,CAACa,sBAAsB,CAACV,CAAC,EAAEC,CAAC,EAAEJ,eAAe,CAAC,EAAE;QAClD,OAAOjC,SAAS;;MAGlB,OAAOoC,CAAC,CAACW,MAAM,CAACF,MAAM,KAAKR,CAAC,CAACU,MAAM,CAACF,MAAM,GACtCG,iCAAiC,CAACZ,CAAC,CAACW,MAAM,EAAEV,CAAC,CAACU,MAAM,CAAC,GACrDE,yCAAyC,CAACb,CAAC,EAAEC,CAAC,CAAC;IACrD;IAEA,SAASS,sBAAsBA,CAC7BV,CAAsB,EACtBC,CAAsB,EACtBJ,eAAgC;MAEhC;MAEA,MAAMiB,WAAW,GACfd,CAAC,CAACL,cAAc,KAAK/B,SAAS,GAAGoC,CAAC,CAACL,cAAc,CAACgB,MAAM,GAAG/C,SAAS;MACtE,MAAMmD,WAAW,GACfd,CAAC,CAACN,cAAc,KAAK/B,SAAS,GAAGqC,CAAC,CAACN,cAAc,CAACgB,MAAM,GAAG/C,SAAS;MAEtE,IAAIT,gCAAgC,EAAE;QACpC,MAAM6D,kBAAkB,GAAGC,IAAI,CAACC,GAAG,CAAClB,CAAC,CAACW,MAAM,CAACF,MAAM,EAAER,CAAC,CAACU,MAAM,CAACF,MAAM,CAAC;QACrE,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,kBAAkB,EAAEG,CAAC,IAAI,CAAC,EAAE;UAC9C,IACEnB,CAAC,CAACW,MAAM,CAACQ,CAAC,CAAC,CAACxE,IAAI,KAAKsD,CAAC,CAACU,MAAM,CAACQ,CAAC,CAAC,CAACxE,IAAI,IACrCyE,sBAAsB,CAACpB,CAAC,CAACW,MAAM,CAACQ,CAAC,CAAC,CAAC,KACjCC,sBAAsB,CAACnB,CAAC,CAACU,MAAM,CAACQ,CAAC,CAAC,CAAC,EACrC;YACA,OAAO,KAAK;;;;MAKlB,OACEE,aAAa,CAACrB,CAAC,CAACsB,UAAU,EAAErB,CAAC,CAACqB,UAAU,CAAC;MACzC;MACA;MACArF,IAAI,CAACsF,cAAc,CAACT,WAAW,EAAEC,WAAW,EAAES,sBAAsB,CAAC,IACrEC,0BAA0B,CAACzB,CAAC,EAAEH,eAAe,CAAC,KAC5C4B,0BAA0B,CAACxB,CAAC,EAAEJ,eAAe,CAAC;IAEpD;IAEA;IACA,SAASe,iCAAiCA,CACxCc,MAAqC,EACrCC,MAAqC;MAErC,MAAMC,KAAK,GAAGC,yBAAyB,CACrCH,MAAM,EACNC,MAAM,EACNG,kBAAkB,CACnB;MACD,IAAIF,KAAK,KAAKhE,SAAS,EAAE;QACvB,OAAOA,SAAS;;MAGlB;MACA,IACE,CAAC3B,IAAI,CAACsF,cAAc,CAClBG,MAAM,CAACK,KAAK,CAACH,KAAK,GAAG,CAAC,CAAC,EACvBD,MAAM,CAACI,KAAK,CAACH,KAAK,GAAG,CAAC,CAAC,EACvBE,kBAAkB,CACnB,EACD;QACA,OAAOlE,SAAS;;MAGlB,MAAMoC,CAAC,GAAG0B,MAAM,CAACE,KAAK,CAAC;MACvB,MAAM3B,CAAC,GAAG0B,MAAM,CAACC,KAAK,CAAC;MACvB;MACA;MACA,OAAOI,yBAAyB,CAAChC,CAAC,EAAEC,CAAC,CAAC,IACpCD,CAAC,CAACrD,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,GACnC;QAAEtB,IAAI,EAAE,6BAA6B;QAAEC,EAAE,EAAE6B,CAAC;QAAE5B,EAAE,EAAE6B;MAAC,CAAE,GACrDrC,SAAS;IACf;IAEA;;;;IAIA,SAASiD,yCAAyCA,CAChDb,CAAsB,EACtBC,CAAsB;MAEtB,MAAMgC,IAAI,GAAGjC,CAAC,CAACW,MAAM;MACrB,MAAMuB,IAAI,GAAGjC,CAAC,CAACU,MAAM;MAErB,MAAMwB,SAAS,GAAGlB,IAAI,CAACC,GAAG,CAACe,IAAI,CAACxB,MAAM,EAAEyB,IAAI,CAACzB,MAAM,CAAC;MACpD,MAAM2B,MAAM,GAAGH,IAAI,CAACxB,MAAM,GAAGyB,IAAI,CAACzB,MAAM,GAAGyB,IAAI,GAAGD,IAAI;MACtD,MAAMI,OAAO,GAAGJ,IAAI,CAACxB,MAAM,GAAGyB,IAAI,CAACzB,MAAM,GAAGwB,IAAI,GAAGC,IAAI;MACvD,MAAMI,UAAU,GAAGL,IAAI,CAACxB,MAAM,GAAGyB,IAAI,CAACzB,MAAM,GAAGT,CAAC,GAAGC,CAAC;MAEpD;MACA;MACA;MACA,KAAK,IAAIkB,CAAC,GAAGgB,SAAS,GAAG,CAAC,EAAEhB,CAAC,GAAGiB,MAAM,CAAC3B,MAAM,EAAEU,CAAC,EAAE,EAAE;QAClD,IAAI,CAACoB,qBAAqB,CAACH,MAAM,CAACjB,CAAC,CAAC,CAAC,EAAE;UACrC,OAAOvD,SAAS;;;MAIpB,KAAK,IAAIuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,SAAS,EAAEhB,CAAC,EAAE,EAAE;QAClC,MAAMqB,KAAK,GAAGP,IAAI,CAACd,CAAC,CAAC;QACrB,MAAMsB,KAAK,GAAGP,IAAI,CAACf,CAAC,CAAC;QACrB,MAAMtC,eAAe,GAAGH,qBAAqB,CAAC8D,KAAK,CAAC,GAChDA,KAAK,CAAC7D,SAAS,CAACC,cAAc,GAC9B4D,KAAK,CAAC5D,cAAc;QACxB,MAAM8D,eAAe,GAAGhE,qBAAqB,CAAC+D,KAAK,CAAC,GAChDA,KAAK,CAAC9D,SAAS,CAACC,cAAc,GAC9B6D,KAAK,CAAC7D,cAAc;QAExB,IAAI,CAACyC,aAAa,CAACxC,eAAe,EAAE6D,eAAe,CAAC,EAAE;UACpD,OAAO9E,SAAS;;;MAIpB,IACEuE,SAAS,GAAG,CAAC,IACbE,OAAO,CAACF,SAAS,GAAG,CAAC,CAAC,CAACxF,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,EAC1D;QACA,OAAO5B,SAAS;;MAGlB,OAAO;QACLyB,cAAc,EAAE+C,MAAM,CAACA,MAAM,CAAC3B,MAAM,GAAG,CAAC,CAAC;QACzCvC,IAAI,EAAE,iBAAiB;QACvBoB,cAAc,EAAEgD;OACjB;IACH;IAEA;IACA,SAASxC,kBAAkBA,CACzBH,cAAoD;MAEpD,IAAIA,cAAc,KAAK/B,SAAS,EAAE;QAChC,OAAQ,MAAM,KAAK;;MAGrB,MAAM+E,GAAG,GAAG,IAAIC,GAAG,EAAU;MAC7B,KAAK,MAAMC,CAAC,IAAIlD,cAAc,CAACgB,MAAM,EAAE;QACrCgC,GAAG,CAACG,GAAG,CAACD,CAAC,CAACvG,IAAI,CAACA,IAAI,CAAC;;MAEtB,OAAQyG,QAAQ,IAAIJ,GAAG,CAACK,GAAG,CAACD,QAAQ,CAAC;IACvC;IAEA;IACA,SAAStB,0BAA0BA,CACjCwB,GAAwB,EACxBpD,eAAgC;MAEhC,OAAOoD,GAAG,CAACtC,MAAM,CAACuC,IAAI,CAAEC,CAAqB,IAC3CC,yBAAyB,CACvB1E,qBAAqB,CAACyE,CAAC,CAAC,GACpBA,CAAC,CAACxE,SAAS,CAACC,cAAc,GAC1BuE,CAAC,CAACvE,cAAc,CACrB,CACF;MAED,SAASwE,yBAAyBA,CAChCzG,IAAoD;QAEpD,IAAI,CAACA,IAAI,EAAE;UACT,OAAO,KAAK;;QAGd,IAAIA,IAAI,CAACA,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAAC8D,eAAe,EAAE;UAChD,MAAMN,QAAQ,GAAGpG,IAAI,CAACoG,QAAQ;UAC9B,IAAIO,YAAY,CAACP,QAAQ,CAAC,IAAIlD,eAAe,CAACkD,QAAQ,CAACzG,IAAI,CAAC,EAAE;YAC5D,OAAO,IAAI;;;QAIf,OAAO8G,yBAAyB,CAC7BzG,IAAkC,CAACiC,cAAc,IAC/CjC,IAA6B,CAAC4G,WAAW,CAC7C;MACH;IACF;IAEA,SAAS7E,qBAAqBA,CAC5BU,IAAmB;MAEnB,OACGA,IAAqC,CAACzC,IAAI,KAC3CZ,OAAA,CAAAwD,cAAc,CAACiE,mBAAmB;IAEtC;IAEA,SAAS1B,kBAAkBA,CACzB9B,CAAqB,EACrBC,CAAqB;MAErB,MAAMwD,eAAe,GAAG/E,qBAAqB,CAACsB,CAAC,CAAC,GAC5CA,CAAC,CAACrB,SAAS,CAACC,cAAc,GAC1BoB,CAAC,CAACpB,cAAc;MACpB,MAAM8E,eAAe,GAAGhF,qBAAqB,CAACuB,CAAC,CAAC,GAC5CA,CAAC,CAACtB,SAAS,CAACC,cAAc,GAC1BqB,CAAC,CAACrB,cAAc;MAEpB,OACEoD,yBAAyB,CAAChC,CAAC,EAAEC,CAAC,CAAC,IAC/BoB,aAAa,CAACoC,eAAe,EAAEC,eAAe,CAAC;IAEnD;IAEA;IACA,SAASnB,qBAAqBA,CAACY,CAAqB;MAClD,MAAMQ,QAAQ,GAAGjF,qBAAqB,CAACyE,CAAC,CAAC,GACrCA,CAAC,CAACxE,SAAS,CAACgF,QAAQ,GACpBR,CAAC,CAACQ,QAAQ;MAEd,OAAOR,CAAC,CAACxG,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,IAAImE,QAAQ;IAC1D;IAEA;IACA,SAAS3B,yBAAyBA,CAChChC,CAAqB,EACrBC,CAAqB;MAErB,MAAM2D,SAAS,GAAGlF,qBAAqB,CAACsB,CAAC,CAAC,GACtCA,CAAC,CAACrB,SAAS,CAACgF,QAAQ,GACpB3D,CAAC,CAAC2D,QAAQ;MACd,MAAME,SAAS,GAAGnF,qBAAqB,CAACuB,CAAC,CAAC,GACtCA,CAAC,CAACtB,SAAS,CAACgF,QAAQ,GACpB1D,CAAC,CAAC0D,QAAQ;MAEd,OACG3D,CAAC,CAACrD,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,MACnCS,CAAC,CAACtD,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACC,WAAW,CAAC,IACxCoE,SAAS,KAAKhG,SAAS,MAAOiG,SAAS,KAAKjG,SAAS,CAAC;IAE3D;IAEA,SAAS4D,sBAAsBA,CAC7BxB,CAA2B,EAC3BC,CAA2B;MAE3B,OACED,CAAC,CAAC1D,IAAI,CAACA,IAAI,KAAK2D,CAAC,CAAC3D,IAAI,CAACA,IAAI,IAC3BwH,mBAAmB,CAAC9D,CAAC,CAAC+D,UAAU,EAAE9D,CAAC,CAAC8D,UAAU,CAAC;IAEnD;IAEA,SAAS1C,aAAaA,CACpBrB,CAAwC,EACxCC,CAAwC;MAExC,OACED,CAAC,KAAKC,CAAC,IACND,CAAC,KAAKpC,SAAS,IACdqC,CAAC,KAAKrC,SAAS,IACfL,UAAU,CAAC2B,OAAO,CAACc,CAAC,CAACpB,cAAc,CAAC,KAClCrB,UAAU,CAAC2B,OAAO,CAACe,CAAC,CAACrB,cAAc,CAAE;IAE7C;IAEA,SAASkF,mBAAmBA,CAC1B9D,CAAgC,EAChCC,CAAgC;MAEhC,OACED,CAAC,KAAKC,CAAC,IAAKD,CAAC,KAAKpC,SAAS,IAAIqC,CAAC,KAAKrC,SAAS,IAAIoC,CAAC,CAACrD,IAAI,KAAKsD,CAAC,CAACtD,IAAK;IAExE;IAEA;IACA,SAASkF,yBAAyBA,CAChC7B,CAAe,EACfC,CAAe,EACf+D,KAAoB;MAEpB,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,CAAC,CAACS,MAAM,IAAIU,CAAC,GAAGlB,CAAC,CAACQ,MAAM,EAAEU,CAAC,EAAE,EAAE;QACjD,IAAI,CAAC6C,KAAK,CAAChE,CAAC,CAACmB,CAAC,CAAC,EAAElB,CAAC,CAACkB,CAAC,CAAC,CAAC,EAAE;UACtB,OAAOA,CAAC;;;MAGZ,OAAOvD,SAAS;IAClB;IAEA;IACA,SAASmC,WAAWA,CAClBkE,MAAoB,EACpBC,MAA4B;MAE5B,KAAK,IAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8C,MAAM,CAACxD,MAAM,EAAEU,CAAC,EAAE,EAAE;QACtC,KAAK,IAAIgD,CAAC,GAAGhD,CAAC,GAAG,CAAC,EAAEgD,CAAC,GAAGF,MAAM,CAACxD,MAAM,EAAE0D,CAAC,EAAE,EAAE;UAC1CD,MAAM,CAACD,MAAM,CAAC9C,CAAC,CAAC,EAAE8C,MAAM,CAACE,CAAC,CAAC,CAAC;;;IAGlC;IAQA,MAAMC,MAAM,GAAY,EAAE;IAC1B,IAAIC,YAAY,GAAU;MACxB1G,SAAS,EAAE,IAAI2G,GAAG;KACnB;IAED,SAASC,WAAWA,CAClBC,MAAiB,EACjB7E,cAAoD;MAEpD0E,YAAY,IAAID,MAAM,CAAC5D,IAAI,CAAC6D,YAAY,CAAC;MACzCA,YAAY,GAAG;QACb1G,SAAS,EAAE,IAAI2G,GAAG,EAA0B;QAC5CE,MAAM;QACN7E;OACD;IACH;IAEA,SAAS8E,UAAUA,CAAA;MACjB,MAAM3G,QAAQ,GAAG2B,cAAc,CAC7BiF,KAAK,CAACC,IAAI,CAACN,YAAY,CAAC1G,SAAS,CAACsG,MAAM,EAAE,CAAC,EAC3CI,YAAY,CAAC1E,cAAc,CAC5B;MACD9B,WAAW,CAACC,QAAQ,CAAC;MACrBuG,YAAY,GAAGD,MAAM,CAACQ,GAAG,EAAG;IAC9B;IAEA,SAASC,WAAWA,CAClBC,SAAuB,EACvBC,GAAY,EACZC,cAA+B;MAE/BD,GAAG,GAAGA,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAIE,cAAc,CAACH,SAAS,CAAC;MACtC,IACET,YAAY,IACZ,CAACW,cAAc,IAAIF,SAAS,EAAEN,MAAM,KAAKH,YAAY,CAACG,MAAM,EAC5D;QACA,MAAM7G,SAAS,GAAG0G,YAAY,CAAC1G,SAAS,CAACuH,GAAG,CAACH,GAAG,CAAC;QACjD,IAAIpH,SAAS,KAAKC,SAAS,EAAE;UAC3BD,SAAS,CAAC6C,IAAI,CAACsE,SAAS,CAAC;SAC1B,MAAM;UACLT,YAAY,CAAC1G,SAAS,CAACgF,GAAG,CAACoC,GAAG,EAAE,CAACD,SAAS,CAAC,CAAC;;;IAGlD;IAEA;IACA;IACA;IAEA,OAAO;MACLK,OAAO,EAAEZ,WAAW;MACpBa,aAAa,EAAEb,WAAW;MAC1Bc,sBAAsBA,CAACjG,IAAI;QACzBmF,WAAW,CAACnF,IAAI,CAACkG,IAAI,EAAElG,IAAI,CAACO,cAAc,CAAC;MAC7C,CAAC;MACD4F,gBAAgBA,CAACnG,IAAI;QACnBmF,WAAW,CAACnF,IAAI,CAACkG,IAAI,EAAElG,IAAI,CAACO,cAAc,CAAC;MAC7C,CAAC;MACD6F,aAAa,EAAEjB,WAAW;MAE1B;MACAkB,iBAAiBA,CAACrG,IAAI;;QACpB,MAAMsG,aAAa,GAAGC,gBAAgB,CAACvG,IAAI,CAAC;QAC5CyF,WAAW,CAACzF,IAAI,EAAE,CAAAkB,EAAA,IAAAH,EAAA,GAAAf,IAAI,CAACwG,EAAE,cAAAzF,EAAA,uBAAAA,EAAA,CAAE7D,IAAI,cAAAgE,EAAA,cAAAA,EAAA,GAAIoF,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAE/I,IAAI,EAAE+I,aAAa,CAAC;MACxE,CAAC;MACDG,0BAA0B,EAAEhB,WAAW;MACvCiB,+BAA+B,EAAEjB,WAAW;MAC5CkB,iBAAiB,EAAElB,WAAW;MAC9BmB,0BAA0BA,CAAC5G,IAAI;QAC7B,IAAI,CAACA,IAAI,CAACgB,KAAK,CAACkF,IAAI,EAAE;UACpBT,WAAW,CAACzF,IAAI,CAAC;;MAErB,CAAC;MACD6G,gBAAgBA,CAAC7G,IAAI;QACnB,IAAI,CAACA,IAAI,CAACgB,KAAK,CAACkF,IAAI,EAAE;UACpBT,WAAW,CAACzF,IAAI,CAAC;;MAErB,CAAC;MAED;MACA,cAAc,EAAEqF,UAAU;MAC1B,oBAAoB,EAAEA,UAAU;MAChC,6BAA6B,EAAEA,UAAU;MACzC,uBAAuB,EAAEA,UAAU;MACnC,oBAAoB,EAAEA;KACvB;EACH;CACD,CAAC;AAEF,SAASkB,gBAAgBA,CACvBvG,IAAgC;EAKhC,OAAOA,IAAI,CAACoF,MAAM,KACfpF,IAAI,CAACoF,MAAM,CAAC7H,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAAC2G,sBAAsB,IACzD9G,IAAI,CAACoF,MAAM,CAAC7H,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAAC4G,wBAAwB,CAAC,GAC7D/G,IAAI,CAACoF,MAAM,GACX5G,SAAS;AACf;AAEA,SAASqH,cAAcA,CAAC7F,IAAkB;EACxC,MAAMgH,IAAI,GAAGC,eAAe,CAACjH,IAAI,CAAC;EAElC,OACE,CAAEA,IAAyB,CAACkH,QAAQ,GAAG,GAAG,GAAG,GAAG,KAC9ClH,IAAyB,CAACmH,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,GAC/CH,IAAI;AAER;AAEA,SAASC,eAAeA,CAACjH,IAAkB;EACzC,QAAQA,IAAI,CAACzC,IAAI;IACf,KAAKZ,OAAA,CAAAwD,cAAc,CAACuG,+BAA+B;MACjD,OAAO,aAAa;IACtB,KAAK/J,OAAA,CAAAwD,cAAc,CAACsG,0BAA0B;MAC5C,OAAO,IAAI;IACb;MAAS;QACP,MAAM;UAAEd;QAAG,CAAE,GAAG3F,IAAwB;QAExC,OAAOkE,YAAY,CAACyB,GAAG,CAAC,GAAGA,GAAG,CAACzI,IAAI,GAAIyI,GAAwB,CAACyB,GAAG;;;AAGzE;AAEA,SAASpF,sBAAsBA,CAACqF,KAAoB;EAClD,QAAQA,KAAK,CAAC9J,IAAI;IAChB,KAAKZ,OAAA,CAAAwD,cAAc,CAACmH,UAAU;MAC5B,OAAOD,KAAK,CAACnK,IAAI;IACnB,KAAKP,OAAA,CAAAwD,cAAc,CAACC,WAAW;MAC7B,OAAO4B,sBAAsB,CAACqF,KAAK,CAACE,QAAQ,CAAC;IAC/C;MACE,OAAO/I,SAAS;;AAEtB;AACA,SAAS0F,YAAYA,CAAClE,IAAmB;EACvC,OAAOA,IAAI,CAACzC,IAAI,KAAKZ,OAAA,CAAAwD,cAAc,CAACmH,UAAU;AAChD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}