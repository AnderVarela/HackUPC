{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\nclass Scope {\n  constructor({\n    prefixes,\n    parent\n  } = {}) {\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n    return `${prefix}${ng.index++}`;\n  }\n  _nameGroup(prefix) {\n    var _a, _b;\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n  setValue(value, {\n    property,\n    itemIndex\n  }) {\n    this.value = value;\n    this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)`\\n`;\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = {\n      ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n  get() {\n    return this._scope;\n  }\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n  value(nameOrPrefix, value) {\n    var _a;\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n    if (vs) {\n      const _name = vs.get(valueKey);\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n  scopeRefs(scopeName, values = this._values) {\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return (0, code_1._)`${scopeName}${name.scopePath}`;\n    });\n  }\n  scopeCode(values = this._values, usedValues, getCode) {\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n  _reduceValues(values, valueCode, usedValues = {}, getCode) {\n    let code = code_1.nil;\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n    return code;\n  }\n}\nexports.ValueScope = ValueScope;","map":{"version":3,"names":["code_1","require","ValueError","Error","constructor","name","value","UsedValueState","exports","varKinds","const","Name","let","var","Scope","prefixes","parent","_names","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","ng","_nameGroup","index","_b","_a","has","ValueScopeName","nameStr","setValue","property","itemIndex","scopePath","_","line","ValueScope","opts","_values","_scope","scope","_n","lines","nil","get","ref","undefined","valueKey","key","vs","_name","Map","set","s","length","getValue","keyOrRef","scopeRefs","scopeName","values","_reduceValues","scopeCode","usedValues","getCode","code","valueCode","nameSet","forEach","Started","c","def","es5","Completed"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\compile\\codegen\\scope.ts"],"sourcesContent":["import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}