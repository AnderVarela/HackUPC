{"ast":null,"code":"const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst v4Size = 4;\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\nconst v6Size = 16;\nexport const v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    buff = buff || new Uint8Array(offset + v4Size);\n    const max = ip.length;\n    let n = 0;\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++);\n      if (c === 46) {\n        // \".\"\n        buff[offset++] = n;\n        n = 0;\n      } else {\n        n = n * 10 + (c - 48);\n      }\n    }\n    buff[offset] = n;\n    return buff;\n  },\n  decode(buff, offset) {\n    offset = ~~offset;\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n  }\n};\nexport const v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n  encode(ip, buff, offset) {\n    offset = ~~offset;\n    let end = offset + v6Size;\n    let fill = -1;\n    let hexN = 0;\n    let decN = 0;\n    let prevColon = true;\n    let useDec = false;\n    buff = buff || new Uint8Array(offset + v6Size);\n    // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i);\n      if (c === 58) {\n        // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0;\n            if (offset < end - 1) buff[offset + 1] = 0;\n            offset += 2;\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset;\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN;\n            offset++;\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8;\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n            offset += 2;\n          }\n          hexN = 0;\n          decN = 0;\n        }\n        prevColon = true;\n        useDec = false;\n      } else if (c === 46) {\n        // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN;\n        offset++;\n        decN = 0;\n        hexN = 0;\n        prevColon = false;\n        useDec = true;\n      } else {\n        prevColon = false;\n        if (c >= 97) {\n          c -= 87; // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55; // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48; // 0-9 ... starting from charCode 48\n          decN = decN * 10 + c;\n        }\n        // We don't know yet if its a dec or hex number\n        hexN = (hexN << 4) + c;\n      }\n    }\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN;\n        offset++;\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8;\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n        offset += 2;\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0;\n      if (offset < end - 1) buff[offset + 1] = 0;\n      offset += 2;\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2;\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2];\n      }\n      buff[fill] = 0;\n      buff[fill + 1] = 0;\n      fill = offset;\n    }\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2;\n      }\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0;\n      }\n    }\n    return buff;\n  },\n  decode(buff, offset) {\n    offset = ~~offset;\n    let result = '';\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':';\n      }\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n    }\n    return result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n  }\n};\nexport const name = 'ip';\nexport function sizeOf(ip) {\n  if (v4.isFormat(ip)) return v4.size;\n  if (v6.isFormat(ip)) return v6.size;\n  throw Error(`Invalid ip address: ${ip}`);\n}\nexport function familyOf(string) {\n  return sizeOf(string) === v4.size ? 1 : 2;\n}\nexport function encode(ip, buff, offset) {\n  offset = ~~offset;\n  const size = sizeOf(ip);\n  if (typeof buff === 'function') {\n    buff = buff(offset + size);\n  }\n  if (size === v4.size) {\n    return v4.encode(ip, buff, offset);\n  }\n  return v6.encode(ip, buff, offset);\n}\nexport function decode(buff, offset, length) {\n  offset = ~~offset;\n  length = length || buff.length - offset;\n  if (length === v4.size) {\n    return v4.decode(buff, offset, length);\n  }\n  if (length === v6.size) {\n    return v6.decode(buff, offset, length);\n  }\n  throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n}","map":{"version":3,"names":["v4Regex","v4Size","v6Regex","v6Size","v4","name","size","isFormat","ip","test","encode","buff","offset","Uint8Array","max","length","n","i","c","charCodeAt","decode","v6","end","fill","hexN","decN","prevColon","useDec","Math","min","result","toString","replace","sizeOf","Error","familyOf","string"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@leichtgewicht/ip-codec/index.mjs"],"sourcesContent":["const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/\nconst v4Size = 4\nconst v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i\nconst v6Size = 16\n\nexport const v4 = {\n  name: 'v4',\n  size: v4Size,\n  isFormat: ip => v4Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    buff = buff || new Uint8Array(offset + v4Size)\n    const max = ip.length\n    let n = 0\n    for (let i = 0; i < max;) {\n      const c = ip.charCodeAt(i++)\n      if (c === 46) { // \".\"\n        buff[offset++] = n\n        n = 0\n      } else {\n        n = n * 10 + (c - 48)\n      }\n    }\n    buff[offset] = n\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`\n  }\n}\n\nexport const v6 = {\n  name: 'v6',\n  size: v6Size,\n  isFormat: ip => ip.length > 0 && v6Regex.test(ip),\n  encode (ip, buff, offset) {\n    offset = ~~offset\n    let end = offset + v6Size\n    let fill = -1\n    let hexN = 0\n    let decN = 0\n    let prevColon = true\n    let useDec = false\n    buff = buff || new Uint8Array(offset + v6Size)\n    // Note: This algorithm needs to check if the offset\n    // could exceed the buffer boundaries as it supports\n    // non-standard compliant encodings that may go beyond\n    // the boundary limits. if (offset < end) checks should\n    // not be necessary...\n    for (let i = 0; i < ip.length; i++) {\n      let c = ip.charCodeAt(i)\n      if (c === 58) { // :\n        if (prevColon) {\n          if (fill !== -1) {\n            // Not Standard! (standard doesn't allow multiple ::)\n            // We need to treat\n            if (offset < end) buff[offset] = 0\n            if (offset < end - 1) buff[offset + 1] = 0\n            offset += 2\n          } else if (offset < end) {\n            // :: in the middle\n            fill = offset\n          }\n        } else {\n          // : ends the previous number\n          if (useDec === true) {\n            // Non-standard! (ipv4 should be at end only)\n            // A ipv4 address should not be found anywhere else but at\n            // the end. This codec also support putting characters\n            // after the ipv4 address..\n            if (offset < end) buff[offset] = decN\n            offset++\n          } else {\n            if (offset < end) buff[offset] = hexN >> 8\n            if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n            offset += 2\n          }\n          hexN = 0\n          decN = 0\n        }\n        prevColon = true\n        useDec = false\n      } else if (c === 46) { // . indicates IPV4 notation\n        if (offset < end) buff[offset] = decN\n        offset++\n        decN = 0\n        hexN = 0\n        prevColon = false\n        useDec = true\n      } else {\n        prevColon = false\n        if (c >= 97) {\n          c -= 87 // a-f ... 97~102 -87 => 10~15\n        } else if (c >= 65) {\n          c -= 55 // A-F ... 65~70 -55 => 10~15\n        } else {\n          c -= 48 // 0-9 ... starting from charCode 48\n          decN = decN * 10 + c\n        }\n        // We don't know yet if its a dec or hex number\n        hexN = (hexN << 4) + c\n      }\n    }\n    if (prevColon === false) {\n      // Commiting last number\n      if (useDec === true) {\n        if (offset < end) buff[offset] = decN\n        offset++\n      } else {\n        if (offset < end) buff[offset] = hexN >> 8\n        if (offset < end - 1) buff[offset + 1] = hexN & 0xff\n        offset += 2\n      }\n    } else if (fill === 0) {\n      // Not Standard! (standard doesn't allow multiple ::)\n      // This means that a : was found at the start AND end which means the\n      // end needs to be treated as 0 entry...\n      if (offset < end) buff[offset] = 0\n      if (offset < end - 1) buff[offset + 1] = 0\n      offset += 2\n    } else if (fill !== -1) {\n      // Non-standard! (standard doens't allow multiple ::)\n      // Here we find that there has been a :: somewhere in the middle\n      // and the end. To treat the end with priority we need to move all\n      // written data two bytes to the right.\n      offset += 2\n      for (let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--) {\n        buff[i] = buff[i - 2]\n      }\n      buff[fill] = 0\n      buff[fill + 1] = 0\n      fill = offset\n    }\n    if (fill !== offset && fill !== -1) {\n      // Move the written numbers to the end while filling the everything\n      // \"fill\" to the bytes with zeros.\n      if (offset > end - 2) {\n        // Non Standard support, when the cursor exceeds bounds.\n        offset = end - 2\n      }\n      while (end > fill) {\n        buff[--end] = offset < end && offset > fill ? buff[--offset] : 0\n      }\n    } else {\n      // Fill the rest with zeros\n      while (offset < end) {\n        buff[offset++] = 0\n      }\n    }\n    return buff\n  },\n  decode (buff, offset) {\n    offset = ~~offset\n    let result = ''\n    for (let i = 0; i < v6Size; i += 2) {\n      if (i !== 0) {\n        result += ':'\n      }\n      result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16)\n    }\n    return result\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n}\n\nexport const name = 'ip'\nexport function sizeOf (ip) {\n  if (v4.isFormat(ip)) return v4.size\n  if (v6.isFormat(ip)) return v6.size\n  throw Error(`Invalid ip address: ${ip}`)\n}\n\nexport function familyOf (string) {\n  return sizeOf(string) === v4.size ? 1 : 2\n}\n\nexport function encode (ip, buff, offset) {\n  offset = ~~offset\n  const size = sizeOf(ip)\n  if (typeof buff === 'function') {\n    buff = buff(offset + size)\n  }\n  if (size === v4.size) {\n    return v4.encode(ip, buff, offset)\n  }\n  return v6.encode(ip, buff, offset)\n}\n\nexport function decode (buff, offset, length) {\n  offset = ~~offset\n  length = length || (buff.length - offset)\n  if (length === v4.size) {\n    return v4.decode(buff, offset, length)\n  }\n  if (length === v6.size) {\n    return v6.decode(buff, offset, length)\n  }\n  throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}