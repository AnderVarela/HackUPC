{"ast":null,"code":"var async = require('./async.js');\n\n// API\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapIterator(iterator) {\n  var stream = this;\n  return function (item, key, cb) {\n    var aborter,\n      wrappedCb = async(wrapIteratorCallback.call(stream, cb, key));\n    stream.jobs[key] = wrappedCb;\n\n    // it's either shortcut (item, cb)\n    if (iterator.length == 2) {\n      aborter = iterator(item, wrappedCb);\n    }\n    // or long format (item, key, cb)\n    else {\n      aborter = iterator(item, key, wrappedCb);\n    }\n    return aborter;\n  };\n}\n\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapCallback(callback) {\n  var stream = this;\n  var wrapped = function (error, result) {\n    return finisher.call(stream, error, result, callback);\n  };\n  return wrapped;\n}\n\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\nfunction wrapIteratorCallback(callback, key) {\n  var stream = this;\n  return function (error, output) {\n    // don't repeat yourself\n    if (!(key in stream.jobs)) {\n      callback(error, output);\n      return;\n    }\n\n    // clean up jobs\n    delete stream.jobs[key];\n    return streamer.call(stream, error, {\n      key: key,\n      value: output\n    }, callback);\n  };\n}\n\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\nfunction streamer(error, output, callback) {\n  if (error && !this.error) {\n    this.error = error;\n    this.pause();\n    this.emit('error', error);\n    // send back value only, as expected\n    callback(error, output && output.value);\n    return;\n  }\n\n  // stream stuff\n  this.push(output);\n\n  // back to original track\n  // send back value only, as expected\n  callback(error, output && output.value);\n}\n\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\nfunction finisher(error, output, callback) {\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error) {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}","map":{"version":3,"names":["async","require","module","exports","iterator","wrapIterator","callback","wrapCallback","stream","item","key","cb","aborter","wrappedCb","wrapIteratorCallback","call","jobs","length","wrapped","error","result","finisher","output","streamer","value","pause","emit","push"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/asynckit/lib/streamify.js"],"sourcesContent":["var async = require('./async.js');\n\n// API\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapIterator(iterator)\n{\n  var stream = this;\n\n  return function(item, key, cb)\n  {\n    var aborter\n      , wrappedCb = async(wrapIteratorCallback.call(stream, cb, key))\n      ;\n\n    stream.jobs[key] = wrappedCb;\n\n    // it's either shortcut (item, cb)\n    if (iterator.length == 2)\n    {\n      aborter = iterator(item, wrappedCb);\n    }\n    // or long format (item, key, cb)\n    else\n    {\n      aborter = iterator(item, key, wrappedCb);\n    }\n\n    return aborter;\n  };\n}\n\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapCallback(callback)\n{\n  var stream = this;\n\n  var wrapped = function(error, result)\n  {\n    return finisher.call(stream, error, result, callback);\n  };\n\n  return wrapped;\n}\n\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\nfunction wrapIteratorCallback(callback, key)\n{\n  var stream = this;\n\n  return function(error, output)\n  {\n    // don't repeat yourself\n    if (!(key in stream.jobs))\n    {\n      callback(error, output);\n      return;\n    }\n\n    // clean up jobs\n    delete stream.jobs[key];\n\n    return streamer.call(stream, error, {key: key, value: output}, callback);\n  };\n}\n\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\nfunction streamer(error, output, callback)\n{\n  if (error && !this.error)\n  {\n    this.error = error;\n    this.pause();\n    this.emit('error', error);\n    // send back value only, as expected\n    callback(error, output && output.value);\n    return;\n  }\n\n  // stream stuff\n  this.push(output);\n\n  // back to original track\n  // send back value only, as expected\n  callback(error, output && output.value);\n}\n\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\nfunction finisher(error, output, callback)\n{\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error)\n  {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}