{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst explicitReturnTypeUtils_1 = require(\"../util/explicitReturnTypeUtils\");\nexports.default = util.createRule({\n  name: 'explicit-function-return-type',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Require explicit return types on functions and class methods',\n      recommended: false\n    },\n    messages: {\n      missingReturnType: 'Missing return type on function.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowConciseArrowFunctionExpressionsStartingWithVoid: {\n          description: 'Whether to allow arrow functions that start with the `void` keyword.',\n          type: 'boolean'\n        },\n        allowExpressions: {\n          description: 'Whether to ignore function expressions (functions which are not part of a declaration).',\n          type: 'boolean'\n        },\n        allowHigherOrderFunctions: {\n          description: 'Whether to ignore functions immediately returning another function expression.',\n          type: 'boolean'\n        },\n        allowTypedFunctionExpressions: {\n          description: 'Whether to ignore type annotations on the variable of function expressions.',\n          type: 'boolean'\n        },\n        allowDirectConstAssertionInArrowFunctions: {\n          description: 'Whether to ignore arrow functions immediately returning a `as const` value.',\n          type: 'boolean'\n        },\n        allowFunctionsWithoutTypeParameters: {\n          description: \"Whether to ignore functions that don't have generic type parameters.\",\n          type: 'boolean'\n        },\n        allowedNames: {\n          description: 'An array of function/method names that will not have their arguments or return values checked.',\n          items: {\n            type: 'string'\n          },\n          type: 'array'\n        },\n        allowIIFEs: {\n          description: 'Whether to ignore immediately invoked function expressions (IIFEs).',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowExpressions: false,\n    allowTypedFunctionExpressions: true,\n    allowHigherOrderFunctions: true,\n    allowDirectConstAssertionInArrowFunctions: true,\n    allowConciseArrowFunctionExpressionsStartingWithVoid: false,\n    allowFunctionsWithoutTypeParameters: false,\n    allowedNames: [],\n    allowIIFEs: false\n  }],\n  create(context, [options]) {\n    const sourceCode = context.getSourceCode();\n    function isAllowedFunction(node) {\n      var _a, _b;\n      if (options.allowFunctionsWithoutTypeParameters && !node.typeParameters) {\n        return true;\n      }\n      if (options.allowIIFEs && isIIFE(node)) {\n        return true;\n      }\n      if (!((_a = options.allowedNames) === null || _a === void 0 ? void 0 : _a.length)) {\n        return false;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || node.type === utils_1.AST_NODE_TYPES.FunctionExpression) {\n        const parent = node.parent;\n        let funcName;\n        if ((_b = node.id) === null || _b === void 0 ? void 0 : _b.name) {\n          funcName = node.id.name;\n        } else if (parent) {\n          switch (parent.type) {\n            case utils_1.AST_NODE_TYPES.VariableDeclarator:\n              {\n                if (parent.id.type === utils_1.AST_NODE_TYPES.Identifier) {\n                  funcName = parent.id.name;\n                }\n                break;\n              }\n            case utils_1.AST_NODE_TYPES.MethodDefinition:\n            case utils_1.AST_NODE_TYPES.PropertyDefinition:\n            case utils_1.AST_NODE_TYPES.Property:\n              {\n                if (parent.key.type === utils_1.AST_NODE_TYPES.Identifier && parent.computed === false) {\n                  funcName = parent.key.name;\n                }\n                break;\n              }\n          }\n        }\n        if (!!funcName && !!options.allowedNames.includes(funcName)) {\n          return true;\n        }\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration && node.id && node.id.type === utils_1.AST_NODE_TYPES.Identifier && !!options.allowedNames.includes(node.id.name)) {\n        return true;\n      }\n      return false;\n    }\n    function isIIFE(node) {\n      return node.parent.type === utils_1.AST_NODE_TYPES.CallExpression;\n    }\n    return {\n      'ArrowFunctionExpression, FunctionExpression'(node) {\n        if (options.allowConciseArrowFunctionExpressionsStartingWithVoid && node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression && node.expression && node.body.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.body.operator === 'void') {\n          return;\n        }\n        if (isAllowedFunction(node)) {\n          return;\n        }\n        if (options.allowTypedFunctionExpressions && ((0, explicitReturnTypeUtils_1.isValidFunctionExpressionReturnType)(node, options) || (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node))) {\n          return;\n        }\n        (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(node, options, sourceCode, loc => context.report({\n          node,\n          loc,\n          messageId: 'missingReturnType'\n        }));\n      },\n      FunctionDeclaration(node) {\n        if (isAllowedFunction(node)) {\n          return;\n        }\n        if (options.allowTypedFunctionExpressions && node.returnType) {\n          return;\n        }\n        (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(node, options, sourceCode, loc => context.report({\n          node,\n          loc,\n          messageId: 'missingReturnType'\n        }));\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","explicitReturnTypeUtils_1","exports","default","createRule","name","meta","type","docs","description","recommended","messages","missingReturnType","schema","properties","allowConciseArrowFunctionExpressionsStartingWithVoid","allowExpressions","allowHigherOrderFunctions","allowTypedFunctionExpressions","allowDirectConstAssertionInArrowFunctions","allowFunctionsWithoutTypeParameters","allowedNames","items","allowIIFEs","additionalProperties","defaultOptions","create","context","options","sourceCode","getSourceCode","isAllowedFunction","node","typeParameters","isIIFE","_a","length","AST_NODE_TYPES","ArrowFunctionExpression","FunctionExpression","parent","funcName","_b","id","VariableDeclarator","Identifier","MethodDefinition","PropertyDefinition","Property","key","computed","includes","FunctionDeclaration","CallExpression","ArrowFunctionExpression, FunctionExpression","expression","body","UnaryExpression","operator","isValidFunctionExpressionReturnType","ancestorHasReturnType","checkFunctionReturnType","loc","report","messageId","returnType"],"sources":["../../src/rules/explicit-function-return-type.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}