{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _long = _interopRequireDefault(require(\"@xtuc/long\"));\nvar bits = _interopRequireWildcard(require(\"./bits\"));\nvar bufs = _interopRequireWildcard(require(\"./bufs\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n  var signBit;\n  var signByte;\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index); // sign-extend if necessary\n\n  var length = result.value.length;\n  if (result.value[length - 1] >> 7) {\n    result.value = bufs.resize(result.value, 8);\n    result.value.fill(255, length);\n  }\n  var value = _long[\"default\"].fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = _long[\"default\"].fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\nvar _default = {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};\nexports[\"default\"] = _default;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","_long","_interopRequireDefault","require","bits","_interopRequireWildcard","bufs","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","MIN_INT32","MAX_INT32","MAX_UINT32","signedBitCount","buffer","highOrder","getSign","unsignedBitCount","result","encodeBufferCommon","signed","signBit","bitCount","byteCount","Math","ceil","alloc","i","payload","extract","encodedLength","encodedBuffer","index","length","decodeBufferCommon","undefined","bitLength","byteLength","outIndex","inject","signByte","lastByte","endBit","shift","resize","nextIndex","encodeIntBuffer","decodeIntBuffer","encodeInt32","num","buf","writeInt32LE","free","decodeInt32","parsed","readInt","Error","encodeInt64","writeInt64","decodeInt64","fill","fromBytesLE","lossy","encodeUIntBuffer","decodeUIntBuffer","encodeUInt32","writeUInt32LE","decodeUInt32","readUInt","encodeUInt64","writeUInt64","decodeUInt64","_default"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/leb128/lib/leb.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _long = _interopRequireDefault(require(\"@xtuc/long\"));\n\nvar bits = _interopRequireWildcard(require(\"./bits\"));\n\nvar bufs = _interopRequireWildcard(require(\"./bufs\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index); // sign-extend if necessary\n\n  var length = result.value.length;\n\n  if (result.value[length - 1] >> 7) {\n    result.value = bufs.resize(result.value, 8);\n    result.value.fill(255, length);\n  }\n\n  var value = _long[\"default\"].fromBytesLE(result.value, false);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n\n  var value = _long[\"default\"].fromBytesLE(result.value, true);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nvar _default = {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};\nexports[\"default\"] = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}