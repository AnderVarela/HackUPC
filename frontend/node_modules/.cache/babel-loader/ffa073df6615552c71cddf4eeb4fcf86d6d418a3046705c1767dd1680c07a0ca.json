{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'promise-function-async',\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Require any function or method that returns a Promise to be marked async',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      missingAsync: 'Functions that return promises must be async.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowAny: {\n          description: 'Whether to consider `any` and `unknown` to be Promises.',\n          type: 'boolean'\n        },\n        allowedPromiseNames: {\n          description: 'Any extra names of classes or interfaces to be considered Promises.',\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        checkArrowFunctions: {\n          type: 'boolean'\n        },\n        checkFunctionDeclarations: {\n          type: 'boolean'\n        },\n        checkFunctionExpressions: {\n          type: 'boolean'\n        },\n        checkMethodDeclarations: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowAny: true,\n    allowedPromiseNames: [],\n    checkArrowFunctions: true,\n    checkFunctionDeclarations: true,\n    checkFunctionExpressions: true,\n    checkMethodDeclarations: true\n  }],\n  create(context, [{\n    allowAny,\n    allowedPromiseNames,\n    checkArrowFunctions,\n    checkFunctionDeclarations,\n    checkFunctionExpressions,\n    checkMethodDeclarations\n  }]) {\n    const allAllowedPromiseNames = new Set(['Promise', ...allowedPromiseNames]);\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    function validateNode(node) {\n      var _a;\n      const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const signatures = checker.getTypeAtLocation(originalNode).getCallSignatures();\n      if (!signatures.length) {\n        return;\n      }\n      const returnType = checker.getReturnTypeOfSignature(signatures[0]);\n      if (!util.containsAllTypesByName(returnType, allowAny, allAllowedPromiseNames,\n      // If no return type is explicitly set, we check if any parts of the return type match a Promise (instead of requiring all to match).\n      node.returnType == null)) {\n        // Return type is not a promise\n        return;\n      }\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {\n        // Abstract method can't be async\n        return;\n      }\n      if (node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.Property || node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) && (node.parent.kind === 'get' || node.parent.kind === 'set')) {\n        // Getters and setters can't be async\n        return;\n      }\n      if (util.isTypeFlagSet(returnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n        // Report without auto fixer because the return type is unknown\n        return context.report({\n          messageId: 'missingAsync',\n          node,\n          loc: util.getFunctionHeadLoc(node, sourceCode)\n        });\n      }\n      context.report({\n        messageId: 'missingAsync',\n        node,\n        loc: util.getFunctionHeadLoc(node, sourceCode),\n        fix: fixer => {\n          if (node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition || node.parent.type === utils_1.AST_NODE_TYPES.Property && node.parent.method)) {\n            // this function is a class method or object function property shorthand\n            const method = node.parent;\n            // the token to put `async` before\n            let keyToken = sourceCode.getFirstToken(method);\n            // if there are decorators then skip past them\n            if (method.type === utils_1.AST_NODE_TYPES.MethodDefinition && method.decorators) {\n              const lastDecorator = method.decorators[method.decorators.length - 1];\n              keyToken = sourceCode.getTokenAfter(lastDecorator);\n            }\n            // if current token is a keyword like `static` or `public` then skip it\n            while (keyToken.type === utils_1.AST_TOKEN_TYPES.Keyword && keyToken.range[0] < method.key.range[0]) {\n              keyToken = sourceCode.getTokenAfter(keyToken);\n            }\n            // check if there is a space between key and previous token\n            const insertSpace = !sourceCode.isSpaceBetween(sourceCode.getTokenBefore(keyToken), keyToken);\n            let code = 'async ';\n            if (insertSpace) {\n              code = ` ${code}`;\n            }\n            return fixer.insertTextBefore(keyToken, code);\n          }\n          return fixer.insertTextBefore(node, 'async ');\n        }\n      });\n    }\n    return Object.assign(Object.assign(Object.assign({}, checkArrowFunctions && {\n      'ArrowFunctionExpression[async = false]'(node) {\n        validateNode(node);\n      }\n    }), checkFunctionDeclarations && {\n      'FunctionDeclaration[async = false]'(node) {\n        validateNode(node);\n      }\n    }), {\n      'FunctionExpression[async = false]'(node) {\n        if (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition && node.parent.kind === 'method') {\n          if (checkMethodDeclarations) {\n            validateNode(node);\n          }\n          return;\n        }\n        if (checkFunctionExpressions) {\n          validateNode(node);\n        }\n      }\n    });\n  }\n});","map":{"version":3,"names":["utils_1","require","ts","__importStar","util","exports","default","createRule","name","meta","type","fixable","docs","description","recommended","requiresTypeChecking","messages","missingAsync","schema","properties","allowAny","allowedPromiseNames","items","checkArrowFunctions","checkFunctionDeclarations","checkFunctionExpressions","checkMethodDeclarations","additionalProperties","defaultOptions","create","context","allAllowedPromiseNames","Set","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","validateNode","node","originalNode","esTreeNodeToTSNodeMap","get","signatures","getTypeAtLocation","getCallSignatures","length","returnType","getReturnTypeOfSignature","containsAllTypesByName","_a","parent","AST_NODE_TYPES","TSAbstractMethodDefinition","Property","MethodDefinition","kind","isTypeFlagSet","TypeFlags","Any","Unknown","report","messageId","loc","getFunctionHeadLoc","fix","fixer","method","keyToken","getFirstToken","decorators","lastDecorator","getTokenAfter","AST_TOKEN_TYPES","Keyword","range","key","insertSpace","isSpaceBetween","getTokenBefore","code","insertTextBefore","Object","assign","ArrowFunctionExpression[async = false]","FunctionDeclaration[async = false]","FunctionExpression[async = false]"],"sources":["../../src/rules/promise-function-async.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}