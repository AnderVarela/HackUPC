{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass RangeTree {\n  constructor(start, end, delta, children) {\n    this.start = start;\n    this.end = end;\n    this.delta = delta;\n    this.children = children;\n  }\n  /**\n   * @precodition `ranges` are well-formed and pre-order sorted\n   */\n  static fromSortedRanges(ranges) {\n    let root;\n    // Stack of parent trees and parent counts.\n    const stack = [];\n    for (const range of ranges) {\n      const node = new RangeTree(range.startOffset, range.endOffset, range.count, []);\n      if (root === undefined) {\n        root = node;\n        stack.push([node, range.count]);\n        continue;\n      }\n      let parent;\n      let parentCount;\n      while (true) {\n        [parent, parentCount] = stack[stack.length - 1];\n        // assert: `top !== undefined` (the ranges are sorted)\n        if (range.startOffset < parent.end) {\n          break;\n        } else {\n          stack.pop();\n        }\n      }\n      node.delta -= parentCount;\n      parent.children.push(node);\n      stack.push([node, range.count]);\n    }\n    return root;\n  }\n  normalize() {\n    const children = [];\n    let curEnd;\n    let head;\n    const tail = [];\n    for (const child of this.children) {\n      if (head === undefined) {\n        head = child;\n      } else if (child.delta === head.delta && child.start === curEnd) {\n        tail.push(child);\n      } else {\n        endChain();\n        head = child;\n      }\n      curEnd = child.end;\n    }\n    if (head !== undefined) {\n      endChain();\n    }\n    if (children.length === 1) {\n      const child = children[0];\n      if (child.start === this.start && child.end === this.end) {\n        this.delta += child.delta;\n        this.children = child.children;\n        // `.lazyCount` is zero for both (both are after normalization)\n        return;\n      }\n    }\n    this.children = children;\n    function endChain() {\n      if (tail.length !== 0) {\n        head.end = tail[tail.length - 1].end;\n        for (const tailTree of tail) {\n          for (const subChild of tailTree.children) {\n            subChild.delta += tailTree.delta - head.delta;\n            head.children.push(subChild);\n          }\n        }\n        tail.length = 0;\n      }\n      head.normalize();\n      children.push(head);\n    }\n  }\n  /**\n   * @precondition `tree.start < value && value < tree.end`\n   * @return RangeTree Right part\n   */\n  split(value) {\n    let leftChildLen = this.children.length;\n    let mid;\n    // TODO(perf): Binary search (check overhead)\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (child.start < value && value < child.end) {\n        mid = child.split(value);\n        leftChildLen = i + 1;\n        break;\n      } else if (child.start >= value) {\n        leftChildLen = i;\n        break;\n      }\n    }\n    const rightLen = this.children.length - leftChildLen;\n    const rightChildren = this.children.splice(leftChildLen, rightLen);\n    if (mid !== undefined) {\n      rightChildren.unshift(mid);\n    }\n    const result = new RangeTree(value, this.end, this.delta, rightChildren);\n    this.end = value;\n    return result;\n  }\n  /**\n   * Get the range coverages corresponding to the tree.\n   *\n   * The ranges are pre-order sorted.\n   */\n  toRanges() {\n    const ranges = [];\n    // Stack of parent trees and counts.\n    const stack = [[this, 0]];\n    while (stack.length > 0) {\n      const [cur, parentCount] = stack.pop();\n      const count = parentCount + cur.delta;\n      ranges.push({\n        startOffset: cur.start,\n        endOffset: cur.end,\n        count\n      });\n      for (let i = cur.children.length - 1; i >= 0; i--) {\n        stack.push([cur.children[i], count]);\n      }\n    }\n    return ranges;\n  }\n}\nexports.RangeTree = RangeTree;","map":{"version":3,"names":["RangeTree","constructor","start","end","delta","children","fromSortedRanges","ranges","root","stack","range","node","startOffset","endOffset","count","undefined","push","parent","parentCount","length","pop","normalize","curEnd","head","tail","child","endChain","tailTree","subChild","split","value","leftChildLen","mid","i","rightLen","rightChildren","splice","unshift","result","toRanges","cur","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\range-tree.ts"],"sourcesContent":["import { RangeCov } from \"./types\";\n\nexport class RangeTree {\n  start: number;\n  end: number;\n  delta: number;\n  children: RangeTree[];\n\n  constructor(\n    start: number,\n    end: number,\n    delta: number,\n    children: RangeTree[],\n  ) {\n    this.start = start;\n    this.end = end;\n    this.delta = delta;\n    this.children = children;\n  }\n\n  /**\n   * @precodition `ranges` are well-formed and pre-order sorted\n   */\n  static fromSortedRanges(ranges: ReadonlyArray<RangeCov>): RangeTree | undefined {\n    let root: RangeTree | undefined;\n    // Stack of parent trees and parent counts.\n    const stack: [RangeTree, number][] = [];\n    for (const range of ranges) {\n      const node: RangeTree = new RangeTree(range.startOffset, range.endOffset, range.count, []);\n      if (root === undefined) {\n        root = node;\n        stack.push([node, range.count]);\n        continue;\n      }\n      let parent: RangeTree;\n      let parentCount: number;\n      while (true) {\n        [parent, parentCount] = stack[stack.length - 1];\n        // assert: `top !== undefined` (the ranges are sorted)\n        if (range.startOffset < parent.end) {\n          break;\n        } else {\n          stack.pop();\n        }\n      }\n      node.delta -= parentCount;\n      parent.children.push(node);\n      stack.push([node, range.count]);\n    }\n    return root;\n  }\n\n  normalize(): void {\n    const children: RangeTree[] = [];\n    let curEnd: number;\n    let head: RangeTree | undefined;\n    const tail: RangeTree[] = [];\n    for (const child of this.children) {\n      if (head === undefined) {\n        head = child;\n      } else if (child.delta === head.delta && child.start === curEnd!) {\n        tail.push(child);\n      } else {\n        endChain();\n        head = child;\n      }\n      curEnd = child.end;\n    }\n    if (head !== undefined) {\n      endChain();\n    }\n\n    if (children.length === 1) {\n      const child: RangeTree = children[0];\n      if (child.start === this.start && child.end === this.end) {\n        this.delta += child.delta;\n        this.children = child.children;\n        // `.lazyCount` is zero for both (both are after normalization)\n        return;\n      }\n    }\n\n    this.children = children;\n\n    function endChain(): void {\n      if (tail.length !== 0) {\n        head!.end = tail[tail.length - 1].end;\n        for (const tailTree of tail) {\n          for (const subChild of tailTree.children) {\n            subChild.delta += tailTree.delta - head!.delta;\n            head!.children.push(subChild);\n          }\n        }\n        tail.length = 0;\n      }\n      head!.normalize();\n      children.push(head!);\n    }\n  }\n\n  /**\n   * @precondition `tree.start < value && value < tree.end`\n   * @return RangeTree Right part\n   */\n  split(value: number): RangeTree {\n    let leftChildLen: number = this.children.length;\n    let mid: RangeTree | undefined;\n\n    // TODO(perf): Binary search (check overhead)\n    for (let i: number = 0; i < this.children.length; i++) {\n      const child: RangeTree = this.children[i];\n      if (child.start < value && value < child.end) {\n        mid = child.split(value);\n        leftChildLen = i + 1;\n        break;\n      } else if (child.start >= value) {\n        leftChildLen = i;\n        break;\n      }\n    }\n\n    const rightLen: number = this.children.length - leftChildLen;\n    const rightChildren: RangeTree[] = this.children.splice(leftChildLen, rightLen);\n    if (mid !== undefined) {\n      rightChildren.unshift(mid);\n    }\n    const result: RangeTree = new RangeTree(\n      value,\n      this.end,\n      this.delta,\n      rightChildren,\n    );\n    this.end = value;\n    return result;\n  }\n\n  /**\n   * Get the range coverages corresponding to the tree.\n   *\n   * The ranges are pre-order sorted.\n   */\n  toRanges(): RangeCov[] {\n    const ranges: RangeCov[] = [];\n    // Stack of parent trees and counts.\n    const stack: [RangeTree, number][] = [[this, 0]];\n    while (stack.length > 0) {\n      const [cur, parentCount]: [RangeTree, number] = stack.pop()!;\n      const count: number = parentCount + cur.delta;\n      ranges.push({startOffset: cur.start, endOffset: cur.end, count});\n      for (let i: number = cur.children.length - 1; i >= 0; i--) {\n        stack.push([cur.children[i], count]);\n      }\n    }\n    return ranges;\n  }\n}\n"],"mappings":";;;;;AAEA,MAAaA,SAAS;EAMpBC,YACEC,KAAa,EACbC,GAAW,EACXC,KAAa,EACbC,QAAqB;IAErB,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EAEA;;;EAGA,OAAOC,gBAAgBA,CAACC,MAA+B;IACrD,IAAIC,IAA2B;IAC/B;IACA,MAAMC,KAAK,GAA0B,EAAE;IACvC,KAAK,MAAMC,KAAK,IAAIH,MAAM,EAAE;MAC1B,MAAMI,IAAI,GAAc,IAAIX,SAAS,CAACU,KAAK,CAACE,WAAW,EAAEF,KAAK,CAACG,SAAS,EAAEH,KAAK,CAACI,KAAK,EAAE,EAAE,CAAC;MAC1F,IAAIN,IAAI,KAAKO,SAAS,EAAE;QACtBP,IAAI,GAAGG,IAAI;QACXF,KAAK,CAACO,IAAI,CAAC,CAACL,IAAI,EAAED,KAAK,CAACI,KAAK,CAAC,CAAC;QAC/B;;MAEF,IAAIG,MAAiB;MACrB,IAAIC,WAAmB;MACvB,OAAO,IAAI,EAAE;QACX,CAACD,MAAM,EAAEC,WAAW,CAAC,GAAGT,KAAK,CAACA,KAAK,CAACU,MAAM,GAAG,CAAC,CAAC;QAC/C;QACA,IAAIT,KAAK,CAACE,WAAW,GAAGK,MAAM,CAACd,GAAG,EAAE;UAClC;SACD,MAAM;UACLM,KAAK,CAACW,GAAG,EAAE;;;MAGfT,IAAI,CAACP,KAAK,IAAIc,WAAW;MACzBD,MAAM,CAACZ,QAAQ,CAACW,IAAI,CAACL,IAAI,CAAC;MAC1BF,KAAK,CAACO,IAAI,CAAC,CAACL,IAAI,EAAED,KAAK,CAACI,KAAK,CAAC,CAAC;;IAEjC,OAAON,IAAI;EACb;EAEAa,SAASA,CAAA;IACP,MAAMhB,QAAQ,GAAgB,EAAE;IAChC,IAAIiB,MAAc;IAClB,IAAIC,IAA2B;IAC/B,MAAMC,IAAI,GAAgB,EAAE;IAC5B,KAAK,MAAMC,KAAK,IAAI,IAAI,CAACpB,QAAQ,EAAE;MACjC,IAAIkB,IAAI,KAAKR,SAAS,EAAE;QACtBQ,IAAI,GAAGE,KAAK;OACb,MAAM,IAAIA,KAAK,CAACrB,KAAK,KAAKmB,IAAI,CAACnB,KAAK,IAAIqB,KAAK,CAACvB,KAAK,KAAKoB,MAAO,EAAE;QAChEE,IAAI,CAACR,IAAI,CAACS,KAAK,CAAC;OACjB,MAAM;QACLC,QAAQ,EAAE;QACVH,IAAI,GAAGE,KAAK;;MAEdH,MAAM,GAAGG,KAAK,CAACtB,GAAG;;IAEpB,IAAIoB,IAAI,KAAKR,SAAS,EAAE;MACtBW,QAAQ,EAAE;;IAGZ,IAAIrB,QAAQ,CAACc,MAAM,KAAK,CAAC,EAAE;MACzB,MAAMM,KAAK,GAAcpB,QAAQ,CAAC,CAAC,CAAC;MACpC,IAAIoB,KAAK,CAACvB,KAAK,KAAK,IAAI,CAACA,KAAK,IAAIuB,KAAK,CAACtB,GAAG,KAAK,IAAI,CAACA,GAAG,EAAE;QACxD,IAAI,CAACC,KAAK,IAAIqB,KAAK,CAACrB,KAAK;QACzB,IAAI,CAACC,QAAQ,GAAGoB,KAAK,CAACpB,QAAQ;QAC9B;QACA;;;IAIJ,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAExB,SAASqB,QAAQA,CAAA;MACf,IAAIF,IAAI,CAACL,MAAM,KAAK,CAAC,EAAE;QACrBI,IAAK,CAACpB,GAAG,GAAGqB,IAAI,CAACA,IAAI,CAACL,MAAM,GAAG,CAAC,CAAC,CAAChB,GAAG;QACrC,KAAK,MAAMwB,QAAQ,IAAIH,IAAI,EAAE;UAC3B,KAAK,MAAMI,QAAQ,IAAID,QAAQ,CAACtB,QAAQ,EAAE;YACxCuB,QAAQ,CAACxB,KAAK,IAAIuB,QAAQ,CAACvB,KAAK,GAAGmB,IAAK,CAACnB,KAAK;YAC9CmB,IAAK,CAAClB,QAAQ,CAACW,IAAI,CAACY,QAAQ,CAAC;;;QAGjCJ,IAAI,CAACL,MAAM,GAAG,CAAC;;MAEjBI,IAAK,CAACF,SAAS,EAAE;MACjBhB,QAAQ,CAACW,IAAI,CAACO,IAAK,CAAC;IACtB;EACF;EAEA;;;;EAIAM,KAAKA,CAACC,KAAa;IACjB,IAAIC,YAAY,GAAW,IAAI,CAAC1B,QAAQ,CAACc,MAAM;IAC/C,IAAIa,GAA0B;IAE9B;IACA,KAAK,IAAIC,CAAC,GAAW,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5B,QAAQ,CAACc,MAAM,EAAEc,CAAC,EAAE,EAAE;MACrD,MAAMR,KAAK,GAAc,IAAI,CAACpB,QAAQ,CAAC4B,CAAC,CAAC;MACzC,IAAIR,KAAK,CAACvB,KAAK,GAAG4B,KAAK,IAAIA,KAAK,GAAGL,KAAK,CAACtB,GAAG,EAAE;QAC5C6B,GAAG,GAAGP,KAAK,CAACI,KAAK,CAACC,KAAK,CAAC;QACxBC,YAAY,GAAGE,CAAC,GAAG,CAAC;QACpB;OACD,MAAM,IAAIR,KAAK,CAACvB,KAAK,IAAI4B,KAAK,EAAE;QAC/BC,YAAY,GAAGE,CAAC;QAChB;;;IAIJ,MAAMC,QAAQ,GAAW,IAAI,CAAC7B,QAAQ,CAACc,MAAM,GAAGY,YAAY;IAC5D,MAAMI,aAAa,GAAgB,IAAI,CAAC9B,QAAQ,CAAC+B,MAAM,CAACL,YAAY,EAAEG,QAAQ,CAAC;IAC/E,IAAIF,GAAG,KAAKjB,SAAS,EAAE;MACrBoB,aAAa,CAACE,OAAO,CAACL,GAAG,CAAC;;IAE5B,MAAMM,MAAM,GAAc,IAAItC,SAAS,CACrC8B,KAAK,EACL,IAAI,CAAC3B,GAAG,EACR,IAAI,CAACC,KAAK,EACV+B,aAAa,CACd;IACD,IAAI,CAAChC,GAAG,GAAG2B,KAAK;IAChB,OAAOQ,MAAM;EACf;EAEA;;;;;EAKAC,QAAQA,CAAA;IACN,MAAMhC,MAAM,GAAe,EAAE;IAC7B;IACA,MAAME,KAAK,GAA0B,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IAChD,OAAOA,KAAK,CAACU,MAAM,GAAG,CAAC,EAAE;MACvB,MAAM,CAACqB,GAAG,EAAEtB,WAAW,CAAC,GAAwBT,KAAK,CAACW,GAAG,EAAG;MAC5D,MAAMN,KAAK,GAAWI,WAAW,GAAGsB,GAAG,CAACpC,KAAK;MAC7CG,MAAM,CAACS,IAAI,CAAC;QAACJ,WAAW,EAAE4B,GAAG,CAACtC,KAAK;QAAEW,SAAS,EAAE2B,GAAG,CAACrC,GAAG;QAAEW;MAAK,CAAC,CAAC;MAChE,KAAK,IAAImB,CAAC,GAAWO,GAAG,CAACnC,QAAQ,CAACc,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACzDxB,KAAK,CAACO,IAAI,CAAC,CAACwB,GAAG,CAACnC,QAAQ,CAAC4B,CAAC,CAAC,EAAEnB,KAAK,CAAC,CAAC;;;IAGxC,OAAOP,MAAM;EACf;;AAxJFkC,OAAA,CAAAzC,SAAA,GAAAA,SAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}