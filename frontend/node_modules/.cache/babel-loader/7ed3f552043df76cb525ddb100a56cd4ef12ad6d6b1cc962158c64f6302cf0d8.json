{"ast":null,"code":"import { compareRangeCovs } from \"./compare\";\nexport function emitForest(trees) {\n  return emitForestLines(trees).join(\"\\n\");\n}\nexport function emitForestLines(trees) {\n  const colMap = getColMap(trees);\n  const header = emitOffsets(colMap);\n  return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\nfunction getColMap(trees) {\n  const eventSet = new Set();\n  for (const tree of trees) {\n    const stack = [tree];\n    while (stack.length > 0) {\n      const cur = stack.pop();\n      eventSet.add(cur.start);\n      eventSet.add(cur.end);\n      for (const child of cur.children) {\n        stack.push(child);\n      }\n    }\n  }\n  const events = [...eventSet];\n  events.sort((a, b) => a - b);\n  let maxDigits = 1;\n  for (const event of events) {\n    maxDigits = Math.max(maxDigits, event.toString(10).length);\n  }\n  const colWidth = maxDigits + 3;\n  const colMap = new Map();\n  for (const [i, event] of events.entries()) {\n    colMap.set(event, i * colWidth);\n  }\n  return colMap;\n}\nfunction emitTree(tree, colMap) {\n  const layers = [];\n  let nextLayer = [tree];\n  while (nextLayer.length > 0) {\n    const layer = nextLayer;\n    layers.push(layer);\n    nextLayer = [];\n    for (const node of layer) {\n      for (const child of node.children) {\n        nextLayer.push(child);\n      }\n    }\n  }\n  return layers.map(layer => emitTreeLayer(layer, colMap));\n}\nexport function parseFunctionRanges(text, offsetMap) {\n  const result = [];\n  for (const line of text.split(\"\\n\")) {\n    for (const range of parseTreeLayer(line, offsetMap)) {\n      result.push(range);\n    }\n  }\n  result.sort(compareRangeCovs);\n  return result;\n}\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\nfunction emitTreeLayer(layer, colMap) {\n  const line = [];\n  let curIdx = 0;\n  for (const {\n    start,\n    end,\n    count\n  } of layer) {\n    const startIdx = colMap.get(start);\n    const endIdx = colMap.get(end);\n    if (startIdx > curIdx) {\n      line.push(\" \".repeat(startIdx - curIdx));\n    }\n    line.push(emitRange(count, endIdx - startIdx));\n    curIdx = endIdx;\n  }\n  return line.join(\"\");\n}\nfunction parseTreeLayer(text, offsetMap) {\n  const result = [];\n  const regex = /\\[(\\d+)-*\\)/gs;\n  while (true) {\n    const match = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    const startIdx = match.index;\n    const endIdx = startIdx + match[0].length;\n    const count = parseInt(match[1], 10);\n    const startOffset = offsetMap.get(startIdx);\n    const endOffset = offsetMap.get(endIdx);\n    if (startOffset === undefined || endOffset === undefined) {\n      throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n    }\n    result.push({\n      startOffset,\n      endOffset,\n      count\n    });\n  }\n  return result;\n}\nfunction emitRange(count, len) {\n  const rangeStart = `[${count.toString(10)}`;\n  const rangeEnd = \")\";\n  const hyphensLen = len - (rangeStart.length + rangeEnd.length);\n  const hyphens = \"-\".repeat(Math.max(0, hyphensLen));\n  return `${rangeStart}${hyphens}${rangeEnd}`;\n}\nfunction emitOffsets(colMap) {\n  let line = \"\";\n  for (const [event, col] of colMap) {\n    if (line.length < col) {\n      line += \" \".repeat(col - line.length);\n    }\n    line += event.toString(10);\n  }\n  return line;\n}\nexport function parseOffsets(text) {\n  const result = new Map();\n  const regex = /\\d+/gs;\n  while (true) {\n    const match = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    result.set(match.index, parseInt(match[0], 10));\n  }\n  return result;\n}","map":{"version":3,"names":["compareRangeCovs","emitForest","trees","emitForestLines","join","colMap","getColMap","header","emitOffsets","map","tree","emitTree","eventSet","Set","stack","length","cur","pop","add","start","end","child","children","push","events","sort","a","b","maxDigits","event","Math","max","toString","colWidth","Map","i","entries","set","layers","nextLayer","layer","node","emitTreeLayer","parseFunctionRanges","text","offsetMap","result","line","split","range","parseTreeLayer","curIdx","count","startIdx","get","endIdx","repeat","emitRange","regex","match","exec","index","parseInt","startOffset","endOffset","undefined","Error","JSON","stringify","len","rangeStart","rangeEnd","hyphensLen","hyphens","col","parseOffsets"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\ascii.ts"],"sourcesContent":["import { compareRangeCovs } from \"./compare\";\nimport { RangeCov } from \"./types\";\n\ninterface ReadonlyRangeTree {\n  readonly start: number;\n  readonly end: number;\n  readonly count: number;\n  readonly children: ReadonlyRangeTree[];\n}\n\nexport function emitForest(trees: ReadonlyArray<ReadonlyRangeTree>): string {\n  return emitForestLines(trees).join(\"\\n\");\n}\n\nexport function emitForestLines(trees: ReadonlyArray<ReadonlyRangeTree>): string[] {\n  const colMap: Map<number, number> = getColMap(trees);\n  const header: string = emitOffsets(colMap);\n  return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\n\nfunction getColMap(trees: Iterable<ReadonlyRangeTree>): Map<number, number> {\n  const eventSet: Set<number> = new Set();\n  for (const tree of trees) {\n    const stack: ReadonlyRangeTree[] = [tree];\n    while (stack.length > 0) {\n      const cur: ReadonlyRangeTree = stack.pop()!;\n      eventSet.add(cur.start);\n      eventSet.add(cur.end);\n      for (const child of cur.children) {\n        stack.push(child);\n      }\n    }\n  }\n  const events: number[] = [...eventSet];\n  events.sort((a, b) => a - b);\n  let maxDigits: number = 1;\n  for (const event of events) {\n    maxDigits = Math.max(maxDigits, event.toString(10).length);\n  }\n  const colWidth: number = maxDigits + 3;\n  const colMap: Map<number, number> = new Map();\n  for (const [i, event] of events.entries()) {\n    colMap.set(event, i * colWidth);\n  }\n  return colMap;\n}\n\nfunction emitTree(tree: ReadonlyRangeTree, colMap: Map<number, number>): string[] {\n  const layers: ReadonlyRangeTree[][] = [];\n  let nextLayer: ReadonlyRangeTree[] = [tree];\n  while (nextLayer.length > 0) {\n    const layer: ReadonlyRangeTree[] = nextLayer;\n    layers.push(layer);\n    nextLayer = [];\n    for (const node of layer) {\n      for (const child of node.children) {\n        nextLayer.push(child);\n      }\n    }\n  }\n  return layers.map(layer => emitTreeLayer(layer, colMap));\n}\n\nexport function parseFunctionRanges(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  for (const line of text.split(\"\\n\")) {\n    for (const range of parseTreeLayer(line, offsetMap)) {\n      result.push(range);\n    }\n  }\n  result.sort(compareRangeCovs);\n  return result;\n}\n\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\nfunction emitTreeLayer(layer: ReadonlyRangeTree[], colMap: Map<number, number>): string {\n  const line: string[] = [];\n  let curIdx: number = 0;\n  for (const {start, end, count} of layer) {\n    const startIdx: number = colMap.get(start)!;\n    const endIdx: number = colMap.get(end)!;\n    if (startIdx > curIdx) {\n      line.push(\" \".repeat(startIdx - curIdx));\n    }\n    line.push(emitRange(count, endIdx - startIdx));\n    curIdx = endIdx;\n  }\n  return line.join(\"\");\n}\n\nfunction parseTreeLayer(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  const regex: RegExp = /\\[(\\d+)-*\\)/gs;\n  while (true) {\n    const match: RegExpMatchArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    const startIdx: number = match.index!;\n    const endIdx: number = startIdx + match[0].length;\n    const count: number = parseInt(match[1], 10);\n    const startOffset: number | undefined = offsetMap.get(startIdx);\n    const endOffset: number | undefined = offsetMap.get(endIdx);\n    if (startOffset === undefined || endOffset === undefined) {\n      throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n    }\n    result.push({startOffset, endOffset, count});\n  }\n  return result;\n}\n\nfunction emitRange(count: number, len: number): string {\n  const rangeStart: string = `[${count.toString(10)}`;\n  const rangeEnd: string = \")\";\n  const hyphensLen: number = len - (rangeStart.length + rangeEnd.length);\n  const hyphens: string = \"-\".repeat(Math.max(0, hyphensLen));\n  return `${rangeStart}${hyphens}${rangeEnd}`;\n}\n\nfunction emitOffsets(colMap: Map<number, number>): string {\n  let line: string = \"\";\n  for (const [event, col] of colMap) {\n    if (line.length < col) {\n      line += \" \".repeat(col - line.length);\n    }\n    line += event.toString(10);\n  }\n  return line;\n}\n\nexport function parseOffsets(text: string): Map<number, number> {\n  const result: Map<number, number> = new Map();\n  const regex: RegExp = /\\d+/gs;\n  while (true) {\n    const match: RegExpExecArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    result.set(match.index, parseInt(match[0], 10));\n  }\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}