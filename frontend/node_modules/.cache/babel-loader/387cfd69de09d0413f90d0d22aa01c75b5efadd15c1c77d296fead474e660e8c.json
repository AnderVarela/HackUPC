{"ast":null,"code":"/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jsyaml = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function isNothing(subject) {\n    return typeof subject === 'undefined' || subject === null;\n  }\n  function isObject(subject) {\n    return typeof subject === 'object' && subject !== null;\n  }\n  function toArray(sequence) {\n    if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n    return [sequence];\n  }\n  function extend(target, source) {\n    var index, length, key, sourceKeys;\n    if (source) {\n      sourceKeys = Object.keys(source);\n      for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n        key = sourceKeys[index];\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n  function repeat(string, count) {\n    var result = '',\n      cycle;\n    for (cycle = 0; cycle < count; cycle += 1) {\n      result += string;\n    }\n    return result;\n  }\n  function isNegativeZero(number) {\n    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n  }\n  var isNothing_1 = isNothing;\n  var isObject_1 = isObject;\n  var toArray_1 = toArray;\n  var repeat_1 = repeat;\n  var isNegativeZero_1 = isNegativeZero;\n  var extend_1 = extend;\n  var common = {\n    isNothing: isNothing_1,\n    isObject: isObject_1,\n    toArray: toArray_1,\n    repeat: repeat_1,\n    isNegativeZero: isNegativeZero_1,\n    extend: extend_1\n  };\n\n  // YAML error class. http://stackoverflow.com/questions/8458984\n\n  function formatError(exception, compact) {\n    var where = '',\n      message = exception.reason || '(unknown reason)';\n    if (!exception.mark) return message;\n    if (exception.mark.name) {\n      where += 'in \"' + exception.mark.name + '\" ';\n    }\n    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n    if (!compact && exception.mark.snippet) {\n      where += '\\n\\n' + exception.mark.snippet;\n    }\n    return message + ' ' + where;\n  }\n  function YAMLException$1(reason, mark) {\n    // Super constructor\n    Error.call(this);\n    this.name = 'YAMLException';\n    this.reason = reason;\n    this.mark = mark;\n    this.message = formatError(this, false);\n\n    // Include stack trace in error object\n    if (Error.captureStackTrace) {\n      // Chrome and NodeJS\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      // FF, IE 10+ and Safari 6+. Fallback for others\n      this.stack = new Error().stack || '';\n    }\n  }\n\n  // Inherit from Error\n  YAMLException$1.prototype = Object.create(Error.prototype);\n  YAMLException$1.prototype.constructor = YAMLException$1;\n  YAMLException$1.prototype.toString = function toString(compact) {\n    return this.name + ': ' + formatError(this, compact);\n  };\n  var exception = YAMLException$1;\n\n  // get snippet for a single line, respecting maxLength\n  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n    var head = '';\n    var tail = '';\n    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n    if (position - lineStart > maxHalfLength) {\n      head = ' ... ';\n      lineStart = position - maxHalfLength + head.length;\n    }\n    if (lineEnd - position > maxHalfLength) {\n      tail = ' ...';\n      lineEnd = position + maxHalfLength - tail.length;\n    }\n    return {\n      str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, 'â†’') + tail,\n      pos: position - lineStart + head.length // relative position\n    };\n  }\n  function padStart(string, max) {\n    return common.repeat(' ', max - string.length) + string;\n  }\n  function makeSnippet(mark, options) {\n    options = Object.create(options || null);\n    if (!mark.buffer) return null;\n    if (!options.maxLength) options.maxLength = 79;\n    if (typeof options.indent !== 'number') options.indent = 1;\n    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n    if (typeof options.linesAfter !== 'number') options.linesAfter = 2;\n    var re = /\\r?\\n|\\r|\\0/g;\n    var lineStarts = [0];\n    var lineEnds = [];\n    var match;\n    var foundLineNo = -1;\n    while (match = re.exec(mark.buffer)) {\n      lineEnds.push(match.index);\n      lineStarts.push(match.index + match[0].length);\n      if (mark.position <= match.index && foundLineNo < 0) {\n        foundLineNo = lineStarts.length - 2;\n      }\n    }\n    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n    var result = '',\n      i,\n      line;\n    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n    for (i = 1; i <= options.linesBefore; i++) {\n      if (foundLineNo - i < 0) break;\n      line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);\n      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n' + result;\n    }\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n';\n    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n    for (i = 1; i <= options.linesAfter; i++) {\n      if (foundLineNo + i >= lineEnds.length) break;\n      line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);\n      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n';\n    }\n    return result.replace(/\\n$/, '');\n  }\n  var snippet = makeSnippet;\n  var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'multi', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'representName', 'defaultStyle', 'styleAliases'];\n  var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n  function compileStyleAliases(map) {\n    var result = {};\n    if (map !== null) {\n      Object.keys(map).forEach(function (style) {\n        map[style].forEach(function (alias) {\n          result[String(alias)] = style;\n        });\n      });\n    }\n    return result;\n  }\n  function Type$1(tag, options) {\n    options = options || {};\n    Object.keys(options).forEach(function (name) {\n      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n        throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n      }\n    });\n\n    // TODO: Add tag format check.\n    this.options = options; // keep original options in case user wants to extend this type later\n    this.tag = tag;\n    this.kind = options['kind'] || null;\n    this.resolve = options['resolve'] || function () {\n      return true;\n    };\n    this.construct = options['construct'] || function (data) {\n      return data;\n    };\n    this.instanceOf = options['instanceOf'] || null;\n    this.predicate = options['predicate'] || null;\n    this.represent = options['represent'] || null;\n    this.representName = options['representName'] || null;\n    this.defaultStyle = options['defaultStyle'] || null;\n    this.multi = options['multi'] || false;\n    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n      throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n    }\n  }\n  var type = Type$1;\n\n  /*eslint-disable max-len*/\n\n  function compileList(schema, name) {\n    var result = [];\n    schema[name].forEach(function (currentType) {\n      var newIndex = result.length;\n      result.forEach(function (previousType, previousIndex) {\n        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n          newIndex = previousIndex;\n        }\n      });\n      result[newIndex] = currentType;\n    });\n    return result;\n  }\n  function compileMap( /* lists... */\n  ) {\n    var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      },\n      index,\n      length;\n    function collectType(type) {\n      if (type.multi) {\n        result.multi[type.kind].push(type);\n        result.multi['fallback'].push(type);\n      } else {\n        result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n      }\n    }\n    for (index = 0, length = arguments.length; index < length; index += 1) {\n      arguments[index].forEach(collectType);\n    }\n    return result;\n  }\n  function Schema$1(definition) {\n    return this.extend(definition);\n  }\n  Schema$1.prototype.extend = function extend(definition) {\n    var implicit = [];\n    var explicit = [];\n    if (definition instanceof type) {\n      // Schema.extend(type)\n      explicit.push(definition);\n    } else if (Array.isArray(definition)) {\n      // Schema.extend([ type1, type2, ... ])\n      explicit = explicit.concat(definition);\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n      if (definition.implicit) implicit = implicit.concat(definition.implicit);\n      if (definition.explicit) explicit = explicit.concat(definition.explicit);\n    } else {\n      throw new exception('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');\n    }\n    implicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n      if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n      }\n      if (type$1.multi) {\n        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n      }\n    });\n    explicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n    });\n    var result = Object.create(Schema$1.prototype);\n    result.implicit = (this.implicit || []).concat(implicit);\n    result.explicit = (this.explicit || []).concat(explicit);\n    result.compiledImplicit = compileList(result, 'implicit');\n    result.compiledExplicit = compileList(result, 'explicit');\n    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n    return result;\n  };\n  var schema = Schema$1;\n  var str = new type('tag:yaml.org,2002:str', {\n    kind: 'scalar',\n    construct: function (data) {\n      return data !== null ? data : '';\n    }\n  });\n  var seq = new type('tag:yaml.org,2002:seq', {\n    kind: 'sequence',\n    construct: function (data) {\n      return data !== null ? data : [];\n    }\n  });\n  var map = new type('tag:yaml.org,2002:map', {\n    kind: 'mapping',\n    construct: function (data) {\n      return data !== null ? data : {};\n    }\n  });\n  var failsafe = new schema({\n    explicit: [str, seq, map]\n  });\n  function resolveYamlNull(data) {\n    if (data === null) return true;\n    var max = data.length;\n    return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n  }\n  function constructYamlNull() {\n    return null;\n  }\n  function isNull(object) {\n    return object === null;\n  }\n  var _null = new type('tag:yaml.org,2002:null', {\n    kind: 'scalar',\n    resolve: resolveYamlNull,\n    construct: constructYamlNull,\n    predicate: isNull,\n    represent: {\n      canonical: function () {\n        return '~';\n      },\n      lowercase: function () {\n        return 'null';\n      },\n      uppercase: function () {\n        return 'NULL';\n      },\n      camelcase: function () {\n        return 'Null';\n      },\n      empty: function () {\n        return '';\n      }\n    },\n    defaultStyle: 'lowercase'\n  });\n  function resolveYamlBoolean(data) {\n    if (data === null) return false;\n    var max = data.length;\n    return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n  }\n  function constructYamlBoolean(data) {\n    return data === 'true' || data === 'True' || data === 'TRUE';\n  }\n  function isBoolean(object) {\n    return Object.prototype.toString.call(object) === '[object Boolean]';\n  }\n  var bool = new type('tag:yaml.org,2002:bool', {\n    kind: 'scalar',\n    resolve: resolveYamlBoolean,\n    construct: constructYamlBoolean,\n    predicate: isBoolean,\n    represent: {\n      lowercase: function (object) {\n        return object ? 'true' : 'false';\n      },\n      uppercase: function (object) {\n        return object ? 'TRUE' : 'FALSE';\n      },\n      camelcase: function (object) {\n        return object ? 'True' : 'False';\n      }\n    },\n    defaultStyle: 'lowercase'\n  });\n  function isHexCode(c) {\n    return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;\n  }\n  function isOctCode(c) {\n    return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;\n  }\n  function isDecCode(c) {\n    return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;\n  }\n  function resolveYamlInteger(data) {\n    if (data === null) return false;\n    var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n    if (!max) return false;\n    ch = data[index];\n\n    // sign\n    if (ch === '-' || ch === '+') {\n      ch = data[++index];\n    }\n    if (ch === '0') {\n      // 0\n      if (index + 1 === max) return true;\n      ch = data[++index];\n\n      // base 2, base 8, base 16\n\n      if (ch === 'b') {\n        // base 2\n        index++;\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch !== '0' && ch !== '1') return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n      if (ch === 'x') {\n        // base 16\n        index++;\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isHexCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n      if (ch === 'o') {\n        // base 8\n        index++;\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isOctCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n    }\n\n    // base 10 (except 0)\n\n    // value should not start with `_`;\n    if (ch === '_') return false;\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isDecCode(data.charCodeAt(index))) {\n        return false;\n      }\n      hasDigits = true;\n    }\n\n    // Should have digits and should not end with `_`\n    if (!hasDigits || ch === '_') return false;\n    return true;\n  }\n  function constructYamlInteger(data) {\n    var value = data,\n      sign = 1,\n      ch;\n    if (value.indexOf('_') !== -1) {\n      value = value.replace(/_/g, '');\n    }\n    ch = value[0];\n    if (ch === '-' || ch === '+') {\n      if (ch === '-') sign = -1;\n      value = value.slice(1);\n      ch = value[0];\n    }\n    if (value === '0') return 0;\n    if (ch === '0') {\n      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n    }\n    return sign * parseInt(value, 10);\n  }\n  function isInteger(object) {\n    return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n  }\n  var int = new type('tag:yaml.org,2002:int', {\n    kind: 'scalar',\n    resolve: resolveYamlInteger,\n    construct: constructYamlInteger,\n    predicate: isInteger,\n    represent: {\n      binary: function (obj) {\n        return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n      },\n      octal: function (obj) {\n        return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);\n      },\n      decimal: function (obj) {\n        return obj.toString(10);\n      },\n      /* eslint-disable max-len */\n      hexadecimal: function (obj) {\n        return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n      }\n    },\n    defaultStyle: 'decimal',\n    styleAliases: {\n      binary: [2, 'bin'],\n      octal: [8, 'oct'],\n      decimal: [10, 'dec'],\n      hexadecimal: [16, 'hex']\n    }\n  });\n  var YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n  function resolveYamlFloat(data) {\n    if (data === null) return false;\n    if (!YAML_FLOAT_PATTERN.test(data) ||\n    // Quick hack to not allow integers end with `_`\n    // Probably should update regexp & check speed\n    data[data.length - 1] === '_') {\n      return false;\n    }\n    return true;\n  }\n  function constructYamlFloat(data) {\n    var value, sign;\n    value = data.replace(/_/g, '').toLowerCase();\n    sign = value[0] === '-' ? -1 : 1;\n    if ('+-'.indexOf(value[0]) >= 0) {\n      value = value.slice(1);\n    }\n    if (value === '.inf') {\n      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n    } else if (value === '.nan') {\n      return NaN;\n    }\n    return sign * parseFloat(value, 10);\n  }\n  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n  function representYamlFloat(object, style) {\n    var res;\n    if (isNaN(object)) {\n      switch (style) {\n        case 'lowercase':\n          return '.nan';\n        case 'uppercase':\n          return '.NAN';\n        case 'camelcase':\n          return '.NaN';\n      }\n    } else if (Number.POSITIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase':\n          return '.inf';\n        case 'uppercase':\n          return '.INF';\n        case 'camelcase':\n          return '.Inf';\n      }\n    } else if (Number.NEGATIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase':\n          return '-.inf';\n        case 'uppercase':\n          return '-.INF';\n        case 'camelcase':\n          return '-.Inf';\n      }\n    } else if (common.isNegativeZero(object)) {\n      return '-0.0';\n    }\n    res = object.toString(10);\n\n    // JS stringifier can build scientific format without dots: 5e-100,\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n  }\n  function isFloat(object) {\n    return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n  }\n  var float = new type('tag:yaml.org,2002:float', {\n    kind: 'scalar',\n    resolve: resolveYamlFloat,\n    construct: constructYamlFloat,\n    predicate: isFloat,\n    represent: representYamlFloat,\n    defaultStyle: 'lowercase'\n  });\n  var json = failsafe.extend({\n    implicit: [_null, bool, int, float]\n  });\n  var core = json;\n  var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n  // [1] year\n  '-([0-9][0-9])' +\n  // [2] month\n  '-([0-9][0-9])$'); // [3] day\n\n  var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n  // [1] year\n  '-([0-9][0-9]?)' +\n  // [2] month\n  '-([0-9][0-9]?)' +\n  // [3] day\n  '(?:[Tt]|[ \\\\t]+)' +\n  // ...\n  '([0-9][0-9]?)' +\n  // [4] hour\n  ':([0-9][0-9])' +\n  // [5] minute\n  ':([0-9][0-9])' +\n  // [6] second\n  '(?:\\\\.([0-9]*))?' +\n  // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' +\n  // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\n  function resolveYamlTimestamp(data) {\n    if (data === null) return false;\n    if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n    return false;\n  }\n  function constructYamlTimestamp(data) {\n    var match,\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      fraction = 0,\n      delta = null,\n      tz_hour,\n      tz_minute,\n      date;\n    match = YAML_DATE_REGEXP.exec(data);\n    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n    if (match === null) throw new Error('Date resolve error');\n\n    // match: [1] year [2] month [3] day\n\n    year = +match[1];\n    month = +match[2] - 1; // JS month starts with 0\n    day = +match[3];\n    if (!match[4]) {\n      // no hour\n      return new Date(Date.UTC(year, month, day));\n    }\n\n    // match: [4] hour [5] minute [6] second [7] fraction\n\n    hour = +match[4];\n    minute = +match[5];\n    second = +match[6];\n    if (match[7]) {\n      fraction = match[7].slice(0, 3);\n      while (fraction.length < 3) {\n        // milli-seconds\n        fraction += '0';\n      }\n      fraction = +fraction;\n    }\n\n    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n    if (match[9]) {\n      tz_hour = +match[10];\n      tz_minute = +(match[11] || 0);\n      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n      if (match[9] === '-') delta = -delta;\n    }\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n    if (delta) date.setTime(date.getTime() - delta);\n    return date;\n  }\n  function representYamlTimestamp(object /*, style*/) {\n    return object.toISOString();\n  }\n  var timestamp = new type('tag:yaml.org,2002:timestamp', {\n    kind: 'scalar',\n    resolve: resolveYamlTimestamp,\n    construct: constructYamlTimestamp,\n    instanceOf: Date,\n    represent: representYamlTimestamp\n  });\n  function resolveYamlMerge(data) {\n    return data === '<<' || data === null;\n  }\n  var merge = new type('tag:yaml.org,2002:merge', {\n    kind: 'scalar',\n    resolve: resolveYamlMerge\n  });\n\n  /*eslint-disable no-bitwise*/\n\n  // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n  function resolveYamlBinary(data) {\n    if (data === null) return false;\n    var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP;\n\n    // Convert one by one.\n    for (idx = 0; idx < max; idx++) {\n      code = map.indexOf(data.charAt(idx));\n\n      // Skip CR/LF\n      if (code > 64) continue;\n\n      // Fail on illegal characters\n      if (code < 0) return false;\n      bitlen += 6;\n    }\n\n    // If there are any bits left, source was corrupted\n    return bitlen % 8 === 0;\n  }\n  function constructYamlBinary(data) {\n    var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n    // Collect by 6*4 bits (3 bytes)\n\n    for (idx = 0; idx < max; idx++) {\n      if (idx % 4 === 0 && idx) {\n        result.push(bits >> 16 & 0xFF);\n        result.push(bits >> 8 & 0xFF);\n        result.push(bits & 0xFF);\n      }\n      bits = bits << 6 | map.indexOf(input.charAt(idx));\n    }\n\n    // Dump tail\n\n    tailbits = max % 4 * 6;\n    if (tailbits === 0) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    } else if (tailbits === 18) {\n      result.push(bits >> 10 & 0xFF);\n      result.push(bits >> 2 & 0xFF);\n    } else if (tailbits === 12) {\n      result.push(bits >> 4 & 0xFF);\n    }\n    return new Uint8Array(result);\n  }\n  function representYamlBinary(object /*, style*/) {\n    var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n    // Convert every three bytes to 4 ASCII characters.\n\n    for (idx = 0; idx < max; idx++) {\n      if (idx % 3 === 0 && idx) {\n        result += map[bits >> 18 & 0x3F];\n        result += map[bits >> 12 & 0x3F];\n        result += map[bits >> 6 & 0x3F];\n        result += map[bits & 0x3F];\n      }\n      bits = (bits << 8) + object[idx];\n    }\n\n    // Dump tail\n\n    tail = max % 3;\n    if (tail === 0) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    } else if (tail === 2) {\n      result += map[bits >> 10 & 0x3F];\n      result += map[bits >> 4 & 0x3F];\n      result += map[bits << 2 & 0x3F];\n      result += map[64];\n    } else if (tail === 1) {\n      result += map[bits >> 2 & 0x3F];\n      result += map[bits << 4 & 0x3F];\n      result += map[64];\n      result += map[64];\n    }\n    return result;\n  }\n  function isBinary(obj) {\n    return Object.prototype.toString.call(obj) === '[object Uint8Array]';\n  }\n  var binary = new type('tag:yaml.org,2002:binary', {\n    kind: 'scalar',\n    resolve: resolveYamlBinary,\n    construct: constructYamlBinary,\n    predicate: isBinary,\n    represent: representYamlBinary\n  });\n  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\n  var _toString$2 = Object.prototype.toString;\n  function resolveYamlOmap(data) {\n    if (data === null) return true;\n    var objectKeys = [],\n      index,\n      length,\n      pair,\n      pairKey,\n      pairHasKey,\n      object = data;\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n      pairHasKey = false;\n      if (_toString$2.call(pair) !== '[object Object]') return false;\n      for (pairKey in pair) {\n        if (_hasOwnProperty$3.call(pair, pairKey)) {\n          if (!pairHasKey) pairHasKey = true;else return false;\n        }\n      }\n      if (!pairHasKey) return false;\n      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n    }\n    return true;\n  }\n  function constructYamlOmap(data) {\n    return data !== null ? data : [];\n  }\n  var omap = new type('tag:yaml.org,2002:omap', {\n    kind: 'sequence',\n    resolve: resolveYamlOmap,\n    construct: constructYamlOmap\n  });\n  var _toString$1 = Object.prototype.toString;\n  function resolveYamlPairs(data) {\n    if (data === null) return true;\n    var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n    result = new Array(object.length);\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n      if (_toString$1.call(pair) !== '[object Object]') return false;\n      keys = Object.keys(pair);\n      if (keys.length !== 1) return false;\n      result[index] = [keys[0], pair[keys[0]]];\n    }\n    return true;\n  }\n  function constructYamlPairs(data) {\n    if (data === null) return [];\n    var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n    result = new Array(object.length);\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n      keys = Object.keys(pair);\n      result[index] = [keys[0], pair[keys[0]]];\n    }\n    return result;\n  }\n  var pairs = new type('tag:yaml.org,2002:pairs', {\n    kind: 'sequence',\n    resolve: resolveYamlPairs,\n    construct: constructYamlPairs\n  });\n  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n  function resolveYamlSet(data) {\n    if (data === null) return true;\n    var key,\n      object = data;\n    for (key in object) {\n      if (_hasOwnProperty$2.call(object, key)) {\n        if (object[key] !== null) return false;\n      }\n    }\n    return true;\n  }\n  function constructYamlSet(data) {\n    return data !== null ? data : {};\n  }\n  var set = new type('tag:yaml.org,2002:set', {\n    kind: 'mapping',\n    resolve: resolveYamlSet,\n    construct: constructYamlSet\n  });\n  var _default = core.extend({\n    implicit: [timestamp, merge],\n    explicit: [binary, omap, pairs, set]\n  });\n\n  /*eslint-disable max-len,no-use-before-define*/\n\n  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  var CONTEXT_FLOW_IN = 1;\n  var CONTEXT_FLOW_OUT = 2;\n  var CONTEXT_BLOCK_IN = 3;\n  var CONTEXT_BLOCK_OUT = 4;\n  var CHOMPING_CLIP = 1;\n  var CHOMPING_STRIP = 2;\n  var CHOMPING_KEEP = 3;\n  var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n  var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n  var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n  function _class(obj) {\n    return Object.prototype.toString.call(obj);\n  }\n  function is_EOL(c) {\n    return c === 0x0A /* LF */ || c === 0x0D /* CR */;\n  }\n  function is_WHITE_SPACE(c) {\n    return c === 0x09 /* Tab */ || c === 0x20 /* Space */;\n  }\n  function is_WS_OR_EOL(c) {\n    return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;\n  }\n  function is_FLOW_INDICATOR(c) {\n    return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;\n  }\n  function fromHexCode(c) {\n    var lc;\n    if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {\n      return c - 0x30;\n    }\n\n    /*eslint-disable no-bitwise*/\n    lc = c | 0x20;\n    if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {\n      return lc - 0x61 + 10;\n    }\n    return -1;\n  }\n  function escapedHexLen(c) {\n    if (c === 0x78 /* x */) {\n      return 2;\n    }\n    if (c === 0x75 /* u */) {\n      return 4;\n    }\n    if (c === 0x55 /* U */) {\n      return 8;\n    }\n    return 0;\n  }\n  function fromDecimalCode(c) {\n    if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {\n      return c - 0x30;\n    }\n    return -1;\n  }\n  function simpleEscapeSequence(c) {\n    /* eslint-disable indent */\n    return c === 0x30 /* 0 */ ? '\\x00' : c === 0x61 /* a */ ? '\\x07' : c === 0x62 /* b */ ? '\\x08' : c === 0x74 /* t */ ? '\\x09' : c === 0x09 /* Tab */ ? '\\x09' : c === 0x6E /* n */ ? '\\x0A' : c === 0x76 /* v */ ? '\\x0B' : c === 0x66 /* f */ ? '\\x0C' : c === 0x72 /* r */ ? '\\x0D' : c === 0x65 /* e */ ? '\\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* \" */ ? '\\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \\ */ ? '\\x5C' : c === 0x4E /* N */ ? '\\x85' : c === 0x5F /* _ */ ? '\\xA0' : c === 0x4C /* L */ ? '\\u2028' : c === 0x50 /* P */ ? '\\u2029' : '';\n  }\n  function charFromCodepoint(c) {\n    if (c <= 0xFFFF) {\n      return String.fromCharCode(c);\n    }\n    // Encode UTF-16 surrogate pair\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n  }\n  var simpleEscapeCheck = new Array(256); // integer, for fast access\n  var simpleEscapeMap = new Array(256);\n  for (var i = 0; i < 256; i++) {\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\n  }\n  function State$1(input, options) {\n    this.input = input;\n    this.filename = options['filename'] || null;\n    this.schema = options['schema'] || _default;\n    this.onWarning = options['onWarning'] || null;\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n    // if such documents have no explicit %YAML directive\n    this.legacy = options['legacy'] || false;\n    this.json = options['json'] || false;\n    this.listener = options['listener'] || null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.typeMap = this.schema.compiledTypeMap;\n    this.length = input.length;\n    this.position = 0;\n    this.line = 0;\n    this.lineStart = 0;\n    this.lineIndent = 0;\n\n    // position of first leading tab in the current line,\n    // used to make sure there are no tabs in the indentation\n    this.firstTabInLine = -1;\n    this.documents = [];\n\n    /*\n    this.version;\n    this.checkLineBreaks;\n    this.tagMap;\n    this.anchorMap;\n    this.tag;\n    this.anchor;\n    this.kind;\n    this.result;*/\n  }\n  function generateError(state, message) {\n    var mark = {\n      name: state.filename,\n      buffer: state.input.slice(0, -1),\n      // omit trailing \\0\n      position: state.position,\n      line: state.line,\n      column: state.position - state.lineStart\n    };\n    mark.snippet = snippet(mark);\n    return new exception(message, mark);\n  }\n  function throwError(state, message) {\n    throw generateError(state, message);\n  }\n  function throwWarning(state, message) {\n    if (state.onWarning) {\n      state.onWarning.call(null, generateError(state, message));\n    }\n  }\n  var directiveHandlers = {\n    YAML: function handleYamlDirective(state, name, args) {\n      var match, major, minor;\n      if (state.version !== null) {\n        throwError(state, 'duplication of %YAML directive');\n      }\n      if (args.length !== 1) {\n        throwError(state, 'YAML directive accepts exactly one argument');\n      }\n      match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n      if (match === null) {\n        throwError(state, 'ill-formed argument of the YAML directive');\n      }\n      major = parseInt(match[1], 10);\n      minor = parseInt(match[2], 10);\n      if (major !== 1) {\n        throwError(state, 'unacceptable YAML version of the document');\n      }\n      state.version = args[0];\n      state.checkLineBreaks = minor < 2;\n      if (minor !== 1 && minor !== 2) {\n        throwWarning(state, 'unsupported YAML version of the document');\n      }\n    },\n    TAG: function handleTagDirective(state, name, args) {\n      var handle, prefix;\n      if (args.length !== 2) {\n        throwError(state, 'TAG directive accepts exactly two arguments');\n      }\n      handle = args[0];\n      prefix = args[1];\n      if (!PATTERN_TAG_HANDLE.test(handle)) {\n        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n      }\n      if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n        throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n      }\n      if (!PATTERN_TAG_URI.test(prefix)) {\n        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n      }\n      try {\n        prefix = decodeURIComponent(prefix);\n      } catch (err) {\n        throwError(state, 'tag prefix is malformed: ' + prefix);\n      }\n      state.tagMap[handle] = prefix;\n    }\n  };\n  function captureSegment(state, start, end, checkJson) {\n    var _position, _length, _character, _result;\n    if (start < end) {\n      _result = state.input.slice(start, end);\n      if (checkJson) {\n        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n          _character = _result.charCodeAt(_position);\n          if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n            throwError(state, 'expected valid JSON character');\n          }\n        }\n      } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n        throwError(state, 'the stream contains non-printable characters');\n      }\n      state.result += _result;\n    }\n  }\n  function mergeMappings(state, destination, source, overridableKeys) {\n    var sourceKeys, key, index, quantity;\n    if (!common.isObject(source)) {\n      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n    }\n    sourceKeys = Object.keys(source);\n    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n      key = sourceKeys[index];\n      if (!_hasOwnProperty$1.call(destination, key)) {\n        destination[key] = source[key];\n        overridableKeys[key] = true;\n      }\n    }\n  }\n  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n    var index, quantity;\n\n    // The output is a plain object here, so keys can only be strings.\n    // We need to convert keyNode to a string, but doing so can hang the process\n    // (deeply nested arrays that explode exponentially using aliases).\n    if (Array.isArray(keyNode)) {\n      keyNode = Array.prototype.slice.call(keyNode);\n      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n        if (Array.isArray(keyNode[index])) {\n          throwError(state, 'nested arrays are not supported inside keys');\n        }\n        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n          keyNode[index] = '[object Object]';\n        }\n      }\n    }\n\n    // Avoid code execution in load() via toString property\n    // (still use its own toString for arrays, timestamps,\n    // and whatever user schema extensions happen to have @@toStringTag)\n    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n      keyNode = '[object Object]';\n    }\n    keyNode = String(keyNode);\n    if (_result === null) {\n      _result = {};\n    }\n    if (keyTag === 'tag:yaml.org,2002:merge') {\n      if (Array.isArray(valueNode)) {\n        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n          mergeMappings(state, _result, valueNode[index], overridableKeys);\n        }\n      } else {\n        mergeMappings(state, _result, valueNode, overridableKeys);\n      }\n    } else {\n      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {\n        state.line = startLine || state.line;\n        state.lineStart = startLineStart || state.lineStart;\n        state.position = startPos || state.position;\n        throwError(state, 'duplicated mapping key');\n      }\n\n      // used for this specific key only because Object.defineProperty is slow\n      if (keyNode === '__proto__') {\n        Object.defineProperty(_result, keyNode, {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: valueNode\n        });\n      } else {\n        _result[keyNode] = valueNode;\n      }\n      delete overridableKeys[keyNode];\n    }\n    return _result;\n  }\n  function readLineBreak(state) {\n    var ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x0A /* LF */) {\n      state.position++;\n    } else if (ch === 0x0D /* CR */) {\n      state.position++;\n      if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {\n        state.position++;\n      }\n    } else {\n      throwError(state, 'a line break is expected');\n    }\n    state.line += 1;\n    state.lineStart = state.position;\n    state.firstTabInLine = -1;\n  }\n  function skipSeparationSpace(state, allowComments, checkIndent) {\n    var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        if (ch === 0x09 /* Tab */ && state.firstTabInLine === -1) {\n          state.firstTabInLine = state.position;\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (allowComments && ch === 0x23 /* # */) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);\n      }\n      if (is_EOL(ch)) {\n        readLineBreak(state);\n        ch = state.input.charCodeAt(state.position);\n        lineBreaks++;\n        state.lineIndent = 0;\n        while (ch === 0x20 /* Space */) {\n          state.lineIndent++;\n          ch = state.input.charCodeAt(++state.position);\n        }\n      } else {\n        break;\n      }\n    }\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n      throwWarning(state, 'deficient indentation');\n    }\n    return lineBreaks;\n  }\n  function testDocumentSeparator(state) {\n    var _position = state.position,\n      ch;\n    ch = state.input.charCodeAt(_position);\n\n    // Condition state.position === state.lineStart is tested\n    // in parent on each call, for efficiency. No needs to test here again.\n    if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n      _position += 3;\n      ch = state.input.charCodeAt(_position);\n      if (ch === 0 || is_WS_OR_EOL(ch)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function writeFoldedLines(state, count) {\n    if (count === 1) {\n      state.result += ' ';\n    } else if (count > 1) {\n      state.result += common.repeat('\\n', count - 1);\n    }\n  }\n  function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n    var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n    ch = state.input.charCodeAt(state.position);\n    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* \" */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {\n      return false;\n    }\n    if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {\n      following = state.input.charCodeAt(state.position + 1);\n      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        return false;\n      }\n    }\n    state.kind = 'scalar';\n    state.result = '';\n    captureStart = captureEnd = state.position;\n    hasPendingContent = false;\n    while (ch !== 0) {\n      if (ch === 0x3A /* : */) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          break;\n        }\n      } else if (ch === 0x23 /* # */) {\n        preceding = state.input.charCodeAt(state.position - 1);\n        if (is_WS_OR_EOL(preceding)) {\n          break;\n        }\n      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n        break;\n      } else if (is_EOL(ch)) {\n        _line = state.line;\n        _lineStart = state.lineStart;\n        _lineIndent = state.lineIndent;\n        skipSeparationSpace(state, false, -1);\n        if (state.lineIndent >= nodeIndent) {\n          hasPendingContent = true;\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        } else {\n          state.position = captureEnd;\n          state.line = _line;\n          state.lineStart = _lineStart;\n          state.lineIndent = _lineIndent;\n          break;\n        }\n      }\n      if (hasPendingContent) {\n        captureSegment(state, captureStart, captureEnd, false);\n        writeFoldedLines(state, state.line - _line);\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n      }\n      if (!is_WHITE_SPACE(ch)) {\n        captureEnd = state.position + 1;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n    captureSegment(state, captureStart, captureEnd, false);\n    if (state.result) {\n      return true;\n    }\n    state.kind = _kind;\n    state.result = _result;\n    return false;\n  }\n  function readSingleQuotedScalar(state, nodeIndent) {\n    var ch, captureStart, captureEnd;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x27 /* ' */) {\n      return false;\n    }\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x27 /* ' */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n        if (ch === 0x27 /* ' */) {\n          captureStart = state.position;\n          state.position++;\n          captureEnd = state.position;\n        } else {\n          return true;\n        }\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a single quoted scalar');\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n    throwError(state, 'unexpected end of the stream within a single quoted scalar');\n  }\n  function readDoubleQuotedScalar(state, nodeIndent) {\n    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x22 /* \" */) {\n      return false;\n    }\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x22 /* \" */) {\n        captureSegment(state, captureStart, state.position, true);\n        state.position++;\n        return true;\n      } else if (ch === 0x5C /* \\ */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n        if (is_EOL(ch)) {\n          skipSeparationSpace(state, false, nodeIndent);\n\n          // TODO: rework to inline fn with no type cast?\n        } else if (ch < 256 && simpleEscapeCheck[ch]) {\n          state.result += simpleEscapeMap[ch];\n          state.position++;\n        } else if ((tmp = escapedHexLen(ch)) > 0) {\n          hexLength = tmp;\n          hexResult = 0;\n          for (; hexLength > 0; hexLength--) {\n            ch = state.input.charCodeAt(++state.position);\n            if ((tmp = fromHexCode(ch)) >= 0) {\n              hexResult = (hexResult << 4) + tmp;\n            } else {\n              throwError(state, 'expected hexadecimal character');\n            }\n          }\n          state.result += charFromCodepoint(hexResult);\n          state.position++;\n        } else {\n          throwError(state, 'unknown escape sequence');\n        }\n        captureStart = captureEnd = state.position;\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a double quoted scalar');\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n    throwError(state, 'unexpected end of the stream within a double quoted scalar');\n  }\n  function readFlowCollection(state, nodeIndent) {\n    var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag = state.tag,\n      _result,\n      _anchor = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x5B /* [ */) {\n      terminator = 0x5D; /* ] */\n      isMapping = false;\n      _result = [];\n    } else if (ch === 0x7B /* { */) {\n      terminator = 0x7D; /* } */\n      isMapping = true;\n      _result = {};\n    } else {\n      return false;\n    }\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(++state.position);\n    while (ch !== 0) {\n      skipSeparationSpace(state, true, nodeIndent);\n      ch = state.input.charCodeAt(state.position);\n      if (ch === terminator) {\n        state.position++;\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = isMapping ? 'mapping' : 'sequence';\n        state.result = _result;\n        return true;\n      } else if (!readNext) {\n        throwError(state, 'missed comma between flow collection entries');\n      } else if (ch === 0x2C /* , */) {\n        // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n        throwError(state, \"expected the node content, but found ','\");\n      }\n      keyTag = keyNode = valueNode = null;\n      isPair = isExplicitPair = false;\n      if (ch === 0x3F /* ? */) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following)) {\n          isPair = isExplicitPair = true;\n          state.position++;\n          skipSeparationSpace(state, true, nodeIndent);\n        }\n      }\n      _line = state.line; // Save the current line.\n      _lineStart = state.lineStart;\n      _pos = state.position;\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      keyTag = state.tag;\n      keyNode = state.result;\n      skipSeparationSpace(state, true, nodeIndent);\n      ch = state.input.charCodeAt(state.position);\n      if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {\n        isPair = true;\n        ch = state.input.charCodeAt(++state.position);\n        skipSeparationSpace(state, true, nodeIndent);\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        valueNode = state.result;\n      }\n      if (isMapping) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n      } else if (isPair) {\n        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n      } else {\n        _result.push(keyNode);\n      }\n      skipSeparationSpace(state, true, nodeIndent);\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 0x2C /* , */) {\n        readNext = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        readNext = false;\n      }\n    }\n    throwError(state, 'unexpected end of the stream within a flow collection');\n  }\n  function readBlockScalar(state, nodeIndent) {\n    var captureStart,\n      folding,\n      chomping = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent = nodeIndent,\n      emptyLines = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x7C /* | */) {\n      folding = false;\n    } else if (ch === 0x3E /* > */) {\n      folding = true;\n    } else {\n      return false;\n    }\n    state.kind = 'scalar';\n    state.result = '';\n    while (ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n      if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {\n        if (CHOMPING_CLIP === chomping) {\n          chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;\n        } else {\n          throwError(state, 'repeat of a chomping mode identifier');\n        }\n      } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n        if (tmp === 0) {\n          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n        } else if (!detectedIndent) {\n          textIndent = nodeIndent + tmp - 1;\n          detectedIndent = true;\n        } else {\n          throwError(state, 'repeat of an indentation width identifier');\n        }\n      } else {\n        break;\n      }\n    }\n    if (is_WHITE_SPACE(ch)) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (is_WHITE_SPACE(ch));\n      if (ch === 0x23 /* # */) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (!is_EOL(ch) && ch !== 0);\n      }\n    }\n    while (ch !== 0) {\n      readLineBreak(state);\n      state.lineIndent = 0;\n      ch = state.input.charCodeAt(state.position);\n      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (!detectedIndent && state.lineIndent > textIndent) {\n        textIndent = state.lineIndent;\n      }\n      if (is_EOL(ch)) {\n        emptyLines++;\n        continue;\n      }\n\n      // End of the scalar.\n      if (state.lineIndent < textIndent) {\n        // Perform the chomping.\n        if (chomping === CHOMPING_KEEP) {\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n        } else if (chomping === CHOMPING_CLIP) {\n          if (didReadContent) {\n            // i.e. only if the scalar is not empty.\n            state.result += '\\n';\n          }\n        }\n\n        // Break this `while` cycle and go to the funciton's epilogue.\n        break;\n      }\n\n      // Folded style: use fancy rules to handle line breaks.\n      if (folding) {\n        // Lines starting with white space characters (more-indented lines) are not folded.\n        if (is_WHITE_SPACE(ch)) {\n          atMoreIndented = true;\n          // except for the first content line (cf. Example 8.1)\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n          // End of more-indented block.\n        } else if (atMoreIndented) {\n          atMoreIndented = false;\n          state.result += common.repeat('\\n', emptyLines + 1);\n\n          // Just one line break - perceive as the same line.\n        } else if (emptyLines === 0) {\n          if (didReadContent) {\n            // i.e. only if we have already read some scalar content.\n            state.result += ' ';\n          }\n\n          // Several line breaks - perceive as different lines.\n        } else {\n          state.result += common.repeat('\\n', emptyLines);\n        }\n\n        // Literal style: just add exact number of line breaks between content lines.\n      } else {\n        // Keep all line breaks except the header line break.\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      }\n      didReadContent = true;\n      detectedIndent = true;\n      emptyLines = 0;\n      captureStart = state.position;\n      while (!is_EOL(ch) && ch !== 0) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      captureSegment(state, captureStart, state.position, false);\n    }\n    return true;\n  }\n  function readBlockSequence(state, nodeIndent) {\n    var _line,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = [],\n      following,\n      detected = false,\n      ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while (ch !== 0) {\n      if (state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n      if (ch !== 0x2D /* - */) {\n        break;\n      }\n      following = state.input.charCodeAt(state.position + 1);\n      if (!is_WS_OR_EOL(following)) {\n        break;\n      }\n      detected = true;\n      state.position++;\n      if (skipSeparationSpace(state, true, -1)) {\n        if (state.lineIndent <= nodeIndent) {\n          _result.push(null);\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        }\n      }\n      _line = state.line;\n      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n      _result.push(state.result);\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n        throwError(state, 'bad indentation of a sequence entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'sequence';\n      state.result = _result;\n      return true;\n    }\n    return false;\n  }\n  function readBlockMapping(state, nodeIndent, flowIndent) {\n    var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = {},\n      overridableKeys = Object.create(null),\n      keyTag = null,\n      keyNode = null,\n      valueNode = null,\n      atExplicitKey = false,\n      detected = false,\n      ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while (ch !== 0) {\n      if (!atExplicitKey && state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n      following = state.input.charCodeAt(state.position + 1);\n      _line = state.line; // Save the current line.\n\n      //\n      // Explicit notation case. There are two separate blocks:\n      // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n      //\n      if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {\n        if (ch === 0x3F /* ? */) {\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n          detected = true;\n          atExplicitKey = true;\n          allowCompact = true;\n        } else if (atExplicitKey) {\n          // i.e. 0x3A/* : */ === character after the explicit key.\n          atExplicitKey = false;\n          allowCompact = true;\n        } else {\n          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n        }\n        state.position += 1;\n        ch = following;\n\n        //\n        // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n        //\n      } else {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n          // Neither implicit nor explicit notation.\n          // Reading is done. Go to the epilogue.\n          break;\n        }\n        if (state.line === _line) {\n          ch = state.input.charCodeAt(state.position);\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (ch === 0x3A /* : */) {\n            ch = state.input.charCodeAt(++state.position);\n            if (!is_WS_OR_EOL(ch)) {\n              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n            }\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n              keyTag = keyNode = valueNode = null;\n            }\n            detected = true;\n            atExplicitKey = false;\n            allowCompact = false;\n            keyTag = state.tag;\n            keyNode = state.result;\n          } else if (detected) {\n            throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n          } else {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            return true; // Keep the result of `composeNode`.\n          }\n        } else if (detected) {\n          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      }\n\n      //\n      // Common reading code for both explicit and implicit notations.\n      //\n      if (state.line === _line || state.lineIndent > nodeIndent) {\n        if (atExplicitKey) {\n          _keyLine = state.line;\n          _keyLineStart = state.lineStart;\n          _keyPos = state.position;\n        }\n        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n          if (atExplicitKey) {\n            keyNode = state.result;\n          } else {\n            valueNode = state.result;\n          }\n        }\n        if (!atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n      }\n      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n        throwError(state, 'bad indentation of a mapping entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n\n    //\n    // Epilogue.\n    //\n\n    // Special case: last mapping's node contains only the key in explicit notation.\n    if (atExplicitKey) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n    }\n\n    // Expose the resulting mapping.\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'mapping';\n      state.result = _result;\n    }\n    return detected;\n  }\n  function readTagProperty(state) {\n    var _position,\n      isVerbatim = false,\n      isNamed = false,\n      tagHandle,\n      tagName,\n      ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x21 /* ! */) return false;\n    if (state.tag !== null) {\n      throwError(state, 'duplication of a tag property');\n    }\n    ch = state.input.charCodeAt(++state.position);\n    if (ch === 0x3C /* < */) {\n      isVerbatim = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else if (ch === 0x21 /* ! */) {\n      isNamed = true;\n      tagHandle = '!!';\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      tagHandle = '!';\n    }\n    _position = state.position;\n    if (isVerbatim) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0 && ch !== 0x3E /* > */);\n      if (state.position < state.length) {\n        tagName = state.input.slice(_position, state.position);\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        throwError(state, 'unexpected end of the stream within a verbatim tag');\n      }\n    } else {\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        if (ch === 0x21 /* ! */) {\n          if (!isNamed) {\n            tagHandle = state.input.slice(_position - 1, state.position + 1);\n            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n              throwError(state, 'named tag handle cannot contain such characters');\n            }\n            isNamed = true;\n            _position = state.position + 1;\n          } else {\n            throwError(state, 'tag suffix cannot contain exclamation marks');\n          }\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n      tagName = state.input.slice(_position, state.position);\n      if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n        throwError(state, 'tag suffix cannot contain flow indicator characters');\n      }\n    }\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n      throwError(state, 'tag name cannot contain such characters: ' + tagName);\n    }\n    try {\n      tagName = decodeURIComponent(tagName);\n    } catch (err) {\n      throwError(state, 'tag name is malformed: ' + tagName);\n    }\n    if (isVerbatim) {\n      state.tag = tagName;\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n      state.tag = state.tagMap[tagHandle] + tagName;\n    } else if (tagHandle === '!') {\n      state.tag = '!' + tagName;\n    } else if (tagHandle === '!!') {\n      state.tag = 'tag:yaml.org,2002:' + tagName;\n    } else {\n      throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n    }\n    return true;\n  }\n  function readAnchorProperty(state) {\n    var _position, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x26 /* & */) return false;\n    if (state.anchor !== null) {\n      throwError(state, 'duplication of an anchor property');\n    }\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n      throwError(state, 'name of an anchor node must contain at least one character');\n    }\n    state.anchor = state.input.slice(_position, state.position);\n    return true;\n  }\n  function readAlias(state) {\n    var _position, alias, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x2A /* * */) return false;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n      throwError(state, 'name of an alias node must contain at least one character');\n    }\n    alias = state.input.slice(_position, state.position);\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n      throwError(state, 'unidentified alias \"' + alias + '\"');\n    }\n    state.result = state.anchorMap[alias];\n    skipSeparationSpace(state, true, -1);\n    return true;\n  }\n  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n    var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1,\n      // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n    if (state.listener !== null) {\n      state.listener('open', state);\n    }\n    state.tag = null;\n    state.anchor = null;\n    state.kind = null;\n    state.result = null;\n    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n    if (allowToSeek) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      }\n    }\n    if (indentStatus === 1) {\n      while (readTagProperty(state) || readAnchorProperty(state)) {\n        if (skipSeparationSpace(state, true, -1)) {\n          atNewLine = true;\n          allowBlockCollections = allowBlockStyles;\n          if (state.lineIndent > parentIndent) {\n            indentStatus = 1;\n          } else if (state.lineIndent === parentIndent) {\n            indentStatus = 0;\n          } else if (state.lineIndent < parentIndent) {\n            indentStatus = -1;\n          }\n        } else {\n          allowBlockCollections = false;\n        }\n      }\n    }\n    if (allowBlockCollections) {\n      allowBlockCollections = atNewLine || allowCompact;\n    }\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n        flowIndent = parentIndent;\n      } else {\n        flowIndent = parentIndent + 1;\n      }\n      blockIndent = state.position - state.lineStart;\n      if (indentStatus === 1) {\n        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n          hasContent = true;\n        } else {\n          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n            hasContent = true;\n          } else if (readAlias(state)) {\n            hasContent = true;\n            if (state.tag !== null || state.anchor !== null) {\n              throwError(state, 'alias node should not have any properties');\n            }\n          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n            hasContent = true;\n            if (state.tag === null) {\n              state.tag = '?';\n            }\n          }\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n        }\n      } else if (indentStatus === 0) {\n        // Special case: block sequences are allowed to have same indentation level as the parent.\n        // http://www.yaml.org/spec/1.2/spec.html#id2799784\n        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n      }\n    }\n    if (state.tag === null) {\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    } else if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n        if (type.resolve(state.result)) {\n          // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (state.tag !== '!') {\n      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n        type = state.typeMap[state.kind || 'fallback'][state.tag];\n      } else {\n        // looking for multi type\n        type = null;\n        typeList = state.typeMap.multi[state.kind || 'fallback'];\n        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n            type = typeList[typeIndex];\n            break;\n          }\n        }\n      }\n      if (!type) {\n        throwError(state, 'unknown tag !<' + state.tag + '>');\n      }\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n      if (!type.resolve(state.result, state.tag)) {\n        // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result, state.tag);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    }\n    if (state.listener !== null) {\n      state.listener('close', state);\n    }\n    return state.tag !== null || state.anchor !== null || hasContent;\n  }\n  function readDocument(state) {\n    var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n    state.version = null;\n    state.checkLineBreaks = state.legacy;\n    state.tagMap = Object.create(null);\n    state.anchorMap = Object.create(null);\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n      if (state.lineIndent > 0 || ch !== 0x25 /* % */) {\n        break;\n      }\n      hasDirectives = true;\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      directiveName = state.input.slice(_position, state.position);\n      directiveArgs = [];\n      if (directiveName.length < 1) {\n        throwError(state, 'directive name must not be less than one character in length');\n      }\n      while (ch !== 0) {\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (ch === 0x23 /* # */) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 0 && !is_EOL(ch));\n          break;\n        }\n        if (is_EOL(ch)) break;\n        _position = state.position;\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        directiveArgs.push(state.input.slice(_position, state.position));\n      }\n      if (ch !== 0) readLineBreak(state);\n      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n        directiveHandlers[directiveName](state, directiveName, directiveArgs);\n      } else {\n        throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n      }\n    }\n    skipSeparationSpace(state, true, -1);\n    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    } else if (hasDirectives) {\n      throwError(state, 'directives end mark is expected');\n    }\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n    skipSeparationSpace(state, true, -1);\n    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n      throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n    }\n    state.documents.push(state.result);\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      if (state.input.charCodeAt(state.position) === 0x2E /* . */) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      }\n      return;\n    }\n    if (state.position < state.length - 1) {\n      throwError(state, 'end of the stream or a document separator is expected');\n    } else {\n      return;\n    }\n  }\n  function loadDocuments(input, options) {\n    input = String(input);\n    options = options || {};\n    if (input.length !== 0) {\n      // Add tailing `\\n` if not exists\n      if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {\n        input += '\\n';\n      }\n\n      // Strip BOM\n      if (input.charCodeAt(0) === 0xFEFF) {\n        input = input.slice(1);\n      }\n    }\n    var state = new State$1(input, options);\n    var nullpos = input.indexOf('\\0');\n    if (nullpos !== -1) {\n      state.position = nullpos;\n      throwError(state, 'null byte is not allowed in input');\n    }\n\n    // Use 0 as string terminator. That significantly simplifies bounds check.\n    state.input += '\\0';\n    while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {\n      state.lineIndent += 1;\n      state.position += 1;\n    }\n    while (state.position < state.length - 1) {\n      readDocument(state);\n    }\n    return state.documents;\n  }\n  function loadAll$1(input, iterator, options) {\n    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n      options = iterator;\n      iterator = null;\n    }\n    var documents = loadDocuments(input, options);\n    if (typeof iterator !== 'function') {\n      return documents;\n    }\n    for (var index = 0, length = documents.length; index < length; index += 1) {\n      iterator(documents[index]);\n    }\n  }\n  function load$1(input, options) {\n    var documents = loadDocuments(input, options);\n    if (documents.length === 0) {\n      /*eslint-disable no-undefined*/\n      return undefined;\n    } else if (documents.length === 1) {\n      return documents[0];\n    }\n    throw new exception('expected a single document in the stream, but found more');\n  }\n  var loadAll_1 = loadAll$1;\n  var load_1 = load$1;\n  var loader = {\n    loadAll: loadAll_1,\n    load: load_1\n  };\n\n  /*eslint-disable no-use-before-define*/\n\n  var _toString = Object.prototype.toString;\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var CHAR_BOM = 0xFEFF;\n  var CHAR_TAB = 0x09; /* Tab */\n  var CHAR_LINE_FEED = 0x0A; /* LF */\n  var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\n  var CHAR_SPACE = 0x20; /* Space */\n  var CHAR_EXCLAMATION = 0x21; /* ! */\n  var CHAR_DOUBLE_QUOTE = 0x22; /* \" */\n  var CHAR_SHARP = 0x23; /* # */\n  var CHAR_PERCENT = 0x25; /* % */\n  var CHAR_AMPERSAND = 0x26; /* & */\n  var CHAR_SINGLE_QUOTE = 0x27; /* ' */\n  var CHAR_ASTERISK = 0x2A; /* * */\n  var CHAR_COMMA = 0x2C; /* , */\n  var CHAR_MINUS = 0x2D; /* - */\n  var CHAR_COLON = 0x3A; /* : */\n  var CHAR_EQUALS = 0x3D; /* = */\n  var CHAR_GREATER_THAN = 0x3E; /* > */\n  var CHAR_QUESTION = 0x3F; /* ? */\n  var CHAR_COMMERCIAL_AT = 0x40; /* @ */\n  var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\n  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\n  var CHAR_GRAVE_ACCENT = 0x60; /* ` */\n  var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\n  var CHAR_VERTICAL_LINE = 0x7C; /* | */\n  var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\n\n  var ESCAPE_SEQUENCES = {};\n  ESCAPE_SEQUENCES[0x00] = '\\\\0';\n  ESCAPE_SEQUENCES[0x07] = '\\\\a';\n  ESCAPE_SEQUENCES[0x08] = '\\\\b';\n  ESCAPE_SEQUENCES[0x09] = '\\\\t';\n  ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n  ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n  ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n  ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n  ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n  ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n  ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n  ESCAPE_SEQUENCES[0x85] = '\\\\N';\n  ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n  ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n  ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n  var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n  function compileStyleMap(schema, map) {\n    var result, keys, index, length, tag, style, type;\n    if (map === null) return {};\n    result = {};\n    keys = Object.keys(map);\n    for (index = 0, length = keys.length; index < length; index += 1) {\n      tag = keys[index];\n      style = String(map[tag]);\n      if (tag.slice(0, 2) === '!!') {\n        tag = 'tag:yaml.org,2002:' + tag.slice(2);\n      }\n      type = schema.compiledTypeMap['fallback'][tag];\n      if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n        style = type.styleAliases[style];\n      }\n      result[tag] = style;\n    }\n    return result;\n  }\n  function encodeHex(character) {\n    var string, handle, length;\n    string = character.toString(16).toUpperCase();\n    if (character <= 0xFF) {\n      handle = 'x';\n      length = 2;\n    } else if (character <= 0xFFFF) {\n      handle = 'u';\n      length = 4;\n    } else if (character <= 0xFFFFFFFF) {\n      handle = 'U';\n      length = 8;\n    } else {\n      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n    }\n    return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n  }\n  var QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n  function State(options) {\n    this.schema = options['schema'] || _default;\n    this.indent = Math.max(1, options['indent'] || 2);\n    this.noArrayIndent = options['noArrayIndent'] || false;\n    this.skipInvalid = options['skipInvalid'] || false;\n    this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n    this.sortKeys = options['sortKeys'] || false;\n    this.lineWidth = options['lineWidth'] || 80;\n    this.noRefs = options['noRefs'] || false;\n    this.noCompatMode = options['noCompatMode'] || false;\n    this.condenseFlow = options['condenseFlow'] || false;\n    this.quotingType = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n    this.forceQuotes = options['forceQuotes'] || false;\n    this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.explicitTypes = this.schema.compiledExplicit;\n    this.tag = null;\n    this.result = '';\n    this.duplicates = [];\n    this.usedDuplicates = null;\n  }\n\n  // Indents every line in a string. Empty lines (\\n only) are not indented.\n  function indentString(string, spaces) {\n    var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n    while (position < length) {\n      next = string.indexOf('\\n', position);\n      if (next === -1) {\n        line = string.slice(position);\n        position = length;\n      } else {\n        line = string.slice(position, next + 1);\n        position = next + 1;\n      }\n      if (line.length && line !== '\\n') result += ind;\n      result += line;\n    }\n    return result;\n  }\n  function generateNextLine(state, level) {\n    return '\\n' + common.repeat(' ', state.indent * level);\n  }\n  function testImplicitResolving(state, str) {\n    var index, length, type;\n    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n      type = state.implicitTypes[index];\n      if (type.resolve(str)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // [33] s-white ::= s-space | s-tab\n  function isWhitespace(c) {\n    return c === CHAR_SPACE || c === CHAR_TAB;\n  }\n\n  // Returns true if the character can be printed without escaping.\n  // From YAML 1.2: \"any allowed characters known to be non-printable\n  // should also be escaped. [However,] This isnâ€™t mandatory\"\n  // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n  function isPrintable(c) {\n    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n  }\n\n  // [34] ns-char ::= nb-char - s-white\n  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n  // [26] b-char  ::= b-line-feed | b-carriage-return\n  // Including s-white (for some reason, examples doesn't match specs in this aspect)\n  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\n  function isNsCharOrWhitespace(c) {\n    return isPrintable(c) && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n  }\n\n  // [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n  //                             c = flow-in   â‡’ ns-plain-safe-in\n  //                             c = block-key â‡’ ns-plain-safe-out\n  //                             c = flow-key  â‡’ ns-plain-safe-in\n  // [128] ns-plain-safe-out ::= ns-char\n  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n  //                            | ( /* An ns-char preceding */ â€œ#â€ )\n  //                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\n  function isPlainSafe(c, prev, inblock) {\n    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n    return (\n    // ns-plain-safe\n    inblock ?\n    // c = flow-in\n    cIsNsCharOrWhitespace : cIsNsCharOrWhitespace\n    // - c-flow-indicator\n    && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET\n\n    // ns-plain-char\n    ) && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n    || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'\n  }\n\n  // Simplified test for values allowed as the first character in plain style.\n  function isPlainSafeFirst(c) {\n    // Uses a subset of ns-char - c-indicator\n    // where ns-char = nb-char - s-white.\n    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€\n    && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ\"â€\n    && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE\n    // | â€œ%â€ | â€œ@â€ | â€œ`â€)\n    && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n  }\n\n  // Simplified test for values allowed as the last character in plain style.\n  function isPlainSafeLast(c) {\n    // just not whitespace or colon, it will be checked to be plain character later\n    return !isWhitespace(c) && c !== CHAR_COLON;\n  }\n\n  // Same as 'string'.codePointAt(pos), but works in older browsers.\n  function codePointAt(string, pos) {\n    var first = string.charCodeAt(pos),\n      second;\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n      second = string.charCodeAt(pos + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n\n  // Determines whether block indentation indicator is required.\n  function needIndentIndicator(string) {\n    var leadingSpaceRe = /^\\n* /;\n    return leadingSpaceRe.test(string);\n  }\n  var STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5;\n\n  // Determines which scalar styles are possible and returns the preferred style.\n  // lineWidth = -1 => no limit.\n  // Pre-conditions: str.length > 0.\n  // Post-conditions:\n  //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n    var i;\n    var char = 0;\n    var prevChar = null;\n    var hasLineBreak = false;\n    var hasFoldableLine = false; // only checked if shouldTrackWidth\n    var shouldTrackWidth = lineWidth !== -1;\n    var previousLineBreak = -1; // count the first line correctly\n    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n    if (singleLineOnly || forceQuotes) {\n      // Case: no block styles.\n      // Check for disallowed characters to rule out plain and single.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n    } else {\n      // Case: block styles permitted.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (char === CHAR_LINE_FEED) {\n          hasLineBreak = true;\n          // Check if any line can be folded.\n          if (shouldTrackWidth) {\n            hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n            previousLineBreak = i;\n          }\n        } else if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n      // in case the end is missing a \\n\n      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n    }\n    // Although every style can represent \\n without escaping, prefer block styles\n    // for multiline, since they're more readable and they don't add empty lines.\n    // Also prefer folding a super-long line.\n    if (!hasLineBreak && !hasFoldableLine) {\n      // Strings interpretable as another type have to be quoted;\n      // e.g. the string 'true' vs. the boolean true.\n      if (plain && !forceQuotes && !testAmbiguousType(string)) {\n        return STYLE_PLAIN;\n      }\n      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    // Edge case: block indentation indicator can only have one digit.\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\n      return STYLE_DOUBLE;\n    }\n    // At this point we know block styles are valid.\n    // Prefer literal style unless we want to fold.\n    if (!forceQuotes) {\n      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n\n  // Note: line breaking/folding is implemented for only the folded style.\n  // NB. We drop the last trailing newline (if any) of a returned block scalar\n  //  since the dumper adds its own newline. This always works:\n  //    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n  //    â€¢ Ending newline    => removed then restored.\n  //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n  function writeScalar(state, string, level, iskey, inblock) {\n    state.dump = function () {\n      if (string.length === 0) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n      }\n      if (!state.noCompatMode) {\n        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n          return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n        }\n      }\n      var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n      // As indentation gets deeper, let the width decrease monotonically\n      // to the lower bound min(state.lineWidth, 40).\n      // Note that this implies\n      //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n      // This behaves better than a constant minimum width which disallows narrower options,\n      // or an indent threshold which causes the width to suddenly increase.\n      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n      // Without knowing if keys are implicit/explicit, assume implicit for safety.\n      var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || state.flowLevel > -1 && level >= state.flowLevel;\n      function testAmbiguity(string) {\n        return testImplicitResolving(state, string);\n      }\n      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n        case STYLE_PLAIN:\n          return string;\n        case STYLE_SINGLE:\n          return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n        case STYLE_LITERAL:\n          return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n        case STYLE_FOLDED:\n          return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n        case STYLE_DOUBLE:\n          return '\"' + escapeString(string) + '\"';\n        default:\n          throw new exception('impossible error: invalid scalar style');\n      }\n    }();\n  }\n\n  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n  function blockHeader(string, indentPerLevel) {\n    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n    // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n    var clip = string[string.length - 1] === '\\n';\n    var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n    var chomp = keep ? '+' : clip ? '' : '-';\n    return indentIndicator + chomp + '\\n';\n  }\n\n  // (See the note for writeScalar.)\n  function dropEndingNewline(string) {\n    return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n  }\n\n  // Note: a long line without a suitable break point will exceed the width limit.\n  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n  function foldString(string, width) {\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n    // unless they're before or after a more-indented line, or at the very\n    // beginning or end, in which case $k$ maps to $k$.\n    // Therefore, parse each chunk as newline(s) followed by a content line.\n    var lineRe = /(\\n+)([^\\n]*)/g;\n\n    // first line (possibly an empty line)\n    var result = function () {\n      var nextLF = string.indexOf('\\n');\n      nextLF = nextLF !== -1 ? nextLF : string.length;\n      lineRe.lastIndex = nextLF;\n      return foldLine(string.slice(0, nextLF), width);\n    }();\n    // If we haven't reached the first content line yet, don't add an extra \\n.\n    var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n    var moreIndented;\n\n    // rest of the lines\n    var match;\n    while (match = lineRe.exec(string)) {\n      var prefix = match[1],\n        line = match[2];\n      moreIndented = line[0] === ' ';\n      result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n      prevMoreIndented = moreIndented;\n    }\n    return result;\n  }\n\n  // Greedy line breaking.\n  // Picks the longest line under the limit each time,\n  // otherwise settles for the shortest line over the limit.\n  // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n  function foldLine(line, width) {\n    if (line === '' || line[0] === ' ') return line;\n\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n    var match;\n    // start is an inclusive index. end, curr, and next are exclusive.\n    var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n    var result = '';\n\n    // Invariants: 0 <= start <= length-1.\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n    // Inside the loop:\n    //   A match implies length >= 2, so curr and next are <= length-2.\n    while (match = breakRe.exec(line)) {\n      next = match.index;\n      // maintain invariant: curr - start <= width\n      if (next - start > width) {\n        end = curr > start ? curr : next; // derive end <= length-2\n        result += '\\n' + line.slice(start, end);\n        // skip the space that was output as \\n\n        start = end + 1; // derive start <= length-1\n      }\n      curr = next;\n    }\n\n    // By the invariants, start <= length-1, so there is something left over.\n    // It is either the whole string or a part starting from non-whitespace.\n    result += '\\n';\n    // Insert a break if the remainder is too long and there is a break available.\n    if (line.length - start > width && curr > start) {\n      result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n    } else {\n      result += line.slice(start);\n    }\n    return result.slice(1); // drop extra \\n joiner\n  }\n\n  // Escapes a double-quoted string.\n  function escapeString(string) {\n    var result = '';\n    var char = 0;\n    var escapeSeq;\n    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      escapeSeq = ESCAPE_SEQUENCES[char];\n      if (!escapeSeq && isPrintable(char)) {\n        result += string[i];\n        if (char >= 0x10000) result += string[i + 1];\n      } else {\n        result += escapeSeq || encodeHex(char);\n      }\n    }\n    return result;\n  }\n  function writeFlowSequence(state, level, object) {\n    var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {\n        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n        _result += state.dump;\n      }\n    }\n    state.tag = _tag;\n    state.dump = '[' + _result + ']';\n  }\n  function writeBlockSequence(state, level, object, compact) {\n    var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {\n        if (!compact || _result !== '') {\n          _result += generateNextLine(state, level);\n        }\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          _result += '-';\n        } else {\n          _result += '- ';\n        }\n        _result += state.dump;\n      }\n    }\n    state.tag = _tag;\n    state.dump = _result || '[]'; // Empty sequence if no valid values.\n  }\n  function writeFlowMapping(state, level, object) {\n    var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n      pairBuffer = '';\n      if (_result !== '') pairBuffer += ', ';\n      if (state.condenseFlow) pairBuffer += '\"';\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n      if (!writeNode(state, level, objectKey, false, false)) {\n        continue; // Skip this pair because of invalid key;\n      }\n      if (state.dump.length > 1024) pairBuffer += '? ';\n      pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n      if (!writeNode(state, level, objectValue, false, false)) {\n        continue; // Skip this pair because of invalid value.\n      }\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = '{' + _result + '}';\n  }\n  function writeBlockMapping(state, level, object, compact) {\n    var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n    // Allow sorting keys so that the output file is deterministic\n    if (state.sortKeys === true) {\n      // Default sorting\n      objectKeyList.sort();\n    } else if (typeof state.sortKeys === 'function') {\n      // Custom sort function\n      objectKeyList.sort(state.sortKeys);\n    } else if (state.sortKeys) {\n      // Something is wrong\n      throw new exception('sortKeys must be a boolean or a function');\n    }\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n      pairBuffer = '';\n      if (!compact || _result !== '') {\n        pairBuffer += generateNextLine(state, level);\n      }\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n      if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n        continue; // Skip this pair because of invalid key.\n      }\n      explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n      if (explicitPair) {\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          pairBuffer += '?';\n        } else {\n          pairBuffer += '? ';\n        }\n      }\n      pairBuffer += state.dump;\n      if (explicitPair) {\n        pairBuffer += generateNextLine(state, level);\n      }\n      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n        continue; // Skip this pair because of invalid value.\n      }\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += ':';\n      } else {\n        pairBuffer += ': ';\n      }\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n  }\n  function detectType(state, object, explicit) {\n    var _result, typeList, index, length, type, style;\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\n    for (index = 0, length = typeList.length; index < length; index += 1) {\n      type = typeList[index];\n      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n        if (explicit) {\n          if (type.multi && type.representName) {\n            state.tag = type.representName(object);\n          } else {\n            state.tag = type.tag;\n          }\n        } else {\n          state.tag = '?';\n        }\n        if (type.represent) {\n          style = state.styleMap[type.tag] || type.defaultStyle;\n          if (_toString.call(type.represent) === '[object Function]') {\n            _result = type.represent(object, style);\n          } else if (_hasOwnProperty.call(type.represent, style)) {\n            _result = type.represent[style](object, style);\n          } else {\n            throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n          }\n          state.dump = _result;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Serializes `object` and writes it to global `result`.\n  // Returns true on success, or false on invalid object.\n  //\n  function writeNode(state, level, object, block, compact, iskey, isblockseq) {\n    state.tag = null;\n    state.dump = object;\n    if (!detectType(state, object, false)) {\n      detectType(state, object, true);\n    }\n    var type = _toString.call(state.dump);\n    var inblock = block;\n    var tagStr;\n    if (block) {\n      block = state.flowLevel < 0 || state.flowLevel > level;\n    }\n    var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n    if (objectOrArray) {\n      duplicateIndex = state.duplicates.indexOf(object);\n      duplicate = duplicateIndex !== -1;\n    }\n    if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n      compact = false;\n    }\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\n      state.dump = '*ref_' + duplicateIndex;\n    } else {\n      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n        state.usedDuplicates[duplicateIndex] = true;\n      }\n      if (type === '[object Object]') {\n        if (block && Object.keys(state.dump).length !== 0) {\n          writeBlockMapping(state, level, state.dump, compact);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowMapping(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object Array]') {\n        if (block && state.dump.length !== 0) {\n          if (state.noArrayIndent && !isblockseq && level > 0) {\n            writeBlockSequence(state, level - 1, state.dump, compact);\n          } else {\n            writeBlockSequence(state, level, state.dump, compact);\n          }\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowSequence(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object String]') {\n        if (state.tag !== '?') {\n          writeScalar(state, state.dump, level, iskey, inblock);\n        }\n      } else if (type === '[object Undefined]') {\n        return false;\n      } else {\n        if (state.skipInvalid) return false;\n        throw new exception('unacceptable kind of an object to dump ' + type);\n      }\n      if (state.tag !== null && state.tag !== '?') {\n        // Need to encode all characters except those allowed by the spec:\n        //\n        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n        // [36] ns-hex-digit    ::=  ns-dec-digit\n        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n        // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n        //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n        //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n        //\n        // Also need to encode '!' because it has special meaning (end of tag prefix).\n        //\n        tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');\n        if (state.tag[0] === '!') {\n          tagStr = '!' + tagStr;\n        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n          tagStr = '!!' + tagStr.slice(18);\n        } else {\n          tagStr = '!<' + tagStr + '>';\n        }\n        state.dump = tagStr + ' ' + state.dump;\n      }\n    }\n    return true;\n  }\n  function getDuplicateReferences(object, state) {\n    var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n    inspectNode(object, objects, duplicatesIndexes);\n    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n      state.duplicates.push(objects[duplicatesIndexes[index]]);\n    }\n    state.usedDuplicates = new Array(length);\n  }\n  function inspectNode(object, objects, duplicatesIndexes) {\n    var objectKeyList, index, length;\n    if (object !== null && typeof object === 'object') {\n      index = objects.indexOf(object);\n      if (index !== -1) {\n        if (duplicatesIndexes.indexOf(index) === -1) {\n          duplicatesIndexes.push(index);\n        }\n      } else {\n        objects.push(object);\n        if (Array.isArray(object)) {\n          for (index = 0, length = object.length; index < length; index += 1) {\n            inspectNode(object[index], objects, duplicatesIndexes);\n          }\n        } else {\n          objectKeyList = Object.keys(object);\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n          }\n        }\n      }\n    }\n  }\n  function dump$1(input, options) {\n    options = options || {};\n    var state = new State(options);\n    if (!state.noRefs) getDuplicateReferences(input, state);\n    var value = input;\n    if (state.replacer) {\n      value = state.replacer.call({\n        '': value\n      }, '', value);\n    }\n    if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n    return '';\n  }\n  var dump_1 = dump$1;\n  var dumper = {\n    dump: dump_1\n  };\n  function renamed(from, to) {\n    return function () {\n      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' + 'Use yaml.' + to + ' instead, which is now safe by default.');\n    };\n  }\n  var Type = type;\n  var Schema = schema;\n  var FAILSAFE_SCHEMA = failsafe;\n  var JSON_SCHEMA = json;\n  var CORE_SCHEMA = core;\n  var DEFAULT_SCHEMA = _default;\n  var load = loader.load;\n  var loadAll = loader.loadAll;\n  var dump = dumper.dump;\n  var YAMLException = exception;\n\n  // Re-export all types in case user wants to create custom schema\n  var types = {\n    binary: binary,\n    float: float,\n    map: map,\n    null: _null,\n    pairs: pairs,\n    set: set,\n    timestamp: timestamp,\n    bool: bool,\n    int: int,\n    merge: merge,\n    omap: omap,\n    seq: seq,\n    str: str\n  };\n\n  // Removed functions from JS-YAML 3.0.x\n  var safeLoad = renamed('safeLoad', 'load');\n  var safeLoadAll = renamed('safeLoadAll', 'loadAll');\n  var safeDump = renamed('safeDump', 'dump');\n  var jsYaml = {\n    Type: Type,\n    Schema: Schema,\n    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n    JSON_SCHEMA: JSON_SCHEMA,\n    CORE_SCHEMA: CORE_SCHEMA,\n    DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n    load: load,\n    loadAll: loadAll,\n    dump: dump,\n    YAMLException: YAMLException,\n    types: types,\n    safeLoad: safeLoad,\n    safeLoadAll: safeLoadAll,\n    safeDump: safeDump\n  };\n  exports.CORE_SCHEMA = CORE_SCHEMA;\n  exports.DEFAULT_SCHEMA = DEFAULT_SCHEMA;\n  exports.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;\n  exports.JSON_SCHEMA = JSON_SCHEMA;\n  exports.Schema = Schema;\n  exports.Type = Type;\n  exports.YAMLException = YAMLException;\n  exports.default = jsYaml;\n  exports.dump = dump;\n  exports.load = load;\n  exports.loadAll = loadAll;\n  exports.safeDump = safeDump;\n  exports.safeLoad = safeLoad;\n  exports.safeLoadAll = safeLoadAll;\n  exports.types = types;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","jsyaml","isNothing","subject","isObject","toArray","sequence","Array","isArray","extend","target","source","index","length","key","sourceKeys","Object","keys","repeat","string","count","result","cycle","isNegativeZero","number","Number","NEGATIVE_INFINITY","isNothing_1","isObject_1","toArray_1","repeat_1","isNegativeZero_1","extend_1","common","formatError","exception","compact","where","message","reason","mark","name","line","column","snippet","YAMLException$1","Error","call","captureStackTrace","constructor","stack","prototype","create","toString","getLine","buffer","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","Math","floor","str","slice","replace","pos","padStart","max","makeSnippet","options","maxLength","indent","linesBefore","linesAfter","re","lineStarts","lineEnds","match","foundLineNo","exec","push","i","lineNoLength","min","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","compileStyleAliases","map","forEach","style","alias","String","Type$1","tag","indexOf","kind","resolve","construct","data","instanceOf","predicate","represent","representName","defaultStyle","multi","styleAliases","type","compileList","schema","currentType","newIndex","previousType","previousIndex","compileMap","scalar","mapping","fallback","collectType","arguments","Schema$1","definition","implicit","explicit","concat","type$1","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","seq","failsafe","resolveYamlNull","constructYamlNull","isNull","object","_null","canonical","lowercase","uppercase","camelcase","empty","resolveYamlBoolean","constructYamlBoolean","isBoolean","bool","isHexCode","c","isOctCode","isDecCode","resolveYamlInteger","hasDigits","ch","charCodeAt","constructYamlInteger","value","sign","parseInt","isInteger","int","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","RegExp","resolveYamlFloat","test","constructYamlFloat","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","res","isNaN","isFloat","float","json","core","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","resolveYamlTimestamp","constructYamlTimestamp","year","month","day","hour","minute","second","fraction","delta","tz_hour","tz_minute","date","Date","UTC","setTime","getTime","representYamlTimestamp","toISOString","timestamp","resolveYamlMerge","merge","BASE64_MAP","resolveYamlBinary","code","idx","bitlen","charAt","constructYamlBinary","tailbits","input","bits","Uint8Array","representYamlBinary","isBinary","_hasOwnProperty$3","hasOwnProperty","_toString$2","resolveYamlOmap","objectKeys","pair","pairKey","pairHasKey","constructYamlOmap","omap","_toString$1","resolveYamlPairs","constructYamlPairs","pairs","_hasOwnProperty$2","resolveYamlSet","constructYamlSet","set","_default","_hasOwnProperty$1","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","escapedHexLen","fromDecimalCode","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","State$1","filename","onWarning","legacy","listener","implicitTypes","typeMap","lineIndent","firstTabInLine","documents","generateError","state","throwError","throwWarning","directiveHandlers","YAML","handleYamlDirective","args","major","minor","version","checkLineBreaks","TAG","handleTagDirective","handle","prefix","tagMap","decodeURIComponent","err","captureSegment","start","end","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","defineProperty","configurable","enumerable","writable","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readPlainScalar","nodeIndent","withinFlowCollection","preceding","following","captureStart","captureEnd","hasPendingContent","_line","_lineStart","_lineIndent","_kind","readSingleQuotedScalar","readDoubleQuotedScalar","hexLength","hexResult","tmp","readFlowCollection","readNext","_pos","_tag","_anchor","anchor","terminator","isPair","isExplicitPair","isMapping","anchorMap","composeNode","readBlockScalar","folding","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockSequence","detected","readBlockMapping","flowIndent","allowCompact","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readTagProperty","isVerbatim","isNamed","tagHandle","tagName","readAnchorProperty","readAlias","parentIndent","nodeContext","allowToSeek","allowBlockStyles","allowBlockScalars","allowBlockCollections","indentStatus","atNewLine","hasContent","typeIndex","typeQuantity","typeList","blockIndent","readDocument","documentStart","directiveName","directiveArgs","hasDirectives","loadDocuments","nullpos","loadAll$1","iterator","load$1","undefined","loadAll_1","load_1","loader","loadAll","load","_toString","_hasOwnProperty","CHAR_BOM","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","compileStyleMap","encodeHex","character","QUOTING_TYPE_SINGLE","QUOTING_TYPE_DOUBLE","State","noArrayIndent","skipInvalid","flowLevel","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","level","testImplicitResolving","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","isPlainSafeFirst","isPlainSafeLast","codePointAt","first","needIndentIndicator","leadingSpaceRe","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","dump","testAmbiguity","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","breakRe","curr","escapeSeq","writeFlowSequence","writeNode","writeBlockSequence","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","block","isblockseq","tagStr","objectOrArray","duplicateIndex","duplicate","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","dump$1","dump_1","dumper","renamed","from","to","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","YAMLException","types","null","safeLoad","safeLoadAll","safeDump","jsYaml","default"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/node_modules/js-yaml/dist/js-yaml.js"],"sourcesContent":["\n/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jsyaml = {}));\n}(this, (function (exports) { 'use strict';\n\n  function isNothing(subject) {\n    return (typeof subject === 'undefined') || (subject === null);\n  }\n\n\n  function isObject(subject) {\n    return (typeof subject === 'object') && (subject !== null);\n  }\n\n\n  function toArray(sequence) {\n    if (Array.isArray(sequence)) return sequence;\n    else if (isNothing(sequence)) return [];\n\n    return [ sequence ];\n  }\n\n\n  function extend(target, source) {\n    var index, length, key, sourceKeys;\n\n    if (source) {\n      sourceKeys = Object.keys(source);\n\n      for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n        key = sourceKeys[index];\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n\n  function repeat(string, count) {\n    var result = '', cycle;\n\n    for (cycle = 0; cycle < count; cycle += 1) {\n      result += string;\n    }\n\n    return result;\n  }\n\n\n  function isNegativeZero(number) {\n    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n  }\n\n\n  var isNothing_1      = isNothing;\n  var isObject_1       = isObject;\n  var toArray_1        = toArray;\n  var repeat_1         = repeat;\n  var isNegativeZero_1 = isNegativeZero;\n  var extend_1         = extend;\n\n  var common = {\n  \tisNothing: isNothing_1,\n  \tisObject: isObject_1,\n  \ttoArray: toArray_1,\n  \trepeat: repeat_1,\n  \tisNegativeZero: isNegativeZero_1,\n  \textend: extend_1\n  };\n\n  // YAML error class. http://stackoverflow.com/questions/8458984\n\n\n  function formatError(exception, compact) {\n    var where = '', message = exception.reason || '(unknown reason)';\n\n    if (!exception.mark) return message;\n\n    if (exception.mark.name) {\n      where += 'in \"' + exception.mark.name + '\" ';\n    }\n\n    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n    if (!compact && exception.mark.snippet) {\n      where += '\\n\\n' + exception.mark.snippet;\n    }\n\n    return message + ' ' + where;\n  }\n\n\n  function YAMLException$1(reason, mark) {\n    // Super constructor\n    Error.call(this);\n\n    this.name = 'YAMLException';\n    this.reason = reason;\n    this.mark = mark;\n    this.message = formatError(this, false);\n\n    // Include stack trace in error object\n    if (Error.captureStackTrace) {\n      // Chrome and NodeJS\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      // FF, IE 10+ and Safari 6+. Fallback for others\n      this.stack = (new Error()).stack || '';\n    }\n  }\n\n\n  // Inherit from Error\n  YAMLException$1.prototype = Object.create(Error.prototype);\n  YAMLException$1.prototype.constructor = YAMLException$1;\n\n\n  YAMLException$1.prototype.toString = function toString(compact) {\n    return this.name + ': ' + formatError(this, compact);\n  };\n\n\n  var exception = YAMLException$1;\n\n  // get snippet for a single line, respecting maxLength\n  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n    var head = '';\n    var tail = '';\n    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n    if (position - lineStart > maxHalfLength) {\n      head = ' ... ';\n      lineStart = position - maxHalfLength + head.length;\n    }\n\n    if (lineEnd - position > maxHalfLength) {\n      tail = ' ...';\n      lineEnd = position + maxHalfLength - tail.length;\n    }\n\n    return {\n      str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, 'â†’') + tail,\n      pos: position - lineStart + head.length // relative position\n    };\n  }\n\n\n  function padStart(string, max) {\n    return common.repeat(' ', max - string.length) + string;\n  }\n\n\n  function makeSnippet(mark, options) {\n    options = Object.create(options || null);\n\n    if (!mark.buffer) return null;\n\n    if (!options.maxLength) options.maxLength = 79;\n    if (typeof options.indent      !== 'number') options.indent      = 1;\n    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n    if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n    var re = /\\r?\\n|\\r|\\0/g;\n    var lineStarts = [ 0 ];\n    var lineEnds = [];\n    var match;\n    var foundLineNo = -1;\n\n    while ((match = re.exec(mark.buffer))) {\n      lineEnds.push(match.index);\n      lineStarts.push(match.index + match[0].length);\n\n      if (mark.position <= match.index && foundLineNo < 0) {\n        foundLineNo = lineStarts.length - 2;\n      }\n    }\n\n    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n    var result = '', i, line;\n    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n    for (i = 1; i <= options.linesBefore; i++) {\n      if (foundLineNo - i < 0) break;\n      line = getLine(\n        mark.buffer,\n        lineStarts[foundLineNo - i],\n        lineEnds[foundLineNo - i],\n        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n        maxLineLength\n      );\n      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n        ' | ' + line.str + '\\n' + result;\n    }\n\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n    for (i = 1; i <= options.linesAfter; i++) {\n      if (foundLineNo + i >= lineEnds.length) break;\n      line = getLine(\n        mark.buffer,\n        lineStarts[foundLineNo + i],\n        lineEnds[foundLineNo + i],\n        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n        maxLineLength\n      );\n      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n        ' | ' + line.str + '\\n';\n    }\n\n    return result.replace(/\\n$/, '');\n  }\n\n\n  var snippet = makeSnippet;\n\n  var TYPE_CONSTRUCTOR_OPTIONS = [\n    'kind',\n    'multi',\n    'resolve',\n    'construct',\n    'instanceOf',\n    'predicate',\n    'represent',\n    'representName',\n    'defaultStyle',\n    'styleAliases'\n  ];\n\n  var YAML_NODE_KINDS = [\n    'scalar',\n    'sequence',\n    'mapping'\n  ];\n\n  function compileStyleAliases(map) {\n    var result = {};\n\n    if (map !== null) {\n      Object.keys(map).forEach(function (style) {\n        map[style].forEach(function (alias) {\n          result[String(alias)] = style;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  function Type$1(tag, options) {\n    options = options || {};\n\n    Object.keys(options).forEach(function (name) {\n      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n        throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n      }\n    });\n\n    // TODO: Add tag format check.\n    this.options       = options; // keep original options in case user wants to extend this type later\n    this.tag           = tag;\n    this.kind          = options['kind']          || null;\n    this.resolve       = options['resolve']       || function () { return true; };\n    this.construct     = options['construct']     || function (data) { return data; };\n    this.instanceOf    = options['instanceOf']    || null;\n    this.predicate     = options['predicate']     || null;\n    this.represent     = options['represent']     || null;\n    this.representName = options['representName'] || null;\n    this.defaultStyle  = options['defaultStyle']  || null;\n    this.multi         = options['multi']         || false;\n    this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n      throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n    }\n  }\n\n  var type = Type$1;\n\n  /*eslint-disable max-len*/\n\n\n\n\n\n  function compileList(schema, name) {\n    var result = [];\n\n    schema[name].forEach(function (currentType) {\n      var newIndex = result.length;\n\n      result.forEach(function (previousType, previousIndex) {\n        if (previousType.tag === currentType.tag &&\n            previousType.kind === currentType.kind &&\n            previousType.multi === currentType.multi) {\n\n          newIndex = previousIndex;\n        }\n      });\n\n      result[newIndex] = currentType;\n    });\n\n    return result;\n  }\n\n\n  function compileMap(/* lists... */) {\n    var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {},\n          multi: {\n            scalar: [],\n            sequence: [],\n            mapping: [],\n            fallback: []\n          }\n        }, index, length;\n\n    function collectType(type) {\n      if (type.multi) {\n        result.multi[type.kind].push(type);\n        result.multi['fallback'].push(type);\n      } else {\n        result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n      }\n    }\n\n    for (index = 0, length = arguments.length; index < length; index += 1) {\n      arguments[index].forEach(collectType);\n    }\n    return result;\n  }\n\n\n  function Schema$1(definition) {\n    return this.extend(definition);\n  }\n\n\n  Schema$1.prototype.extend = function extend(definition) {\n    var implicit = [];\n    var explicit = [];\n\n    if (definition instanceof type) {\n      // Schema.extend(type)\n      explicit.push(definition);\n\n    } else if (Array.isArray(definition)) {\n      // Schema.extend([ type1, type2, ... ])\n      explicit = explicit.concat(definition);\n\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n      if (definition.implicit) implicit = implicit.concat(definition.implicit);\n      if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n    } else {\n      throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n        'or a schema definition ({ implicit: [...], explicit: [...] })');\n    }\n\n    implicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n\n      if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n      }\n\n      if (type$1.multi) {\n        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n      }\n    });\n\n    explicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n    });\n\n    var result = Object.create(Schema$1.prototype);\n\n    result.implicit = (this.implicit || []).concat(implicit);\n    result.explicit = (this.explicit || []).concat(explicit);\n\n    result.compiledImplicit = compileList(result, 'implicit');\n    result.compiledExplicit = compileList(result, 'explicit');\n    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n    return result;\n  };\n\n\n  var schema = Schema$1;\n\n  var str = new type('tag:yaml.org,2002:str', {\n    kind: 'scalar',\n    construct: function (data) { return data !== null ? data : ''; }\n  });\n\n  var seq = new type('tag:yaml.org,2002:seq', {\n    kind: 'sequence',\n    construct: function (data) { return data !== null ? data : []; }\n  });\n\n  var map = new type('tag:yaml.org,2002:map', {\n    kind: 'mapping',\n    construct: function (data) { return data !== null ? data : {}; }\n  });\n\n  var failsafe = new schema({\n    explicit: [\n      str,\n      seq,\n      map\n    ]\n  });\n\n  function resolveYamlNull(data) {\n    if (data === null) return true;\n\n    var max = data.length;\n\n    return (max === 1 && data === '~') ||\n           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n  }\n\n  function constructYamlNull() {\n    return null;\n  }\n\n  function isNull(object) {\n    return object === null;\n  }\n\n  var _null = new type('tag:yaml.org,2002:null', {\n    kind: 'scalar',\n    resolve: resolveYamlNull,\n    construct: constructYamlNull,\n    predicate: isNull,\n    represent: {\n      canonical: function () { return '~';    },\n      lowercase: function () { return 'null'; },\n      uppercase: function () { return 'NULL'; },\n      camelcase: function () { return 'Null'; },\n      empty:     function () { return '';     }\n    },\n    defaultStyle: 'lowercase'\n  });\n\n  function resolveYamlBoolean(data) {\n    if (data === null) return false;\n\n    var max = data.length;\n\n    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n  }\n\n  function constructYamlBoolean(data) {\n    return data === 'true' ||\n           data === 'True' ||\n           data === 'TRUE';\n  }\n\n  function isBoolean(object) {\n    return Object.prototype.toString.call(object) === '[object Boolean]';\n  }\n\n  var bool = new type('tag:yaml.org,2002:bool', {\n    kind: 'scalar',\n    resolve: resolveYamlBoolean,\n    construct: constructYamlBoolean,\n    predicate: isBoolean,\n    represent: {\n      lowercase: function (object) { return object ? 'true' : 'false'; },\n      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n      camelcase: function (object) { return object ? 'True' : 'False'; }\n    },\n    defaultStyle: 'lowercase'\n  });\n\n  function isHexCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n           ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n  }\n\n  function isOctCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n  }\n\n  function isDecCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n  }\n\n  function resolveYamlInteger(data) {\n    if (data === null) return false;\n\n    var max = data.length,\n        index = 0,\n        hasDigits = false,\n        ch;\n\n    if (!max) return false;\n\n    ch = data[index];\n\n    // sign\n    if (ch === '-' || ch === '+') {\n      ch = data[++index];\n    }\n\n    if (ch === '0') {\n      // 0\n      if (index + 1 === max) return true;\n      ch = data[++index];\n\n      // base 2, base 8, base 16\n\n      if (ch === 'b') {\n        // base 2\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch !== '0' && ch !== '1') return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n\n\n      if (ch === 'x') {\n        // base 16\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isHexCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n\n\n      if (ch === 'o') {\n        // base 8\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isOctCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n    }\n\n    // base 10 (except 0)\n\n    // value should not start with `_`;\n    if (ch === '_') return false;\n\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isDecCode(data.charCodeAt(index))) {\n        return false;\n      }\n      hasDigits = true;\n    }\n\n    // Should have digits and should not end with `_`\n    if (!hasDigits || ch === '_') return false;\n\n    return true;\n  }\n\n  function constructYamlInteger(data) {\n    var value = data, sign = 1, ch;\n\n    if (value.indexOf('_') !== -1) {\n      value = value.replace(/_/g, '');\n    }\n\n    ch = value[0];\n\n    if (ch === '-' || ch === '+') {\n      if (ch === '-') sign = -1;\n      value = value.slice(1);\n      ch = value[0];\n    }\n\n    if (value === '0') return 0;\n\n    if (ch === '0') {\n      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n    }\n\n    return sign * parseInt(value, 10);\n  }\n\n  function isInteger(object) {\n    return (Object.prototype.toString.call(object)) === '[object Number]' &&\n           (object % 1 === 0 && !common.isNegativeZero(object));\n  }\n\n  var int = new type('tag:yaml.org,2002:int', {\n    kind: 'scalar',\n    resolve: resolveYamlInteger,\n    construct: constructYamlInteger,\n    predicate: isInteger,\n    represent: {\n      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n      octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n      decimal:     function (obj) { return obj.toString(10); },\n      /* eslint-disable max-len */\n      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n    },\n    defaultStyle: 'decimal',\n    styleAliases: {\n      binary:      [ 2,  'bin' ],\n      octal:       [ 8,  'oct' ],\n      decimal:     [ 10, 'dec' ],\n      hexadecimal: [ 16, 'hex' ]\n    }\n  });\n\n  var YAML_FLOAT_PATTERN = new RegExp(\n    // 2.5e4, 2.5 and integers\n    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n    // .2e4, .2\n    // special case, seems not from spec\n    '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n    // .inf\n    '|[-+]?\\\\.(?:inf|Inf|INF)' +\n    // .nan\n    '|\\\\.(?:nan|NaN|NAN))$');\n\n  function resolveYamlFloat(data) {\n    if (data === null) return false;\n\n    if (!YAML_FLOAT_PATTERN.test(data) ||\n        // Quick hack to not allow integers end with `_`\n        // Probably should update regexp & check speed\n        data[data.length - 1] === '_') {\n      return false;\n    }\n\n    return true;\n  }\n\n  function constructYamlFloat(data) {\n    var value, sign;\n\n    value  = data.replace(/_/g, '').toLowerCase();\n    sign   = value[0] === '-' ? -1 : 1;\n\n    if ('+-'.indexOf(value[0]) >= 0) {\n      value = value.slice(1);\n    }\n\n    if (value === '.inf') {\n      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n    } else if (value === '.nan') {\n      return NaN;\n    }\n    return sign * parseFloat(value, 10);\n  }\n\n\n  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n  function representYamlFloat(object, style) {\n    var res;\n\n    if (isNaN(object)) {\n      switch (style) {\n        case 'lowercase': return '.nan';\n        case 'uppercase': return '.NAN';\n        case 'camelcase': return '.NaN';\n      }\n    } else if (Number.POSITIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase': return '.inf';\n        case 'uppercase': return '.INF';\n        case 'camelcase': return '.Inf';\n      }\n    } else if (Number.NEGATIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase': return '-.inf';\n        case 'uppercase': return '-.INF';\n        case 'camelcase': return '-.Inf';\n      }\n    } else if (common.isNegativeZero(object)) {\n      return '-0.0';\n    }\n\n    res = object.toString(10);\n\n    // JS stringifier can build scientific format without dots: 5e-100,\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n  }\n\n  function isFloat(object) {\n    return (Object.prototype.toString.call(object) === '[object Number]') &&\n           (object % 1 !== 0 || common.isNegativeZero(object));\n  }\n\n  var float = new type('tag:yaml.org,2002:float', {\n    kind: 'scalar',\n    resolve: resolveYamlFloat,\n    construct: constructYamlFloat,\n    predicate: isFloat,\n    represent: representYamlFloat,\n    defaultStyle: 'lowercase'\n  });\n\n  var json = failsafe.extend({\n    implicit: [\n      _null,\n      bool,\n      int,\n      float\n    ]\n  });\n\n  var core = json;\n\n  var YAML_DATE_REGEXP = new RegExp(\n    '^([0-9][0-9][0-9][0-9])'          + // [1] year\n    '-([0-9][0-9])'                    + // [2] month\n    '-([0-9][0-9])$');                   // [3] day\n\n  var YAML_TIMESTAMP_REGEXP = new RegExp(\n    '^([0-9][0-9][0-9][0-9])'          + // [1] year\n    '-([0-9][0-9]?)'                   + // [2] month\n    '-([0-9][0-9]?)'                   + // [3] day\n    '(?:[Tt]|[ \\\\t]+)'                 + // ...\n    '([0-9][0-9]?)'                    + // [4] hour\n    ':([0-9][0-9])'                    + // [5] minute\n    ':([0-9][0-9])'                    + // [6] second\n    '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n    '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\n  function resolveYamlTimestamp(data) {\n    if (data === null) return false;\n    if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n    return false;\n  }\n\n  function constructYamlTimestamp(data) {\n    var match, year, month, day, hour, minute, second, fraction = 0,\n        delta = null, tz_hour, tz_minute, date;\n\n    match = YAML_DATE_REGEXP.exec(data);\n    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n    if (match === null) throw new Error('Date resolve error');\n\n    // match: [1] year [2] month [3] day\n\n    year = +(match[1]);\n    month = +(match[2]) - 1; // JS month starts with 0\n    day = +(match[3]);\n\n    if (!match[4]) { // no hour\n      return new Date(Date.UTC(year, month, day));\n    }\n\n    // match: [4] hour [5] minute [6] second [7] fraction\n\n    hour = +(match[4]);\n    minute = +(match[5]);\n    second = +(match[6]);\n\n    if (match[7]) {\n      fraction = match[7].slice(0, 3);\n      while (fraction.length < 3) { // milli-seconds\n        fraction += '0';\n      }\n      fraction = +fraction;\n    }\n\n    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n    if (match[9]) {\n      tz_hour = +(match[10]);\n      tz_minute = +(match[11] || 0);\n      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n      if (match[9] === '-') delta = -delta;\n    }\n\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n    if (delta) date.setTime(date.getTime() - delta);\n\n    return date;\n  }\n\n  function representYamlTimestamp(object /*, style*/) {\n    return object.toISOString();\n  }\n\n  var timestamp = new type('tag:yaml.org,2002:timestamp', {\n    kind: 'scalar',\n    resolve: resolveYamlTimestamp,\n    construct: constructYamlTimestamp,\n    instanceOf: Date,\n    represent: representYamlTimestamp\n  });\n\n  function resolveYamlMerge(data) {\n    return data === '<<' || data === null;\n  }\n\n  var merge = new type('tag:yaml.org,2002:merge', {\n    kind: 'scalar',\n    resolve: resolveYamlMerge\n  });\n\n  /*eslint-disable no-bitwise*/\n\n\n\n\n\n  // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\n  function resolveYamlBinary(data) {\n    if (data === null) return false;\n\n    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n    // Convert one by one.\n    for (idx = 0; idx < max; idx++) {\n      code = map.indexOf(data.charAt(idx));\n\n      // Skip CR/LF\n      if (code > 64) continue;\n\n      // Fail on illegal characters\n      if (code < 0) return false;\n\n      bitlen += 6;\n    }\n\n    // If there are any bits left, source was corrupted\n    return (bitlen % 8) === 0;\n  }\n\n  function constructYamlBinary(data) {\n    var idx, tailbits,\n        input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n        max = input.length,\n        map = BASE64_MAP,\n        bits = 0,\n        result = [];\n\n    // Collect by 6*4 bits (3 bytes)\n\n    for (idx = 0; idx < max; idx++) {\n      if ((idx % 4 === 0) && idx) {\n        result.push((bits >> 16) & 0xFF);\n        result.push((bits >> 8) & 0xFF);\n        result.push(bits & 0xFF);\n      }\n\n      bits = (bits << 6) | map.indexOf(input.charAt(idx));\n    }\n\n    // Dump tail\n\n    tailbits = (max % 4) * 6;\n\n    if (tailbits === 0) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    } else if (tailbits === 18) {\n      result.push((bits >> 10) & 0xFF);\n      result.push((bits >> 2) & 0xFF);\n    } else if (tailbits === 12) {\n      result.push((bits >> 4) & 0xFF);\n    }\n\n    return new Uint8Array(result);\n  }\n\n  function representYamlBinary(object /*, style*/) {\n    var result = '', bits = 0, idx, tail,\n        max = object.length,\n        map = BASE64_MAP;\n\n    // Convert every three bytes to 4 ASCII characters.\n\n    for (idx = 0; idx < max; idx++) {\n      if ((idx % 3 === 0) && idx) {\n        result += map[(bits >> 18) & 0x3F];\n        result += map[(bits >> 12) & 0x3F];\n        result += map[(bits >> 6) & 0x3F];\n        result += map[bits & 0x3F];\n      }\n\n      bits = (bits << 8) + object[idx];\n    }\n\n    // Dump tail\n\n    tail = max % 3;\n\n    if (tail === 0) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    } else if (tail === 2) {\n      result += map[(bits >> 10) & 0x3F];\n      result += map[(bits >> 4) & 0x3F];\n      result += map[(bits << 2) & 0x3F];\n      result += map[64];\n    } else if (tail === 1) {\n      result += map[(bits >> 2) & 0x3F];\n      result += map[(bits << 4) & 0x3F];\n      result += map[64];\n      result += map[64];\n    }\n\n    return result;\n  }\n\n  function isBinary(obj) {\n    return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n  }\n\n  var binary = new type('tag:yaml.org,2002:binary', {\n    kind: 'scalar',\n    resolve: resolveYamlBinary,\n    construct: constructYamlBinary,\n    predicate: isBinary,\n    represent: representYamlBinary\n  });\n\n  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\n  var _toString$2       = Object.prototype.toString;\n\n  function resolveYamlOmap(data) {\n    if (data === null) return true;\n\n    var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n        object = data;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n      pairHasKey = false;\n\n      if (_toString$2.call(pair) !== '[object Object]') return false;\n\n      for (pairKey in pair) {\n        if (_hasOwnProperty$3.call(pair, pairKey)) {\n          if (!pairHasKey) pairHasKey = true;\n          else return false;\n        }\n      }\n\n      if (!pairHasKey) return false;\n\n      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n      else return false;\n    }\n\n    return true;\n  }\n\n  function constructYamlOmap(data) {\n    return data !== null ? data : [];\n  }\n\n  var omap = new type('tag:yaml.org,2002:omap', {\n    kind: 'sequence',\n    resolve: resolveYamlOmap,\n    construct: constructYamlOmap\n  });\n\n  var _toString$1 = Object.prototype.toString;\n\n  function resolveYamlPairs(data) {\n    if (data === null) return true;\n\n    var index, length, pair, keys, result,\n        object = data;\n\n    result = new Array(object.length);\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n\n      if (_toString$1.call(pair) !== '[object Object]') return false;\n\n      keys = Object.keys(pair);\n\n      if (keys.length !== 1) return false;\n\n      result[index] = [ keys[0], pair[keys[0]] ];\n    }\n\n    return true;\n  }\n\n  function constructYamlPairs(data) {\n    if (data === null) return [];\n\n    var index, length, pair, keys, result,\n        object = data;\n\n    result = new Array(object.length);\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n\n      keys = Object.keys(pair);\n\n      result[index] = [ keys[0], pair[keys[0]] ];\n    }\n\n    return result;\n  }\n\n  var pairs = new type('tag:yaml.org,2002:pairs', {\n    kind: 'sequence',\n    resolve: resolveYamlPairs,\n    construct: constructYamlPairs\n  });\n\n  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\n  function resolveYamlSet(data) {\n    if (data === null) return true;\n\n    var key, object = data;\n\n    for (key in object) {\n      if (_hasOwnProperty$2.call(object, key)) {\n        if (object[key] !== null) return false;\n      }\n    }\n\n    return true;\n  }\n\n  function constructYamlSet(data) {\n    return data !== null ? data : {};\n  }\n\n  var set = new type('tag:yaml.org,2002:set', {\n    kind: 'mapping',\n    resolve: resolveYamlSet,\n    construct: constructYamlSet\n  });\n\n  var _default = core.extend({\n    implicit: [\n      timestamp,\n      merge\n    ],\n    explicit: [\n      binary,\n      omap,\n      pairs,\n      set\n    ]\n  });\n\n  /*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\n  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\n  var CONTEXT_FLOW_IN   = 1;\n  var CONTEXT_FLOW_OUT  = 2;\n  var CONTEXT_BLOCK_IN  = 3;\n  var CONTEXT_BLOCK_OUT = 4;\n\n\n  var CHOMPING_CLIP  = 1;\n  var CHOMPING_STRIP = 2;\n  var CHOMPING_KEEP  = 3;\n\n\n  var PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n  var PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\n  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\n  var PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\n  function _class(obj) { return Object.prototype.toString.call(obj); }\n\n  function is_EOL(c) {\n    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n  }\n\n  function is_WHITE_SPACE(c) {\n    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n  }\n\n  function is_WS_OR_EOL(c) {\n    return (c === 0x09/* Tab */) ||\n           (c === 0x20/* Space */) ||\n           (c === 0x0A/* LF */) ||\n           (c === 0x0D/* CR */);\n  }\n\n  function is_FLOW_INDICATOR(c) {\n    return c === 0x2C/* , */ ||\n           c === 0x5B/* [ */ ||\n           c === 0x5D/* ] */ ||\n           c === 0x7B/* { */ ||\n           c === 0x7D/* } */;\n  }\n\n  function fromHexCode(c) {\n    var lc;\n\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n      return c - 0x30;\n    }\n\n    /*eslint-disable no-bitwise*/\n    lc = c | 0x20;\n\n    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n      return lc - 0x61 + 10;\n    }\n\n    return -1;\n  }\n\n  function escapedHexLen(c) {\n    if (c === 0x78/* x */) { return 2; }\n    if (c === 0x75/* u */) { return 4; }\n    if (c === 0x55/* U */) { return 8; }\n    return 0;\n  }\n\n  function fromDecimalCode(c) {\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n      return c - 0x30;\n    }\n\n    return -1;\n  }\n\n  function simpleEscapeSequence(c) {\n    /* eslint-disable indent */\n    return (c === 0x30/* 0 */) ? '\\x00' :\n          (c === 0x61/* a */) ? '\\x07' :\n          (c === 0x62/* b */) ? '\\x08' :\n          (c === 0x74/* t */) ? '\\x09' :\n          (c === 0x09/* Tab */) ? '\\x09' :\n          (c === 0x6E/* n */) ? '\\x0A' :\n          (c === 0x76/* v */) ? '\\x0B' :\n          (c === 0x66/* f */) ? '\\x0C' :\n          (c === 0x72/* r */) ? '\\x0D' :\n          (c === 0x65/* e */) ? '\\x1B' :\n          (c === 0x20/* Space */) ? ' ' :\n          (c === 0x22/* \" */) ? '\\x22' :\n          (c === 0x2F/* / */) ? '/' :\n          (c === 0x5C/* \\ */) ? '\\x5C' :\n          (c === 0x4E/* N */) ? '\\x85' :\n          (c === 0x5F/* _ */) ? '\\xA0' :\n          (c === 0x4C/* L */) ? '\\u2028' :\n          (c === 0x50/* P */) ? '\\u2029' : '';\n  }\n\n  function charFromCodepoint(c) {\n    if (c <= 0xFFFF) {\n      return String.fromCharCode(c);\n    }\n    // Encode UTF-16 surrogate pair\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n    return String.fromCharCode(\n      ((c - 0x010000) >> 10) + 0xD800,\n      ((c - 0x010000) & 0x03FF) + 0xDC00\n    );\n  }\n\n  var simpleEscapeCheck = new Array(256); // integer, for fast access\n  var simpleEscapeMap = new Array(256);\n  for (var i = 0; i < 256; i++) {\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\n  }\n\n\n  function State$1(input, options) {\n    this.input = input;\n\n    this.filename  = options['filename']  || null;\n    this.schema    = options['schema']    || _default;\n    this.onWarning = options['onWarning'] || null;\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n    // if such documents have no explicit %YAML directive\n    this.legacy    = options['legacy']    || false;\n\n    this.json      = options['json']      || false;\n    this.listener  = options['listener']  || null;\n\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.typeMap       = this.schema.compiledTypeMap;\n\n    this.length     = input.length;\n    this.position   = 0;\n    this.line       = 0;\n    this.lineStart  = 0;\n    this.lineIndent = 0;\n\n    // position of first leading tab in the current line,\n    // used to make sure there are no tabs in the indentation\n    this.firstTabInLine = -1;\n\n    this.documents = [];\n\n    /*\n    this.version;\n    this.checkLineBreaks;\n    this.tagMap;\n    this.anchorMap;\n    this.tag;\n    this.anchor;\n    this.kind;\n    this.result;*/\n\n  }\n\n\n  function generateError(state, message) {\n    var mark = {\n      name:     state.filename,\n      buffer:   state.input.slice(0, -1), // omit trailing \\0\n      position: state.position,\n      line:     state.line,\n      column:   state.position - state.lineStart\n    };\n\n    mark.snippet = snippet(mark);\n\n    return new exception(message, mark);\n  }\n\n  function throwError(state, message) {\n    throw generateError(state, message);\n  }\n\n  function throwWarning(state, message) {\n    if (state.onWarning) {\n      state.onWarning.call(null, generateError(state, message));\n    }\n  }\n\n\n  var directiveHandlers = {\n\n    YAML: function handleYamlDirective(state, name, args) {\n\n      var match, major, minor;\n\n      if (state.version !== null) {\n        throwError(state, 'duplication of %YAML directive');\n      }\n\n      if (args.length !== 1) {\n        throwError(state, 'YAML directive accepts exactly one argument');\n      }\n\n      match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n      if (match === null) {\n        throwError(state, 'ill-formed argument of the YAML directive');\n      }\n\n      major = parseInt(match[1], 10);\n      minor = parseInt(match[2], 10);\n\n      if (major !== 1) {\n        throwError(state, 'unacceptable YAML version of the document');\n      }\n\n      state.version = args[0];\n      state.checkLineBreaks = (minor < 2);\n\n      if (minor !== 1 && minor !== 2) {\n        throwWarning(state, 'unsupported YAML version of the document');\n      }\n    },\n\n    TAG: function handleTagDirective(state, name, args) {\n\n      var handle, prefix;\n\n      if (args.length !== 2) {\n        throwError(state, 'TAG directive accepts exactly two arguments');\n      }\n\n      handle = args[0];\n      prefix = args[1];\n\n      if (!PATTERN_TAG_HANDLE.test(handle)) {\n        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n      }\n\n      if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n        throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n      }\n\n      if (!PATTERN_TAG_URI.test(prefix)) {\n        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n      }\n\n      try {\n        prefix = decodeURIComponent(prefix);\n      } catch (err) {\n        throwError(state, 'tag prefix is malformed: ' + prefix);\n      }\n\n      state.tagMap[handle] = prefix;\n    }\n  };\n\n\n  function captureSegment(state, start, end, checkJson) {\n    var _position, _length, _character, _result;\n\n    if (start < end) {\n      _result = state.input.slice(start, end);\n\n      if (checkJson) {\n        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n          _character = _result.charCodeAt(_position);\n          if (!(_character === 0x09 ||\n                (0x20 <= _character && _character <= 0x10FFFF))) {\n            throwError(state, 'expected valid JSON character');\n          }\n        }\n      } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n        throwError(state, 'the stream contains non-printable characters');\n      }\n\n      state.result += _result;\n    }\n  }\n\n  function mergeMappings(state, destination, source, overridableKeys) {\n    var sourceKeys, key, index, quantity;\n\n    if (!common.isObject(source)) {\n      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n    }\n\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n      key = sourceKeys[index];\n\n      if (!_hasOwnProperty$1.call(destination, key)) {\n        destination[key] = source[key];\n        overridableKeys[key] = true;\n      }\n    }\n  }\n\n  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n    startLine, startLineStart, startPos) {\n\n    var index, quantity;\n\n    // The output is a plain object here, so keys can only be strings.\n    // We need to convert keyNode to a string, but doing so can hang the process\n    // (deeply nested arrays that explode exponentially using aliases).\n    if (Array.isArray(keyNode)) {\n      keyNode = Array.prototype.slice.call(keyNode);\n\n      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n        if (Array.isArray(keyNode[index])) {\n          throwError(state, 'nested arrays are not supported inside keys');\n        }\n\n        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n          keyNode[index] = '[object Object]';\n        }\n      }\n    }\n\n    // Avoid code execution in load() via toString property\n    // (still use its own toString for arrays, timestamps,\n    // and whatever user schema extensions happen to have @@toStringTag)\n    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n      keyNode = '[object Object]';\n    }\n\n\n    keyNode = String(keyNode);\n\n    if (_result === null) {\n      _result = {};\n    }\n\n    if (keyTag === 'tag:yaml.org,2002:merge') {\n      if (Array.isArray(valueNode)) {\n        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n          mergeMappings(state, _result, valueNode[index], overridableKeys);\n        }\n      } else {\n        mergeMappings(state, _result, valueNode, overridableKeys);\n      }\n    } else {\n      if (!state.json &&\n          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n          _hasOwnProperty$1.call(_result, keyNode)) {\n        state.line = startLine || state.line;\n        state.lineStart = startLineStart || state.lineStart;\n        state.position = startPos || state.position;\n        throwError(state, 'duplicated mapping key');\n      }\n\n      // used for this specific key only because Object.defineProperty is slow\n      if (keyNode === '__proto__') {\n        Object.defineProperty(_result, keyNode, {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: valueNode\n        });\n      } else {\n        _result[keyNode] = valueNode;\n      }\n      delete overridableKeys[keyNode];\n    }\n\n    return _result;\n  }\n\n  function readLineBreak(state) {\n    var ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x0A/* LF */) {\n      state.position++;\n    } else if (ch === 0x0D/* CR */) {\n      state.position++;\n      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n        state.position++;\n      }\n    } else {\n      throwError(state, 'a line break is expected');\n    }\n\n    state.line += 1;\n    state.lineStart = state.position;\n    state.firstTabInLine = -1;\n  }\n\n  function skipSeparationSpace(state, allowComments, checkIndent) {\n    var lineBreaks = 0,\n        ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n          state.firstTabInLine = state.position;\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (allowComments && ch === 0x23/* # */) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n      }\n\n      if (is_EOL(ch)) {\n        readLineBreak(state);\n\n        ch = state.input.charCodeAt(state.position);\n        lineBreaks++;\n        state.lineIndent = 0;\n\n        while (ch === 0x20/* Space */) {\n          state.lineIndent++;\n          ch = state.input.charCodeAt(++state.position);\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n      throwWarning(state, 'deficient indentation');\n    }\n\n    return lineBreaks;\n  }\n\n  function testDocumentSeparator(state) {\n    var _position = state.position,\n        ch;\n\n    ch = state.input.charCodeAt(_position);\n\n    // Condition state.position === state.lineStart is tested\n    // in parent on each call, for efficiency. No needs to test here again.\n    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n        ch === state.input.charCodeAt(_position + 1) &&\n        ch === state.input.charCodeAt(_position + 2)) {\n\n      _position += 3;\n\n      ch = state.input.charCodeAt(_position);\n\n      if (ch === 0 || is_WS_OR_EOL(ch)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function writeFoldedLines(state, count) {\n    if (count === 1) {\n      state.result += ' ';\n    } else if (count > 1) {\n      state.result += common.repeat('\\n', count - 1);\n    }\n  }\n\n\n  function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n    var preceding,\n        following,\n        captureStart,\n        captureEnd,\n        hasPendingContent,\n        _line,\n        _lineStart,\n        _lineIndent,\n        _kind = state.kind,\n        _result = state.result,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (is_WS_OR_EOL(ch)      ||\n        is_FLOW_INDICATOR(ch) ||\n        ch === 0x23/* # */    ||\n        ch === 0x26/* & */    ||\n        ch === 0x2A/* * */    ||\n        ch === 0x21/* ! */    ||\n        ch === 0x7C/* | */    ||\n        ch === 0x3E/* > */    ||\n        ch === 0x27/* ' */    ||\n        ch === 0x22/* \" */    ||\n        ch === 0x25/* % */    ||\n        ch === 0x40/* @ */    ||\n        ch === 0x60/* ` */) {\n      return false;\n    }\n\n    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        return false;\n      }\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    captureStart = captureEnd = state.position;\n    hasPendingContent = false;\n\n    while (ch !== 0) {\n      if (ch === 0x3A/* : */) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following) ||\n            withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          break;\n        }\n\n      } else if (ch === 0x23/* # */) {\n        preceding = state.input.charCodeAt(state.position - 1);\n\n        if (is_WS_OR_EOL(preceding)) {\n          break;\n        }\n\n      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n        break;\n\n      } else if (is_EOL(ch)) {\n        _line = state.line;\n        _lineStart = state.lineStart;\n        _lineIndent = state.lineIndent;\n        skipSeparationSpace(state, false, -1);\n\n        if (state.lineIndent >= nodeIndent) {\n          hasPendingContent = true;\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        } else {\n          state.position = captureEnd;\n          state.line = _line;\n          state.lineStart = _lineStart;\n          state.lineIndent = _lineIndent;\n          break;\n        }\n      }\n\n      if (hasPendingContent) {\n        captureSegment(state, captureStart, captureEnd, false);\n        writeFoldedLines(state, state.line - _line);\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n      }\n\n      if (!is_WHITE_SPACE(ch)) {\n        captureEnd = state.position + 1;\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, captureEnd, false);\n\n    if (state.result) {\n      return true;\n    }\n\n    state.kind = _kind;\n    state.result = _result;\n    return false;\n  }\n\n  function readSingleQuotedScalar(state, nodeIndent) {\n    var ch,\n        captureStart, captureEnd;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x27/* ' */) {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x27/* ' */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x27/* ' */) {\n          captureStart = state.position;\n          state.position++;\n          captureEnd = state.position;\n        } else {\n          return true;\n        }\n\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a single quoted scalar');\n  }\n\n  function readDoubleQuotedScalar(state, nodeIndent) {\n    var captureStart,\n        captureEnd,\n        hexLength,\n        hexResult,\n        tmp,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x22/* \" */) {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x22/* \" */) {\n        captureSegment(state, captureStart, state.position, true);\n        state.position++;\n        return true;\n\n      } else if (ch === 0x5C/* \\ */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (is_EOL(ch)) {\n          skipSeparationSpace(state, false, nodeIndent);\n\n          // TODO: rework to inline fn with no type cast?\n        } else if (ch < 256 && simpleEscapeCheck[ch]) {\n          state.result += simpleEscapeMap[ch];\n          state.position++;\n\n        } else if ((tmp = escapedHexLen(ch)) > 0) {\n          hexLength = tmp;\n          hexResult = 0;\n\n          for (; hexLength > 0; hexLength--) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if ((tmp = fromHexCode(ch)) >= 0) {\n              hexResult = (hexResult << 4) + tmp;\n\n            } else {\n              throwError(state, 'expected hexadecimal character');\n            }\n          }\n\n          state.result += charFromCodepoint(hexResult);\n\n          state.position++;\n\n        } else {\n          throwError(state, 'unknown escape sequence');\n        }\n\n        captureStart = captureEnd = state.position;\n\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a double quoted scalar');\n  }\n\n  function readFlowCollection(state, nodeIndent) {\n    var readNext = true,\n        _line,\n        _lineStart,\n        _pos,\n        _tag     = state.tag,\n        _result,\n        _anchor  = state.anchor,\n        following,\n        terminator,\n        isPair,\n        isExplicitPair,\n        isMapping,\n        overridableKeys = Object.create(null),\n        keyNode,\n        keyTag,\n        valueNode,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x5B/* [ */) {\n      terminator = 0x5D;/* ] */\n      isMapping = false;\n      _result = [];\n    } else if (ch === 0x7B/* { */) {\n      terminator = 0x7D;/* } */\n      isMapping = true;\n      _result = {};\n    } else {\n      return false;\n    }\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n\n    while (ch !== 0) {\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (ch === terminator) {\n        state.position++;\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = isMapping ? 'mapping' : 'sequence';\n        state.result = _result;\n        return true;\n      } else if (!readNext) {\n        throwError(state, 'missed comma between flow collection entries');\n      } else if (ch === 0x2C/* , */) {\n        // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n        throwError(state, \"expected the node content, but found ','\");\n      }\n\n      keyTag = keyNode = valueNode = null;\n      isPair = isExplicitPair = false;\n\n      if (ch === 0x3F/* ? */) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following)) {\n          isPair = isExplicitPair = true;\n          state.position++;\n          skipSeparationSpace(state, true, nodeIndent);\n        }\n      }\n\n      _line = state.line; // Save the current line.\n      _lineStart = state.lineStart;\n      _pos = state.position;\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      keyTag = state.tag;\n      keyNode = state.result;\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n        isPair = true;\n        ch = state.input.charCodeAt(++state.position);\n        skipSeparationSpace(state, true, nodeIndent);\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        valueNode = state.result;\n      }\n\n      if (isMapping) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n      } else if (isPair) {\n        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n      } else {\n        _result.push(keyNode);\n      }\n\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (ch === 0x2C/* , */) {\n        readNext = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        readNext = false;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a flow collection');\n  }\n\n  function readBlockScalar(state, nodeIndent) {\n    var captureStart,\n        folding,\n        chomping       = CHOMPING_CLIP,\n        didReadContent = false,\n        detectedIndent = false,\n        textIndent     = nodeIndent,\n        emptyLines     = 0,\n        atMoreIndented = false,\n        tmp,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x7C/* | */) {\n      folding = false;\n    } else if (ch === 0x3E/* > */) {\n      folding = true;\n    } else {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n\n    while (ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n        if (CHOMPING_CLIP === chomping) {\n          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n        } else {\n          throwError(state, 'repeat of a chomping mode identifier');\n        }\n\n      } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n        if (tmp === 0) {\n          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n        } else if (!detectedIndent) {\n          textIndent = nodeIndent + tmp - 1;\n          detectedIndent = true;\n        } else {\n          throwError(state, 'repeat of an indentation width identifier');\n        }\n\n      } else {\n        break;\n      }\n    }\n\n    if (is_WHITE_SPACE(ch)) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (is_WHITE_SPACE(ch));\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (!is_EOL(ch) && (ch !== 0));\n      }\n    }\n\n    while (ch !== 0) {\n      readLineBreak(state);\n      state.lineIndent = 0;\n\n      ch = state.input.charCodeAt(state.position);\n\n      while ((!detectedIndent || state.lineIndent < textIndent) &&\n             (ch === 0x20/* Space */)) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (!detectedIndent && state.lineIndent > textIndent) {\n        textIndent = state.lineIndent;\n      }\n\n      if (is_EOL(ch)) {\n        emptyLines++;\n        continue;\n      }\n\n      // End of the scalar.\n      if (state.lineIndent < textIndent) {\n\n        // Perform the chomping.\n        if (chomping === CHOMPING_KEEP) {\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n        } else if (chomping === CHOMPING_CLIP) {\n          if (didReadContent) { // i.e. only if the scalar is not empty.\n            state.result += '\\n';\n          }\n        }\n\n        // Break this `while` cycle and go to the funciton's epilogue.\n        break;\n      }\n\n      // Folded style: use fancy rules to handle line breaks.\n      if (folding) {\n\n        // Lines starting with white space characters (more-indented lines) are not folded.\n        if (is_WHITE_SPACE(ch)) {\n          atMoreIndented = true;\n          // except for the first content line (cf. Example 8.1)\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n        // End of more-indented block.\n        } else if (atMoreIndented) {\n          atMoreIndented = false;\n          state.result += common.repeat('\\n', emptyLines + 1);\n\n        // Just one line break - perceive as the same line.\n        } else if (emptyLines === 0) {\n          if (didReadContent) { // i.e. only if we have already read some scalar content.\n            state.result += ' ';\n          }\n\n        // Several line breaks - perceive as different lines.\n        } else {\n          state.result += common.repeat('\\n', emptyLines);\n        }\n\n      // Literal style: just add exact number of line breaks between content lines.\n      } else {\n        // Keep all line breaks except the header line break.\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      }\n\n      didReadContent = true;\n      detectedIndent = true;\n      emptyLines = 0;\n      captureStart = state.position;\n\n      while (!is_EOL(ch) && (ch !== 0)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      captureSegment(state, captureStart, state.position, false);\n    }\n\n    return true;\n  }\n\n  function readBlockSequence(state, nodeIndent) {\n    var _line,\n        _tag      = state.tag,\n        _anchor   = state.anchor,\n        _result   = [],\n        following,\n        detected  = false,\n        ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      if (state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n\n      if (ch !== 0x2D/* - */) {\n        break;\n      }\n\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (!is_WS_OR_EOL(following)) {\n        break;\n      }\n\n      detected = true;\n      state.position++;\n\n      if (skipSeparationSpace(state, true, -1)) {\n        if (state.lineIndent <= nodeIndent) {\n          _result.push(null);\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        }\n      }\n\n      _line = state.line;\n      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n      _result.push(state.result);\n      skipSeparationSpace(state, true, -1);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n        throwError(state, 'bad indentation of a sequence entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'sequence';\n      state.result = _result;\n      return true;\n    }\n    return false;\n  }\n\n  function readBlockMapping(state, nodeIndent, flowIndent) {\n    var following,\n        allowCompact,\n        _line,\n        _keyLine,\n        _keyLineStart,\n        _keyPos,\n        _tag          = state.tag,\n        _anchor       = state.anchor,\n        _result       = {},\n        overridableKeys = Object.create(null),\n        keyTag        = null,\n        keyNode       = null,\n        valueNode     = null,\n        atExplicitKey = false,\n        detected      = false,\n        ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      if (!atExplicitKey && state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n\n      following = state.input.charCodeAt(state.position + 1);\n      _line = state.line; // Save the current line.\n\n      //\n      // Explicit notation case. There are two separate blocks:\n      // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n      //\n      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n        if (ch === 0x3F/* ? */) {\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = true;\n          allowCompact = true;\n\n        } else if (atExplicitKey) {\n          // i.e. 0x3A/* : */ === character after the explicit key.\n          atExplicitKey = false;\n          allowCompact = true;\n\n        } else {\n          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n        }\n\n        state.position += 1;\n        ch = following;\n\n      //\n      // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n      //\n      } else {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n\n        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n          // Neither implicit nor explicit notation.\n          // Reading is done. Go to the epilogue.\n          break;\n        }\n\n        if (state.line === _line) {\n          ch = state.input.charCodeAt(state.position);\n\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (ch === 0x3A/* : */) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if (!is_WS_OR_EOL(ch)) {\n              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n            }\n\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            detected = true;\n            atExplicitKey = false;\n            allowCompact = false;\n            keyTag = state.tag;\n            keyNode = state.result;\n\n          } else if (detected) {\n            throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n          } else {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            return true; // Keep the result of `composeNode`.\n          }\n\n        } else if (detected) {\n          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      }\n\n      //\n      // Common reading code for both explicit and implicit notations.\n      //\n      if (state.line === _line || state.lineIndent > nodeIndent) {\n        if (atExplicitKey) {\n          _keyLine = state.line;\n          _keyLineStart = state.lineStart;\n          _keyPos = state.position;\n        }\n\n        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n          if (atExplicitKey) {\n            keyNode = state.result;\n          } else {\n            valueNode = state.result;\n          }\n        }\n\n        if (!atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n      }\n\n      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n        throwError(state, 'bad indentation of a mapping entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n\n    //\n    // Epilogue.\n    //\n\n    // Special case: last mapping's node contains only the key in explicit notation.\n    if (atExplicitKey) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n    }\n\n    // Expose the resulting mapping.\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'mapping';\n      state.result = _result;\n    }\n\n    return detected;\n  }\n\n  function readTagProperty(state) {\n    var _position,\n        isVerbatim = false,\n        isNamed    = false,\n        tagHandle,\n        tagName,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x21/* ! */) return false;\n\n    if (state.tag !== null) {\n      throwError(state, 'duplication of a tag property');\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x3C/* < */) {\n      isVerbatim = true;\n      ch = state.input.charCodeAt(++state.position);\n\n    } else if (ch === 0x21/* ! */) {\n      isNamed = true;\n      tagHandle = '!!';\n      ch = state.input.charCodeAt(++state.position);\n\n    } else {\n      tagHandle = '!';\n    }\n\n    _position = state.position;\n\n    if (isVerbatim) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (ch !== 0 && ch !== 0x3E/* > */);\n\n      if (state.position < state.length) {\n        tagName = state.input.slice(_position, state.position);\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        throwError(state, 'unexpected end of the stream within a verbatim tag');\n      }\n    } else {\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n        if (ch === 0x21/* ! */) {\n          if (!isNamed) {\n            tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n              throwError(state, 'named tag handle cannot contain such characters');\n            }\n\n            isNamed = true;\n            _position = state.position + 1;\n          } else {\n            throwError(state, 'tag suffix cannot contain exclamation marks');\n          }\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      tagName = state.input.slice(_position, state.position);\n\n      if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n        throwError(state, 'tag suffix cannot contain flow indicator characters');\n      }\n    }\n\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n      throwError(state, 'tag name cannot contain such characters: ' + tagName);\n    }\n\n    try {\n      tagName = decodeURIComponent(tagName);\n    } catch (err) {\n      throwError(state, 'tag name is malformed: ' + tagName);\n    }\n\n    if (isVerbatim) {\n      state.tag = tagName;\n\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n      state.tag = state.tagMap[tagHandle] + tagName;\n\n    } else if (tagHandle === '!') {\n      state.tag = '!' + tagName;\n\n    } else if (tagHandle === '!!') {\n      state.tag = 'tag:yaml.org,2002:' + tagName;\n\n    } else {\n      throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n    }\n\n    return true;\n  }\n\n  function readAnchorProperty(state) {\n    var _position,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x26/* & */) return false;\n\n    if (state.anchor !== null) {\n      throwError(state, 'duplication of an anchor property');\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (state.position === _position) {\n      throwError(state, 'name of an anchor node must contain at least one character');\n    }\n\n    state.anchor = state.input.slice(_position, state.position);\n    return true;\n  }\n\n  function readAlias(state) {\n    var _position, alias,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x2A/* * */) return false;\n\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (state.position === _position) {\n      throwError(state, 'name of an alias node must contain at least one character');\n    }\n\n    alias = state.input.slice(_position, state.position);\n\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n      throwError(state, 'unidentified alias \"' + alias + '\"');\n    }\n\n    state.result = state.anchorMap[alias];\n    skipSeparationSpace(state, true, -1);\n    return true;\n  }\n\n  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n    var allowBlockStyles,\n        allowBlockScalars,\n        allowBlockCollections,\n        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n        atNewLine  = false,\n        hasContent = false,\n        typeIndex,\n        typeQuantity,\n        typeList,\n        type,\n        flowIndent,\n        blockIndent;\n\n    if (state.listener !== null) {\n      state.listener('open', state);\n    }\n\n    state.tag    = null;\n    state.anchor = null;\n    state.kind   = null;\n    state.result = null;\n\n    allowBlockStyles = allowBlockScalars = allowBlockCollections =\n      CONTEXT_BLOCK_OUT === nodeContext ||\n      CONTEXT_BLOCK_IN  === nodeContext;\n\n    if (allowToSeek) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      }\n    }\n\n    if (indentStatus === 1) {\n      while (readTagProperty(state) || readAnchorProperty(state)) {\n        if (skipSeparationSpace(state, true, -1)) {\n          atNewLine = true;\n          allowBlockCollections = allowBlockStyles;\n\n          if (state.lineIndent > parentIndent) {\n            indentStatus = 1;\n          } else if (state.lineIndent === parentIndent) {\n            indentStatus = 0;\n          } else if (state.lineIndent < parentIndent) {\n            indentStatus = -1;\n          }\n        } else {\n          allowBlockCollections = false;\n        }\n      }\n    }\n\n    if (allowBlockCollections) {\n      allowBlockCollections = atNewLine || allowCompact;\n    }\n\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n        flowIndent = parentIndent;\n      } else {\n        flowIndent = parentIndent + 1;\n      }\n\n      blockIndent = state.position - state.lineStart;\n\n      if (indentStatus === 1) {\n        if (allowBlockCollections &&\n            (readBlockSequence(state, blockIndent) ||\n             readBlockMapping(state, blockIndent, flowIndent)) ||\n            readFlowCollection(state, flowIndent)) {\n          hasContent = true;\n        } else {\n          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n              readSingleQuotedScalar(state, flowIndent) ||\n              readDoubleQuotedScalar(state, flowIndent)) {\n            hasContent = true;\n\n          } else if (readAlias(state)) {\n            hasContent = true;\n\n            if (state.tag !== null || state.anchor !== null) {\n              throwError(state, 'alias node should not have any properties');\n            }\n\n          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n            hasContent = true;\n\n            if (state.tag === null) {\n              state.tag = '?';\n            }\n          }\n\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n        }\n      } else if (indentStatus === 0) {\n        // Special case: block sequences are allowed to have same indentation level as the parent.\n        // http://www.yaml.org/spec/1.2/spec.html#id2799784\n        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n      }\n    }\n\n    if (state.tag === null) {\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n\n    } else if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (state.tag !== '!') {\n      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n        type = state.typeMap[state.kind || 'fallback'][state.tag];\n      } else {\n        // looking for multi type\n        type = null;\n        typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n            type = typeList[typeIndex];\n            break;\n          }\n        }\n      }\n\n      if (!type) {\n        throwError(state, 'unknown tag !<' + state.tag + '>');\n      }\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result, state.tag);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    }\n\n    if (state.listener !== null) {\n      state.listener('close', state);\n    }\n    return state.tag !== null ||  state.anchor !== null || hasContent;\n  }\n\n  function readDocument(state) {\n    var documentStart = state.position,\n        _position,\n        directiveName,\n        directiveArgs,\n        hasDirectives = false,\n        ch;\n\n    state.version = null;\n    state.checkLineBreaks = state.legacy;\n    state.tagMap = Object.create(null);\n    state.anchorMap = Object.create(null);\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      skipSeparationSpace(state, true, -1);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n        break;\n      }\n\n      hasDirectives = true;\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveName = state.input.slice(_position, state.position);\n      directiveArgs = [];\n\n      if (directiveName.length < 1) {\n        throwError(state, 'directive name must not be less than one character in length');\n      }\n\n      while (ch !== 0) {\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x23/* # */) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (ch !== 0 && !is_EOL(ch));\n          break;\n        }\n\n        if (is_EOL(ch)) break;\n\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        directiveArgs.push(state.input.slice(_position, state.position));\n      }\n\n      if (ch !== 0) readLineBreak(state);\n\n      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n        directiveHandlers[directiveName](state, directiveName, directiveArgs);\n      } else {\n        throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n      }\n    }\n\n    skipSeparationSpace(state, true, -1);\n\n    if (state.lineIndent === 0 &&\n        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n\n    } else if (hasDirectives) {\n      throwError(state, 'directives end mark is expected');\n    }\n\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n    skipSeparationSpace(state, true, -1);\n\n    if (state.checkLineBreaks &&\n        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n      throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n    }\n\n    state.documents.push(state.result);\n\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      }\n      return;\n    }\n\n    if (state.position < (state.length - 1)) {\n      throwError(state, 'end of the stream or a document separator is expected');\n    } else {\n      return;\n    }\n  }\n\n\n  function loadDocuments(input, options) {\n    input = String(input);\n    options = options || {};\n\n    if (input.length !== 0) {\n\n      // Add tailing `\\n` if not exists\n      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n        input += '\\n';\n      }\n\n      // Strip BOM\n      if (input.charCodeAt(0) === 0xFEFF) {\n        input = input.slice(1);\n      }\n    }\n\n    var state = new State$1(input, options);\n\n    var nullpos = input.indexOf('\\0');\n\n    if (nullpos !== -1) {\n      state.position = nullpos;\n      throwError(state, 'null byte is not allowed in input');\n    }\n\n    // Use 0 as string terminator. That significantly simplifies bounds check.\n    state.input += '\\0';\n\n    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n      state.lineIndent += 1;\n      state.position += 1;\n    }\n\n    while (state.position < (state.length - 1)) {\n      readDocument(state);\n    }\n\n    return state.documents;\n  }\n\n\n  function loadAll$1(input, iterator, options) {\n    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n      options = iterator;\n      iterator = null;\n    }\n\n    var documents = loadDocuments(input, options);\n\n    if (typeof iterator !== 'function') {\n      return documents;\n    }\n\n    for (var index = 0, length = documents.length; index < length; index += 1) {\n      iterator(documents[index]);\n    }\n  }\n\n\n  function load$1(input, options) {\n    var documents = loadDocuments(input, options);\n\n    if (documents.length === 0) {\n      /*eslint-disable no-undefined*/\n      return undefined;\n    } else if (documents.length === 1) {\n      return documents[0];\n    }\n    throw new exception('expected a single document in the stream, but found more');\n  }\n\n\n  var loadAll_1 = loadAll$1;\n  var load_1    = load$1;\n\n  var loader = {\n  \tloadAll: loadAll_1,\n  \tload: load_1\n  };\n\n  /*eslint-disable no-use-before-define*/\n\n\n\n\n\n  var _toString       = Object.prototype.toString;\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  var CHAR_BOM                  = 0xFEFF;\n  var CHAR_TAB                  = 0x09; /* Tab */\n  var CHAR_LINE_FEED            = 0x0A; /* LF */\n  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\n  var CHAR_SPACE                = 0x20; /* Space */\n  var CHAR_EXCLAMATION          = 0x21; /* ! */\n  var CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\n  var CHAR_SHARP                = 0x23; /* # */\n  var CHAR_PERCENT              = 0x25; /* % */\n  var CHAR_AMPERSAND            = 0x26; /* & */\n  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */\n  var CHAR_ASTERISK             = 0x2A; /* * */\n  var CHAR_COMMA                = 0x2C; /* , */\n  var CHAR_MINUS                = 0x2D; /* - */\n  var CHAR_COLON                = 0x3A; /* : */\n  var CHAR_EQUALS               = 0x3D; /* = */\n  var CHAR_GREATER_THAN         = 0x3E; /* > */\n  var CHAR_QUESTION             = 0x3F; /* ? */\n  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */\n  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\n  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\n  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */\n  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\n  var CHAR_VERTICAL_LINE        = 0x7C; /* | */\n  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\n  var ESCAPE_SEQUENCES = {};\n\n  ESCAPE_SEQUENCES[0x00]   = '\\\\0';\n  ESCAPE_SEQUENCES[0x07]   = '\\\\a';\n  ESCAPE_SEQUENCES[0x08]   = '\\\\b';\n  ESCAPE_SEQUENCES[0x09]   = '\\\\t';\n  ESCAPE_SEQUENCES[0x0A]   = '\\\\n';\n  ESCAPE_SEQUENCES[0x0B]   = '\\\\v';\n  ESCAPE_SEQUENCES[0x0C]   = '\\\\f';\n  ESCAPE_SEQUENCES[0x0D]   = '\\\\r';\n  ESCAPE_SEQUENCES[0x1B]   = '\\\\e';\n  ESCAPE_SEQUENCES[0x22]   = '\\\\\"';\n  ESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\n  ESCAPE_SEQUENCES[0x85]   = '\\\\N';\n  ESCAPE_SEQUENCES[0xA0]   = '\\\\_';\n  ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n  ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\n  var DEPRECATED_BOOLEANS_SYNTAX = [\n    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n  ];\n\n  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\n  function compileStyleMap(schema, map) {\n    var result, keys, index, length, tag, style, type;\n\n    if (map === null) return {};\n\n    result = {};\n    keys = Object.keys(map);\n\n    for (index = 0, length = keys.length; index < length; index += 1) {\n      tag = keys[index];\n      style = String(map[tag]);\n\n      if (tag.slice(0, 2) === '!!') {\n        tag = 'tag:yaml.org,2002:' + tag.slice(2);\n      }\n      type = schema.compiledTypeMap['fallback'][tag];\n\n      if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n        style = type.styleAliases[style];\n      }\n\n      result[tag] = style;\n    }\n\n    return result;\n  }\n\n  function encodeHex(character) {\n    var string, handle, length;\n\n    string = character.toString(16).toUpperCase();\n\n    if (character <= 0xFF) {\n      handle = 'x';\n      length = 2;\n    } else if (character <= 0xFFFF) {\n      handle = 'u';\n      length = 4;\n    } else if (character <= 0xFFFFFFFF) {\n      handle = 'U';\n      length = 8;\n    } else {\n      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n    }\n\n    return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n  }\n\n\n  var QUOTING_TYPE_SINGLE = 1,\n      QUOTING_TYPE_DOUBLE = 2;\n\n  function State(options) {\n    this.schema        = options['schema'] || _default;\n    this.indent        = Math.max(1, (options['indent'] || 2));\n    this.noArrayIndent = options['noArrayIndent'] || false;\n    this.skipInvalid   = options['skipInvalid'] || false;\n    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n    this.sortKeys      = options['sortKeys'] || false;\n    this.lineWidth     = options['lineWidth'] || 80;\n    this.noRefs        = options['noRefs'] || false;\n    this.noCompatMode  = options['noCompatMode'] || false;\n    this.condenseFlow  = options['condenseFlow'] || false;\n    this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n    this.forceQuotes   = options['forceQuotes'] || false;\n    this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.explicitTypes = this.schema.compiledExplicit;\n\n    this.tag = null;\n    this.result = '';\n\n    this.duplicates = [];\n    this.usedDuplicates = null;\n  }\n\n  // Indents every line in a string. Empty lines (\\n only) are not indented.\n  function indentString(string, spaces) {\n    var ind = common.repeat(' ', spaces),\n        position = 0,\n        next = -1,\n        result = '',\n        line,\n        length = string.length;\n\n    while (position < length) {\n      next = string.indexOf('\\n', position);\n      if (next === -1) {\n        line = string.slice(position);\n        position = length;\n      } else {\n        line = string.slice(position, next + 1);\n        position = next + 1;\n      }\n\n      if (line.length && line !== '\\n') result += ind;\n\n      result += line;\n    }\n\n    return result;\n  }\n\n  function generateNextLine(state, level) {\n    return '\\n' + common.repeat(' ', state.indent * level);\n  }\n\n  function testImplicitResolving(state, str) {\n    var index, length, type;\n\n    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n      type = state.implicitTypes[index];\n\n      if (type.resolve(str)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // [33] s-white ::= s-space | s-tab\n  function isWhitespace(c) {\n    return c === CHAR_SPACE || c === CHAR_TAB;\n  }\n\n  // Returns true if the character can be printed without escaping.\n  // From YAML 1.2: \"any allowed characters known to be non-printable\n  // should also be escaped. [However,] This isnâ€™t mandatory\"\n  // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n  function isPrintable(c) {\n    return  (0x00020 <= c && c <= 0x00007E)\n        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n        ||  (0x10000 <= c && c <= 0x10FFFF);\n  }\n\n  // [34] ns-char ::= nb-char - s-white\n  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n  // [26] b-char  ::= b-line-feed | b-carriage-return\n  // Including s-white (for some reason, examples doesn't match specs in this aspect)\n  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\n  function isNsCharOrWhitespace(c) {\n    return isPrintable(c)\n      && c !== CHAR_BOM\n      // - b-char\n      && c !== CHAR_CARRIAGE_RETURN\n      && c !== CHAR_LINE_FEED;\n  }\n\n  // [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n  //                             c = flow-in   â‡’ ns-plain-safe-in\n  //                             c = block-key â‡’ ns-plain-safe-out\n  //                             c = flow-key  â‡’ ns-plain-safe-in\n  // [128] ns-plain-safe-out ::= ns-char\n  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n  //                            | ( /* An ns-char preceding */ â€œ#â€ )\n  //                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\n  function isPlainSafe(c, prev, inblock) {\n    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n    return (\n      // ns-plain-safe\n      inblock ? // c = flow-in\n        cIsNsCharOrWhitespace\n        : cIsNsCharOrWhitespace\n          // - c-flow-indicator\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n    )\n      // ns-plain-char\n      && c !== CHAR_SHARP // false on '#'\n      && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n      || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n      || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n  }\n\n  // Simplified test for values allowed as the first character in plain style.\n  function isPlainSafeFirst(c) {\n    // Uses a subset of ns-char - c-indicator\n    // where ns-char = nb-char - s-white.\n    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n    return isPrintable(c) && c !== CHAR_BOM\n      && !isWhitespace(c) // - s-white\n      // - (c-indicator ::=\n      // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€\n      && c !== CHAR_MINUS\n      && c !== CHAR_QUESTION\n      && c !== CHAR_COLON\n      && c !== CHAR_COMMA\n      && c !== CHAR_LEFT_SQUARE_BRACKET\n      && c !== CHAR_RIGHT_SQUARE_BRACKET\n      && c !== CHAR_LEFT_CURLY_BRACKET\n      && c !== CHAR_RIGHT_CURLY_BRACKET\n      // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ\"â€\n      && c !== CHAR_SHARP\n      && c !== CHAR_AMPERSAND\n      && c !== CHAR_ASTERISK\n      && c !== CHAR_EXCLAMATION\n      && c !== CHAR_VERTICAL_LINE\n      && c !== CHAR_EQUALS\n      && c !== CHAR_GREATER_THAN\n      && c !== CHAR_SINGLE_QUOTE\n      && c !== CHAR_DOUBLE_QUOTE\n      // | â€œ%â€ | â€œ@â€ | â€œ`â€)\n      && c !== CHAR_PERCENT\n      && c !== CHAR_COMMERCIAL_AT\n      && c !== CHAR_GRAVE_ACCENT;\n  }\n\n  // Simplified test for values allowed as the last character in plain style.\n  function isPlainSafeLast(c) {\n    // just not whitespace or colon, it will be checked to be plain character later\n    return !isWhitespace(c) && c !== CHAR_COLON;\n  }\n\n  // Same as 'string'.codePointAt(pos), but works in older browsers.\n  function codePointAt(string, pos) {\n    var first = string.charCodeAt(pos), second;\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n      second = string.charCodeAt(pos + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n\n  // Determines whether block indentation indicator is required.\n  function needIndentIndicator(string) {\n    var leadingSpaceRe = /^\\n* /;\n    return leadingSpaceRe.test(string);\n  }\n\n  var STYLE_PLAIN   = 1,\n      STYLE_SINGLE  = 2,\n      STYLE_LITERAL = 3,\n      STYLE_FOLDED  = 4,\n      STYLE_DOUBLE  = 5;\n\n  // Determines which scalar styles are possible and returns the preferred style.\n  // lineWidth = -1 => no limit.\n  // Pre-conditions: str.length > 0.\n  // Post-conditions:\n  //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n    testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n    var i;\n    var char = 0;\n    var prevChar = null;\n    var hasLineBreak = false;\n    var hasFoldableLine = false; // only checked if shouldTrackWidth\n    var shouldTrackWidth = lineWidth !== -1;\n    var previousLineBreak = -1; // count the first line correctly\n    var plain = isPlainSafeFirst(codePointAt(string, 0))\n            && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n    if (singleLineOnly || forceQuotes) {\n      // Case: no block styles.\n      // Check for disallowed characters to rule out plain and single.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n    } else {\n      // Case: block styles permitted.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (char === CHAR_LINE_FEED) {\n          hasLineBreak = true;\n          // Check if any line can be folded.\n          if (shouldTrackWidth) {\n            hasFoldableLine = hasFoldableLine ||\n              // Foldable line = too long, and not more-indented.\n              (i - previousLineBreak - 1 > lineWidth &&\n               string[previousLineBreak + 1] !== ' ');\n            previousLineBreak = i;\n          }\n        } else if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n      // in case the end is missing a \\n\n      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n        (i - previousLineBreak - 1 > lineWidth &&\n         string[previousLineBreak + 1] !== ' '));\n    }\n    // Although every style can represent \\n without escaping, prefer block styles\n    // for multiline, since they're more readable and they don't add empty lines.\n    // Also prefer folding a super-long line.\n    if (!hasLineBreak && !hasFoldableLine) {\n      // Strings interpretable as another type have to be quoted;\n      // e.g. the string 'true' vs. the boolean true.\n      if (plain && !forceQuotes && !testAmbiguousType(string)) {\n        return STYLE_PLAIN;\n      }\n      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    // Edge case: block indentation indicator can only have one digit.\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\n      return STYLE_DOUBLE;\n    }\n    // At this point we know block styles are valid.\n    // Prefer literal style unless we want to fold.\n    if (!forceQuotes) {\n      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n\n  // Note: line breaking/folding is implemented for only the folded style.\n  // NB. We drop the last trailing newline (if any) of a returned block scalar\n  //  since the dumper adds its own newline. This always works:\n  //    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n  //    â€¢ Ending newline    => removed then restored.\n  //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n  function writeScalar(state, string, level, iskey, inblock) {\n    state.dump = (function () {\n      if (string.length === 0) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n      }\n      if (!state.noCompatMode) {\n        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n          return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n        }\n      }\n\n      var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n      // As indentation gets deeper, let the width decrease monotonically\n      // to the lower bound min(state.lineWidth, 40).\n      // Note that this implies\n      //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n      // This behaves better than a constant minimum width which disallows narrower options,\n      // or an indent threshold which causes the width to suddenly increase.\n      var lineWidth = state.lineWidth === -1\n        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n      // Without knowing if keys are implicit/explicit, assume implicit for safety.\n      var singleLineOnly = iskey\n        // No block styles in flow mode.\n        || (state.flowLevel > -1 && level >= state.flowLevel);\n      function testAmbiguity(string) {\n        return testImplicitResolving(state, string);\n      }\n\n      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n        testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n        case STYLE_PLAIN:\n          return string;\n        case STYLE_SINGLE:\n          return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n        case STYLE_LITERAL:\n          return '|' + blockHeader(string, state.indent)\n            + dropEndingNewline(indentString(string, indent));\n        case STYLE_FOLDED:\n          return '>' + blockHeader(string, state.indent)\n            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n        case STYLE_DOUBLE:\n          return '\"' + escapeString(string) + '\"';\n        default:\n          throw new exception('impossible error: invalid scalar style');\n      }\n    }());\n  }\n\n  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n  function blockHeader(string, indentPerLevel) {\n    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n    // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n    var clip =          string[string.length - 1] === '\\n';\n    var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n    var chomp = keep ? '+' : (clip ? '' : '-');\n\n    return indentIndicator + chomp + '\\n';\n  }\n\n  // (See the note for writeScalar.)\n  function dropEndingNewline(string) {\n    return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n  }\n\n  // Note: a long line without a suitable break point will exceed the width limit.\n  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n  function foldString(string, width) {\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n    // unless they're before or after a more-indented line, or at the very\n    // beginning or end, in which case $k$ maps to $k$.\n    // Therefore, parse each chunk as newline(s) followed by a content line.\n    var lineRe = /(\\n+)([^\\n]*)/g;\n\n    // first line (possibly an empty line)\n    var result = (function () {\n      var nextLF = string.indexOf('\\n');\n      nextLF = nextLF !== -1 ? nextLF : string.length;\n      lineRe.lastIndex = nextLF;\n      return foldLine(string.slice(0, nextLF), width);\n    }());\n    // If we haven't reached the first content line yet, don't add an extra \\n.\n    var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n    var moreIndented;\n\n    // rest of the lines\n    var match;\n    while ((match = lineRe.exec(string))) {\n      var prefix = match[1], line = match[2];\n      moreIndented = (line[0] === ' ');\n      result += prefix\n        + (!prevMoreIndented && !moreIndented && line !== ''\n          ? '\\n' : '')\n        + foldLine(line, width);\n      prevMoreIndented = moreIndented;\n    }\n\n    return result;\n  }\n\n  // Greedy line breaking.\n  // Picks the longest line under the limit each time,\n  // otherwise settles for the shortest line over the limit.\n  // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n  function foldLine(line, width) {\n    if (line === '' || line[0] === ' ') return line;\n\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n    var match;\n    // start is an inclusive index. end, curr, and next are exclusive.\n    var start = 0, end, curr = 0, next = 0;\n    var result = '';\n\n    // Invariants: 0 <= start <= length-1.\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n    // Inside the loop:\n    //   A match implies length >= 2, so curr and next are <= length-2.\n    while ((match = breakRe.exec(line))) {\n      next = match.index;\n      // maintain invariant: curr - start <= width\n      if (next - start > width) {\n        end = (curr > start) ? curr : next; // derive end <= length-2\n        result += '\\n' + line.slice(start, end);\n        // skip the space that was output as \\n\n        start = end + 1;                    // derive start <= length-1\n      }\n      curr = next;\n    }\n\n    // By the invariants, start <= length-1, so there is something left over.\n    // It is either the whole string or a part starting from non-whitespace.\n    result += '\\n';\n    // Insert a break if the remainder is too long and there is a break available.\n    if (line.length - start > width && curr > start) {\n      result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n    } else {\n      result += line.slice(start);\n    }\n\n    return result.slice(1); // drop extra \\n joiner\n  }\n\n  // Escapes a double-quoted string.\n  function escapeString(string) {\n    var result = '';\n    var char = 0;\n    var escapeSeq;\n\n    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      escapeSeq = ESCAPE_SEQUENCES[char];\n\n      if (!escapeSeq && isPrintable(char)) {\n        result += string[i];\n        if (char >= 0x10000) result += string[i + 1];\n      } else {\n        result += escapeSeq || encodeHex(char);\n      }\n    }\n\n    return result;\n  }\n\n  function writeFlowSequence(state, level, object) {\n    var _result = '',\n        _tag    = state.tag,\n        index,\n        length,\n        value;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level, value, false, false) ||\n          (typeof value === 'undefined' &&\n           writeNode(state, level, null, false, false))) {\n\n        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n        _result += state.dump;\n      }\n    }\n\n    state.tag = _tag;\n    state.dump = '[' + _result + ']';\n  }\n\n  function writeBlockSequence(state, level, object, compact) {\n    var _result = '',\n        _tag    = state.tag,\n        index,\n        length,\n        value;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level + 1, value, true, true, false, true) ||\n          (typeof value === 'undefined' &&\n           writeNode(state, level + 1, null, true, true, false, true))) {\n\n        if (!compact || _result !== '') {\n          _result += generateNextLine(state, level);\n        }\n\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          _result += '-';\n        } else {\n          _result += '- ';\n        }\n\n        _result += state.dump;\n      }\n    }\n\n    state.tag = _tag;\n    state.dump = _result || '[]'; // Empty sequence if no valid values.\n  }\n\n  function writeFlowMapping(state, level, object) {\n    var _result       = '',\n        _tag          = state.tag,\n        objectKeyList = Object.keys(object),\n        index,\n        length,\n        objectKey,\n        objectValue,\n        pairBuffer;\n\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n      pairBuffer = '';\n      if (_result !== '') pairBuffer += ', ';\n\n      if (state.condenseFlow) pairBuffer += '\"';\n\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n\n      if (!writeNode(state, level, objectKey, false, false)) {\n        continue; // Skip this pair because of invalid key;\n      }\n\n      if (state.dump.length > 1024) pairBuffer += '? ';\n\n      pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n      if (!writeNode(state, level, objectValue, false, false)) {\n        continue; // Skip this pair because of invalid value.\n      }\n\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n\n    state.tag = _tag;\n    state.dump = '{' + _result + '}';\n  }\n\n  function writeBlockMapping(state, level, object, compact) {\n    var _result       = '',\n        _tag          = state.tag,\n        objectKeyList = Object.keys(object),\n        index,\n        length,\n        objectKey,\n        objectValue,\n        explicitPair,\n        pairBuffer;\n\n    // Allow sorting keys so that the output file is deterministic\n    if (state.sortKeys === true) {\n      // Default sorting\n      objectKeyList.sort();\n    } else if (typeof state.sortKeys === 'function') {\n      // Custom sort function\n      objectKeyList.sort(state.sortKeys);\n    } else if (state.sortKeys) {\n      // Something is wrong\n      throw new exception('sortKeys must be a boolean or a function');\n    }\n\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n      pairBuffer = '';\n\n      if (!compact || _result !== '') {\n        pairBuffer += generateNextLine(state, level);\n      }\n\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n\n      if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n        continue; // Skip this pair because of invalid key.\n      }\n\n      explicitPair = (state.tag !== null && state.tag !== '?') ||\n                     (state.dump && state.dump.length > 1024);\n\n      if (explicitPair) {\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          pairBuffer += '?';\n        } else {\n          pairBuffer += '? ';\n        }\n      }\n\n      pairBuffer += state.dump;\n\n      if (explicitPair) {\n        pairBuffer += generateNextLine(state, level);\n      }\n\n      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n        continue; // Skip this pair because of invalid value.\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += ':';\n      } else {\n        pairBuffer += ': ';\n      }\n\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n\n    state.tag = _tag;\n    state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n  }\n\n  function detectType(state, object, explicit) {\n    var _result, typeList, index, length, type, style;\n\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n    for (index = 0, length = typeList.length; index < length; index += 1) {\n      type = typeList[index];\n\n      if ((type.instanceOf  || type.predicate) &&\n          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n          (!type.predicate  || type.predicate(object))) {\n\n        if (explicit) {\n          if (type.multi && type.representName) {\n            state.tag = type.representName(object);\n          } else {\n            state.tag = type.tag;\n          }\n        } else {\n          state.tag = '?';\n        }\n\n        if (type.represent) {\n          style = state.styleMap[type.tag] || type.defaultStyle;\n\n          if (_toString.call(type.represent) === '[object Function]') {\n            _result = type.represent(object, style);\n          } else if (_hasOwnProperty.call(type.represent, style)) {\n            _result = type.represent[style](object, style);\n          } else {\n            throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n          }\n\n          state.dump = _result;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Serializes `object` and writes it to global `result`.\n  // Returns true on success, or false on invalid object.\n  //\n  function writeNode(state, level, object, block, compact, iskey, isblockseq) {\n    state.tag = null;\n    state.dump = object;\n\n    if (!detectType(state, object, false)) {\n      detectType(state, object, true);\n    }\n\n    var type = _toString.call(state.dump);\n    var inblock = block;\n    var tagStr;\n\n    if (block) {\n      block = (state.flowLevel < 0 || state.flowLevel > level);\n    }\n\n    var objectOrArray = type === '[object Object]' || type === '[object Array]',\n        duplicateIndex,\n        duplicate;\n\n    if (objectOrArray) {\n      duplicateIndex = state.duplicates.indexOf(object);\n      duplicate = duplicateIndex !== -1;\n    }\n\n    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n      compact = false;\n    }\n\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\n      state.dump = '*ref_' + duplicateIndex;\n    } else {\n      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n        state.usedDuplicates[duplicateIndex] = true;\n      }\n      if (type === '[object Object]') {\n        if (block && (Object.keys(state.dump).length !== 0)) {\n          writeBlockMapping(state, level, state.dump, compact);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowMapping(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object Array]') {\n        if (block && (state.dump.length !== 0)) {\n          if (state.noArrayIndent && !isblockseq && level > 0) {\n            writeBlockSequence(state, level - 1, state.dump, compact);\n          } else {\n            writeBlockSequence(state, level, state.dump, compact);\n          }\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowSequence(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object String]') {\n        if (state.tag !== '?') {\n          writeScalar(state, state.dump, level, iskey, inblock);\n        }\n      } else if (type === '[object Undefined]') {\n        return false;\n      } else {\n        if (state.skipInvalid) return false;\n        throw new exception('unacceptable kind of an object to dump ' + type);\n      }\n\n      if (state.tag !== null && state.tag !== '?') {\n        // Need to encode all characters except those allowed by the spec:\n        //\n        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n        // [36] ns-hex-digit    ::=  ns-dec-digit\n        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n        // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n        //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n        //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n        //\n        // Also need to encode '!' because it has special meaning (end of tag prefix).\n        //\n        tagStr = encodeURI(\n          state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n        ).replace(/!/g, '%21');\n\n        if (state.tag[0] === '!') {\n          tagStr = '!' + tagStr;\n        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n          tagStr = '!!' + tagStr.slice(18);\n        } else {\n          tagStr = '!<' + tagStr + '>';\n        }\n\n        state.dump = tagStr + ' ' + state.dump;\n      }\n    }\n\n    return true;\n  }\n\n  function getDuplicateReferences(object, state) {\n    var objects = [],\n        duplicatesIndexes = [],\n        index,\n        length;\n\n    inspectNode(object, objects, duplicatesIndexes);\n\n    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n      state.duplicates.push(objects[duplicatesIndexes[index]]);\n    }\n    state.usedDuplicates = new Array(length);\n  }\n\n  function inspectNode(object, objects, duplicatesIndexes) {\n    var objectKeyList,\n        index,\n        length;\n\n    if (object !== null && typeof object === 'object') {\n      index = objects.indexOf(object);\n      if (index !== -1) {\n        if (duplicatesIndexes.indexOf(index) === -1) {\n          duplicatesIndexes.push(index);\n        }\n      } else {\n        objects.push(object);\n\n        if (Array.isArray(object)) {\n          for (index = 0, length = object.length; index < length; index += 1) {\n            inspectNode(object[index], objects, duplicatesIndexes);\n          }\n        } else {\n          objectKeyList = Object.keys(object);\n\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n          }\n        }\n      }\n    }\n  }\n\n  function dump$1(input, options) {\n    options = options || {};\n\n    var state = new State(options);\n\n    if (!state.noRefs) getDuplicateReferences(input, state);\n\n    var value = input;\n\n    if (state.replacer) {\n      value = state.replacer.call({ '': value }, '', value);\n    }\n\n    if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n    return '';\n  }\n\n  var dump_1 = dump$1;\n\n  var dumper = {\n  \tdump: dump_1\n  };\n\n  function renamed(from, to) {\n    return function () {\n      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n        'Use yaml.' + to + ' instead, which is now safe by default.');\n    };\n  }\n\n\n  var Type                = type;\n  var Schema              = schema;\n  var FAILSAFE_SCHEMA     = failsafe;\n  var JSON_SCHEMA         = json;\n  var CORE_SCHEMA         = core;\n  var DEFAULT_SCHEMA      = _default;\n  var load                = loader.load;\n  var loadAll             = loader.loadAll;\n  var dump                = dumper.dump;\n  var YAMLException       = exception;\n\n  // Re-export all types in case user wants to create custom schema\n  var types = {\n    binary:    binary,\n    float:     float,\n    map:       map,\n    null:      _null,\n    pairs:     pairs,\n    set:       set,\n    timestamp: timestamp,\n    bool:      bool,\n    int:       int,\n    merge:     merge,\n    omap:      omap,\n    seq:       seq,\n    str:       str\n  };\n\n  // Removed functions from JS-YAML 3.0.x\n  var safeLoad            = renamed('safeLoad', 'load');\n  var safeLoadAll         = renamed('safeLoadAll', 'loadAll');\n  var safeDump            = renamed('safeDump', 'dump');\n\n  var jsYaml = {\n  \tType: Type,\n  \tSchema: Schema,\n  \tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n  \tJSON_SCHEMA: JSON_SCHEMA,\n  \tCORE_SCHEMA: CORE_SCHEMA,\n  \tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n  \tload: load,\n  \tloadAll: loadAll,\n  \tdump: dump,\n  \tYAMLException: YAMLException,\n  \ttypes: types,\n  \tsafeLoad: safeLoad,\n  \tsafeLoadAll: safeLoadAll,\n  \tsafeDump: safeDump\n  };\n\n  exports.CORE_SCHEMA = CORE_SCHEMA;\n  exports.DEFAULT_SCHEMA = DEFAULT_SCHEMA;\n  exports.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;\n  exports.JSON_SCHEMA = JSON_SCHEMA;\n  exports.Schema = Schema;\n  exports.Type = Type;\n  exports.YAMLException = YAMLException;\n  exports.default = jsYaml;\n  exports.dump = dump;\n  exports.load = load;\n  exports.loadAll = loadAll;\n  exports.safeDump = safeDump;\n  exports.safeLoad = safeLoad;\n  exports.safeLoadAll = safeLoadAll;\n  exports.types = types;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}