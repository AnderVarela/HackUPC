{"ast":null,"code":"\"use strict\";\n\n// any is required to work around manipulating the AST in weird ways\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-extra-parens');\nexports.default = util.createRule({\n  name: 'no-extra-parens',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Disallow unnecessary parentheses',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'code',\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: baseRule.meta.schema,\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: ['all'],\n  create(context) {\n    const rules = baseRule.create(context);\n    function binaryExp(node) {\n      const rule = rules.BinaryExpression;\n      // makes the rule think it should skip the left or right\n      const isLeftTypeAssertion = util.isTypeAssertion(node.left);\n      const isRightTypeAssertion = util.isTypeAssertion(node.right);\n      if (isLeftTypeAssertion && isRightTypeAssertion) {\n        return; // ignore\n      }\n      if (isLeftTypeAssertion) {\n        return rule(Object.assign(Object.assign({}, node), {\n          left: Object.assign(Object.assign({}, node.left), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n      if (isRightTypeAssertion) {\n        return rule(Object.assign(Object.assign({}, node), {\n          right: Object.assign(Object.assign({}, node.right), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n      return rule(node);\n    }\n    function callExp(node) {\n      var _a;\n      const rule = rules.CallExpression;\n      if (util.isTypeAssertion(node.callee)) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        return rule(Object.assign(Object.assign({}, node), {\n          callee: Object.assign(Object.assign({}, node.callee), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n      if (node.arguments.length === 1 && ((_a = node.typeParameters) === null || _a === void 0 ? void 0 : _a.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSImportType || param.type === utils_1.AST_NODE_TYPES.TSArrayType))) {\n        return rule(Object.assign(Object.assign({}, node), {\n          arguments: [Object.assign(Object.assign({}, node.arguments[0]), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })]\n        }));\n      }\n      return rule(node);\n    }\n    function unaryUpdateExpression(node) {\n      const rule = rules.UnaryExpression;\n      if (util.isTypeAssertion(node.argument)) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        return rule(Object.assign(Object.assign({}, node), {\n          argument: Object.assign(Object.assign({}, node.argument), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n      return rule(node);\n    }\n    const overrides = {\n      // ArrayExpression\n      ArrowFunctionExpression(node) {\n        if (!util.isTypeAssertion(node.body)) {\n          return rules.ArrowFunctionExpression(node);\n        }\n      },\n      // AssignmentExpression\n      AwaitExpression(node) {\n        if (util.isTypeAssertion(node.argument)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.AwaitExpression(Object.assign(Object.assign({}, node), {\n            argument: Object.assign(Object.assign({}, node.argument), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.AwaitExpression(node);\n      },\n      BinaryExpression: binaryExp,\n      CallExpression: callExp,\n      ClassDeclaration(node) {\n        var _a;\n        if (((_a = node.superClass) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSAsExpression) {\n          return rules.ClassDeclaration(Object.assign(Object.assign({}, node), {\n            superClass: Object.assign(Object.assign({}, node.superClass), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.ClassDeclaration(node);\n      },\n      ClassExpression(node) {\n        var _a;\n        if (((_a = node.superClass) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSAsExpression) {\n          return rules.ClassExpression(Object.assign(Object.assign({}, node), {\n            superClass: Object.assign(Object.assign({}, node.superClass), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.ClassExpression(node);\n      },\n      ConditionalExpression(node) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        if (util.isTypeAssertion(node.test)) {\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            test: Object.assign(Object.assign({}, node.test), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        if (util.isTypeAssertion(node.consequent)) {\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            consequent: Object.assign(Object.assign({}, node.consequent), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        if (util.isTypeAssertion(node.alternate)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            alternate: Object.assign(Object.assign({}, node.alternate), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.ConditionalExpression(node);\n      },\n      // DoWhileStatement\n      // ForIn and ForOf are guarded by eslint version\n      ForStatement(node) {\n        // make the rule skip the piece by removing it entirely\n        if (node.init && util.isTypeAssertion(node.init)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            init: null\n          }));\n        }\n        if (node.test && util.isTypeAssertion(node.test)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            test: null\n          }));\n        }\n        if (node.update && util.isTypeAssertion(node.update)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            update: null\n          }));\n        }\n        return rules.ForStatement(node);\n      },\n      'ForStatement > *.init:exit'(node) {\n        if (!util.isTypeAssertion(node)) {\n          return rules['ForStatement > *.init:exit'](node);\n        }\n      },\n      // IfStatement\n      LogicalExpression: binaryExp,\n      MemberExpression(node) {\n        if (util.isTypeAssertion(node.object)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.MemberExpression(Object.assign(Object.assign({}, node), {\n            object: Object.assign(Object.assign({}, node.object), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.MemberExpression(node);\n      },\n      NewExpression: callExp,\n      // ObjectExpression\n      // ReturnStatement\n      // SequenceExpression\n      SpreadElement(node) {\n        if (!util.isTypeAssertion(node.argument)) {\n          return rules.SpreadElement(node);\n        }\n      },\n      SwitchCase(node) {\n        if (node.test && !util.isTypeAssertion(node.test)) {\n          return rules.SwitchCase(node);\n        }\n      },\n      // SwitchStatement\n      ThrowStatement(node) {\n        if (node.argument && !util.isTypeAssertion(node.argument)) {\n          return rules.ThrowStatement(node);\n        }\n      },\n      UnaryExpression: unaryUpdateExpression,\n      UpdateExpression: unaryUpdateExpression,\n      // VariableDeclarator\n      // WhileStatement\n      // WithStatement - i'm not going to even bother implementing this terrible and never used feature\n      YieldExpression(node) {\n        if (node.argument && !util.isTypeAssertion(node.argument)) {\n          return rules.YieldExpression(node);\n        }\n      }\n    };\n    if (rules.ForInStatement && rules.ForOfStatement) {\n      overrides.ForInStatement = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // as of 7.20.0 there's no way to skip checking the right of the ForIn\n          // so just don't validate it at all\n          return;\n        }\n        return rules.ForInStatement(node);\n      };\n      overrides.ForOfStatement = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // makes the rule skip checking of the right\n          return rules.ForOfStatement(Object.assign(Object.assign({}, node), {\n            type: utils_1.AST_NODE_TYPES.ForOfStatement,\n            right: Object.assign(Object.assign({}, node.right), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules.ForOfStatement(node);\n      };\n    } else {\n      overrides['ForInStatement, ForOfStatement'] = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // makes the rule skip checking of the right\n          return rules['ForInStatement, ForOfStatement'](Object.assign(Object.assign({}, node), {\n            type: utils_1.AST_NODE_TYPES.ForOfStatement,\n            right: Object.assign(Object.assign({}, node.right), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n        return rules['ForInStatement, ForOfStatement'](node);\n      };\n    }\n    return Object.assign({}, rules, overrides);\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","messages","defaultOptions","create","context","rules","binaryExp","node","rule","BinaryExpression","isLeftTypeAssertion","isTypeAssertion","left","isRightTypeAssertion","right","Object","assign","AST_NODE_TYPES","SequenceExpression","callExp","CallExpression","callee","arguments","length","_a","typeParameters","params","some","param","TSImportType","TSArrayType","unaryUpdateExpression","UnaryExpression","argument","overrides","ArrowFunctionExpression","body","AwaitExpression","ClassDeclaration","superClass","TSAsExpression","ClassExpression","ConditionalExpression","test","consequent","alternate","ForStatement","init","update","ForStatement > *.init:exit","LogicalExpression","MemberExpression","object","NewExpression","SpreadElement","SwitchCase","ThrowStatement","UpdateExpression","YieldExpression","ForInStatement","ForOfStatement"],"sources":["../../src/rules/no-extra-parens.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}