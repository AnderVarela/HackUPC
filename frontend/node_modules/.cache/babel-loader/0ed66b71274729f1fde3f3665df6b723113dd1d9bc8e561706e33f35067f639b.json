{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-explicit-any',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow the `any` type',\n      recommended: 'warn'\n    },\n    fixable: 'code',\n    hasSuggestions: true,\n    messages: {\n      unexpectedAny: 'Unexpected any. Specify a different type.',\n      suggestUnknown: 'Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.',\n      suggestNever: \"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.\"\n    },\n    schema: [{\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        fixToUnknown: {\n          description: 'Whether to enable auto-fixing in which the `any` type is converted to the `unknown` type.',\n          type: 'boolean'\n        },\n        ignoreRestArgs: {\n          description: 'Whether to ignore rest parameter arrays.',\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n  defaultOptions: [{\n    fixToUnknown: false,\n    ignoreRestArgs: false\n  }],\n  create(context, [{\n    ignoreRestArgs,\n    fixToUnknown\n  }]) {\n    /**\n     * Checks if the node is an arrow function, function/constructor declaration or function expression\n     * @param node the node to be validated.\n     * @returns true if the node is any kind of function declaration or expression\n     * @private\n     */\n    function isNodeValidFunction(node) {\n      return [utils_1.AST_NODE_TYPES.ArrowFunctionExpression, utils_1.AST_NODE_TYPES.FunctionDeclaration, utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, utils_1.AST_NODE_TYPES.TSFunctionType, utils_1.AST_NODE_TYPES.TSConstructorType, utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration, utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration, utils_1.AST_NODE_TYPES.TSMethodSignature, utils_1.AST_NODE_TYPES.TSDeclareFunction // declare function _8(...args: any[]): unknown;\n      ].includes(node.type);\n    }\n    /**\n     * Checks if the node is a rest element child node of a function\n     * @param node the node to be validated.\n     * @returns true if the node is a rest element child node of a function\n     * @private\n     */\n    function isNodeRestElementInFunction(node) {\n      return node.type === utils_1.AST_NODE_TYPES.RestElement && node.parent !== undefined && isNodeValidFunction(node.parent);\n    }\n    /**\n     * Checks if the node is a TSTypeOperator node with a readonly operator\n     * @param node the node to be validated.\n     * @returns true if the node is a TSTypeOperator node with a readonly operator\n     * @private\n     */\n    function isNodeReadonlyTSTypeOperator(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSTypeOperator && node.operator === 'readonly';\n    }\n    /**\n     * Checks if the node is a TSTypeReference node with an Array identifier\n     * @param node the node to be validated.\n     * @returns true if the node is a TSTypeReference node with an Array identifier\n     * @private\n     */\n    function isNodeValidArrayTSTypeReference(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSTypeReference && node.typeName !== undefined && node.typeName.type === utils_1.AST_NODE_TYPES.Identifier && ['Array', 'ReadonlyArray'].includes(node.typeName.name);\n    }\n    /**\n     * Checks if the node is a valid TSTypeOperator or TSTypeReference node\n     * @param node the node to be validated.\n     * @returns true if the node is a valid TSTypeOperator or TSTypeReference node\n     * @private\n     */\n    function isNodeValidTSType(node) {\n      return isNodeReadonlyTSTypeOperator(node) || isNodeValidArrayTSTypeReference(node);\n    }\n    /**\n     * Checks if the great grand-parent node is a RestElement node in a function\n     * @param node the node to be validated.\n     * @returns true if the great grand-parent node is a RestElement node in a function\n     * @private\n     */\n    function isGreatGrandparentRestElement(node) {\n      var _a, _b;\n      return ((_b = (_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) != null && isNodeRestElementInFunction(node.parent.parent.parent);\n    }\n    /**\n     * Checks if the great great grand-parent node is a valid RestElement node in a function\n     * @param node the node to be validated.\n     * @returns true if the great great grand-parent node is a valid RestElement node in a function\n     * @private\n     */\n    function isGreatGreatGrandparentRestElement(node) {\n      var _a, _b, _c;\n      return ((_c = (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.parent) != null && isNodeValidTSType(node.parent.parent) && isNodeRestElementInFunction(node.parent.parent.parent.parent);\n    }\n    /**\n     * Checks if the great grand-parent or the great great grand-parent node is a RestElement node\n     * @param node the node to be validated.\n     * @returns true if the great grand-parent or the great great grand-parent node is a RestElement node\n     * @private\n     */\n    function isNodeDescendantOfRestElementInFunction(node) {\n      return isGreatGrandparentRestElement(node) || isGreatGreatGrandparentRestElement(node);\n    }\n    return {\n      TSAnyKeyword(node) {\n        if (ignoreRestArgs && isNodeDescendantOfRestElementInFunction(node)) {\n          return;\n        }\n        const fixOrSuggest = {\n          fix: null,\n          suggest: [{\n            messageId: 'suggestUnknown',\n            fix(fixer) {\n              return fixer.replaceText(node, 'unknown');\n            }\n          }, {\n            messageId: 'suggestNever',\n            fix(fixer) {\n              return fixer.replaceText(node, 'never');\n            }\n          }]\n        };\n        if (fixToUnknown) {\n          fixOrSuggest.fix = fixer => fixer.replaceText(node, 'unknown');\n        }\n        context.report(Object.assign({\n          node,\n          messageId: 'unexpectedAny'\n        }, fixOrSuggest));\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","fixable","hasSuggestions","messages","unexpectedAny","suggestUnknown","suggestNever","schema","additionalProperties","properties","fixToUnknown","ignoreRestArgs","defaultOptions","create","context","isNodeValidFunction","node","AST_NODE_TYPES","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression","TSEmptyBodyFunctionExpression","TSFunctionType","TSConstructorType","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","TSMethodSignature","TSDeclareFunction","includes","isNodeRestElementInFunction","RestElement","parent","undefined","isNodeReadonlyTSTypeOperator","TSTypeOperator","operator","isNodeValidArrayTSTypeReference","TSTypeReference","typeName","Identifier","isNodeValidTSType","isGreatGrandparentRestElement","_b","_a","isGreatGreatGrandparentRestElement","_c","isNodeDescendantOfRestElementInFunction","TSAnyKeyword","fixOrSuggest","fix","suggest","messageId","fixer","replaceText","report","Object","assign"],"sources":["../../src/rules/no-explicit-any.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}