{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ScopeBase_declaredVariables, _ScopeBase_dynamic, _ScopeBase_staticCloseRef, _ScopeBase_dynamicCloseRef, _ScopeBase_globalCloseRef;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScopeBase = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst assert_1 = require(\"../assert\");\nconst definition_1 = require(\"../definition\");\nconst ID_1 = require(\"../ID\");\nconst Reference_1 = require(\"../referencer/Reference\");\nconst variable_1 = require(\"../variable\");\nconst ScopeType_1 = require(\"./ScopeType\");\n/**\n * Test if scope is strict\n */\nfunction isStrictScope(scope, block, isMethodDefinition) {\n  var _a;\n  let body;\n  // When upper scope is exists and strict, inner scope is also strict.\n  if ((_a = scope.upper) === null || _a === void 0 ? void 0 : _a.isStrict) {\n    return true;\n  }\n  if (isMethodDefinition) {\n    return true;\n  }\n  if (scope.type === ScopeType_1.ScopeType.class || scope.type === ScopeType_1.ScopeType.conditionalType || scope.type === ScopeType_1.ScopeType.functionType || scope.type === ScopeType_1.ScopeType.mappedType || scope.type === ScopeType_1.ScopeType.module || scope.type === ScopeType_1.ScopeType.tsEnum || scope.type === ScopeType_1.ScopeType.tsModule || scope.type === ScopeType_1.ScopeType.type) {\n    return true;\n  }\n  if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {\n    return false;\n  }\n  if (scope.type === ScopeType_1.ScopeType.function) {\n    const functionBody = block;\n    switch (functionBody.type) {\n      case types_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {\n          return false;\n        }\n        body = functionBody.body;\n        break;\n      case types_1.AST_NODE_TYPES.Program:\n        body = functionBody;\n        break;\n      default:\n        body = functionBody.body;\n    }\n    if (!body) {\n      return false;\n    }\n  } else if (scope.type === ScopeType_1.ScopeType.global) {\n    body = block;\n  } else {\n    return false;\n  }\n  // Search 'use strict' directive.\n  for (const stmt of body.body) {\n    if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {\n      break;\n    }\n    if (stmt.directive === 'use strict') {\n      return true;\n    }\n    const expr = stmt.expression;\n    if (expr.type !== types_1.AST_NODE_TYPES.Literal) {\n      break;\n    }\n    if (expr.raw === '\"use strict\"' || expr.raw === \"'use strict'\") {\n      return true;\n    }\n    if (expr.value === 'use strict') {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Register scope\n */\nfunction registerScope(scopeManager, scope) {\n  scopeManager.scopes.push(scope);\n  const scopes = scopeManager.nodeToScope.get(scope.block);\n  if (scopes) {\n    scopes.push(scope);\n  } else {\n    scopeManager.nodeToScope.set(scope.block, [scope]);\n  }\n}\nconst generator = (0, ID_1.createIdGenerator)();\nconst VARIABLE_SCOPE_TYPES = new Set([ScopeType_1.ScopeType.classFieldInitializer, ScopeType_1.ScopeType.classStaticBlock, ScopeType_1.ScopeType.function, ScopeType_1.ScopeType.global, ScopeType_1.ScopeType.module, ScopeType_1.ScopeType.tsModule]);\nclass ScopeBase {\n  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n    /**\n     * A unique ID for this instance - primarily used to help debugging and testing\n     */\n    this.$id = generator();\n    /**\n     * The array of child scopes. This does not include grandchild scopes.\n     * @public\n     */\n    this.childScopes = [];\n    /**\n     * A map of the variables for each node in this scope.\n     * This is map is a pointer to the one in the parent ScopeManager instance\n     */\n    _ScopeBase_declaredVariables.set(this, void 0);\n    /**\n     * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code\n     * refers to. There are a few exceptions to this rule. With `global` and `with` scopes you can only decide at runtime\n     * which variable a reference refers to.\n     * All those scopes are considered \"dynamic\".\n     */\n    _ScopeBase_dynamic.set(this, void 0);\n    /**\n     * Whether this scope is created by a FunctionExpression.\n     * @public\n     */\n    this.functionExpressionScope = false;\n    /**\n     * List of {@link Reference}s that are left to be resolved (i.e. which\n     * need to be linked to the variable they refer to).\n     */\n    this.leftToResolve = [];\n    /**\n     * Any variable {@link Reference} found in this scope.\n     * This includes occurrences of local variables as well as variables from parent scopes (including the global scope).\n     * For local variables this also includes defining occurrences (like in a 'var' statement).\n     * In a 'function' scope this does not include the occurrences of the formal parameter in the parameter list.\n     * @public\n     */\n    this.references = [];\n    /**\n     * The map from variable names to variable objects.\n     * @public\n     */\n    this.set = new Map();\n    /**\n     * The {@link Reference}s that are not resolved with this scope.\n     * @public\n     */\n    this.through = [];\n    /**\n     * The scoped {@link Variable}s of this scope.\n     * In the case of a 'function' scope this includes the automatic argument `arguments` as its first element, as well\n     * as all further formal arguments.\n     * This does not include variables which are defined in child scopes.\n     * @public\n     */\n    this.variables = [];\n    _ScopeBase_staticCloseRef.set(this, ref => {\n      const resolve = () => {\n        const name = ref.identifier.name;\n        const variable = this.set.get(name);\n        if (!variable) {\n          return false;\n        }\n        if (!this.isValidResolution(ref, variable)) {\n          return false;\n        }\n        // make sure we don't match a type reference to a value variable\n        const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;\n        const isValidValueReference = ref.isValueReference && variable.isValueVariable;\n        if (!isValidTypeReference && !isValidValueReference) {\n          return false;\n        }\n        variable.references.push(ref);\n        ref.resolved = variable;\n        return true;\n      };\n      if (!resolve()) {\n        this.delegateToUpperScope(ref);\n      }\n    });\n    _ScopeBase_dynamicCloseRef.set(this, ref => {\n      // notify all names are through to global\n      let current = this;\n      do {\n        current.through.push(ref);\n        current = current.upper;\n      } while (current);\n    });\n    _ScopeBase_globalCloseRef.set(this, (ref, scopeManager) => {\n      // let/const/class declarations should be resolved statically.\n      // others should be resolved dynamically.\n      if (this.shouldStaticallyCloseForGlobal(ref, scopeManager)) {\n        __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\").call(this, ref);\n      } else {\n        __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\").call(this, ref);\n      }\n    });\n    const upperScopeAsScopeBase = upperScope;\n    this.type = type;\n    __classPrivateFieldSet(this, _ScopeBase_dynamic, this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, \"f\");\n    this.block = block;\n    this.variableScope = this.isVariableScope() ? this : upperScopeAsScopeBase.variableScope;\n    this.upper = upperScope;\n    /**\n     * Whether 'use strict' is in effect in this scope.\n     * @member {boolean} Scope#isStrict\n     */\n    this.isStrict = isStrictScope(this, block, isMethodDefinition);\n    if (upperScopeAsScopeBase) {\n      // this is guaranteed to be correct at runtime\n      upperScopeAsScopeBase.childScopes.push(this);\n    }\n    __classPrivateFieldSet(this, _ScopeBase_declaredVariables, scopeManager.declaredVariables, \"f\");\n    registerScope(scopeManager, this);\n  }\n  isVariableScope() {\n    return VARIABLE_SCOPE_TYPES.has(this.type);\n  }\n  shouldStaticallyClose() {\n    return !__classPrivateFieldGet(this, _ScopeBase_dynamic, \"f\");\n  }\n  shouldStaticallyCloseForGlobal(ref, scopeManager) {\n    // On global scope, let/const/class declarations should be resolved statically.\n    const name = ref.identifier.name;\n    const variable = this.set.get(name);\n    if (!variable) {\n      return false;\n    }\n    // variable exists on the scope\n    // in module mode, we can statically resolve everything, regardless of its decl type\n    if (scopeManager.isModule()) {\n      return true;\n    }\n    // in script mode, only certain cases should be statically resolved\n    // Example:\n    // a `var` decl is ignored by the runtime if it clashes with a global name\n    // this means that we should not resolve the reference to the variable\n    const defs = variable.defs;\n    return defs.length > 0 && defs.every(def => {\n      var _a;\n      if (def.type === definition_1.DefinitionType.Variable && ((_a = def.parent) === null || _a === void 0 ? void 0 : _a.type) === types_1.AST_NODE_TYPES.VariableDeclaration && def.parent.kind === 'var') {\n        return false;\n      }\n      return true;\n    });\n  }\n  close(scopeManager) {\n    let closeRef;\n    if (this.shouldStaticallyClose()) {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\");\n    } else if (this.type !== 'global') {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\");\n    } else {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_globalCloseRef, \"f\");\n    }\n    // Try Resolving all references in this scope.\n    (0, assert_1.assert)(this.leftToResolve);\n    this.leftToResolve.forEach(ref => closeRef(ref, scopeManager));\n    this.leftToResolve = null;\n    return this.upper;\n  }\n  /**\n   * To override by function scopes.\n   * References in default parameters isn't resolved to variables which are in their function body.\n   */\n  isValidResolution(_ref, _variable) {\n    return true;\n  }\n  delegateToUpperScope(ref) {\n    const upper = this.upper;\n    if (upper === null || upper === void 0 ? void 0 : upper.leftToResolve) {\n      upper.leftToResolve.push(ref);\n    }\n    this.through.push(ref);\n  }\n  addDeclaredVariablesOfNode(variable, node) {\n    if (node == null) {\n      return;\n    }\n    let variables = __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").get(node);\n    if (variables == null) {\n      variables = [];\n      __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").set(node, variables);\n    }\n    if (!variables.includes(variable)) {\n      variables.push(variable);\n    }\n  }\n  defineVariable(nameOrVariable, set, variables, node, def) {\n    const name = typeof nameOrVariable === 'string' ? nameOrVariable : nameOrVariable.name;\n    let variable = set.get(name);\n    if (!variable) {\n      variable = typeof nameOrVariable === 'string' ? new variable_1.Variable(name, this) : nameOrVariable;\n      set.set(name, variable);\n      variables.push(variable);\n    }\n    if (def) {\n      variable.defs.push(def);\n      this.addDeclaredVariablesOfNode(variable, def.node);\n      this.addDeclaredVariablesOfNode(variable, def.parent);\n    }\n    if (node) {\n      variable.identifiers.push(node);\n    }\n  }\n  defineIdentifier(node, def) {\n    this.defineVariable(node.name, this.set, this.variables, node, def);\n  }\n  defineLiteralIdentifier(node, def) {\n    this.defineVariable(node.value, this.set, this.variables, null, def);\n  }\n  referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = false) {\n    var _a;\n    const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n  referenceType(node) {\n    var _a;\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n  referenceDualValueType(node) {\n    var _a;\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n}\nexports.ScopeBase = ScopeBase;\n_ScopeBase_declaredVariables = new WeakMap(), _ScopeBase_dynamic = new WeakMap(), _ScopeBase_staticCloseRef = new WeakMap(), _ScopeBase_dynamicCloseRef = new WeakMap(), _ScopeBase_globalCloseRef = new WeakMap();","map":{"version":3,"names":["types_1","require","assert_1","definition_1","ID_1","Reference_1","variable_1","ScopeType_1","isStrictScope","scope","block","isMethodDefinition","body","_a","upper","isStrict","type","ScopeType","class","conditionalType","functionType","mappedType","module","tsEnum","tsModule","switch","function","functionBody","AST_NODE_TYPES","ArrowFunctionExpression","BlockStatement","Program","global","stmt","ExpressionStatement","directive","expr","expression","Literal","raw","value","registerScope","scopeManager","scopes","push","nodeToScope","get","set","generator","createIdGenerator","VARIABLE_SCOPE_TYPES","Set","classFieldInitializer","classStaticBlock","ScopeBase","constructor","upperScope","$id","childScopes","_ScopeBase_declaredVariables","_ScopeBase_dynamic","functionExpressionScope","leftToResolve","references","Map","through","variables","_ScopeBase_staticCloseRef","ref","resolve","name","identifier","variable","isValidResolution","isValidTypeReference","isTypeReference","isTypeVariable","isValidValueReference","isValueReference","isValueVariable","resolved","delegateToUpperScope","_ScopeBase_dynamicCloseRef","current","_ScopeBase_globalCloseRef","shouldStaticallyCloseForGlobal","__classPrivateFieldGet","call","upperScopeAsScopeBase","__classPrivateFieldSet","with","variableScope","isVariableScope","declaredVariables","has","shouldStaticallyClose","isModule","defs","length","every","def","DefinitionType","Variable","parent","VariableDeclaration","kind","close","closeRef","assert","forEach","_ref","_variable","addDeclaredVariablesOfNode","node","includes","defineVariable","nameOrVariable","identifiers","defineIdentifier","defineLiteralIdentifier","referenceValue","assign","ReferenceFlag","Read","writeExpr","maybeImplicitGlobal","init","Reference","ReferenceTypeFlag","Value","referenceType","Type","referenceDualValueType","exports"],"sources":["../../src/scope/ScopeBase.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}