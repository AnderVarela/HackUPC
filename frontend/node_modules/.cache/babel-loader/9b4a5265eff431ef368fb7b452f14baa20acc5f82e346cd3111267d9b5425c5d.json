{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst util = __importStar(require(\"../util\"));\nconst util_1 = require(\"../util\");\nexports.default = util.createRule({\n  name: 'no-unsafe-return',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow returning a value with type `any` from a function',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unsafeReturn: 'Unsafe return of an `{{type}}` typed value.',\n      unsafeReturnThis: ['Unsafe return of an `{{type}}` typed value. `this` is typed as `any`.', 'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.'].join('\\n'),\n      unsafeReturnAssignment: 'Unsafe return of type `{{sender}}` from function with return type `{{receiver}}`.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    const compilerOptions = program.getCompilerOptions();\n    const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n    function getParentFunctionNode(node) {\n      let current = node.parent;\n      while (current) {\n        if (current.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || current.type === utils_1.AST_NODE_TYPES.FunctionDeclaration || current.type === utils_1.AST_NODE_TYPES.FunctionExpression) {\n          return current;\n        }\n        current = current.parent;\n      }\n      // this shouldn't happen in correct code, but someone may attempt to parse bad code\n      // the parser won't error, so we shouldn't throw here\n      /* istanbul ignore next */\n      return null;\n    }\n    function checkReturn(returnNode, reportingNode = returnNode) {\n      const tsNode = esTreeNodeToTSNodeMap.get(returnNode);\n      const anyType = util.isAnyOrAnyArrayTypeDiscriminated(tsNode, checker);\n      const functionNode = getParentFunctionNode(returnNode);\n      /* istanbul ignore if */\n      if (!functionNode) {\n        return;\n      }\n      // function has an explicit return type, so ensure it's a safe return\n      const returnNodeType = util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(returnNode));\n      const functionTSNode = esTreeNodeToTSNodeMap.get(functionNode);\n      // function expressions will not have their return type modified based on receiver typing\n      // so we have to use the contextual typing in these cases, i.e.\n      // const foo1: () => Set<string> = () => new Set<any>();\n      // the return type of the arrow function is Set<any> even though the variable is typed as Set<string>\n      let functionType = tsutils.isExpression(functionTSNode) ? util.getContextualType(checker, functionTSNode) : checker.getTypeAtLocation(functionTSNode);\n      if (!functionType) {\n        functionType = checker.getTypeAtLocation(functionTSNode);\n      }\n      // If there is an explicit type annotation *and* that type matches the actual\n      // function return type, we shouldn't complain (it's intentional, even if unsafe)\n      if (functionTSNode.type) {\n        for (const signature of functionType.getCallSignatures()) {\n          if (returnNodeType === signature.getReturnType()) {\n            return;\n          }\n        }\n      }\n      if (anyType !== util.AnyType.Safe) {\n        // Allow cases when the declared return type of the function is either unknown or unknown[]\n        // and the function is returning any or any[].\n        for (const signature of functionType.getCallSignatures()) {\n          const functionReturnType = signature.getReturnType();\n          if (anyType === util.AnyType.Any && util.isTypeUnknownType(functionReturnType)) {\n            return;\n          }\n          if (anyType === util.AnyType.AnyArray && util.isTypeUnknownArrayType(functionReturnType, checker)) {\n            return;\n          }\n        }\n        let messageId = 'unsafeReturn';\n        if (!isNoImplicitThis) {\n          // `return this`\n          const thisExpression = (0, util_1.getThisExpression)(returnNode);\n          if (thisExpression && util.isTypeAnyType(util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(thisExpression)))) {\n            messageId = 'unsafeReturnThis';\n          }\n        }\n        // If the function return type was not unknown/unknown[], mark usage as unsafeReturn.\n        return context.report({\n          node: reportingNode,\n          messageId,\n          data: {\n            type: anyType === util.AnyType.Any ? 'any' : 'any[]'\n          }\n        });\n      }\n      for (const signature of functionType.getCallSignatures()) {\n        const functionReturnType = signature.getReturnType();\n        const result = util.isUnsafeAssignment(returnNodeType, functionReturnType, checker, returnNode);\n        if (!result) {\n          return;\n        }\n        const {\n          sender,\n          receiver\n        } = result;\n        return context.report({\n          node: reportingNode,\n          messageId: 'unsafeReturnAssignment',\n          data: {\n            sender: checker.typeToString(sender),\n            receiver: checker.typeToString(receiver)\n          }\n        });\n      }\n    }\n    return {\n      ReturnStatement(node) {\n        const argument = node.argument;\n        if (!argument) {\n          return;\n        }\n        checkReturn(argument, node);\n      },\n      'ArrowFunctionExpression > :not(BlockStatement).body': checkReturn\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","util","util_1","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","unsafeReturn","unsafeReturnThis","join","unsafeReturnAssignment","schema","defaultOptions","create","context","program","esTreeNodeToTSNodeMap","getParserServices","checker","getTypeChecker","compilerOptions","getCompilerOptions","isNoImplicitThis","isStrictCompilerOptionEnabled","getParentFunctionNode","node","current","parent","AST_NODE_TYPES","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression","checkReturn","returnNode","reportingNode","tsNode","get","anyType","isAnyOrAnyArrayTypeDiscriminated","functionNode","returnNodeType","getConstrainedTypeAtLocation","functionTSNode","functionType","isExpression","getContextualType","getTypeAtLocation","signature","getCallSignatures","getReturnType","AnyType","Safe","functionReturnType","Any","isTypeUnknownType","AnyArray","isTypeUnknownArrayType","messageId","thisExpression","getThisExpression","isTypeAnyType","report","data","result","isUnsafeAssignment","sender","receiver","typeToString","ReturnStatement","argument"],"sources":["../../src/rules/no-unsafe-return.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}