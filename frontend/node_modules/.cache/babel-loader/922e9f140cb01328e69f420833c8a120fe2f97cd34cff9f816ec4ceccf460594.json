{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasRef = void 0;\nconst compile_1 = require(\"../../compile\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst names_1 = require(\"../../compile/names\");\nconst ref_1 = require(\"../core/ref\");\nconst metadata_1 = require(\"./metadata\");\nconst def = {\n  keyword: \"ref\",\n  schemaType: \"string\",\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema: ref,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      schemaEnv: {\n        root\n      }\n    } = it;\n    const valid = gen.name(\"valid\");\n    if (parentSchema.nullable) {\n      gen.var(valid, (0, codegen_1._)`${data} === null`);\n      gen.if((0, codegen_1.not)(valid), validateJtdRef);\n    } else {\n      gen.var(valid, false);\n      validateJtdRef();\n    }\n    cxt.ok(valid);\n    function validateJtdRef() {\n      var _a;\n      const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];\n      if (!refSchema) {\n        throw new ref_error_1.default(it.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n      }\n      if (hasRef(refSchema) || !it.opts.inlineRefs) callValidate(refSchema);else inlineRefSchema(refSchema);\n    }\n    function callValidate(schema) {\n      const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({\n        schema,\n        root,\n        schemaPath: `/definitions/${ref}`\n      }));\n      const v = (0, ref_1.getValidate)(cxt, sch);\n      const errsCount = gen.const(\"_errs\", names_1.default.errors);\n      (0, ref_1.callRef)(cxt, v, sch, sch.$async);\n      gen.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n    }\n    function inlineRefSchema(schema) {\n      const schName = gen.scopeValue(\"schema\", it.opts.code.source === true ? {\n        ref: schema,\n        code: (0, codegen_1.stringify)(schema)\n      } : {\n        ref: schema\n      });\n      cxt.subschema({\n        schema,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: `/definitions/${ref}`\n      }, valid);\n    }\n  }\n};\nfunction hasRef(schema) {\n  for (const key in schema) {\n    let sch;\n    if (key === \"ref\" || typeof (sch = schema[key]) == \"object\" && hasRef(sch)) return true;\n  }\n  return false;\n}\nexports.hasRef = hasRef;\nexports.default = def;","map":{"version":3,"names":["compile_1","require","codegen_1","ref_error_1","names_1","ref_1","metadata_1","def","keyword","schemaType","code","cxt","checkMetadata","gen","data","schema","ref","parentSchema","it","schemaEnv","root","valid","name","nullable","var","_","if","not","validateJtdRef","ok","refSchema","_a","definitions","default","opts","uriResolver","hasRef","inlineRefs","callValidate","inlineRefSchema","sch","compileSchema","call","self","SchemaEnv","schemaPath","v","getValidate","errsCount","const","errors","callRef","$async","assign","schName","scopeValue","source","stringify","subschema","dataTypes","nil","topSchemaRef","errSchemaPath","key","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\ref.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {compileSchema, SchemaEnv} from \"../../compile\"\nimport {_, not, nil, stringify} from \"../../compile/codegen\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport N from \"../../compile/names\"\nimport {getValidate, callRef} from \"../core/ref\"\nimport {checkMetadata} from \"./metadata\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema: ref, parentSchema, it} = cxt\n    const {\n      schemaEnv: {root},\n    } = it\n    const valid = gen.name(\"valid\")\n    if (parentSchema.nullable) {\n      gen.var(valid, _`${data} === null`)\n      gen.if(not(valid), validateJtdRef)\n    } else {\n      gen.var(valid, false)\n      validateJtdRef()\n    }\n    cxt.ok(valid)\n\n    function validateJtdRef(): void {\n      const refSchema = (root.schema as AnySchemaObject).definitions?.[ref]\n      if (!refSchema) {\n        throw new MissingRefError(it.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n      }\n      if (hasRef(refSchema) || !it.opts.inlineRefs) callValidate(refSchema)\n      else inlineRefSchema(refSchema)\n    }\n\n    function callValidate(schema: AnySchemaObject): void {\n      const sch = compileSchema.call(\n        it.self,\n        new SchemaEnv({schema, root, schemaPath: `/definitions/${ref}`})\n      )\n      const v = getValidate(cxt, sch)\n      const errsCount = gen.const(\"_errs\", N.errors)\n      callRef(cxt, v, sch, sch.$async)\n      gen.assign(valid, _`${errsCount} === ${N.errors}`)\n    }\n\n    function inlineRefSchema(schema: AnySchemaObject): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        it.opts.code.source === true ? {ref: schema, code: stringify(schema)} : {ref: schema}\n      )\n      cxt.subschema(\n        {\n          schema,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: `/definitions/${ref}`,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport function hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    let sch: AnySchemaObject\n    if (key === \"ref\" || (typeof (sch = schema[key]) == \"object\" && hasRef(sch))) return true\n  }\n  return false\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}