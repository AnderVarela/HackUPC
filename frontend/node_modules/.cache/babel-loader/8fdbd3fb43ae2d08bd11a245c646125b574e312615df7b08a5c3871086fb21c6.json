{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'require-await',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow async functions which have no `await` expression',\n      recommended: 'error',\n      requiresTypeChecking: true,\n      extendsBaseRule: true\n    },\n    schema: [],\n    messages: {\n      missingAwait: \"{{name}} has no 'await' expression.\"\n    }\n  },\n  defaultOptions: [],\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\n     * Push the scope info object to the stack.\n     */\n    function enterFunction(node) {\n      scopeInfo = {\n        upper: scopeInfo,\n        hasAwait: false,\n        hasAsync: node.async,\n        isGen: node.generator || false,\n        isAsyncYield: false\n      };\n    }\n    /**\n     * Pop the top scope info object from the stack.\n     * Also, it reports the function if needed.\n     */\n    function exitFunction(node) {\n      /* istanbul ignore if */if (!scopeInfo) {\n        // this shouldn't ever happen, as we have to exit a function after we enter it\n        return;\n      }\n      if (node.async && !scopeInfo.hasAwait && !isEmptyFunction(node) && !(scopeInfo.isGen && scopeInfo.isAsyncYield)) {\n        context.report({\n          node,\n          loc: getFunctionHeadLoc(node, sourceCode),\n          messageId: 'missingAwait',\n          data: {\n            name: util.upperCaseFirst(util.getFunctionNameWithKind(node))\n          }\n        });\n      }\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\n     * Checks if the node returns a thenable type\n     */\n    function isThenableType(node) {\n      const type = checker.getTypeAtLocation(node);\n      return tsutils.isThenableType(checker, node, type);\n    }\n    /**\n     * Marks the current scope as having an await\n     */\n    function markAsHasAwait() {\n      if (!scopeInfo) {\n        return;\n      }\n      scopeInfo.hasAwait = true;\n    }\n    /**\n     * mark `scopeInfo.isAsyncYield` to `true` if its a generator\n     * function and the delegate is `true`\n     */\n    function markAsHasDelegateGen(node) {\n      var _a;\n      if (!(scopeInfo === null || scopeInfo === void 0 ? void 0 : scopeInfo.isGen) || !node.argument) {\n        return;\n      }\n      if (((_a = node === null || node === void 0 ? void 0 : node.argument) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Literal) {\n        // making this `false` as for literals we don't need to check the definition\n        // eg : async function* run() { yield* 1 }\n        scopeInfo.isAsyncYield || (scopeInfo.isAsyncYield = false);\n      }\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node === null || node === void 0 ? void 0 : node.argument);\n      const type = checker.getTypeAtLocation(tsNode);\n      const typesToCheck = expandUnionOrIntersectionType(type);\n      for (const type of typesToCheck) {\n        const asyncIterator = tsutils.getWellKnownSymbolPropertyOfType(type, 'asyncIterator', checker);\n        if (asyncIterator !== undefined) {\n          scopeInfo.isAsyncYield = true;\n          break;\n        }\n      }\n    }\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction,\n      'FunctionDeclaration:exit': exitFunction,\n      'FunctionExpression:exit': exitFunction,\n      'ArrowFunctionExpression:exit': exitFunction,\n      AwaitExpression: markAsHasAwait,\n      'ForOfStatement[await = true]': markAsHasAwait,\n      'YieldExpression[delegate = true]': markAsHasDelegateGen,\n      // check body-less async arrow function.\n      // ignore `async () => await foo` because it's obviously correct\n      'ArrowFunctionExpression[async = true] > :not(BlockStatement, AwaitExpression)'(node) {\n        const expression = parserServices.esTreeNodeToTSNodeMap.get(node);\n        if (expression && isThenableType(expression)) {\n          markAsHasAwait();\n        }\n      },\n      ReturnStatement(node) {\n        // short circuit early to avoid unnecessary type checks\n        if (!scopeInfo || scopeInfo.hasAwait || !scopeInfo.hasAsync) {\n          return;\n        }\n        const {\n          expression\n        } = parserServices.esTreeNodeToTSNodeMap.get(node);\n        if (expression && isThenableType(expression)) {\n          markAsHasAwait();\n        }\n      }\n    };\n  }\n});\nfunction isEmptyFunction(node) {\n  var _a;\n  return ((_a = node.body) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.BlockStatement && node.body.body.length === 0;\n}\n// https://github.com/eslint/eslint/blob/03a69dbe86d5b5768a310105416ae726822e3c1c/lib/rules/utils/ast-utils.js#L382-L392\n/**\n * Gets the `(` token of the given function node.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n  return util.nullThrows(node.id ? sourceCode.getTokenAfter(node.id, util.isOpeningParenToken) : sourceCode.getFirstToken(node, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken('(', node.type));\n}\n// https://github.com/eslint/eslint/blob/03a69dbe86d5b5768a310105416ae726822e3c1c/lib/rules/utils/ast-utils.js#L1220-L1242\n/**\n * Gets the location of the given function node for reporting.\n */\nfunction getFunctionHeadLoc(node, sourceCode) {\n  const parent = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n  let start = null;\n  let end = null;\n  if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n    const arrowToken = util.nullThrows(sourceCode.getTokenBefore(node.body, util.isArrowToken), util.NullThrowsReasons.MissingToken('=>', node.type));\n    start = arrowToken.loc.start;\n    end = arrowToken.loc.end;\n  } else if (parent.type === utils_1.AST_NODE_TYPES.Property || parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) {\n    start = parent.loc.start;\n    end = getOpeningParenOfParams(node, sourceCode).loc.start;\n  } else {\n    start = node.loc.start;\n    end = getOpeningParenOfParams(node, sourceCode).loc.start;\n  }\n  return {\n    start,\n    end\n  };\n}\nfunction expandUnionOrIntersectionType(type) {\n  if (type.isUnionOrIntersection()) {\n    return type.types.flatMap(expandUnionOrIntersectionType);\n  }\n  return [type];\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","util","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","extendsBaseRule","schema","messages","missingAwait","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","scopeInfo","enterFunction","node","upper","hasAwait","hasAsync","async","isGen","generator","isAsyncYield","exitFunction","isEmptyFunction","report","loc","getFunctionHeadLoc","messageId","data","upperCaseFirst","getFunctionNameWithKind","isThenableType","getTypeAtLocation","markAsHasAwait","markAsHasDelegateGen","argument","_a","AST_NODE_TYPES","Literal","tsNode","esTreeNodeToTSNodeMap","get","typesToCheck","expandUnionOrIntersectionType","asyncIterator","getWellKnownSymbolPropertyOfType","undefined","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","AwaitExpression","ArrowFunctionExpression[async = true] > :not(BlockStatement, AwaitExpression)","expression","ReturnStatement","body","BlockStatement","length","getOpeningParenOfParams","nullThrows","id","getTokenAfter","isOpeningParenToken","getFirstToken","NullThrowsReasons","MissingToken","parent","MissingParent","start","end","arrowToken","getTokenBefore","isArrowToken","Property","MethodDefinition","isUnionOrIntersection","types","flatMap"],"sources":["../../src/rules/require-await.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}