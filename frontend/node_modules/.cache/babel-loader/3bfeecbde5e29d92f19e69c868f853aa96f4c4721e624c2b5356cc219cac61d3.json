{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-unused-vars',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow unused variables',\n      recommended: 'warn',\n      extendsBaseRule: true\n    },\n    schema: [{\n      oneOf: [{\n        enum: ['all', 'local']\n      }, {\n        type: 'object',\n        properties: {\n          vars: {\n            enum: ['all', 'local']\n          },\n          varsIgnorePattern: {\n            type: 'string'\n          },\n          args: {\n            enum: ['all', 'after-used', 'none']\n          },\n          ignoreRestSiblings: {\n            type: 'boolean'\n          },\n          argsIgnorePattern: {\n            type: 'string'\n          },\n          caughtErrors: {\n            enum: ['all', 'none']\n          },\n          caughtErrorsIgnorePattern: {\n            type: 'string'\n          },\n          destructuredArrayIgnorePattern: {\n            type: 'string'\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n  defaultOptions: [{}],\n  create(context, [firstOption]) {\n    const filename = context.getFilename();\n    const sourceCode = context.getSourceCode();\n    const MODULE_DECL_CACHE = new Map();\n    const options = (() => {\n      var _a, _b, _c, _d;\n      const options = {\n        vars: 'all',\n        args: 'after-used',\n        ignoreRestSiblings: false,\n        caughtErrors: 'none'\n      };\n      if (firstOption) {\n        if (typeof firstOption === 'string') {\n          options.vars = firstOption;\n        } else {\n          options.vars = (_a = firstOption.vars) !== null && _a !== void 0 ? _a : options.vars;\n          options.args = (_b = firstOption.args) !== null && _b !== void 0 ? _b : options.args;\n          options.ignoreRestSiblings = (_c = firstOption.ignoreRestSiblings) !== null && _c !== void 0 ? _c : options.ignoreRestSiblings;\n          options.caughtErrors = (_d = firstOption.caughtErrors) !== null && _d !== void 0 ? _d : options.caughtErrors;\n          if (firstOption.varsIgnorePattern) {\n            options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, 'u');\n          }\n          if (firstOption.argsIgnorePattern) {\n            options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, 'u');\n          }\n          if (firstOption.caughtErrorsIgnorePattern) {\n            options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, 'u');\n          }\n          if (firstOption.destructuredArrayIgnorePattern) {\n            options.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, 'u');\n          }\n        }\n      }\n      return options;\n    })();\n    function collectUnusedVariables() {\n      var _a, _b, _c, _d, _e;\n      /**\n       * Checks whether a node is a sibling of the rest property or not.\n       * @param {ASTNode} node a node to check\n       * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n       */\n      function hasRestSibling(node) {\n        var _a;\n        return node.type === utils_1.AST_NODE_TYPES.Property && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ObjectPattern && node.parent.properties[node.parent.properties.length - 1].type === utils_1.AST_NODE_TYPES.RestElement;\n      }\n      /**\n       * Determines if a variable has a sibling rest property\n       * @param variable eslint-scope variable object.\n       * @returns True if the variable is exported, false if not.\n       */\n      function hasRestSpreadSibling(variable) {\n        if (options.ignoreRestSiblings) {\n          const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n          const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n          return hasRestSiblingDefinition || hasRestSiblingReference;\n        }\n        return false;\n      }\n      /**\n       * Checks whether the given variable is after the last used parameter.\n       * @param variable The variable to check.\n       * @returns `true` if the variable is defined after the last used parameter.\n       */\n      function isAfterLastUsedArg(variable) {\n        const def = variable.defs[0];\n        const params = context.getDeclaredVariables(def.node);\n        const posteriorParams = params.slice(params.indexOf(variable) + 1);\n        // If any used parameters occur after this parameter, do not report.\n        return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n      }\n      const unusedVariablesOriginal = util.collectUnusedVariables(context);\n      const unusedVariablesReturn = [];\n      for (const variable of unusedVariablesOriginal) {\n        // explicit global variables don't have definitions.\n        if (variable.defs.length === 0) {\n          unusedVariablesReturn.push(variable);\n          continue;\n        }\n        const def = variable.defs[0];\n        if (variable.scope.type === utils_1.TSESLint.Scope.ScopeType.global && options.vars === 'local') {\n          // skip variables in the global scope if configured to\n          continue;\n        }\n        const refUsedInArrayPatterns = variable.references.some(ref => {\n          var _a;\n          return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern;\n        });\n        // skip elements of array destructuring patterns\n        if ((((_a = def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern || refUsedInArrayPatterns) && 'name' in def.name && ((_b = options.destructuredArrayIgnorePattern) === null || _b === void 0 ? void 0 : _b.test(def.name.name))) {\n          continue;\n        }\n        // skip catch variables\n        if (def.type === utils_1.TSESLint.Scope.DefinitionType.CatchClause) {\n          if (options.caughtErrors === 'none') {\n            continue;\n          }\n          // skip ignored parameters\n          if ('name' in def.name && ((_c = options.caughtErrorsIgnorePattern) === null || _c === void 0 ? void 0 : _c.test(def.name.name))) {\n            continue;\n          }\n        }\n        if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n          // if \"args\" option is \"none\", skip any parameter\n          if (options.args === 'none') {\n            continue;\n          }\n          // skip ignored parameters\n          if ('name' in def.name && ((_d = options.argsIgnorePattern) === null || _d === void 0 ? void 0 : _d.test(def.name.name))) {\n            continue;\n          }\n          // if \"args\" option is \"after-used\", skip used variables\n          if (options.args === 'after-used' && util.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n            continue;\n          }\n        } else {\n          // skip ignored variables\n          if ('name' in def.name && ((_e = options.varsIgnorePattern) === null || _e === void 0 ? void 0 : _e.test(def.name.name))) {\n            continue;\n          }\n        }\n        if (hasRestSpreadSibling(variable)) {\n          continue;\n        }\n        // in case another rule has run and used the collectUnusedVariables,\n        // we want to ensure our selectors that marked variables as used are respected\n        if (variable.eslintUsed) {\n          continue;\n        }\n        unusedVariablesReturn.push(variable);\n      }\n      return unusedVariablesReturn;\n    }\n    return {\n      // declaration file handling\n      [ambientDeclarationSelector(utils_1.AST_NODE_TYPES.Program, true)](node) {\n        if (!util.isDefinitionFile(filename)) {\n          return;\n        }\n        markDeclarationChildAsUsed(node);\n      },\n      // module declaration in module declaration should not report unused vars error\n      // this is workaround as this change should be done in better way\n      'TSModuleDeclaration > TSModuleDeclaration'(node) {\n        if (node.id.type === utils_1.AST_NODE_TYPES.Identifier) {\n          let scope = context.getScope();\n          if (scope.upper) {\n            scope = scope.upper;\n          }\n          const superVar = scope.set.get(node.id.name);\n          if (superVar) {\n            superVar.eslintUsed = true;\n          }\n        }\n      },\n      // children of a namespace that is a child of a declared namespace are auto-exported\n      [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock TSModuleDeclaration > TSModuleBlock', false)](node) {\n        markDeclarationChildAsUsed(node);\n      },\n      // declared namespace handling\n      [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock', false)](node) {\n        var _a;\n        const moduleDecl = util.nullThrows((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent, util.NullThrowsReasons.MissingParent);\n        // declared ambient modules with an `export =` statement will only export that one thing\n        // all other statements are not automatically exported in this case\n        if (moduleDecl.id.type === utils_1.AST_NODE_TYPES.Literal && checkModuleDeclForExportEquals(moduleDecl)) {\n          return;\n        }\n        markDeclarationChildAsUsed(node);\n      },\n      // collect\n      'Program:exit'(programNode) {\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n          var _a;\n          const defType = (_a = unusedVar === null || unusedVar === void 0 ? void 0 : unusedVar.defs[0]) === null || _a === void 0 ? void 0 : _a.type;\n          let type;\n          let pattern;\n          if (defType === utils_1.TSESLint.Scope.DefinitionType.CatchClause && options.caughtErrorsIgnorePattern) {\n            type = 'args';\n            pattern = options.caughtErrorsIgnorePattern.toString();\n          } else if (defType === utils_1.TSESLint.Scope.DefinitionType.Parameter && options.argsIgnorePattern) {\n            type = 'args';\n            pattern = options.argsIgnorePattern.toString();\n          } else if (defType !== utils_1.TSESLint.Scope.DefinitionType.Parameter && options.varsIgnorePattern) {\n            type = 'vars';\n            pattern = options.varsIgnorePattern.toString();\n          }\n          const additional = type ? `. Allowed unused ${type} must match ${pattern}` : '';\n          return {\n            varName: unusedVar.name,\n            action: 'defined',\n            additional\n          };\n        }\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n          var _a;\n          const def = unusedVar.defs[0];\n          let additional = '';\n          if (options.destructuredArrayIgnorePattern && ((_a = def === null || def === void 0 ? void 0 : def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern) {\n            additional = `. Allowed unused elements of array destructuring patterns must match ${options.destructuredArrayIgnorePattern.toString()}`;\n          } else if (options.varsIgnorePattern) {\n            additional = `. Allowed unused vars must match ${options.varsIgnorePattern.toString()}`;\n          }\n          return {\n            varName: unusedVar.name,\n            action: 'assigned a value',\n            additional\n          };\n        }\n        const unusedVars = collectUnusedVariables();\n        for (const unusedVar of unusedVars) {\n          // Report the first declaration.\n          if (unusedVar.defs.length > 0) {\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            context.report({\n              node: writeReferences.length ? writeReferences[writeReferences.length - 1].identifier : unusedVar.identifiers[0],\n              messageId: 'unusedVar',\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            });\n            // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if ('eslintExplicitGlobalComments' in unusedVar && unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: util.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: 'unusedVar',\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n    };\n    function checkModuleDeclForExportEquals(node) {\n      const cached = MODULE_DECL_CACHE.get(node);\n      if (cached != null) {\n        return cached;\n      }\n      if (node.body && node.body.type === utils_1.AST_NODE_TYPES.TSModuleBlock) {\n        for (const statement of node.body.body) {\n          if (statement.type === utils_1.AST_NODE_TYPES.TSExportAssignment) {\n            MODULE_DECL_CACHE.set(node, true);\n            return true;\n          }\n        }\n      }\n      MODULE_DECL_CACHE.set(node, false);\n      return false;\n    }\n    function ambientDeclarationSelector(parent, childDeclare) {\n      return [\n      // Types are ambiently exported\n      `${parent} > :matches(${[utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration].join(', ')})`,\n      // Value things are ambiently exported if they are \"declare\"d\n      `${parent} > :matches(${[utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.TSDeclareFunction, utils_1.AST_NODE_TYPES.TSEnumDeclaration, utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.VariableDeclaration].join(', ')})${childDeclare ? '[declare = true]' : ''}`].join(', ');\n    }\n    function markDeclarationChildAsUsed(node) {\n      var _a;\n      const identifiers = [];\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n        case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:\n        case utils_1.AST_NODE_TYPES.ClassDeclaration:\n        case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n        case utils_1.AST_NODE_TYPES.TSEnumDeclaration:\n        case utils_1.AST_NODE_TYPES.TSModuleDeclaration:\n          if (((_a = node.id) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Identifier) {\n            identifiers.push(node.id);\n          }\n          break;\n        case utils_1.AST_NODE_TYPES.VariableDeclaration:\n          for (const declaration of node.declarations) {\n            visitPattern(declaration, pattern => {\n              identifiers.push(pattern);\n            });\n          }\n          break;\n      }\n      let scope = context.getScope();\n      const shouldUseUpperScope = [utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.TSDeclareFunction].includes(node.type);\n      if (scope.variableScope !== scope) {\n        scope = scope.variableScope;\n      } else if (shouldUseUpperScope && scope.upper) {\n        scope = scope.upper;\n      }\n      for (const id of identifiers) {\n        const superVar = scope.set.get(id.name);\n        if (superVar) {\n          superVar.eslintUsed = true;\n        }\n      }\n    }\n    function visitPattern(node, cb) {\n      const visitor = new scope_manager_1.PatternVisitor({}, node, cb);\n      visitor.visit(node);\n    }\n  }\n});\n/*\n\n###### TODO ######\n\nEdge cases that aren't currently handled due to laziness and them being super edgy edge cases\n\n\n--- function params referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases wrong\n\nfunction _foo(\n  arg: number // arg should be unused\n): typeof arg {\n  return 1 as any;\n}\n\nfunction _bar(\n  arg: number, // arg should be unused\n  _arg2: typeof arg,\n) {}\n\n\n--- function names referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases right\n\nfunction foo( // foo should be unused\n): typeof foo {\n    return 1 as any;\n}\n\nfunction bar( // bar should be unused\n  _arg: typeof bar\n) {}\n\n\n--- if an interface is merged into a namespace  ---\n--- NOTE - TS gets these cases wrong\n\nnamespace Test {\n    interface Foo { // Foo should be unused here\n        a: string;\n    }\n    export namespace Foo {\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n\nnamespace Test {\n    export interface Foo {\n        a: string;\n    }\n    namespace Foo { // Foo should be unused here\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo.T; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n*/\n/*\n\n###### TODO ######\n\nWe currently extend base `no-unused-vars` implementation because it's easier and lighter-weight.\n\nBecause of this, there are a few false-negatives which won't get caught.\nWe could fix these if we fork the base rule; but that's a lot of code (~650 lines) to add in.\nI didn't want to do that just yet without some real-world issues, considering these are pretty rare edge-cases.\n\nThese cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing\ncreates a variable with two defs\n\n--- type-only or value-only references to type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\ntype T = 1;\nconst T = 2; // this T should be unused\n\ntype U = T; // this U should be unused\nconst U = 3;\n\nconst _V = U;\n\n\n--- partially exported type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\nexport interface Foo {}\nconst Foo = 1; // this Foo should be unused\n\ninterface Bar {} // this Bar should be unused\nexport const Bar = 1;\n\n*/","map":{"version":3,"names":["scope_manager_1","require","utils_1","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","destructuredArrayIgnorePattern","additionalProperties","messages","unusedVar","defaultOptions","create","context","firstOption","filename","getFilename","sourceCode","getSourceCode","MODULE_DECL_CACHE","Map","options","_a","_b","_c","_d","RegExp","collectUnusedVariables","hasRestSibling","node","AST_NODE_TYPES","Property","parent","ObjectPattern","length","RestElement","hasRestSpreadSibling","variable","hasRestSiblingDefinition","defs","some","def","hasRestSiblingReference","references","ref","identifier","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","indexOf","v","eslintUsed","unusedVariablesOriginal","unusedVariablesReturn","push","scope","TSESLint","Scope","ScopeType","global","refUsedInArrayPatterns","ArrayPattern","test","DefinitionType","CatchClause","Parameter","isFunction","_e","ambientDeclarationSelector","Program","isDefinitionFile","markDeclarationChildAsUsed","TSModuleDeclaration > TSModuleDeclaration","id","Identifier","getScope","upper","superVar","set","get","moduleDecl","nullThrows","NullThrowsReasons","MissingParent","Literal","checkModuleDeclForExportEquals","Program:exit","programNode","getDefinedMessageData","defType","pattern","toString","additional","varName","action","getAssignedMessageData","unusedVars","writeReferences","filter","isWrite","from","variableScope","report","identifiers","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment","cached","body","TSModuleBlock","statement","TSExportAssignment","childDeclare","TSInterfaceDeclaration","TSTypeAliasDeclaration","join","ClassDeclaration","TSDeclareFunction","TSEnumDeclaration","TSModuleDeclaration","VariableDeclaration","FunctionDeclaration","declaration","declarations","visitPattern","shouldUseUpperScope","includes","cb","visitor","PatternVisitor","visit"],"sources":["../../src/rules/no-unused-vars.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}