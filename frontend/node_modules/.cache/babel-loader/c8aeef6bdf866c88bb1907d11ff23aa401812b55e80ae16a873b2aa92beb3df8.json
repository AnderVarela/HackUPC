{"ast":null,"code":"var Marker = require('./marker');\nvar Token = require('./token');\nvar formatPosition = require('../utils/format-position');\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\nvar AT_RULES = ['@charset', '@import'];\nvar BLOCK_RULES = ['@-moz-document', '@document', '@-moz-keyframes', '@-ms-keyframes', '@-o-keyframes', '@-webkit-keyframes', '@keyframes', '@media', '@supports', '@container', '@layer'];\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean-css ignore:start \\*\\//;\nvar PAGE_MARGIN_BOXES = ['@bottom-center', '@bottom-left', '@bottom-left-corner', '@bottom-right', '@bottom-right-corner', '@left-bottom', '@left-middle', '@left-top', '@right-bottom', '@right-middle', '@right-top', '@top-center', '@top-left', '@top-left-corner', '@top-right', '@top-right-corner'];\nvar EXTRA_PAGE_BOXES = ['@footnote', '@footnotes', '@left', '@page-float-bottom', '@page-float-top', '@right'];\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar TAIL_BROKEN_VALUE_PATTERN = /([^}])\\}*$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s(]/;\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n  return intoTokens(source, externalContext, internalContext, false);\n}\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var isBufferEmpty = true;\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var characterWithNoSpecialMeaning;\n  var isPreviousDash = false;\n  var isVariable = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');\n    isVariable = isVariable || level != Level.COMMENT && !seekingValue && isPreviousDash && character === '-' && buffer.length === 1;\n    isPreviousDash = character === '-';\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n    metadata = isBufferEmpty ? [position.line, position.column, position.source] : metadata;\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (characterWithNoSpecialMeaning) {\n      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {\n      // noop\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentStart && isVariable && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within a variable, e.g. var(/*<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, -2));\n      isBufferEmpty = false;\n      buffer = buffer.slice(-2);\n      metadata = [position.line, position.column - 1, position.source];\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentEnd && isVariable) {\n      // comment end within a variable, e.g. var(/*!*/<--\n      buffer.push(character);\n      level = levels.pop();\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];\n      newTokens.push(propertyToken);\n      seekingValue = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty && isVariable && !propertyToken[2]) {\n      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {\n      // stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && !isBufferEmpty && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty && buffer[0] == Marker.AT && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && isVariable && propertyToken && !propertyToken[2]) {\n      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      roundBracketLevel--;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      isVariable = false;\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && !isBufferEmpty && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && level == Level.RULE && seekingValue && propertyToken && !isBufferEmpty) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && buffer.length == 1) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n      isBufferEmpty = buffer.length === 0;\n    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n      isBufferEmpty = false;\n    }\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n    position.line = isNewLineWin || isNewLineNix || isCarriageReturn ? position.line + 1 : position.line;\n    position.column = isNewLineWin || isNewLineNix || isCarriageReturn ? 0 : position.column + 1;\n  }\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').trimRight().replace(TAIL_BROKEN_VALUE_PATTERN, '$1').trimRight();\n    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n    buffer = [];\n  }\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n  return allTokens;\n}\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n  return externalContext.inputSourceMapTracker.isTracking(source) ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) : metadata;\n}\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  }\n  if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  }\n  if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  }\n  return Token.RULE;\n}\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  }\n  if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  }\n  if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\nmodule.exports = tokenize;","map":{"version":3,"names":["Marker","require","Token","formatPosition","Level","BLOCK","COMMENT","DOUBLE_QUOTE","RULE","SINGLE_QUOTE","AT_RULES","BLOCK_RULES","IGNORE_END_COMMENT_PATTERN","IGNORE_START_COMMENT_PATTERN","PAGE_MARGIN_BOXES","EXTRA_PAGE_BOXES","REPEAT_PATTERN","TAIL_BROKEN_VALUE_PATTERN","RULE_WORD_SEPARATOR_PATTERN","tokenize","source","externalContext","internalContext","level","position","undefined","line","column","index","intoTokens","isNested","allTokens","newTokens","lastToken","ruleToken","ruleTokens","propertyToken","metadata","metadatas","levels","buffer","buffers","isBufferEmpty","serializedBuffer","serializedBufferPart","roundBracketLevel","isQuoted","isSpace","isNewLineNix","isNewLineWin","isCarriageReturn","isCommentStart","wasCommentStart","isCommentEnd","wasCommentEnd","isCommentEndMarker","isEscaped","wasEscaped","characterWithNoSpecialMeaning","isPreviousDash","isVariable","isRaw","seekingValue","seekingPropertyBlockClosing","lastCommentStartAt","length","character","SPACE","TAB","NEW_LINE_NIX","CARRIAGE_RETURN","ASTERISK","FORWARD_SLASH","Math","max","push","slice","pop","isIgnoreStartComment","join","trim","originalMetadata","isIgnoreEndComment","lastIndexOf","substring","RAW","warnings","CLOSE_ROUND_BRACKET","OPEN_ROUND_BRACKET","SEMICOLON","AT","AT_RULE","COMMA","tokenScopeFrom","tokenTypeFrom","OPEN_CURLY_BRACKET","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY_BLOCK","isPageMarginBox","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","COLON","PROPERTY","PROPERTY_NAME","PROPERTY_VALUE","CLOSE_CURLY_BRACKET","CLOSE_SQUARE_BRACKET","isRepeatToken","BACK_SLASH","trimRight","replace","test","value","selectorFallbacks","inputSourceMapTracker","isTracking","originalPositionFor","isAtRule","UNDERSCORE","ruleWord","split","indexOf","tokenType","RULE_SCOPE","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/clean-css/lib/tokenizer/tokenize.js"],"sourcesContent":["var Marker = require('./marker');\nvar Token = require('./token');\n\nvar formatPosition = require('../utils/format-position');\n\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\n\nvar AT_RULES = [\n  '@charset',\n  '@import'\n];\n\nvar BLOCK_RULES = [\n  '@-moz-document',\n  '@document',\n  '@-moz-keyframes',\n  '@-ms-keyframes',\n  '@-o-keyframes',\n  '@-webkit-keyframes',\n  '@keyframes',\n  '@media',\n  '@supports',\n  '@container',\n  '@layer'\n];\n\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean-css ignore:start \\*\\//;\n\nvar PAGE_MARGIN_BOXES = [\n  '@bottom-center',\n  '@bottom-left',\n  '@bottom-left-corner',\n  '@bottom-right',\n  '@bottom-right-corner',\n  '@left-bottom',\n  '@left-middle',\n  '@left-top',\n  '@right-bottom',\n  '@right-middle',\n  '@right-top',\n  '@top-center',\n  '@top-left',\n  '@top-left-corner',\n  '@top-right',\n  '@top-right-corner'\n];\n\nvar EXTRA_PAGE_BOXES = [\n  '@footnote',\n  '@footnotes',\n  '@left',\n  '@page-float-bottom',\n  '@page-float-top',\n  '@right'\n];\n\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar TAIL_BROKEN_VALUE_PATTERN = /([^}])\\}*$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s(]/;\n\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n\n  return intoTokens(source, externalContext, internalContext, false);\n}\n\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var isBufferEmpty = true;\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var characterWithNoSpecialMeaning;\n  var isPreviousDash = false;\n  var isVariable = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX\n      && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN\n      && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd\n      && level != Level.COMMENT && !isQuoted\n      && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart\n      && !isQuoted && character == Marker.FORWARD_SLASH\n      && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');\n    isVariable = isVariable || (level != Level.COMMENT && !seekingValue && isPreviousDash && character === '-' && buffer.length === 1);\n    isPreviousDash = character === '-';\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n\n    metadata = isBufferEmpty\n      ? [position.line, position.column, position.source]\n      : metadata;\n\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (characterWithNoSpecialMeaning) {\n      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {\n      // noop\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentStart\n        && isVariable\n        && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within a variable, e.g. var(/*<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, -2));\n      isBufferEmpty = false;\n\n      buffer = buffer.slice(-2);\n      metadata = [position.line, position.column - 1, position.source];\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentEnd && isVariable) {\n      // comment end within a variable, e.g. var(/*!*/<--\n      buffer.push(character);\n      level = levels.pop();\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [\n        Token.COMMENT,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [\n        Token.RAW,\n        serializedBufferPart,\n        [originalMetadata(metadata, serializedBufferPart, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [\n        Token.COMMENT,\n        serializedBufferPart,\n        [originalMetadata(metadata, serializedBufferPart, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [\n        Token.COMMENT,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character != Marker.CLOSE_ROUND_BRACKET\n      && character != Marker.OPEN_ROUND_BRACKET\n      && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET\n      && !isQuoted && level != Level.COMMENT\n      && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET\n      && !isQuoted\n      && level != Level.COMMENT\n      && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, 0)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET\n      && level == Level.BLOCK\n      && ruleToken\n      && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        Token.NESTED_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET\n      && level == Level.BLOCK\n      && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([\n        Token.NESTED_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]\n      ]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([\n        Token.AT_RULE_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [\n        Token.PROPERTY,\n        [\n          Token.PROPERTY_NAME,\n          serializedBuffer,\n          [originalMetadata(metadata, serializedBuffer, externalContext)]\n        ]\n      ];\n      newTokens.push(propertyToken);\n\n      seekingValue = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && propertyToken\n      && ruleTokens.length > 0\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && propertyToken\n      && isBufferEmpty\n      && isVariable\n      && !propertyToken[2]) {\n      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {\n      // stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && seekingValue\n      && !isBufferEmpty && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT\n      && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && !isBufferEmpty) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && isVariable\n      && propertyToken\n      && !propertyToken[2]) {\n      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.BLOCK\n      && !isNested\n      && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET\n      && level == Level.RULE\n      && seekingValue\n      && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      roundBracketLevel--;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      isVariable = false;\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH\n      && source[position.index + 1] != Marker.ASTERISK\n      && level == Level.RULE\n      && seekingValue\n      && !isBufferEmpty) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.FORWARD_SLASH\n      && source[position.index + 1] != Marker.ASTERISK\n      && level == Level.RULE\n      && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET\n      && propertyToken\n      && propertyToken.length > 1\n      && !isBufferEmpty\n      && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if ((isSpace || (isNewLineNix && !isNewLineWin))\n      && level == Level.RULE\n      && seekingValue\n      && propertyToken\n      && !isBufferEmpty) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && buffer.length == 1) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n      isBufferEmpty = buffer.length === 0;\n    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n      isBufferEmpty = false;\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n\n    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;\n    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;\n  }\n\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').trimRight().replace(TAIL_BROKEN_VALUE_PATTERN, '$1').trimRight();\n    propertyToken.push([\n      Token.PROPERTY_VALUE,\n      serializedBuffer,\n      [originalMetadata(metadata, serializedBuffer, externalContext)]\n    ]);\n\n    buffer = [];\n  }\n\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n\n  return allTokens;\n}\n\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n\n  return externalContext.inputSourceMapTracker.isTracking(source)\n    ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks)\n    : metadata;\n}\n\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  } if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  } if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  }\n  return Token.RULE;\n}\n\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  } if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  } if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\n\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\n\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\n\nmodule.exports = tokenize;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}