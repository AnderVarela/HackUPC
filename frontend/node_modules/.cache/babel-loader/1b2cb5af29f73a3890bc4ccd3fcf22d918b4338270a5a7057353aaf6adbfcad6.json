{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-magic-numbers');\n// Extend base schema with additional property to ignore TS numeric literal types\nconst schema = util.deepMerge(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002\nArray.isArray(baseRule.meta.schema) ? baseRule.meta.schema[0] : baseRule.meta.schema, {\n  properties: {\n    ignoreNumericLiteralTypes: {\n      type: 'boolean'\n    },\n    ignoreEnums: {\n      type: 'boolean'\n    },\n    ignoreReadonlyClassProperties: {\n      type: 'boolean'\n    },\n    ignoreTypeIndexes: {\n      type: 'boolean'\n    }\n  }\n});\nexports.default = util.createRule({\n  name: 'no-magic-numbers',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow magic numbers',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    schema: [schema],\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: [{\n    ignore: [],\n    ignoreArrayIndexes: false,\n    enforceConst: false,\n    detectObjects: false,\n    ignoreNumericLiteralTypes: false,\n    ignoreEnums: false,\n    ignoreReadonlyClassProperties: false\n  }],\n  create(context, [options]) {\n    const rules = baseRule.create(context);\n    return {\n      Literal(node) {\n        var _a;\n        // If it’s not a numeric literal we’re not interested\n        if (typeof node.value !== 'number' && typeof node.value !== 'bigint') {\n          return;\n        }\n        // This will be `true` if we’re configured to ignore this case (eg. it’s\n        // an enum and `ignoreEnums` is `true`). It will be `false` if we’re not\n        // configured to ignore this case. It will remain `undefined` if this is\n        // not one of our exception cases, and we’ll fall back to the base rule.\n        let isAllowed;\n        // Check if the node is a TypeScript enum declaration\n        if (isParentTSEnumDeclaration(node)) {\n          isAllowed = options.ignoreEnums === true;\n        }\n        // Check TypeScript specific nodes for Numeric Literal\n        else if (isTSNumericLiteralType(node)) {\n          isAllowed = options.ignoreNumericLiteralTypes === true;\n        }\n        // Check if the node is a type index\n        else if (isAncestorTSIndexedAccessType(node)) {\n          isAllowed = options.ignoreTypeIndexes === true;\n        }\n        // Check if the node is a readonly class property\n        else if (isParentTSReadonlyPropertyDefinition(node)) {\n          isAllowed = options.ignoreReadonlyClassProperties === true;\n        }\n        // If we’ve hit a case where the ignore option is true we can return now\n        if (isAllowed === true) {\n          return;\n        }\n        // If the ignore option is *not* set we can report it now\n        else if (isAllowed === false) {\n          let fullNumberNode = node;\n          let raw = node.raw;\n          if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression &&\n          // the base rule only shows the operator for negative numbers\n          // https://github.com/eslint/eslint/blob/9dfc8501fb1956c90dc11e6377b4cb38a6bea65d/lib/rules/no-magic-numbers.js#L126\n          node.parent.operator === '-') {\n            fullNumberNode = node.parent;\n            raw = `${node.parent.operator}${node.raw}`;\n          }\n          context.report({\n            messageId: 'noMagic',\n            node: fullNumberNode,\n            data: {\n              raw\n            }\n          });\n          return;\n        }\n        // Let the base rule deal with the rest\n        rules.Literal(node);\n      }\n    };\n  }\n});\n/**\n * Gets the true parent of the literal, handling prefixed numbers (-1 / +1)\n */\nfunction getLiteralParent(node) {\n  var _a;\n  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression && ['-', '+'].includes(node.parent.operator)) {\n    return node.parent.parent;\n  }\n  return node.parent;\n}\n/**\n * Checks if the node grandparent is a Typescript type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript type alias declaration\n * @private\n */\nfunction isGrandparentTSTypeAliasDeclaration(node) {\n  var _a, _b;\n  return ((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n}\n/**\n * Checks if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @private\n */\nfunction isGrandparentTSUnionType(node) {\n  var _a, _b;\n  if (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSUnionType) {\n    return isGrandparentTSTypeAliasDeclaration(node.parent);\n  }\n  return false;\n}\n/**\n * Checks if the node parent is a Typescript enum member\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript enum member\n * @private\n */\nfunction isParentTSEnumDeclaration(node) {\n  const parent = getLiteralParent(node);\n  return (parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.TSEnumMember;\n}\n/**\n * Checks if the node parent is a Typescript literal type\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript literal type\n * @private\n */\nfunction isParentTSLiteralType(node) {\n  var _a;\n  return ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSLiteralType;\n}\n/**\n * Checks if the node is a valid TypeScript numeric literal type.\n * @param node the node to be validated.\n * @returns true if the node is a TypeScript numeric literal type.\n * @private\n */\nfunction isTSNumericLiteralType(node) {\n  var _a;\n  // For negative numbers, use the parent node\n  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression && node.parent.operator === '-') {\n    node = node.parent;\n  }\n  // If the parent node is not a TSLiteralType, early return\n  if (!isParentTSLiteralType(node)) {\n    return false;\n  }\n  // If the grandparent is a TSTypeAliasDeclaration, ignore\n  if (isGrandparentTSTypeAliasDeclaration(node)) {\n    return true;\n  }\n  // If the grandparent is a TSUnionType and it's parent is a TSTypeAliasDeclaration, ignore\n  if (isGrandparentTSUnionType(node)) {\n    return true;\n  }\n  return false;\n}\n/**\n * Checks if the node parent is a readonly class property\n * @param node the node to be validated.\n * @returns true if the node parent is a readonly class property\n * @private\n */\nfunction isParentTSReadonlyPropertyDefinition(node) {\n  const parent = getLiteralParent(node);\n  if ((parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.PropertyDefinition && parent.readonly) {\n    return true;\n  }\n  return false;\n}\n/**\n * Checks if the node is part of a type indexed access (eg. Foo[4])\n * @param node the node to be validated.\n * @returns true if the node is part of an indexed access\n * @private\n */\nfunction isAncestorTSIndexedAccessType(node) {\n  var _a, _b, _c;\n  // Handle unary expressions (eg. -4)\n  let ancestor = getLiteralParent(node);\n  // Go up another level while we’re part of a type union (eg. 1 | 2) or\n  // intersection (eg. 1 & 2)\n  while (((_a = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSUnionType || ((_b = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n    ancestor = ancestor.parent;\n  }\n  return ((_c = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _c === void 0 ? void 0 : _c.type) === utils_1.AST_NODE_TYPES.TSIndexedAccessType;\n}","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","schema","deepMerge","Array","isArray","meta","properties","ignoreNumericLiteralTypes","type","ignoreEnums","ignoreReadonlyClassProperties","ignoreTypeIndexes","exports","default","createRule","name","docs","description","recommended","extendsBaseRule","messages","defaultOptions","ignore","ignoreArrayIndexes","enforceConst","detectObjects","create","context","options","rules","Literal","node","value","isAllowed","isParentTSEnumDeclaration","isTSNumericLiteralType","isAncestorTSIndexedAccessType","isParentTSReadonlyPropertyDefinition","fullNumberNode","raw","_a","parent","AST_NODE_TYPES","UnaryExpression","operator","report","messageId","data","getLiteralParent","includes","isGrandparentTSTypeAliasDeclaration","_b","TSTypeAliasDeclaration","isGrandparentTSUnionType","TSUnionType","TSEnumMember","isParentTSLiteralType","TSLiteralType","PropertyDefinition","readonly","ancestor","TSIntersectionType","_c","TSIndexedAccessType"],"sources":["../../src/rules/no-magic-numbers.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}