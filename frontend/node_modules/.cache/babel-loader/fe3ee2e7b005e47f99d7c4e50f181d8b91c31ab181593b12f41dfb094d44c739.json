{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.getTopFrame = exports.getStackTraceLines = exports.formatStackTrace = exports.formatResultsErrors = exports.formatExecError = void 0;\nvar path = _interopRequireWildcard(require('path'));\nvar _url = require('url');\nvar _codeFrame = require('@babel/code-frame');\nvar _chalk = _interopRequireDefault(require('chalk'));\nvar fs = _interopRequireWildcard(require('graceful-fs'));\nvar _micromatch = _interopRequireDefault(require('micromatch'));\nvar _slash = _interopRequireDefault(require('slash'));\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\nvar _prettyFormat = require('pretty-format');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n// stack utils tries to create pretty stack by making paths relative.\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\nconst indentAllLines = (lines, indent) => lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\nconst trimPaths = string => string.match(STACK_PATH_REGEXP) ? trim(string) : string;\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column,\n      line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\nconst blankStringRegexp = /^\\s*$/;\nfunction checkForCommonEnvironmentErrors(error) {\n  if (error.includes('ReferenceError: document is not defined') || error.includes('ReferenceError: window is not defined') || error.includes('ReferenceError: navigator is not defined')) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n  return error;\n}\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return _chalk.default.bold.red(`The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline('https://jestjs.io/docs/configuration#testenvironment-string')}.\\nConsider using the \"${env}\" test environment.\\n\\n`) + error;\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n  let message, stack;\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = typeof error.stack === 'string' ? error.stack : `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack = stack && !options.noStackTrace ? '\\n' + formatStackTrace(stack, config, options, testPath) : '';\n  if (typeof stack !== 'string' || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n  let messageToUse;\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\nexports.formatExecError = formatExecError;\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n    if (options.noStackTrace) {\n      return false;\n    }\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n    return true;\n  });\n};\nconst formatPaths = (config, relativeTestPath, line) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n  if (!match) {\n    return line;\n  }\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (config.testMatch && config.testMatch.length && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\nconst getStackTraceLines = (stack, options = {\n  noCodeFrame: false,\n  noStackTrace: false\n}) => removeInternalStackEntries(stack.split(/\\n/), options);\nexports.getStackTraceLines = getStackTraceLines;\nconst getTopFrame = lines => {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n    const parsedFrame = stackUtils.parseLine(line.trim());\n    if (parsedFrame && parsedFrame.file) {\n      if (parsedFrame.file.startsWith('file://')) {\n        parsedFrame.file = (0, _slash.default)((0, _url.fileURLToPath)(parsedFrame.file));\n      }\n      return parsedFrame;\n    }\n  }\n  return null;\n};\nexports.getTopFrame = getTopFrame;\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n    if (topFrame) {\n      const {\n        column,\n        file: filename,\n        line\n      } = topFrame;\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {\n          // the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n  const stacktrace = lines.filter(Boolean).map(line => STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))).join('\\n');\n  return renderedCallsite ? `${renderedCallsite}\\n${stacktrace}` : `\\n${stacktrace}`;\n};\nexports.formatStackTrace = formatStackTrace;\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.forEach(item => {\n      errors.push({\n        content: checkForCommonEnvironmentErrors(item),\n        result\n      });\n    });\n    return errors;\n  }, []);\n  if (!failedResults.length) {\n    return null;\n  }\n  return failedResults.map(({\n    result,\n    content\n  }) => {\n    let {\n      message,\n      stack\n    } = separateMessageFromStack(content);\n    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\\n';\n    message = indentAllLines(message, MESSAGE_INDENT);\n    const title = _chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\\n';\n    return title + '\\n' + message + '\\n' + stack;\n  }).join('\\n');\n};\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\nconst removeBlankErrorLine = str => str.split('\\n') // Lines saying just `Error:` are useless\n.filter(line => !errorRegexp.test(line)).join('\\n').trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n  const messageMatch = content.match(/^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/);\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\nexports.separateMessageFromStack = separateMessageFromStack;","map":{"version":3,"names":["Object","defineProperty","exports","value","separateMessageFromStack","getTopFrame","getStackTraceLines","formatStackTrace","formatResultsErrors","formatExecError","path","_interopRequireWildcard","require","_url","_codeFrame","_chalk","_interopRequireDefault","fs","_micromatch","_slash","_stackUtils","_prettyFormat","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","global","globalThis","self","window","Function","Symbol","jestReadFile","for","readFileSync","stackUtils","cwd","nodeInternals","PATH_NODE_MODULES","sep","PATH_JEST_PACKAGES","JASMINE_IGNORE","JEST_INTERNALS_IGNORE","ANONYMOUS_FN_IGNORE","ANONYMOUS_PROMISE_IGNORE","ANONYMOUS_GENERATOR_IGNORE","NATIVE_NEXT_IGNORE","TITLE_INDENT","MESSAGE_INDENT","STACK_INDENT","ANCESTRY_SEPARATOR","TITLE_BULLET","bold","STACK_TRACE_COLOR","dim","STACK_PATH_REGEXP","EXEC_ERROR_MESSAGE","NOT_EMPTY_LINE_REGEXP","indentAllLines","lines","indent","replace","trim","string","trimPaths","match","getRenderedCallsite","fileContent","line","column","renderedCallsite","codeFrameColumns","start","highlightCode","blankStringRegexp","checkForCommonEnvironmentErrors","error","includes","warnAboutWrongTestEnvironment","env","red","underline","config","options","testPath","reuseMessage","Error","String","stack","message","format","maxDepth","separated","noStackTrace","test","messageToUse","removeInternalStackEntries","pathCounter","filter","some","internal","formatPaths","relativeTestPath","filePath","relative","rootDir","testMatch","length","reset","cyan","noCodeFrame","split","parsedFrame","parseLine","file","startsWith","fileURLToPath","topFrame","filename","isAbsolute","stacktrace","Boolean","map","join","testResults","failedResults","reduce","errors","result","failureMessages","forEach","item","push","content","title","ancestorTitles","errorRegexp","removeBlankErrorLine","str","trimRight","messageMatch"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/console/node_modules/jest-message-util/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack =\n  exports.getTopFrame =\n  exports.getStackTraceLines =\n  exports.formatStackTrace =\n  exports.formatResultsErrors =\n  exports.formatExecError =\n    void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _url = require('url');\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = require('pretty-format');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar jestReadFile =\n  global[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n// stack utils tries to create pretty stack by making paths relative.\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE =\n  /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE =\n  /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = (lines, indent) =>\n  lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\nconst trimPaths = string =>\n  string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(\n    fileContent,\n    {\n      start: {\n        column,\n        line\n      }\n    },\n    {\n      highlightCode: true\n    }\n  );\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (\n    error.includes('ReferenceError: document is not defined') ||\n    error.includes('ReferenceError: window is not defined') ||\n    error.includes('ReferenceError: navigator is not defined')\n  ) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return (\n    _chalk.default.bold.red(\n      `The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline(\n        'https://jestjs.io/docs/configuration#testenvironment-string'\n      )}.\\nConsider using the \"${env}\" test environment.\\n\\n`\n    ) + error\n  );\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack =\n      typeof error.stack === 'string'\n        ? error.stack\n        : `thrown: ${(0, _prettyFormat.format)(error, {\n            maxDepth: 3\n          })}`;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack =\n    stack && !options.noStackTrace\n      ? '\\n' + formatStackTrace(stack, config, options, testPath)\n      : '';\n\n  if (\n    typeof stack !== 'string' ||\n    (blankStringRegexp.test(message) && blankStringRegexp.test(stack))\n  ) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${(0, _prettyFormat.format)(error, {\n      maxDepth: 3\n    })}`;\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPaths = (config, relativeTestPath, line) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (\n    (config.testMatch &&\n      config.testMatch.length &&\n      (0, _micromatch.default)([filePath], config.testMatch).length > 0) ||\n    filePath === relativeTestPath\n  ) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nconst getStackTraceLines = (\n  stack,\n  options = {\n    noCodeFrame: false,\n    noStackTrace: false\n  }\n) => removeInternalStackEntries(stack.split(/\\n/), options);\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n\n    const parsedFrame = stackUtils.parseLine(line.trim());\n\n    if (parsedFrame && parsedFrame.file) {\n      if (parsedFrame.file.startsWith('file://')) {\n        parsedFrame.file = (0, _slash.default)(\n          (0, _url.fileURLToPath)(parsedFrame.file)\n        );\n      }\n\n      return parsedFrame;\n    }\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath\n    ? (0, _slash.default)(path.relative(config.rootDir, testPath))\n    : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      const {column, file: filename, line} = topFrame;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {\n          // the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines\n    .filter(Boolean)\n    .map(\n      line =>\n        STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))\n    )\n    .join('\\n');\n  return renderedCallsite\n    ? `${renderedCallsite}\\n${stacktrace}`\n    : `\\n${stacktrace}`;\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.forEach(item => {\n      errors.push({\n        content: checkForCommonEnvironmentErrors(item),\n        result\n      });\n    });\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults\n    .map(({result, content}) => {\n      let {message, stack} = separateMessageFromStack(content);\n      stack = options.noStackTrace\n        ? ''\n        : STACK_TRACE_COLOR(\n            formatStackTrace(stack, config, options, testPath)\n          ) + '\\n';\n      message = indentAllLines(message, MESSAGE_INDENT);\n      const title =\n        _chalk.default.bold.red(\n          TITLE_INDENT +\n            TITLE_BULLET +\n            result.ancestorTitles.join(ANCESTRY_SEPARATOR) +\n            (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') +\n            result.title\n        ) + '\\n';\n      return title + '\\n' + message + '\\n' + stack;\n    })\n    .join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str =>\n  str\n    .split('\\n') // Lines saying just `Error:` are useless\n    .filter(line => !errorRegexp.test(line))\n    .join('\\n')\n    .trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n  const messageMatch = content.match(\n    /^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/\n  );\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}