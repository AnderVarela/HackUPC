{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dynamicRef = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst ref_1 = require(\"../core/ref\");\nconst def = {\n  keyword: \"$dynamicRef\",\n  schemaType: \"string\",\n  code: cxt => dynamicRef(cxt, cxt.schema)\n};\nfunction dynamicRef(cxt, ref) {\n  const {\n    gen,\n    keyword,\n    it\n  } = cxt;\n  if (ref[0] !== \"#\") throw new Error(`\"${keyword}\" only supports hash fragment reference`);\n  const anchor = ref.slice(1);\n  if (it.allErrors) {\n    _dynamicRef();\n  } else {\n    const valid = gen.let(\"valid\", false);\n    _dynamicRef(valid);\n    cxt.ok(valid);\n  }\n  function _dynamicRef(valid) {\n    // TODO the assumption here is that `recursiveRef: #` always points to the root\n    // of the schema object, which is not correct, because there may be $id that\n    // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n    // Because of that 2 tests in recursiveRef.json fail.\n    // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n    // (This problem is not tested in JSON-Schema-Test-Suite)\n    if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n      const v = gen.let(\"_v\", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);\n      gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));\n    } else {\n      _callRef(it.validateName, valid)();\n    }\n  }\n  function _callRef(validate, valid) {\n    return valid ? () => gen.block(() => {\n      (0, ref_1.callRef)(cxt, validate);\n      gen.let(valid, true);\n    }) : () => (0, ref_1.callRef)(cxt, validate);\n  }\n}\nexports.dynamicRef = dynamicRef;\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","names_1","ref_1","def","keyword","schemaType","code","cxt","dynamicRef","schema","ref","gen","it","Error","anchor","slice","allErrors","_dynamicRef","valid","let","ok","schemaEnv","root","dynamicAnchors","v","_","default","getProperty","if","_callRef","validateName","validate","block","callRef","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\dynamic\\dynamicRef.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {callRef} from \"../core/ref\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$dynamicRef\",\n  schemaType: \"string\",\n  code: (cxt) => dynamicRef(cxt, cxt.schema),\n}\n\nexport function dynamicRef(cxt: KeywordCxt, ref: string): void {\n  const {gen, keyword, it} = cxt\n  if (ref[0] !== \"#\") throw new Error(`\"${keyword}\" only supports hash fragment reference`)\n  const anchor = ref.slice(1)\n  if (it.allErrors) {\n    _dynamicRef()\n  } else {\n    const valid = gen.let(\"valid\", false)\n    _dynamicRef(valid)\n    cxt.ok(valid)\n  }\n\n  function _dynamicRef(valid?: Name): void {\n    // TODO the assumption here is that `recursiveRef: #` always points to the root\n    // of the schema object, which is not correct, because there may be $id that\n    // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n    // Because of that 2 tests in recursiveRef.json fail.\n    // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n    // (This problem is not tested in JSON-Schema-Test-Suite)\n    if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n      const v = gen.let(\"_v\", _`${N.dynamicAnchors}${getProperty(anchor)}`)\n      gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid))\n    } else {\n      _callRef(it.validateName, valid)()\n    }\n  }\n\n  function _callRef(validate: Code, valid?: Name): () => void {\n    return valid\n      ? () =>\n          gen.block(() => {\n            callRef(cxt, validate)\n            gen.let(valid, true)\n          })\n      : () => callRef(cxt, validate)\n  }\n}\n\nexport default def\n"],"mappings":";;;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,KAAA,GAAAF,OAAA;AAEA,MAAMG,GAAG,GAA0B;EACjCC,OAAO,EAAE,aAAa;EACtBC,UAAU,EAAE,QAAQ;EACpBC,IAAI,EAAGC,GAAG,IAAKC,UAAU,CAACD,GAAG,EAAEA,GAAG,CAACE,MAAM;CAC1C;AAED,SAAgBD,UAAUA,CAACD,GAAe,EAAEG,GAAW;EACrD,MAAM;IAACC,GAAG;IAAEP,OAAO;IAAEQ;EAAE,CAAC,GAAGL,GAAG;EAC9B,IAAIG,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,MAAM,IAAIG,KAAK,CAAC,IAAIT,OAAO,yCAAyC,CAAC;EACzF,MAAMU,MAAM,GAAGJ,GAAG,CAACK,KAAK,CAAC,CAAC,CAAC;EAC3B,IAAIH,EAAE,CAACI,SAAS,EAAE;IAChBC,WAAW,EAAE;EACf,CAAC,MAAM;IACL,MAAMC,KAAK,GAAGP,GAAG,CAACQ,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC;IACrCF,WAAW,CAACC,KAAK,CAAC;IAClBX,GAAG,CAACa,EAAE,CAACF,KAAK,CAAC;EACf;EAEA,SAASD,WAAWA,CAACC,KAAY;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA,IAAIN,EAAE,CAACS,SAAS,CAACC,IAAI,CAACC,cAAc,CAACT,MAAM,CAAC,EAAE;MAC5C,MAAMU,CAAC,GAAGb,GAAG,CAACQ,GAAG,CAAC,IAAI,EAAE,IAAApB,SAAA,CAAA0B,CAAC,IAAGxB,OAAA,CAAAyB,OAAC,CAACH,cAAc,GAAG,IAAAxB,SAAA,CAAA4B,WAAW,EAACb,MAAM,CAAC,EAAE,CAAC;MACrEH,GAAG,CAACiB,EAAE,CAACJ,CAAC,EAAEK,QAAQ,CAACL,CAAC,EAAEN,KAAK,CAAC,EAAEW,QAAQ,CAACjB,EAAE,CAACkB,YAAY,EAAEZ,KAAK,CAAC,CAAC;IACjE,CAAC,MAAM;MACLW,QAAQ,CAACjB,EAAE,CAACkB,YAAY,EAAEZ,KAAK,CAAC,EAAE;IACpC;EACF;EAEA,SAASW,QAAQA,CAACE,QAAc,EAAEb,KAAY;IAC5C,OAAOA,KAAK,GACR,MACEP,GAAG,CAACqB,KAAK,CAAC,MAAK;MACb,IAAA9B,KAAA,CAAA+B,OAAO,EAAC1B,GAAG,EAAEwB,QAAQ,CAAC;MACtBpB,GAAG,CAACQ,GAAG,CAACD,KAAK,EAAE,IAAI,CAAC;IACtB,CAAC,CAAC,GACJ,MAAM,IAAAhB,KAAA,CAAA+B,OAAO,EAAC1B,GAAG,EAAEwB,QAAQ,CAAC;EAClC;AACF;AApCAG,OAAA,CAAA1B,UAAA,GAAAA,UAAA;AAsCA0B,OAAA,CAAAR,OAAA,GAAevB,GAAG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}