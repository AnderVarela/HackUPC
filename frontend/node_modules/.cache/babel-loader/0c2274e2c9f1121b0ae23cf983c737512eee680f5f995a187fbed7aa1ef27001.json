{"ast":null,"code":"import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\nfunction resolve(input, base) {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n  return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const {\n    lastKey,\n    lastNeedle,\n    lastIndex\n  } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(buildNullArray);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      const memo = memos[sourceIndex];\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  return sources;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n  return {\n    __proto__: null\n  };\n}\nconst AnyMap = function (map, mapUrl) {\n  const parsed = parse(map);\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction parse(map) {\n  return typeof map === 'string' ? JSON.parse(map) : map;\n}\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const {\n    sections\n  } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const {\n      map,\n      offset\n    } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const {\n    resolvedSources,\n    sourcesContent: contents,\n    ignoreList: ignores\n  } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\nclass TraceMap {\n  constructor(map, mapUrl) {\n    const isString = typeof map === 'string';\n    if (!isString && map._decodedMemo) return map;\n    const parsed = isString ? JSON.parse(map) : map;\n    const {\n      version,\n      file,\n      names,\n      sourceRoot,\n      sources,\n      sourcesContent\n    } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map(s => resolve(s || '', from));\n    const {\n      mappings\n    } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n  return map;\n}\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nfunction encodedMappings(map) {\n  var _a;\n  var _b;\n  return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = encode(cast(map)._decoded);\n}\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));\n}\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n  return index === -1 ? null : segments[index];\n}\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nfunction originalPositionFor(map, needle) {\n  let {\n    line,\n    column,\n    bias\n  } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nfunction generatedPositionFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nfunction allGeneratedPositionsFor(map, needle) {\n  const {\n    source,\n    line,\n    column,\n    bias\n  } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n/**\n * Iterates each mapping in generated position order.\n */\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const {\n    names,\n    resolvedSources\n  } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nfunction sourceContentFor(map, source) {\n  const {\n    sourcesContent\n  } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nfunction isIgnored(map, source) {\n  const {\n    ignoreList\n  } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return {\n    source,\n    line,\n    column,\n    name\n  };\n}\nfunction GMapping(line, column) {\n  return {\n    line,\n    column\n  };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const {\n    sources,\n    resolvedSources\n  } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n  const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = cast(map)._bySourceMemos[sourceIndex];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, isIgnored, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":{"version":3,"names":["resolve","input","base","endsWith","resolveUri","stripFilename","path","index","lastIndexOf","slice","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","AnyMap","mapUrl","parsed","parse","TraceMap","sourcesContent","names","ignoreList","recurse","Infinity","joined","version","file","presortedDecodedMap","JSON","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","ignores","append","push","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","constructor","isString","_decodedMemo","sourceRoot","x_google_ignoreList","undefined","from","s","_encoded","_decoded","_bySources","_bySourceMemos","cast","encodedMappings","_a","_b","encode","decode","traceSegment","segments","traceSegmentInternal","originalPositionFor","bias","Error","OMapping","segment","generatedPositionFor","source","generatedPosition","allGeneratedPositionsFor","eachMapping","cb","generatedLine","generatedColumn","originalColumn","name","indexOf","sourceContentFor","isIgnored","includes","tracer","clone","decodedMap","encodedMap","GMapping","sliceGeneratedPositions","matchedColumn","max","result","all","generated"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\resolve.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\strip-filename.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sourcemap-segment.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sort.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\binary-search.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\by-source.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\any-map.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\trace-mapping.ts"],"sourcesContent":["import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      let index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  DecodedSourceMap,\n  DecodedSourceMapXInput,\n  EncodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionedSourceMapInput,\n  SectionXInput,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed = parse(map);\n\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\n  }\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const ignoreList: number[] = [];\n\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity,\n  );\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction parse<T>(map: T): Exclude<T, string> {\n  return typeof map === 'string' ? JSON.parse(map) : map;\n}\n\nfunction recurse(\n  input: SectionedSourceMapXInput,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: SectionXInput['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n  XInput,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMap,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Section,\n  SectionedSourceMap,\n  SourceMapV3,\n  Bias,\n  EachMapping,\n  GeneratedMapping,\n  InvalidGeneratedMapping,\n  InvalidOriginalMapping,\n  Needle,\n  OriginalMapping,\n  OriginalMapping as Mapping,\n  SectionedSourceMapInput,\n  SourceMapInput,\n  SourceNeedle,\n  XInput,\n  EncodedSourceMapXInput,\n  DecodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionXInput,\n} from './types';\n\ninterface PublicMap {\n  _encoded: TraceMap['_encoded'];\n  _decoded: TraceMap['_decoded'];\n  _decodedMemo: TraceMap['_decodedMemo'];\n  _bySources: TraceMap['_bySources'];\n  _bySourceMemos: TraceMap['_bySourceMemos'];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\n}\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\n}\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport function traceSegment(\n  map: TraceMap,\n  line: number,\n  column: number,\n): Readonly<SourceMapSegment> | null {\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND,\n  );\n\n  return index === -1 ? null : segments[index];\n}\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport function originalPositionFor(\n  map: TraceMap,\n  needle: Needle,\n): OriginalMapping | InvalidOriginalMapping {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND,\n  );\n\n  if (index === -1) return OMapping(null, null, null, null);\n\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n  );\n}\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport function generatedPositionFor(\n  map: TraceMap,\n  needle: SourceNeedle,\n): GeneratedMapping | InvalidGeneratedMapping {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\n  const { source, line, column, bias } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name,\n      } as EachMapping);\n    }\n  }\n}\n\nfunction sourceIndex(map: TraceMap, source: string): number {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nexport function isIgnored(map: TraceMap, source: string): boolean {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function decodedMap(\n  map: TraceMap,\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\n  return clone(map, decodedMappings(map));\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\n  return clone(map, encodedMappings(map));\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: false,\n): GeneratedMapping | InvalidGeneratedMapping;\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: true,\n): GeneratedMapping[];\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: boolean,\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const { sources, resolvedSources } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n  const generated = (cast(map)._bySources ||= buildBySources(\n    decodedMappings(map),\n    (cast(map)._bySourceMemos = sources.map(memoizedState)),\n  ));\n\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n\n  const memo = cast(map)._bySourceMemos![sourceIndex];\n\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}