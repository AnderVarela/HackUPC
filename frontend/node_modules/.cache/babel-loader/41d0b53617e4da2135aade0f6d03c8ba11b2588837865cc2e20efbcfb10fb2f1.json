{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\nconst eventify = require('./eventify');\nconst events = require('./events');\nconst JsonStream = require('./jsonstream');\nconst Hoopy = require('hoopy');\nconst promise = require('./promise');\nconst tryer = require('tryer');\nconst DEFAULT_BUFFER_LENGTH = 1024;\nmodule.exports = streamify;\n\n/**\n * Public function `streamify`.\n *\n * Asynchronously serialises a data structure to a stream of JSON\n * data. Sanely handles promises, buffers, maps and other iterables.\n *\n * @param data:           The data to transform.\n *\n * @option space:         Indentation string, or the number of spaces\n *                        to indent each nested level by.\n *\n * @option promises:      'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:       'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:          'object' or 'ignore', default is 'object'.\n *\n * @option iterables:     'array' or 'ignore', default is 'array'.\n *\n * @option circular:      'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction streamify(data, options = {}) {\n  const emitter = eventify(data, options);\n  const json = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH);\n  const Promise = promise(options);\n  const space = normaliseSpace(options);\n  let streamOptions;\n  const {\n    highWaterMark\n  } = options;\n  if (highWaterMark) {\n    streamOptions = {\n      highWaterMark\n    };\n  }\n  const stream = new JsonStream(read, streamOptions);\n  let awaitPush = true;\n  let index = 0;\n  let indentation = '';\n  let isEnded;\n  let isPaused = false;\n  let isProperty;\n  let length = 0;\n  let mutex = Promise.resolve();\n  let needsComma;\n  emitter.on(events.array, noRacing(array));\n  emitter.on(events.object, noRacing(object));\n  emitter.on(events.property, noRacing(property));\n  emitter.on(events.string, noRacing(string));\n  emitter.on(events.number, noRacing(value));\n  emitter.on(events.literal, noRacing(value));\n  emitter.on(events.endArray, noRacing(endArray));\n  emitter.on(events.endObject, noRacing(endObject));\n  emitter.on(events.end, noRacing(end));\n  emitter.on(events.error, noRacing(error));\n  emitter.on(events.dataError, noRacing(dataError));\n  return stream;\n  function read() {\n    if (awaitPush) {\n      awaitPush = false;\n      if (isEnded) {\n        if (length > 0) {\n          after();\n        }\n        return endStream();\n      }\n    }\n    if (isPaused) {\n      after();\n    }\n  }\n  function after() {\n    if (awaitPush) {\n      return;\n    }\n    let i;\n    for (i = 0; i < length && !awaitPush; ++i) {\n      if (!stream.push(json[i + index], 'utf8')) {\n        awaitPush = true;\n      }\n    }\n    if (i === length) {\n      index = length = 0;\n    } else {\n      length -= i;\n      index += i;\n    }\n  }\n  function endStream() {\n    if (!awaitPush) {\n      stream.push(null);\n    }\n  }\n  function noRacing(handler) {\n    return eventData => mutex = mutex.then(() => handler(eventData));\n  }\n  function array() {\n    return beforeScope().then(() => addJson('[')).then(() => afterScope());\n  }\n  function beforeScope() {\n    return before(true);\n  }\n  function before(isScope) {\n    if (isProperty) {\n      isProperty = false;\n      if (space) {\n        return addJson(' ');\n      }\n      return Promise.resolve();\n    }\n    return Promise.resolve().then(() => {\n      if (needsComma) {\n        if (isScope) {\n          needsComma = false;\n        }\n        return addJson(',');\n      }\n      if (!isScope) {\n        needsComma = true;\n      }\n    }).then(() => {\n      if (space && indentation) {\n        return indent();\n      }\n    });\n  }\n  function addJson(chunk) {\n    if (length + 1 <= json.length) {\n      json[index + length++] = chunk;\n      after();\n      return Promise.resolve();\n    }\n    isPaused = true;\n    return new Promise(resolve => {\n      const unpause = emitter.pause();\n      tryer({\n        interval: -10,\n        until() {\n          return length + 1 <= json.length;\n        },\n        pass() {\n          isPaused = false;\n          json[index + length++] = chunk;\n          resolve();\n          setImmediate(unpause);\n        }\n      });\n    });\n  }\n  function indent() {\n    return addJson(`\\n${indentation}`);\n  }\n  function afterScope() {\n    needsComma = false;\n    if (space) {\n      indentation += space;\n    }\n  }\n  function object() {\n    return beforeScope().then(() => addJson('{')).then(() => afterScope());\n  }\n  function property(name) {\n    return before().then(() => addJson(`\"${name}\":`)).then(() => {\n      isProperty = true;\n    });\n  }\n  function string(s) {\n    return value(`\"${s}\"`);\n  }\n  function value(v) {\n    return before().then(() => addJson(`${v}`));\n  }\n  function endArray() {\n    return beforeScopeEnd().then(() => addJson(']')).then(() => afterScopeEnd());\n  }\n  function beforeScopeEnd() {\n    if (space) {\n      indentation = indentation.substr(space.length);\n      return indent();\n    }\n    return Promise.resolve();\n  }\n  function afterScopeEnd() {\n    needsComma = true;\n  }\n  function endObject() {\n    return beforeScopeEnd().then(() => addJson('}')).then(() => afterScopeEnd());\n  }\n  function end() {\n    after();\n    isEnded = true;\n    endStream();\n  }\n  function error(err) {\n    stream.emit('error', err);\n  }\n  function dataError(err) {\n    stream.emit('dataError', err);\n  }\n}\nfunction normaliseSpace(options) {\n  if (check.positive(options.space)) {\n    return new Array(options.space + 1).join(' ');\n  }\n  if (check.nonEmptyString(options.space)) {\n    return options.space;\n  }\n}","map":{"version":3,"names":["check","require","eventify","events","JsonStream","Hoopy","promise","tryer","DEFAULT_BUFFER_LENGTH","module","exports","streamify","data","options","emitter","json","bufferLength","Promise","space","normaliseSpace","streamOptions","highWaterMark","stream","read","awaitPush","index","indentation","isEnded","isPaused","isProperty","length","mutex","resolve","needsComma","on","array","noRacing","object","property","string","number","value","literal","endArray","endObject","end","error","dataError","after","endStream","i","push","handler","eventData","then","beforeScope","addJson","afterScope","before","isScope","indent","chunk","unpause","pause","interval","until","pass","setImmediate","name","s","v","beforeScopeEnd","afterScopeEnd","substr","err","emit","positive","Array","join","nonEmptyString"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/src/streamify.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst eventify = require('./eventify')\nconst events = require('./events')\nconst JsonStream = require('./jsonstream')\nconst Hoopy = require('hoopy')\nconst promise = require('./promise')\nconst tryer = require('tryer')\n\nconst DEFAULT_BUFFER_LENGTH = 1024\n\nmodule.exports = streamify\n\n/**\n * Public function `streamify`.\n *\n * Asynchronously serialises a data structure to a stream of JSON\n * data. Sanely handles promises, buffers, maps and other iterables.\n *\n * @param data:           The data to transform.\n *\n * @option space:         Indentation string, or the number of spaces\n *                        to indent each nested level by.\n *\n * @option promises:      'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:       'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:          'object' or 'ignore', default is 'object'.\n *\n * @option iterables:     'array' or 'ignore', default is 'array'.\n *\n * @option circular:      'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction streamify (data, options = {}) {\n  const emitter = eventify(data, options)\n  const json = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH)\n  const Promise = promise(options)\n  const space = normaliseSpace(options)\n  let streamOptions\n  const { highWaterMark } = options\n  if (highWaterMark) {\n    streamOptions = { highWaterMark }\n  }\n  const stream = new JsonStream(read, streamOptions)\n\n  let awaitPush = true\n  let index = 0\n  let indentation = ''\n  let isEnded\n  let isPaused = false\n  let isProperty\n  let length = 0\n  let mutex = Promise.resolve()\n  let needsComma\n\n  emitter.on(events.array, noRacing(array))\n  emitter.on(events.object, noRacing(object))\n  emitter.on(events.property, noRacing(property))\n  emitter.on(events.string, noRacing(string))\n  emitter.on(events.number, noRacing(value))\n  emitter.on(events.literal, noRacing(value))\n  emitter.on(events.endArray, noRacing(endArray))\n  emitter.on(events.endObject, noRacing(endObject))\n  emitter.on(events.end, noRacing(end))\n  emitter.on(events.error, noRacing(error))\n  emitter.on(events.dataError, noRacing(dataError))\n\n  return stream\n\n  function read () {\n    if (awaitPush) {\n      awaitPush = false\n\n      if (isEnded) {\n        if (length > 0) {\n          after()\n        }\n\n        return endStream()\n      }\n    }\n\n    if (isPaused) {\n      after()\n    }\n  }\n\n  function after () {\n    if (awaitPush) {\n      return\n    }\n\n    let i\n\n    for (i = 0; i < length && ! awaitPush; ++i) {\n      if (! stream.push(json[i + index], 'utf8')) {\n        awaitPush = true\n      }\n    }\n\n    if (i === length) {\n      index = length = 0\n    } else {\n      length -= i\n      index += i\n    }\n  }\n\n  function endStream () {\n    if (! awaitPush) {\n      stream.push(null)\n    }\n  }\n\n  function noRacing (handler) {\n    return eventData => mutex = mutex.then(() => handler(eventData))\n  }\n\n  function array () {\n    return beforeScope()\n      .then(() => addJson('['))\n      .then(() => afterScope())\n  }\n\n  function beforeScope () {\n    return before(true)\n  }\n\n  function before (isScope) {\n    if (isProperty) {\n      isProperty = false\n\n      if (space) {\n        return addJson(' ')\n      }\n\n      return Promise.resolve()\n    }\n\n    return Promise.resolve()\n      .then(() => {\n        if (needsComma) {\n          if (isScope) {\n            needsComma = false\n          }\n\n          return addJson(',')\n        }\n\n        if (! isScope) {\n          needsComma = true\n        }\n      })\n      .then(() => {\n        if (space && indentation) {\n          return indent()\n        }\n      })\n  }\n\n  function addJson (chunk) {\n    if (length + 1 <= json.length) {\n      json[index + length++] = chunk\n      after()\n      return Promise.resolve()\n    }\n\n    isPaused = true\n    return new Promise(resolve => {\n      const unpause = emitter.pause()\n      tryer({\n        interval: -10,\n        until () {\n          return length + 1 <= json.length\n        },\n        pass () {\n          isPaused = false\n          json[index + length++] = chunk\n          resolve()\n          setImmediate(unpause)\n        }\n      })\n    })\n  }\n\n  function indent () {\n    return addJson(`\\n${indentation}`)\n  }\n\n  function afterScope () {\n    needsComma = false\n\n    if (space) {\n      indentation += space\n    }\n  }\n\n  function object () {\n    return beforeScope()\n      .then(() => addJson('{'))\n      .then(() => afterScope())\n  }\n\n  function property (name) {\n    return before()\n      .then(() => addJson(`\"${name}\":`))\n      .then(() => {\n        isProperty = true\n      })\n  }\n\n  function string (s) {\n    return value(`\"${s}\"`)\n  }\n\n  function value (v) {\n    return before()\n      .then(() => addJson(`${v}`))\n  }\n\n  function endArray () {\n    return beforeScopeEnd()\n      .then(() => addJson(']'))\n      .then(() => afterScopeEnd())\n  }\n\n  function beforeScopeEnd () {\n    if (space) {\n      indentation = indentation.substr(space.length)\n\n      return indent()\n    }\n\n    return Promise.resolve()\n  }\n\n  function afterScopeEnd () {\n    needsComma = true\n  }\n\n  function endObject () {\n    return beforeScopeEnd()\n      .then(() => addJson('}'))\n      .then(() => afterScopeEnd())\n  }\n\n  function end () {\n    after()\n\n    isEnded = true\n    endStream()\n  }\n\n  function error (err) {\n    stream.emit('error', err)\n  }\n\n  function dataError (err) {\n    stream.emit('dataError', err)\n  }\n}\n\nfunction normaliseSpace (options) {\n  if (check.positive(options.space)) {\n    return new Array(options.space + 1).join(' ')\n  }\n\n  if (check.nonEmptyString(options.space)) {\n    return options.space\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}