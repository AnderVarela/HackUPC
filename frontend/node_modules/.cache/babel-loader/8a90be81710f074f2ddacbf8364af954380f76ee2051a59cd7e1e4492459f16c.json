{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\nvar _index = require(\"../../index\");\nvar _astModuleToModuleContext = require(\"../ast-module-to-module-context\");\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n// FIXME(sven): do the same with all block instructions, must be more generic here\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\nfunction transform(ast) {\n  var module = null;\n  (0, _index.traverse)(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n      Module.toString = function () {\n        return _Module.toString();\n      };\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  if (module == null) {\n    throw new Error(\"Module not foudn in program\");\n  }\n  var moduleContext = (0, _astModuleToModuleContext.moduleContextFromModuleAST)(module); // Transform the actual instruction in function bodies\n\n  (0, _index.traverse)(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n      Func.toString = function () {\n        return _Func.toString();\n      };\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n      Start.toString = function () {\n        return _Start.toString();\n      };\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n        path.node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  (0, _index.traverse)(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n          firstArg = _instrNode$args[0];\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n          _firstArg = _instrNode$args2[0];\n        if ((0, _index.isIdentifier)(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier(\n          // $FlowIgnore: reference?\n          _firstArg.value);\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n          _firstArg2 = _instrNode$args3[0];\n        if ((0, _index.isIdentifier)(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n            if ((0, _index.isBlock)(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n            if ((0, _index.isFunc)(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(relativeBlockCount);\n        }\n      }\n    }),\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n        node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","transform","_index","require","_astModuleToModuleContext","_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","err","isArray","newUnexpectedFunction","Error","ast","module","traverse","Module","_Module","_x","apply","arguments","path","node","moduleContext","moduleContextFromModuleAST","Func","_Func","_x2","transformFuncPath","Start","_Start","_x3","index","isIdentifier","offsetInModule","getFunctionOffsetByIdentifier","numberLiteralFromRaw","funcPath","funcNode","signature","type","params","forEach","p","addLocal","valtype","Instr","_Instr","_x4","instrPath","instrNode","id","_instrNode$args","args","firstArg","offsetInParams","findIndex","_ref","concat","_instrNode$args2","_firstArg","globalOffset","getGlobalOffsetByIdentifier","_instrNode$args3","_firstArg2","relativeBlockCount","findParent","_ref2","isBlock","label","isFunc","CallInstruction","_CallInstruction","_x5","_ref3"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/lib/transform/wast-identifier-to-index/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar _index = require(\"../../index\");\n\nvar _astModuleToModuleContext = require(\"../ast-module-to-module-context\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n// FIXME(sven): do the same with all block instructions, must be more generic here\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nfunction transform(ast) {\n  var module = null;\n  (0, _index.traverse)(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n\n  if (module == null) {\n    throw new Error(\"Module not foudn in program\");\n  }\n\n  var moduleContext = (0, _astModuleToModuleContext.moduleContextFromModuleAST)(module); // Transform the actual instruction in function bodies\n\n  (0, _index.traverse)(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  (0, _index.traverse)(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if ((0, _index.isIdentifier)(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if ((0, _index.isIdentifier)(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if ((0, _index.isBlock)(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if ((0, _index.isFunc)(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}