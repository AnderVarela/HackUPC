{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapWordsToLines = void 0;\nfunction wrapWordsToLines(text, maxLineLength, indentOrLinePrefix) {\n  var _a;\n  let linePrefix;\n  switch (typeof indentOrLinePrefix) {\n    case 'number':\n      linePrefix = ' '.repeat(indentOrLinePrefix);\n      break;\n    case 'string':\n      linePrefix = indentOrLinePrefix;\n      break;\n    default:\n      linePrefix = '';\n      break;\n  }\n  const linePrefixLength = linePrefix.length;\n  if (!maxLineLength) {\n    maxLineLength = process.stdout.getWindowSize()[0];\n  }\n  // Apply word wrapping and the provided line prefix, while also respecting existing newlines\n  // and prefix spaces that may exist in the text string already.\n  const lines = text.split(/\\r?\\n/);\n  const wrappedLines = [];\n  for (const line of lines) {\n    if (line.length + linePrefixLength <= maxLineLength) {\n      wrappedLines.push(linePrefix + line);\n    } else {\n      const lineAdditionalPrefix = ((_a = line.match(/^\\s*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n      const whitespaceRegexp = /\\s+/g;\n      let currentWhitespaceMatch = null;\n      let previousWhitespaceMatch;\n      let currentLineStartIndex = lineAdditionalPrefix.length;\n      let previousBreakRanOver = false;\n      while ((currentWhitespaceMatch = whitespaceRegexp.exec(line)) !== null) {\n        if (currentWhitespaceMatch.index + linePrefixLength - currentLineStartIndex > maxLineLength) {\n          let whitespaceToSplitAt;\n          if (!previousWhitespaceMatch ||\n          // Handle the case where there are two words longer than the maxLineLength in a row\n          previousBreakRanOver) {\n            whitespaceToSplitAt = currentWhitespaceMatch;\n          } else {\n            whitespaceToSplitAt = previousWhitespaceMatch;\n          }\n          wrappedLines.push(linePrefix + lineAdditionalPrefix + line.substring(currentLineStartIndex, whitespaceToSplitAt.index));\n          previousBreakRanOver = whitespaceToSplitAt.index - currentLineStartIndex > maxLineLength;\n          currentLineStartIndex = whitespaceToSplitAt.index + whitespaceToSplitAt[0].length;\n        } else {\n          previousBreakRanOver = false;\n        }\n        previousWhitespaceMatch = currentWhitespaceMatch;\n      }\n      if (currentLineStartIndex < line.length) {\n        wrappedLines.push(linePrefix + lineAdditionalPrefix + line.substring(currentLineStartIndex));\n      }\n    }\n  }\n  return wrappedLines;\n}\nexports.wrapWordsToLines = wrapWordsToLines;","map":{"version":3,"names":["wrapWordsToLines","text","maxLineLength","indentOrLinePrefix","linePrefix","repeat","linePrefixLength","length","process","stdout","getWindowSize","lines","split","wrappedLines","line","push","lineAdditionalPrefix","_a","match","whitespaceRegexp","currentWhitespaceMatch","previousWhitespaceMatch","currentLineStartIndex","previousBreakRanOver","exec","index","whitespaceToSplitAt","substring","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@rushstack\\eslint-patch\\src\\eslint-bulk-suppressions\\cli\\utils\\wrap-words-to-lines.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n// ----------------------------------------------------------------------------------------------------------\n// TO AVOID EXTRA DEPENDENCIES, THE CODE IN THIS FILE WAS BORROWED FROM:\n//\n// rushstack/libraries/terminal/src/PrintUtilities.ts\n//\n// KEEP IT IN SYNC WITH THAT FILE.\n// ----------------------------------------------------------------------------------------------------------\n\n/**\n * Applies word wrapping and returns an array of lines.\n *\n * @param text - The text to wrap\n * @param maxLineLength - The maximum length of a line, defaults to the console width\n * @param indent - The number of spaces to indent the wrapped lines, defaults to 0\n */\nexport function wrapWordsToLines(text: string, maxLineLength?: number, indent?: number): string[];\n/**\n * Applies word wrapping and returns an array of lines.\n *\n * @param text - The text to wrap\n * @param maxLineLength - The maximum length of a line, defaults to the console width\n * @param linePrefix - The string to prefix each line with, defaults to ''\n */\nexport function wrapWordsToLines(text: string, maxLineLength?: number, linePrefix?: string): string[];\n/**\n * Applies word wrapping and returns an array of lines.\n *\n * @param text - The text to wrap\n * @param maxLineLength - The maximum length of a line, defaults to the console width\n * @param indentOrLinePrefix - The number of spaces to indent the wrapped lines or the string to prefix\n * each line with, defaults to no prefix\n */\nexport function wrapWordsToLines(\n  text: string,\n  maxLineLength?: number,\n  indentOrLinePrefix?: number | string\n): string[];\nexport function wrapWordsToLines(\n  text: string,\n  maxLineLength?: number,\n  indentOrLinePrefix?: number | string\n): string[] {\n  let linePrefix: string;\n  switch (typeof indentOrLinePrefix) {\n    case 'number':\n      linePrefix = ' '.repeat(indentOrLinePrefix);\n      break;\n    case 'string':\n      linePrefix = indentOrLinePrefix;\n      break;\n    default:\n      linePrefix = '';\n      break;\n  }\n\n  const linePrefixLength: number = linePrefix.length;\n\n  if (!maxLineLength) {\n    maxLineLength = process.stdout.getWindowSize()[0];\n  }\n\n  // Apply word wrapping and the provided line prefix, while also respecting existing newlines\n  // and prefix spaces that may exist in the text string already.\n  const lines: string[] = text.split(/\\r?\\n/);\n\n  const wrappedLines: string[] = [];\n  for (const line of lines) {\n    if (line.length + linePrefixLength <= maxLineLength) {\n      wrappedLines.push(linePrefix + line);\n    } else {\n      const lineAdditionalPrefix: string = line.match(/^\\s*/)?.[0] || '';\n      const whitespaceRegexp: RegExp = /\\s+/g;\n      let currentWhitespaceMatch: RegExpExecArray | null = null;\n      let previousWhitespaceMatch: RegExpExecArray | undefined;\n      let currentLineStartIndex: number = lineAdditionalPrefix.length;\n      let previousBreakRanOver: boolean = false;\n      while ((currentWhitespaceMatch = whitespaceRegexp.exec(line)) !== null) {\n        if (currentWhitespaceMatch.index + linePrefixLength - currentLineStartIndex > maxLineLength) {\n          let whitespaceToSplitAt: RegExpExecArray | undefined;\n          if (\n            !previousWhitespaceMatch ||\n            // Handle the case where there are two words longer than the maxLineLength in a row\n            previousBreakRanOver\n          ) {\n            whitespaceToSplitAt = currentWhitespaceMatch;\n          } else {\n            whitespaceToSplitAt = previousWhitespaceMatch;\n          }\n\n          wrappedLines.push(\n            linePrefix +\n              lineAdditionalPrefix +\n              line.substring(currentLineStartIndex, whitespaceToSplitAt.index)\n          );\n          previousBreakRanOver = whitespaceToSplitAt.index - currentLineStartIndex > maxLineLength;\n          currentLineStartIndex = whitespaceToSplitAt.index + whitespaceToSplitAt[0].length;\n        } else {\n          previousBreakRanOver = false;\n        }\n\n        previousWhitespaceMatch = currentWhitespaceMatch;\n      }\n\n      if (currentLineStartIndex < line.length) {\n        wrappedLines.push(linePrefix + lineAdditionalPrefix + line.substring(currentLineStartIndex));\n      }\n    }\n  }\n\n  return wrappedLines;\n}\n"],"mappings":";;AAAA;AACA;;;;;AAuCA,SAAgBA,gBAAgBA,CAC9BC,IAAY,EACZC,aAAsB,EACtBC,kBAAoC;;EAEpC,IAAIC,UAAkB;EACtB,QAAQ,OAAOD,kBAAkB;IAC/B,KAAK,QAAQ;MACXC,UAAU,GAAG,GAAG,CAACC,MAAM,CAACF,kBAAkB,CAAC;MAC3C;IACF,KAAK,QAAQ;MACXC,UAAU,GAAGD,kBAAkB;MAC/B;IACF;MACEC,UAAU,GAAG,EAAE;MACf;EACJ;EAEA,MAAME,gBAAgB,GAAWF,UAAU,CAACG,MAAM;EAElD,IAAI,CAACL,aAAa,EAAE;IAClBA,aAAa,GAAGM,OAAO,CAACC,MAAM,CAACC,aAAa,EAAE,CAAC,CAAC,CAAC;EACnD;EAEA;EACA;EACA,MAAMC,KAAK,GAAaV,IAAI,CAACW,KAAK,CAAC,OAAO,CAAC;EAE3C,MAAMC,YAAY,GAAa,EAAE;EACjC,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;IACxB,IAAIG,IAAI,CAACP,MAAM,GAAGD,gBAAgB,IAAIJ,aAAa,EAAE;MACnDW,YAAY,CAACE,IAAI,CAACX,UAAU,GAAGU,IAAI,CAAC;IACtC,CAAC,MAAM;MACL,MAAME,oBAAoB,GAAW,EAAAC,EAAA,GAAAH,IAAI,CAACI,KAAK,CAAC,MAAM,CAAC,cAAAD,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC,KAAI,EAAE;MAClE,MAAME,gBAAgB,GAAW,MAAM;MACvC,IAAIC,sBAAsB,GAA2B,IAAI;MACzD,IAAIC,uBAAoD;MACxD,IAAIC,qBAAqB,GAAWN,oBAAoB,CAACT,MAAM;MAC/D,IAAIgB,oBAAoB,GAAY,KAAK;MACzC,OAAO,CAACH,sBAAsB,GAAGD,gBAAgB,CAACK,IAAI,CAACV,IAAI,CAAC,MAAM,IAAI,EAAE;QACtE,IAAIM,sBAAsB,CAACK,KAAK,GAAGnB,gBAAgB,GAAGgB,qBAAqB,GAAGpB,aAAa,EAAE;UAC3F,IAAIwB,mBAAgD;UACpD,IACE,CAACL,uBAAuB;UACxB;UACAE,oBAAoB,EACpB;YACAG,mBAAmB,GAAGN,sBAAsB;UAC9C,CAAC,MAAM;YACLM,mBAAmB,GAAGL,uBAAuB;UAC/C;UAEAR,YAAY,CAACE,IAAI,CACfX,UAAU,GACRY,oBAAoB,GACpBF,IAAI,CAACa,SAAS,CAACL,qBAAqB,EAAEI,mBAAmB,CAACD,KAAK,CAAC,CACnE;UACDF,oBAAoB,GAAGG,mBAAmB,CAACD,KAAK,GAAGH,qBAAqB,GAAGpB,aAAa;UACxFoB,qBAAqB,GAAGI,mBAAmB,CAACD,KAAK,GAAGC,mBAAmB,CAAC,CAAC,CAAC,CAACnB,MAAM;QACnF,CAAC,MAAM;UACLgB,oBAAoB,GAAG,KAAK;QAC9B;QAEAF,uBAAuB,GAAGD,sBAAsB;MAClD;MAEA,IAAIE,qBAAqB,GAAGR,IAAI,CAACP,MAAM,EAAE;QACvCM,YAAY,CAACE,IAAI,CAACX,UAAU,GAAGY,oBAAoB,GAAGF,IAAI,CAACa,SAAS,CAACL,qBAAqB,CAAC,CAAC;MAC9F;IACF;EACF;EAEA,OAAOT,YAAY;AACrB;AAzEAe,OAAA,CAAA5B,gBAAA,GAAAA,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}