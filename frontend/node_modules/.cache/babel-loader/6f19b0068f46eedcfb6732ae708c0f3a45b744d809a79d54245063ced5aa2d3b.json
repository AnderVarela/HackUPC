{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'consistent-type-imports',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce consistent usage of type imports',\n      recommended: false\n    },\n    messages: {\n      typeOverValue: 'All imports in the declaration are only used as types. Use `import type`.',\n      someImportsAreOnlyTypes: 'Imports {{typeImports}} are only used as types.',\n      aImportIsOnlyTypes: 'Import {{typeImports}} is only used as types.',\n      someImportsInDecoMeta: 'Type imports {{typeImports}} are used by decorator metadata.',\n      aImportInDecoMeta: 'Type import {{typeImports}} is used by decorator metadata.',\n      valueOverType: 'Use an `import` instead of an `import type`.',\n      noImportTypeAnnotations: '`import()` type annotations are forbidden.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        prefer: {\n          enum: ['type-imports', 'no-type-imports']\n        },\n        disallowTypeAnnotations: {\n          type: 'boolean'\n        },\n        fixStyle: {\n          enum: ['separate-type-imports', 'inline-type-imports']\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code'\n  },\n  defaultOptions: [{\n    prefer: 'type-imports',\n    disallowTypeAnnotations: true,\n    fixStyle: 'separate-type-imports'\n  }],\n  create(context, [option]) {\n    var _a, _b;\n    const prefer = (_a = option.prefer) !== null && _a !== void 0 ? _a : 'type-imports';\n    const disallowTypeAnnotations = option.disallowTypeAnnotations !== false;\n    const fixStyle = (_b = option.fixStyle) !== null && _b !== void 0 ? _b : 'separate-type-imports';\n    const sourceCode = context.getSourceCode();\n    const sourceImportsMap = {};\n    return Object.assign(Object.assign({}, prefer === 'type-imports' ? {\n      // prefer type imports\n      ImportDeclaration(node) {\n        var _a;\n        const source = node.source.value;\n        // sourceImports is the object containing all the specifics for a particular import source, type or value\n        const sourceImports = (_a = sourceImportsMap[source]) !== null && _a !== void 0 ? _a : sourceImportsMap[source] = {\n          source,\n          reportValueImports: [],\n          typeOnlyNamedImport: null,\n          valueOnlyNamedImport: null,\n          valueImport: null // if only value imports\n        };\n        if (node.importKind === 'type') {\n          if (!sourceImports.typeOnlyNamedImport && node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n            // definitely import type { TypeX }\n            sourceImports.typeOnlyNamedImport = node;\n          }\n        } else {\n          if (!sourceImports.valueOnlyNamedImport && node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n            sourceImports.valueOnlyNamedImport = node;\n            sourceImports.valueImport = node;\n          } else if (!sourceImports.valueImport && node.specifiers.some(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {\n            sourceImports.valueImport = node;\n          }\n        }\n        const typeSpecifiers = [];\n        const inlineTypeSpecifiers = [];\n        const valueSpecifiers = [];\n        const unusedSpecifiers = [];\n        for (const specifier of node.specifiers) {\n          if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier && specifier.importKind === 'type') {\n            inlineTypeSpecifiers.push(specifier);\n            continue;\n          }\n          const [variable] = context.getDeclaredVariables(specifier);\n          if (variable.references.length === 0) {\n            unusedSpecifiers.push(specifier);\n          } else {\n            const onlyHasTypeReferences = variable.references.every(ref => {\n              var _a, _b;\n              /**\n               * keep origin import kind when export\n               * export { Type }\n               * export default Type;\n               */\n              if (((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportSpecifier || ((_b = ref.identifier.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n                if (ref.isValueReference && ref.isTypeReference) {\n                  return node.importKind === 'type';\n                }\n              }\n              if (ref.isValueReference) {\n                let parent = ref.identifier.parent;\n                let child = ref.identifier;\n                while (parent) {\n                  switch (parent.type) {\n                    // CASE 1:\n                    // `type T = typeof foo` will create a value reference because \"foo\" must be a value type\n                    // however this value reference is safe to use with type-only imports\n                    case utils_1.AST_NODE_TYPES.TSTypeQuery:\n                      return true;\n                    case utils_1.AST_NODE_TYPES.TSQualifiedName:\n                      // TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early\n                      if (parent.left !== child) {\n                        return false;\n                      }\n                      child = parent;\n                      parent = parent.parent;\n                      continue;\n                    // END CASE 1\n                    //////////////\n                    // CASE 2:\n                    // `type T = { [foo]: string }` will create a value reference because \"foo\" must be a value type\n                    // however this value reference is safe to use with type-only imports.\n                    // Also this is represented as a non-type AST - hence it uses MemberExpression\n                    case utils_1.AST_NODE_TYPES.TSPropertySignature:\n                      return parent.key === child;\n                    case utils_1.AST_NODE_TYPES.MemberExpression:\n                      if (parent.object !== child) {\n                        return false;\n                      }\n                      child = parent;\n                      parent = parent.parent;\n                      continue;\n                    // END CASE 2\n                    default:\n                      return false;\n                  }\n                }\n              }\n              return ref.isTypeReference;\n            });\n            if (onlyHasTypeReferences) {\n              typeSpecifiers.push(specifier);\n            } else {\n              valueSpecifiers.push(specifier);\n            }\n          }\n        }\n        if (node.importKind === 'value' && typeSpecifiers.length || node.importKind === 'type' && valueSpecifiers.length) {\n          sourceImports.reportValueImports.push({\n            node,\n            typeSpecifiers,\n            valueSpecifiers,\n            unusedSpecifiers,\n            inlineTypeSpecifiers\n          });\n        }\n      },\n      'Program:exit'() {\n        for (const sourceImports of Object.values(sourceImportsMap)) {\n          if (sourceImports.reportValueImports.length === 0) {\n            // nothing to fix. value specifiers and type specifiers are correctly written\n            continue;\n          }\n          for (const report of sourceImports.reportValueImports) {\n            if (report.valueSpecifiers.length === 0 && report.unusedSpecifiers.length === 0 && report.node.importKind !== 'type') {\n              context.report({\n                node: report.node,\n                messageId: 'typeOverValue',\n                *fix(fixer) {\n                  yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                }\n              });\n            } else {\n              const isTypeImport = report.node.importKind === 'type';\n              // we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured\n              const importNames = (isTypeImport ? report.valueSpecifiers // import type { A } from 'roo'; // WHERE A is used in value position\n              : report.typeSpecifiers // import { A, B } from 'roo'; // WHERE A is used in type position and B is in value position\n              ).map(specifier => `\"${specifier.local.name}\"`);\n              const message = (() => {\n                const typeImports = util.formatWordList(importNames);\n                if (importNames.length === 1) {\n                  if (isTypeImport) {\n                    return {\n                      messageId: 'aImportInDecoMeta',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  } else {\n                    return {\n                      messageId: 'aImportIsOnlyTypes',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  }\n                } else {\n                  if (isTypeImport) {\n                    return {\n                      messageId: 'someImportsInDecoMeta',\n                      data: {\n                        typeImports\n                      } // typeImports are all the value specifiers that are in the type position\n                    };\n                  } else {\n                    return {\n                      messageId: 'someImportsAreOnlyTypes',\n                      data: {\n                        typeImports\n                      } // typeImports are all the type specifiers in the value position\n                    };\n                  }\n                }\n              })();\n              context.report(Object.assign(Object.assign({\n                node: report.node\n              }, message), {\n                *fix(fixer) {\n                  if (isTypeImport) {\n                    // take all the valueSpecifiers and put them on a new line\n                    yield* fixToValueImportDeclaration(fixer, report, sourceImports);\n                  } else {\n                    // take all the typeSpecifiers and put them on a new line\n                    yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                  }\n                }\n              }));\n            }\n          }\n        }\n      }\n    } : {\n      // prefer no type imports\n      'ImportDeclaration[importKind = \"type\"]'(node) {\n        context.report({\n          node,\n          messageId: 'valueOverType',\n          fix(fixer) {\n            return fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          }\n        });\n      },\n      'ImportSpecifier[importKind = \"type\"]'(node) {\n        context.report({\n          node,\n          messageId: 'valueOverType',\n          fix(fixer) {\n            return fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);\n          }\n        });\n      }\n    }), disallowTypeAnnotations ? {\n      // disallow `import()` type\n      TSImportType(node) {\n        context.report({\n          node,\n          messageId: 'noImportTypeAnnotations'\n        });\n      }\n    } : {});\n    function classifySpecifier(node) {\n      var _a;\n      const defaultSpecifier = node.specifiers[0].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier ? node.specifiers[0] : null;\n      const namespaceSpecifier = (_a = node.specifiers.find(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier)) !== null && _a !== void 0 ? _a : null;\n      const namedSpecifiers = node.specifiers.filter(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);\n      return {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      };\n    }\n    /**\n     * Returns information for fixing named specifiers, type or value\n     */\n    function getFixesNamedSpecifiers(fixer, node, subsetNamedSpecifiers, allNamedSpecifiers) {\n      if (allNamedSpecifiers.length === 0) {\n        return {\n          typeNamedSpecifiersText: '',\n          removeTypeNamedSpecifiers: []\n        };\n      }\n      const typeNamedSpecifiersTexts = [];\n      const removeTypeNamedSpecifiers = [];\n      if (subsetNamedSpecifiers.length === allNamedSpecifiers.length) {\n        // import Foo, {Type1, Type2} from 'foo'\n        // import DefType, {Type1, Type2} from 'foo'\n        const openingBraceToken = util.nullThrows(sourceCode.getTokenBefore(subsetNamedSpecifiers[0], util.isOpeningBraceToken), util.NullThrowsReasons.MissingToken('{', node.type));\n        const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type));\n        const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type));\n        // import DefType, {...} from 'foo'\n        //               ^^^^^^^ remove\n        removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]));\n        typeNamedSpecifiersTexts.push(sourceCode.text.slice(openingBraceToken.range[1], closingBraceToken.range[0]));\n      } else {\n        const namedSpecifierGroups = [];\n        let group = [];\n        for (const namedSpecifier of allNamedSpecifiers) {\n          if (subsetNamedSpecifiers.includes(namedSpecifier)) {\n            group.push(namedSpecifier);\n          } else if (group.length) {\n            namedSpecifierGroups.push(group);\n            group = [];\n          }\n        }\n        if (group.length) {\n          namedSpecifierGroups.push(group);\n        }\n        for (const namedSpecifiers of namedSpecifierGroups) {\n          const {\n            removeRange,\n            textRange\n          } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);\n          removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));\n          typeNamedSpecifiersTexts.push(sourceCode.text.slice(...textRange));\n        }\n      }\n      return {\n        typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(','),\n        removeTypeNamedSpecifiers\n      };\n    }\n    /**\n     * Returns ranges for fixing named specifier.\n     */\n    function getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {\n      const first = namedSpecifierGroup[0];\n      const last = namedSpecifierGroup[namedSpecifierGroup.length - 1];\n      const removeRange = [first.range[0], last.range[1]];\n      const textRange = [...removeRange];\n      const before = sourceCode.getTokenBefore(first);\n      textRange[0] = before.range[1];\n      if (util.isCommaToken(before)) {\n        removeRange[0] = before.range[0];\n      } else {\n        removeRange[0] = before.range[1];\n      }\n      const isFirst = allNamedSpecifiers[0] === first;\n      const isLast = allNamedSpecifiers[allNamedSpecifiers.length - 1] === last;\n      const after = sourceCode.getTokenAfter(last);\n      textRange[1] = after.range[0];\n      if (isFirst || isLast) {\n        if (util.isCommaToken(after)) {\n          removeRange[1] = after.range[1];\n        }\n      }\n      return {\n        textRange,\n        removeRange\n      };\n    }\n    /**\n     * insert specifiers to named import node.\n     * e.g.\n     * import type { Already, Type1, Type2 } from 'foo'\n     *                        ^^^^^^^^^^^^^ insert\n     */\n    function fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {\n      const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(sourceCode.getFirstToken(target), target.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', target.type));\n      const before = sourceCode.getTokenBefore(closingBraceToken);\n      if (!util.isCommaToken(before) && !util.isOpeningBraceToken(before)) {\n        insertText = `,${insertText}`;\n      }\n      return fixer.insertTextBefore(closingBraceToken, insertText);\n    }\n    /**\n     * insert type keyword to named import node.\n     * e.g.\n     * import ADefault, { Already, type Type1, type Type2 } from 'foo'\n     *                             ^^^^ insert\n     */\n    function* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeSpecifiers) {\n      for (const spec of typeSpecifiers) {\n        const insertText = sourceCode.text.slice(...spec.range);\n        yield fixer.replaceTextRange(spec.range, `type ${insertText}`);\n      }\n    }\n    function* fixInlineTypeImportDeclaration(fixer, report, sourceImports) {\n      const {\n        node\n      } = report;\n      // For a value import, will only add an inline type to named specifiers\n      const {\n        namedSpecifiers\n      } = classifySpecifier(node);\n      const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));\n      if (sourceImports.valueImport) {\n        // add import named type specifiers to its value import\n        // import ValueA, { type A }\n        //                  ^^^^ insert\n        const {\n          namedSpecifiers: valueImportNamedSpecifiers\n        } = classifySpecifier(sourceImports.valueImport);\n        if (sourceImports.valueOnlyNamedImport || valueImportNamedSpecifiers.length) {\n          yield* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeNamedSpecifiers);\n        }\n      }\n    }\n    function* fixToTypeImportDeclaration(fixer, report, sourceImports) {\n      const {\n        node\n      } = report;\n      const {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      } = classifySpecifier(node);\n      if (namespaceSpecifier && !defaultSpecifier) {\n        // import * as types from 'foo'\n        yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n        return;\n      } else if (defaultSpecifier) {\n        if (report.typeSpecifiers.includes(defaultSpecifier) && namedSpecifiers.length === 0 && !namespaceSpecifier) {\n          // import Type from 'foo'\n          yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, true);\n          return;\n        } else if (fixStyle === 'inline-type-imports' && !report.typeSpecifiers.includes(defaultSpecifier) && namedSpecifiers.length > 0 && !namespaceSpecifier) {\n          // if there is a default specifier but it isn't a type specifier, then just add the inline type modifier to the named specifiers\n          // import AValue, {BValue, Type1, Type2} from 'foo'\n          yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);\n          return;\n        }\n      } else if (!namespaceSpecifier) {\n        if (fixStyle === 'inline-type-imports' && namedSpecifiers.some(specifier => report.typeSpecifiers.includes(specifier))) {\n          // import {AValue, Type1, Type2} from 'foo'\n          yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);\n          return;\n        } else if (namedSpecifiers.every(specifier => report.typeSpecifiers.includes(specifier))) {\n          // import {Type1, Type2} from 'foo'\n          yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n          return;\n        }\n      }\n      const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));\n      const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);\n      const afterFixes = [];\n      if (typeNamedSpecifiers.length) {\n        if (sourceImports.typeOnlyNamedImport) {\n          const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);\n          if (sourceImports.typeOnlyNamedImport.range[1] <= node.range[0]) {\n            yield insertTypeNamedSpecifiers;\n          } else {\n            afterFixes.push(insertTypeNamedSpecifiers);\n          }\n        } else {\n          // The import is both default and named.  Insert named on new line because can't mix default type import and named type imports\n          if (fixStyle === 'inline-type-imports') {\n            yield fixer.insertTextBefore(node, `import {${typeNamedSpecifiers.map(spec => {\n              const insertText = sourceCode.text.slice(...spec.range);\n              return `type ${insertText}`;\n            }).join(', ')}} from ${sourceCode.getText(node.source)};\\n`);\n          } else {\n            yield fixer.insertTextBefore(node, `import type {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\\n`);\n          }\n        }\n      }\n      const fixesRemoveTypeNamespaceSpecifier = [];\n      if (namespaceSpecifier && report.typeSpecifiers.includes(namespaceSpecifier)) {\n        // import Foo, * as Type from 'foo'\n        // import DefType, * as Type from 'foo'\n        // import DefType, * as Type from 'foo'\n        const commaToken = util.nullThrows(sourceCode.getTokenBefore(namespaceSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type));\n        // import Def, * as Ns from 'foo'\n        //           ^^^^^^^^^ remove\n        fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[0], namespaceSpecifier.range[1]]));\n        // import type * as Ns from 'foo'\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert\n        yield fixer.insertTextBefore(node, `import type ${sourceCode.getText(namespaceSpecifier)} from ${sourceCode.getText(node.source)};\\n`);\n      }\n      if (defaultSpecifier && report.typeSpecifiers.includes(defaultSpecifier)) {\n        if (report.typeSpecifiers.length === node.specifiers.length) {\n          const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken('import', node.type));\n          // import type Type from 'foo'\n          //        ^^^^ insert\n          yield fixer.insertTextAfter(importToken, ' type');\n        } else {\n          const commaToken = util.nullThrows(sourceCode.getTokenAfter(defaultSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', defaultSpecifier.type));\n          // import Type , {...} from 'foo'\n          //        ^^^^^ pick\n          const defaultText = sourceCode.text.slice(defaultSpecifier.range[0], commaToken.range[0]).trim();\n          yield fixer.insertTextBefore(node, `import type ${defaultText} from ${sourceCode.getText(node.source)};\\n`);\n          const afterToken = util.nullThrows(sourceCode.getTokenAfter(commaToken, {\n            includeComments: true\n          }), util.NullThrowsReasons.MissingToken('any token', node.type));\n          // import Type , {...} from 'foo'\n          //        ^^^^^^^ remove\n          yield fixer.removeRange([defaultSpecifier.range[0], afterToken.range[0]]);\n        }\n      }\n      yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;\n      yield* fixesRemoveTypeNamespaceSpecifier;\n      yield* afterFixes;\n    }\n    function* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {\n      // import type Foo from 'foo'\n      //       ^^^^^ insert\n      const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken('import', node.type));\n      yield fixer.insertTextAfter(importToken, ' type');\n      if (isDefaultImport) {\n        // Has default import\n        const openingBraceToken = sourceCode.getFirstTokenBetween(importToken, node.source, util.isOpeningBraceToken);\n        if (openingBraceToken) {\n          // Only braces. e.g. import Foo, {} from 'foo'\n          const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type));\n          const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type));\n          // import type Foo, {} from 'foo'\n          //                  ^^ remove\n          yield fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]);\n          const specifiersText = sourceCode.text.slice(commaToken.range[1], closingBraceToken.range[1]);\n          if (node.specifiers.length > 1) {\n            yield fixer.insertTextAfter(node, `\\nimport type${specifiersText} from ${sourceCode.getText(node.source)};`);\n          }\n        }\n      }\n      // make sure we don't do anything like `import type {type T} from 'foo';`\n      for (const specifier of node.specifiers) {\n        if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier && specifier.importKind === 'type') {\n          yield* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);\n        }\n      }\n    }\n    function* fixToValueImportDeclaration(fixer, report, sourceImports) {\n      const {\n        node\n      } = report;\n      const {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      } = classifySpecifier(node);\n      if (namespaceSpecifier) {\n        // import type * as types from 'foo'\n        yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n        return;\n      } else if (defaultSpecifier) {\n        if (report.valueSpecifiers.includes(defaultSpecifier) && namedSpecifiers.length === 0) {\n          // import type Type from 'foo'\n          yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          return;\n        }\n      } else {\n        if (namedSpecifiers.every(specifier => report.valueSpecifiers.includes(specifier))) {\n          // import type {Type1, Type2} from 'foo'\n          yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          return;\n        }\n      }\n      // we have some valueSpecifiers intermixed in types that need to be put on their own line\n      // import type { Type1, A } from 'foo'\n      // import type { A } from 'foo'\n      const valueNamedSpecifiers = namedSpecifiers.filter(specifier => report.valueSpecifiers.includes(specifier));\n      const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, valueNamedSpecifiers, namedSpecifiers);\n      const afterFixes = [];\n      if (valueNamedSpecifiers.length) {\n        if (sourceImports.valueOnlyNamedImport) {\n          const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.valueOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);\n          if (sourceImports.valueOnlyNamedImport.range[1] <= node.range[0]) {\n            yield insertTypeNamedSpecifiers;\n          } else {\n            afterFixes.push(insertTypeNamedSpecifiers);\n          }\n        } else {\n          // some are types.\n          // Add new value import and later remove those value specifiers from import type\n          yield fixer.insertTextBefore(node, `import {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\\n`);\n        }\n      }\n      yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;\n      yield* afterFixes;\n    }\n    function* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {\n      var _a, _b;\n      // import type Foo from 'foo'\n      //        ^^^^ remove\n      const importToken = util.nullThrows(sourceCode.getFirstToken(node, util.isImportKeyword), util.NullThrowsReasons.MissingToken('import', node.type));\n      const typeToken = util.nullThrows(sourceCode.getFirstTokenBetween(importToken, (_b = (_a = node.specifiers[0]) === null || _a === void 0 ? void 0 : _a.local) !== null && _b !== void 0 ? _b : node.source, util.isTypeKeyword), util.NullThrowsReasons.MissingToken('type', node.type));\n      const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, {\n        includeComments: true\n      }), util.NullThrowsReasons.MissingToken('any token', node.type));\n      yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n    }\n    function* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {\n      // import { type Foo } from 'foo'\n      //          ^^^^ remove\n      const typeToken = util.nullThrows(sourceCode.getFirstToken(node, util.isTypeKeyword), util.NullThrowsReasons.MissingToken('type', node.type));\n      const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, {\n        includeComments: true\n      }), util.NullThrowsReasons.MissingToken('any token', node.type));\n      yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n    }\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","messages","typeOverValue","someImportsAreOnlyTypes","aImportIsOnlyTypes","someImportsInDecoMeta","aImportInDecoMeta","valueOverType","noImportTypeAnnotations","schema","properties","prefer","enum","disallowTypeAnnotations","fixStyle","additionalProperties","fixable","defaultOptions","create","context","option","_a","_b","sourceCode","getSourceCode","sourceImportsMap","Object","assign","ImportDeclaration","node","source","value","sourceImports","reportValueImports","typeOnlyNamedImport","valueOnlyNamedImport","valueImport","importKind","specifiers","every","specifier","AST_NODE_TYPES","ImportSpecifier","some","ImportDefaultSpecifier","typeSpecifiers","inlineTypeSpecifiers","valueSpecifiers","unusedSpecifiers","push","variable","getDeclaredVariables","references","length","onlyHasTypeReferences","ref","identifier","parent","ExportSpecifier","ExportDefaultDeclaration","isValueReference","isTypeReference","child","TSTypeQuery","TSQualifiedName","left","TSPropertySignature","key","MemberExpression","object","Program:exit","values","report","messageId","fix","fixer","fixToTypeImportDeclaration","isTypeImport","importNames","map","local","message","typeImports","formatWordList","data","fixToValueImportDeclaration","ImportDeclaration[importKind = \"type\"]","fixRemoveTypeSpecifierFromImportDeclaration","ImportSpecifier[importKind = \"type\"]","fixRemoveTypeSpecifierFromImportSpecifier","TSImportType","classifySpecifier","defaultSpecifier","namespaceSpecifier","find","ImportNamespaceSpecifier","namedSpecifiers","filter","getFixesNamedSpecifiers","subsetNamedSpecifiers","allNamedSpecifiers","typeNamedSpecifiersText","removeTypeNamedSpecifiers","typeNamedSpecifiersTexts","openingBraceToken","nullThrows","getTokenBefore","isOpeningBraceToken","NullThrowsReasons","MissingToken","commaToken","isCommaToken","closingBraceToken","getFirstTokenBetween","isClosingBraceToken","removeRange","range","text","slice","namedSpecifierGroups","group","namedSpecifier","includes","textRange","getNamedSpecifierRanges","join","namedSpecifierGroup","first","last","before","isFirst","isLast","after","getTokenAfter","fixInsertNamedSpecifiersInNamedSpecifierList","target","insertText","getFirstToken","insertTextBefore","fixInsertTypeKeywordInNamedSpecifierList","spec","replaceTextRange","fixInlineTypeImportDeclaration","typeNamedSpecifiers","valueImportNamedSpecifiers","fixInsertTypeSpecifierForImportDeclaration","fixesNamedSpecifiers","afterFixes","insertTypeNamedSpecifiers","getText","fixesRemoveTypeNamespaceSpecifier","importToken","isImportKeyword","insertTextAfter","defaultText","trim","afterToken","includeComments","isDefaultImport","specifiersText","valueNamedSpecifiers","typeToken","isTypeKeyword"],"sources":["../../src/rules/consistent-type-imports.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAEA,MAAAC,IAAA,GAAAC,YAAA,CAAAF,OAAA;AAuCAG,OAAA,CAAAC,OAAA,GAAeH,IAAI,CAACI,UAAU,CAAsB;EAClDC,IAAI,EAAE,yBAAyB;EAC/BC,IAAI,EAAE;IACJC,IAAI,EAAE,YAAY;IAClBC,IAAI,EAAE;MACJC,WAAW,EAAE,0CAA0C;MACvDC,WAAW,EAAE;KACd;IACDC,QAAQ,EAAE;MACRC,aAAa,EACX,2EAA2E;MAC7EC,uBAAuB,EACrB,iDAAiD;MACnDC,kBAAkB,EAAE,+CAA+C;MACnEC,qBAAqB,EACnB,8DAA8D;MAChEC,iBAAiB,EACf,4DAA4D;MAC9DC,aAAa,EAAE,8CAA8C;MAC7DC,uBAAuB,EAAE;KAC1B;IACDC,MAAM,EAAE,CACN;MACEZ,IAAI,EAAE,QAAQ;MACda,UAAU,EAAE;QACVC,MAAM,EAAE;UACNC,IAAI,EAAE,CAAC,cAAc,EAAE,iBAAiB;SACzC;QACDC,uBAAuB,EAAE;UACvBhB,IAAI,EAAE;SACP;QACDiB,QAAQ,EAAE;UACRF,IAAI,EAAE,CAAC,uBAAuB,EAAE,qBAAqB;;OAExD;MACDG,oBAAoB,EAAE;KACvB,CACF;IACDC,OAAO,EAAE;GACV;EAEDC,cAAc,EAAE,CACd;IACEN,MAAM,EAAE,cAAc;IACtBE,uBAAuB,EAAE,IAAI;IAC7BC,QAAQ,EAAE;GACX,CACF;EAEDI,MAAMA,CAACC,OAAO,EAAE,CAACC,MAAM,CAAC;;IACtB,MAAMT,MAAM,GAAG,CAAAU,EAAA,GAAAD,MAAM,CAACT,MAAM,cAAAU,EAAA,cAAAA,EAAA,GAAI,cAAc;IAC9C,MAAMR,uBAAuB,GAAGO,MAAM,CAACP,uBAAuB,KAAK,KAAK;IACxE,MAAMC,QAAQ,GAAG,CAAAQ,EAAA,GAAAF,MAAM,CAACN,QAAQ,cAAAQ,EAAA,cAAAA,EAAA,GAAI,uBAAuB;IAC3D,MAAMC,UAAU,GAAGJ,OAAO,CAACK,aAAa,EAAE;IAE1C,MAAMC,gBAAgB,GAAqC,EAAE;IAE7D,OAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACMhB,MAAM,KAAK,cAAc,GACzB;MACE;MACAiB,iBAAiBA,CAACC,IAAI;;QACpB,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAAM,CAACC,KAAK;QAChC;QACA,MAAMC,aAAa,GACjB,CAAAX,EAAA,GAAAI,gBAAgB,CAACK,MAAM,CAAC,cAAAT,EAAA,cAAAA,EAAA,GACvBI,gBAAgB,CAACK,MAAM,CAAC,GAAG;UAC1BA,MAAM;UACNG,kBAAkB,EAAE,EAAE;UACtBC,mBAAmB,EAAE,IAAI;UACzBC,oBAAoB,EAAE,IAAI;UAC1BC,WAAW,EAAE,IAAI,CAAE;SACnB;QACJ,IAAIP,IAAI,CAACQ,UAAU,KAAK,MAAM,EAAE;UAC9B,IACE,CAACL,aAAa,CAACE,mBAAmB,IAClCL,IAAI,CAACS,UAAU,CAACC,KAAK,CACnBC,SAAS,IACPA,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACC,eAAe,CACpD,EACD;YACA;YACAV,aAAa,CAACE,mBAAmB,GAAGL,IAAI;;SAE3C,MAAM;UACL,IACE,CAACG,aAAa,CAACG,oBAAoB,IACnCN,IAAI,CAACS,UAAU,CAACC,KAAK,CACnBC,SAAS,IACPA,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACC,eAAe,CACpD,EACD;YACAV,aAAa,CAACG,oBAAoB,GAAGN,IAAI;YACzCG,aAAa,CAACI,WAAW,GAAGP,IAAI;WACjC,MAAM,IACL,CAACG,aAAa,CAACI,WAAW,IAC1BP,IAAI,CAACS,UAAU,CAACK,IAAI,CAClBH,SAAS,IACPA,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACG,sBAAsB,CAC3D,EACD;YACAZ,aAAa,CAACI,WAAW,GAAGP,IAAI;;;QAIpC,MAAMgB,cAAc,GAA4B,EAAE;QAClD,MAAMC,oBAAoB,GAA+B,EAAE;QAC3D,MAAMC,eAAe,GAA4B,EAAE;QACnD,MAAMC,gBAAgB,GAA4B,EAAE;QACpD,KAAK,MAAMR,SAAS,IAAIX,IAAI,CAACS,UAAU,EAAE;UACvC,IACEE,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACC,eAAe,IACjDF,SAAS,CAACH,UAAU,KAAK,MAAM,EAC/B;YACAS,oBAAoB,CAACG,IAAI,CAACT,SAAS,CAAC;YACpC;;UAGF,MAAM,CAACU,QAAQ,CAAC,GAAG/B,OAAO,CAACgC,oBAAoB,CAACX,SAAS,CAAC;UAC1D,IAAIU,QAAQ,CAACE,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;YACpCL,gBAAgB,CAACC,IAAI,CAACT,SAAS,CAAC;WACjC,MAAM;YACL,MAAMc,qBAAqB,GAAGJ,QAAQ,CAACE,UAAU,CAACb,KAAK,CACrDgB,GAAG,IAAG;;cACJ;;;;;cAKA,IACE,EAAAlC,EAAA,GAAAkC,GAAG,CAACC,UAAU,CAACC,MAAM,cAAApC,EAAA,uBAAAA,EAAA,CAAExB,IAAI,MACzBT,OAAA,CAAAqD,cAAc,CAACiB,eAAe,IAChC,EAAApC,EAAA,GAAAiC,GAAG,CAACC,UAAU,CAACC,MAAM,cAAAnC,EAAA,uBAAAA,EAAA,CAAEzB,IAAI,MACzBT,OAAA,CAAAqD,cAAc,CAACkB,wBAAwB,EACzC;gBACA,IAAIJ,GAAG,CAACK,gBAAgB,IAAIL,GAAG,CAACM,eAAe,EAAE;kBAC/C,OAAOhC,IAAI,CAACQ,UAAU,KAAK,MAAM;;;cAGrC,IAAIkB,GAAG,CAACK,gBAAgB,EAAE;gBACxB,IAAIH,MAAM,GACRF,GAAG,CAACC,UAAU,CAACC,MAAM;gBACvB,IAAIK,KAAK,GAAkBP,GAAG,CAACC,UAAU;gBACzC,OAAOC,MAAM,EAAE;kBACb,QAAQA,MAAM,CAAC5D,IAAI;oBACjB;oBACA;oBACA;oBACA,KAAKT,OAAA,CAAAqD,cAAc,CAACsB,WAAW;sBAC7B,OAAO,IAAI;oBAEb,KAAK3E,OAAA,CAAAqD,cAAc,CAACuB,eAAe;sBACjC;sBACA,IAAIP,MAAM,CAACQ,IAAI,KAAKH,KAAK,EAAE;wBACzB,OAAO,KAAK;;sBAEdA,KAAK,GAAGL,MAAM;sBACdA,MAAM,GAAGA,MAAM,CAACA,MAAM;sBACtB;oBACF;oBAEA;oBAEA;oBACA;oBACA;oBACA;oBACA,KAAKrE,OAAA,CAAAqD,cAAc,CAACyB,mBAAmB;sBACrC,OAAOT,MAAM,CAACU,GAAG,KAAKL,KAAK;oBAE7B,KAAK1E,OAAA,CAAAqD,cAAc,CAAC2B,gBAAgB;sBAClC,IAAIX,MAAM,CAACY,MAAM,KAAKP,KAAK,EAAE;wBAC3B,OAAO,KAAK;;sBAEdA,KAAK,GAAGL,MAAM;sBACdA,MAAM,GAAGA,MAAM,CAACA,MAAM;sBACtB;oBACF;oBAEA;sBACE,OAAO,KAAK;;;;cAKpB,OAAOF,GAAG,CAACM,eAAe;YAC5B,CAAC,CACF;YACD,IAAIP,qBAAqB,EAAE;cACzBT,cAAc,CAACI,IAAI,CAACT,SAAS,CAAC;aAC/B,MAAM;cACLO,eAAe,CAACE,IAAI,CAACT,SAAS,CAAC;;;;QAKrC,IACGX,IAAI,CAACQ,UAAU,KAAK,OAAO,IAAIQ,cAAc,CAACQ,MAAM,IACpDxB,IAAI,CAACQ,UAAU,KAAK,MAAM,IAAIU,eAAe,CAACM,MAAO,EACtD;UACArB,aAAa,CAACC,kBAAkB,CAACgB,IAAI,CAAC;YACpCpB,IAAI;YACJgB,cAAc;YACdE,eAAe;YACfC,gBAAgB;YAChBF;WACD,CAAC;;MAEN,CAAC;MACD,cAAcwB,CAAA;QACZ,KAAK,MAAMtC,aAAa,IAAIN,MAAM,CAAC6C,MAAM,CAAC9C,gBAAgB,CAAC,EAAE;UAC3D,IAAIO,aAAa,CAACC,kBAAkB,CAACoB,MAAM,KAAK,CAAC,EAAE;YACjD;YACA;;UAEF,KAAK,MAAMmB,MAAM,IAAIxC,aAAa,CAACC,kBAAkB,EAAE;YACrD,IACEuC,MAAM,CAACzB,eAAe,CAACM,MAAM,KAAK,CAAC,IACnCmB,MAAM,CAACxB,gBAAgB,CAACK,MAAM,KAAK,CAAC,IACpCmB,MAAM,CAAC3C,IAAI,CAACQ,UAAU,KAAK,MAAM,EACjC;cACAlB,OAAO,CAACqD,MAAM,CAAC;gBACb3C,IAAI,EAAE2C,MAAM,CAAC3C,IAAI;gBACjB4C,SAAS,EAAE,eAAe;gBAC1B,CAACC,GAAGA,CAACC,KAAK;kBACR,OAAOC,0BAA0B,CAC/BD,KAAK,EACLH,MAAM,EACNxC,aAAa,CACd;gBACH;eACD,CAAC;aACH,MAAM;cACL,MAAM6C,YAAY,GAAGL,MAAM,CAAC3C,IAAI,CAACQ,UAAU,KAAK,MAAM;cAEtD;cACA,MAAMyC,WAAW,GAAG,CAClBD,YAAY,GACRL,MAAM,CAACzB,eAAe,CAAC;cAAA,EACvByB,MAAM,CAAC3B,cAAc,CACzB;cAAA,EACCkC,GAAG,CAACvC,SAAS,IAAI,IAAIA,SAAS,CAACwC,KAAK,CAACrF,IAAI,GAAG,CAAC;cAEhD,MAAMsF,OAAO,GAAG,CAAC,MAGb;gBACF,MAAMC,WAAW,GAAG5F,IAAI,CAAC6F,cAAc,CAACL,WAAW,CAAC;gBAEpD,IAAIA,WAAW,CAACzB,MAAM,KAAK,CAAC,EAAE;kBAC5B,IAAIwB,YAAY,EAAE;oBAChB,OAAO;sBACLJ,SAAS,EAAE,mBAAmB;sBAC9BW,IAAI,EAAE;wBAAEF;sBAAW;qBACpB;mBACF,MAAM;oBACL,OAAO;sBACLT,SAAS,EAAE,oBAAoB;sBAC/BW,IAAI,EAAE;wBAAEF;sBAAW;qBACpB;;iBAEJ,MAAM;kBACL,IAAIL,YAAY,EAAE;oBAChB,OAAO;sBACLJ,SAAS,EAAE,uBAAuB;sBAClCW,IAAI,EAAE;wBAAEF;sBAAW,CAAE,CAAE;qBACxB;mBACF,MAAM;oBACL,OAAO;sBACLT,SAAS,EAAE,yBAAyB;sBACpCW,IAAI,EAAE;wBAAEF;sBAAW,CAAE,CAAE;qBACxB;;;cAGP,CAAC,EAAC,CAAE;cAEJ/D,OAAO,CAACqD,MAAM,CAAA9C,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA;gBACZE,IAAI,EAAE2C,MAAM,CAAC3C;cAAI,GACdoD,OAAO;gBACV,CAACP,GAAGA,CAACC,KAAK;kBACR,IAAIE,YAAY,EAAE;oBAChB;oBACA,OAAOQ,2BAA2B,CAChCV,KAAK,EACLH,MAAM,EACNxC,aAAa,CACd;mBACF,MAAM;oBACL;oBACA,OAAO4C,0BAA0B,CAC/BD,KAAK,EACLH,MAAM,EACNxC,aAAa,CACd;;gBAEL;cAAC,GACD;;;;MAIV;KACD,GACD;MACE;MACA,wCAAwCsD,CACtCzD,IAAgC;QAEhCV,OAAO,CAACqD,MAAM,CAAC;UACb3C,IAAI;UACJ4C,SAAS,EAAE,eAAe;UAC1BC,GAAGA,CAACC,KAAK;YACP,OAAOY,2CAA2C,CAChDZ,KAAK,EACL9C,IAAI,CACL;UACH;SACD,CAAC;MACJ,CAAC;MACD,sCAAsC2D,CACpC3D,IAA8B;QAE9BV,OAAO,CAACqD,MAAM,CAAC;UACb3C,IAAI;UACJ4C,SAAS,EAAE,eAAe;UAC1BC,GAAGA,CAACC,KAAK;YACP,OAAOc,yCAAyC,CAACd,KAAK,EAAE9C,IAAI,CAAC;UAC/D;SACD,CAAC;MACJ;KACA,GACFhB,uBAAuB,GACvB;MACE;MACA6E,YAAYA,CAAC7D,IAA2B;QACtCV,OAAO,CAACqD,MAAM,CAAC;UACb3C,IAAI;UACJ4C,SAAS,EAAE;SACZ,CAAC;MACJ;KACD,GACD,EAAG;IAGT,SAASkB,iBAAiBA,CAAC9D,IAAgC;;MAKzD,MAAM+D,gBAAgB,GACpB/D,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAACzC,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACG,sBAAsB,GAC7Df,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,GAClB,IAAI;MACV,MAAMuD,kBAAkB,GACtB,CAAAxE,EAAA,GAAAQ,IAAI,CAACS,UAAU,CAACwD,IAAI,CACjBtD,SAAS,IACRA,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACsD,wBAAwB,CAC7D,cAAA1E,EAAA,cAAAA,EAAA,GAAI,IAAI;MACX,MAAM2E,eAAe,GAAGnE,IAAI,CAACS,UAAU,CAAC2D,MAAM,CAC3CzD,SAAS,IACRA,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACC,eAAe,CACpD;MACD,OAAO;QACLkD,gBAAgB;QAChBC,kBAAkB;QAClBG;OACD;IACH;IAEA;;;IAGA,SAASE,uBAAuBA,CAC9BvB,KAAyB,EACzB9C,IAAgC,EAChCsE,qBAAiD,EACjDC,kBAA8C;MAK9C,IAAIA,kBAAkB,CAAC/C,MAAM,KAAK,CAAC,EAAE;QACnC,OAAO;UACLgD,uBAAuB,EAAE,EAAE;UAC3BC,yBAAyB,EAAE;SAC5B;;MAEH,MAAMC,wBAAwB,GAAa,EAAE;MAC7C,MAAMD,yBAAyB,GAAuB,EAAE;MACxD,IAAIH,qBAAqB,CAAC9C,MAAM,KAAK+C,kBAAkB,CAAC/C,MAAM,EAAE;QAC9D;QACA;QACA,MAAMmD,iBAAiB,GAAGlH,IAAI,CAACmH,UAAU,CACvClF,UAAU,CAACmF,cAAc,CACvBP,qBAAqB,CAAC,CAAC,CAAC,EACxB7G,IAAI,CAACqH,mBAAmB,CACzB,EACDrH,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;QACD,MAAMiH,UAAU,GAAGxH,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAACmF,cAAc,CAACF,iBAAiB,EAAElH,IAAI,CAACyH,YAAY,CAAC,EAC/DzH,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;QACD,MAAMmH,iBAAiB,GAAG1H,IAAI,CAACmH,UAAU,CACvClF,UAAU,CAAC0F,oBAAoB,CAC7BT,iBAAiB,EACjB3E,IAAI,CAACC,MAAM,EACXxC,IAAI,CAAC4H,mBAAmB,CACzB,EACD5H,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;QAED;QACA;QACAyG,yBAAyB,CAACrD,IAAI,CAC5B0B,KAAK,CAACwC,WAAW,CAAC,CAACL,UAAU,CAACM,KAAK,CAAC,CAAC,CAAC,EAAEJ,iBAAiB,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CACrE;QAEDb,wBAAwB,CAACtD,IAAI,CAC3B1B,UAAU,CAAC8F,IAAI,CAACC,KAAK,CACnBd,iBAAiB,CAACY,KAAK,CAAC,CAAC,CAAC,EAC1BJ,iBAAiB,CAACI,KAAK,CAAC,CAAC,CAAC,CAC3B,CACF;OACF,MAAM;QACL,MAAMG,oBAAoB,GAAiC,EAAE;QAC7D,IAAIC,KAAK,GAA+B,EAAE;QAC1C,KAAK,MAAMC,cAAc,IAAIrB,kBAAkB,EAAE;UAC/C,IAAID,qBAAqB,CAACuB,QAAQ,CAACD,cAAc,CAAC,EAAE;YAClDD,KAAK,CAACvE,IAAI,CAACwE,cAAc,CAAC;WAC3B,MAAM,IAAID,KAAK,CAACnE,MAAM,EAAE;YACvBkE,oBAAoB,CAACtE,IAAI,CAACuE,KAAK,CAAC;YAChCA,KAAK,GAAG,EAAE;;;QAGd,IAAIA,KAAK,CAACnE,MAAM,EAAE;UAChBkE,oBAAoB,CAACtE,IAAI,CAACuE,KAAK,CAAC;;QAElC,KAAK,MAAMxB,eAAe,IAAIuB,oBAAoB,EAAE;UAClD,MAAM;YAAEJ,WAAW;YAAEQ;UAAS,CAAE,GAAGC,uBAAuB,CACxD5B,eAAe,EACfI,kBAAkB,CACnB;UACDE,yBAAyB,CAACrD,IAAI,CAAC0B,KAAK,CAACwC,WAAW,CAACA,WAAW,CAAC,CAAC;UAE9DZ,wBAAwB,CAACtD,IAAI,CAAC1B,UAAU,CAAC8F,IAAI,CAACC,KAAK,CAAC,GAAGK,SAAS,CAAC,CAAC;;;MAGtE,OAAO;QACLtB,uBAAuB,EAAEE,wBAAwB,CAACsB,IAAI,CAAC,GAAG,CAAC;QAC3DvB;OACD;IACH;IAEA;;;IAGA,SAASsB,uBAAuBA,CAC9BE,mBAA+C,EAC/C1B,kBAA8C;MAK9C,MAAM2B,KAAK,GAAGD,mBAAmB,CAAC,CAAC,CAAC;MACpC,MAAME,IAAI,GAAGF,mBAAmB,CAACA,mBAAmB,CAACzE,MAAM,GAAG,CAAC,CAAC;MAChE,MAAM8D,WAAW,GAAmB,CAACY,KAAK,CAACX,KAAK,CAAC,CAAC,CAAC,EAAEY,IAAI,CAACZ,KAAK,CAAC,CAAC,CAAC,CAAC;MACnE,MAAMO,SAAS,GAAmB,CAAC,GAAGR,WAAW,CAAC;MAClD,MAAMc,MAAM,GAAG1G,UAAU,CAACmF,cAAc,CAACqB,KAAK,CAAE;MAChDJ,SAAS,CAAC,CAAC,CAAC,GAAGM,MAAM,CAACb,KAAK,CAAC,CAAC,CAAC;MAC9B,IAAI9H,IAAI,CAACyH,YAAY,CAACkB,MAAM,CAAC,EAAE;QAC7Bd,WAAW,CAAC,CAAC,CAAC,GAAGc,MAAM,CAACb,KAAK,CAAC,CAAC,CAAC;OACjC,MAAM;QACLD,WAAW,CAAC,CAAC,CAAC,GAAGc,MAAM,CAACb,KAAK,CAAC,CAAC,CAAC;;MAGlC,MAAMc,OAAO,GAAG9B,kBAAkB,CAAC,CAAC,CAAC,KAAK2B,KAAK;MAC/C,MAAMI,MAAM,GAAG/B,kBAAkB,CAACA,kBAAkB,CAAC/C,MAAM,GAAG,CAAC,CAAC,KAAK2E,IAAI;MACzE,MAAMI,KAAK,GAAG7G,UAAU,CAAC8G,aAAa,CAACL,IAAI,CAAE;MAC7CL,SAAS,CAAC,CAAC,CAAC,GAAGS,KAAK,CAAChB,KAAK,CAAC,CAAC,CAAC;MAC7B,IAAIc,OAAO,IAAIC,MAAM,EAAE;QACrB,IAAI7I,IAAI,CAACyH,YAAY,CAACqB,KAAK,CAAC,EAAE;UAC5BjB,WAAW,CAAC,CAAC,CAAC,GAAGiB,KAAK,CAAChB,KAAK,CAAC,CAAC,CAAC;;;MAInC,OAAO;QACLO,SAAS;QACTR;OACD;IACH;IAEA;;;;;;IAMA,SAASmB,4CAA4CA,CACnD3D,KAAyB,EACzB4D,MAAkC,EAClCC,UAAkB;MAElB,MAAMxB,iBAAiB,GAAG1H,IAAI,CAACmH,UAAU,CACvClF,UAAU,CAAC0F,oBAAoB,CAC7B1F,UAAU,CAACkH,aAAa,CAACF,MAAM,CAAE,EACjCA,MAAM,CAACzG,MAAM,EACbxC,IAAI,CAAC4H,mBAAmB,CACzB,EACD5H,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAE0B,MAAM,CAAC1I,IAAI,CAAC,CACtD;MACD,MAAMoI,MAAM,GAAG1G,UAAU,CAACmF,cAAc,CAACM,iBAAiB,CAAE;MAC5D,IAAI,CAAC1H,IAAI,CAACyH,YAAY,CAACkB,MAAM,CAAC,IAAI,CAAC3I,IAAI,CAACqH,mBAAmB,CAACsB,MAAM,CAAC,EAAE;QACnEO,UAAU,GAAG,IAAIA,UAAU,EAAE;;MAE/B,OAAO7D,KAAK,CAAC+D,gBAAgB,CAAC1B,iBAAiB,EAAEwB,UAAU,CAAC;IAC9D;IAEA;;;;;;IAMA,UAAUG,wCAAwCA,CAChDhE,KAAyB,EACzB9B,cAA0C;MAE1C,KAAK,MAAM+F,IAAI,IAAI/F,cAAc,EAAE;QACjC,MAAM2F,UAAU,GAAGjH,UAAU,CAAC8F,IAAI,CAACC,KAAK,CAAC,GAAGsB,IAAI,CAACxB,KAAK,CAAC;QACvD,MAAMzC,KAAK,CAACkE,gBAAgB,CAACD,IAAI,CAACxB,KAAK,EAAE,QAAQoB,UAAU,EAAE,CAAC;;IAElE;IAEA,UAAUM,8BAA8BA,CACtCnE,KAAyB,EACzBH,MAAyB,EACzBxC,aAA4B;MAE5B,MAAM;QAAEH;MAAI,CAAE,GAAG2C,MAAM;MACvB;MACA,MAAM;QAAEwB;MAAe,CAAE,GAAGL,iBAAiB,CAAC9D,IAAI,CAAC;MACnD,MAAMkH,mBAAmB,GAAG/C,eAAe,CAACC,MAAM,CAACzD,SAAS,IAC1DgC,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAClF,SAAS,CAAC,CAC1C;MAED,IAAIR,aAAa,CAACI,WAAW,EAAE;QAC7B;QACA;QACA;QACA,MAAM;UAAE4D,eAAe,EAAEgD;QAA0B,CAAE,GACnDrD,iBAAiB,CAAC3D,aAAa,CAACI,WAAW,CAAC;QAC9C,IACEJ,aAAa,CAACG,oBAAoB,IAClC6G,0BAA0B,CAAC3F,MAAM,EACjC;UACA,OAAOsF,wCAAwC,CAC7ChE,KAAK,EACLoE,mBAAmB,CACpB;;;IAGP;IAEA,UAAUnE,0BAA0BA,CAClCD,KAAyB,EACzBH,MAAyB,EACzBxC,aAA4B;MAE5B,MAAM;QAAEH;MAAI,CAAE,GAAG2C,MAAM;MAEvB,MAAM;QAAEoB,gBAAgB;QAAEC,kBAAkB;QAAEG;MAAe,CAAE,GAC7DL,iBAAiB,CAAC9D,IAAI,CAAC;MAEzB,IAAIgE,kBAAkB,IAAI,CAACD,gBAAgB,EAAE;QAC3C;QACA,OAAOqD,0CAA0C,CAACtE,KAAK,EAAE9C,IAAI,EAAE,KAAK,CAAC;QACrE;OACD,MAAM,IAAI+D,gBAAgB,EAAE;QAC3B,IACEpB,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAC9B,gBAAgB,CAAC,IAChDI,eAAe,CAAC3C,MAAM,KAAK,CAAC,IAC5B,CAACwC,kBAAkB,EACnB;UACA;UACA,OAAOoD,0CAA0C,CAACtE,KAAK,EAAE9C,IAAI,EAAE,IAAI,CAAC;UACpE;SACD,MAAM,IACLf,QAAQ,KAAK,qBAAqB,IAClC,CAAC0D,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAC9B,gBAAgB,CAAC,IACjDI,eAAe,CAAC3C,MAAM,GAAG,CAAC,IAC1B,CAACwC,kBAAkB,EACnB;UACA;UACA;UACA,OAAOiD,8BAA8B,CAACnE,KAAK,EAAEH,MAAM,EAAExC,aAAa,CAAC;UACnE;;OAEH,MAAM,IAAI,CAAC6D,kBAAkB,EAAE;QAC9B,IACE/E,QAAQ,KAAK,qBAAqB,IAClCkF,eAAe,CAACrD,IAAI,CAACH,SAAS,IAC5BgC,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAClF,SAAS,CAAC,CAC1C,EACD;UACA;UACA,OAAOsG,8BAA8B,CAACnE,KAAK,EAAEH,MAAM,EAAExC,aAAa,CAAC;UACnE;SACD,MAAM,IACLgE,eAAe,CAACzD,KAAK,CAACC,SAAS,IAC7BgC,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAClF,SAAS,CAAC,CAC1C,EACD;UACA;UACA,OAAOyG,0CAA0C,CAACtE,KAAK,EAAE9C,IAAI,EAAE,KAAK,CAAC;UACrE;;;MAIJ,MAAMkH,mBAAmB,GAAG/C,eAAe,CAACC,MAAM,CAACzD,SAAS,IAC1DgC,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAClF,SAAS,CAAC,CAC1C;MAED,MAAM0G,oBAAoB,GAAGhD,uBAAuB,CAClDvB,KAAK,EACL9C,IAAI,EACJkH,mBAAmB,EACnB/C,eAAe,CAChB;MACD,MAAMmD,UAAU,GAAuB,EAAE;MACzC,IAAIJ,mBAAmB,CAAC1F,MAAM,EAAE;QAC9B,IAAIrB,aAAa,CAACE,mBAAmB,EAAE;UACrC,MAAMkH,yBAAyB,GAC7Bd,4CAA4C,CAC1C3D,KAAK,EACL3C,aAAa,CAACE,mBAAmB,EACjCgH,oBAAoB,CAAC7C,uBAAuB,CAC7C;UACH,IAAIrE,aAAa,CAACE,mBAAmB,CAACkF,KAAK,CAAC,CAAC,CAAC,IAAIvF,IAAI,CAACuF,KAAK,CAAC,CAAC,CAAC,EAAE;YAC/D,MAAMgC,yBAAyB;WAChC,MAAM;YACLD,UAAU,CAAClG,IAAI,CAACmG,yBAAyB,CAAC;;SAE7C,MAAM;UACL;UACA,IAAItI,QAAQ,KAAK,qBAAqB,EAAE;YACtC,MAAM6D,KAAK,CAAC+D,gBAAgB,CAC1B7G,IAAI,EACJ,WAAWkH,mBAAmB,CAC3BhE,GAAG,CAAC6D,IAAI,IAAG;cACV,MAAMJ,UAAU,GAAGjH,UAAU,CAAC8F,IAAI,CAACC,KAAK,CAAC,GAAGsB,IAAI,CAACxB,KAAK,CAAC;cACvD,OAAO,QAAQoB,UAAU,EAAE;YAC7B,CAAC,CAAC,CACDX,IAAI,CAAC,IAAI,CAAC,UAAUtG,UAAU,CAAC8H,OAAO,CAACxH,IAAI,CAACC,MAAM,CAAC,KAAK,CAC5D;WACF,MAAM;YACL,MAAM6C,KAAK,CAAC+D,gBAAgB,CAC1B7G,IAAI,EACJ,gBACEqH,oBAAoB,CAAC7C,uBACvB,UAAU9E,UAAU,CAAC8H,OAAO,CAACxH,IAAI,CAACC,MAAM,CAAC,KAAK,CAC/C;;;;MAKP,MAAMwH,iCAAiC,GAAuB,EAAE;MAChE,IACEzD,kBAAkB,IAClBrB,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAC7B,kBAAkB,CAAC,EAClD;QACA;QACA;QACA;QACA,MAAMiB,UAAU,GAAGxH,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAACmF,cAAc,CAACb,kBAAkB,EAAEvG,IAAI,CAACyH,YAAY,CAAC,EAChEzH,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;QAED;QACA;QACAyJ,iCAAiC,CAACrG,IAAI,CACpC0B,KAAK,CAACwC,WAAW,CAAC,CAACL,UAAU,CAACM,KAAK,CAAC,CAAC,CAAC,EAAEvB,kBAAkB,CAACuB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CACtE;QAED;QACA;QACA,MAAMzC,KAAK,CAAC+D,gBAAgB,CAC1B7G,IAAI,EACJ,eAAeN,UAAU,CAAC8H,OAAO,CAC/BxD,kBAAkB,CACnB,SAAStE,UAAU,CAAC8H,OAAO,CAACxH,IAAI,CAACC,MAAM,CAAC,KAAK,CAC/C;;MAEH,IACE8D,gBAAgB,IAChBpB,MAAM,CAAC3B,cAAc,CAAC6E,QAAQ,CAAC9B,gBAAgB,CAAC,EAChD;QACA,IAAIpB,MAAM,CAAC3B,cAAc,CAACQ,MAAM,KAAKxB,IAAI,CAACS,UAAU,CAACe,MAAM,EAAE;UAC3D,MAAMkG,WAAW,GAAGjK,IAAI,CAACmH,UAAU,CACjClF,UAAU,CAACkH,aAAa,CAAC5G,IAAI,EAAEvC,IAAI,CAACkK,eAAe,CAAC,EACpDlK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,QAAQ,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACzD;UACD;UACA;UACA,MAAM8E,KAAK,CAAC8E,eAAe,CAACF,WAAW,EAAE,OAAO,CAAC;SAClD,MAAM;UACL,MAAMzC,UAAU,GAAGxH,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAAC8G,aAAa,CAACzC,gBAAgB,EAAEtG,IAAI,CAACyH,YAAY,CAAC,EAC7DzH,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEjB,gBAAgB,CAAC/F,IAAI,CAAC,CAChE;UACD;UACA;UACA,MAAM6J,WAAW,GAAGnI,UAAU,CAAC8F,IAAI,CAChCC,KAAK,CAAC1B,gBAAgB,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAEN,UAAU,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,CACrDuC,IAAI,EAAE;UACT,MAAMhF,KAAK,CAAC+D,gBAAgB,CAC1B7G,IAAI,EACJ,eAAe6H,WAAW,SAASnI,UAAU,CAAC8H,OAAO,CACnDxH,IAAI,CAACC,MAAM,CACZ,KAAK,CACP;UACD,MAAM8H,UAAU,GAAGtK,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAAC8G,aAAa,CAACvB,UAAU,EAAE;YAAE+C,eAAe,EAAE;UAAI,CAAE,CAAC,EAC/DvK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,WAAW,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CAC5D;UACD;UACA;UACA,MAAM8E,KAAK,CAACwC,WAAW,CAAC,CACtBvB,gBAAgB,CAACwB,KAAK,CAAC,CAAC,CAAC,EACzBwC,UAAU,CAACxC,KAAK,CAAC,CAAC,CAAC,CACpB,CAAC;;;MAIN,OAAO8B,oBAAoB,CAAC5C,yBAAyB;MACrD,OAAOgD,iCAAiC;MAExC,OAAOH,UAAU;IACnB;IAEA,UAAUF,0CAA0CA,CAClDtE,KAAyB,EACzB9C,IAAgC,EAChCiI,eAAwB;MAExB;MACA;MACA,MAAMP,WAAW,GAAGjK,IAAI,CAACmH,UAAU,CACjClF,UAAU,CAACkH,aAAa,CAAC5G,IAAI,EAAEvC,IAAI,CAACkK,eAAe,CAAC,EACpDlK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,QAAQ,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACzD;MACD,MAAM8E,KAAK,CAAC8E,eAAe,CAACF,WAAW,EAAE,OAAO,CAAC;MAEjD,IAAIO,eAAe,EAAE;QACnB;QACA,MAAMtD,iBAAiB,GAAGjF,UAAU,CAAC0F,oBAAoB,CACvDsC,WAAW,EACX1H,IAAI,CAACC,MAAM,EACXxC,IAAI,CAACqH,mBAAmB,CACzB;QACD,IAAIH,iBAAiB,EAAE;UACrB;UACA,MAAMM,UAAU,GAAGxH,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAACmF,cAAc,CAACF,iBAAiB,EAAElH,IAAI,CAACyH,YAAY,CAAC,EAC/DzH,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;UACD,MAAMmH,iBAAiB,GAAG1H,IAAI,CAACmH,UAAU,CACvClF,UAAU,CAAC0F,oBAAoB,CAC7BT,iBAAiB,EACjB3E,IAAI,CAACC,MAAM,EACXxC,IAAI,CAAC4H,mBAAmB,CACzB,EACD5H,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,GAAG,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACpD;UAED;UACA;UACA,MAAM8E,KAAK,CAACwC,WAAW,CAAC,CACtBL,UAAU,CAACM,KAAK,CAAC,CAAC,CAAC,EACnBJ,iBAAiB,CAACI,KAAK,CAAC,CAAC,CAAC,CAC3B,CAAC;UACF,MAAM2C,cAAc,GAAGxI,UAAU,CAAC8F,IAAI,CAACC,KAAK,CAC1CR,UAAU,CAACM,KAAK,CAAC,CAAC,CAAC,EACnBJ,iBAAiB,CAACI,KAAK,CAAC,CAAC,CAAC,CAC3B;UACD,IAAIvF,IAAI,CAACS,UAAU,CAACe,MAAM,GAAG,CAAC,EAAE;YAC9B,MAAMsB,KAAK,CAAC8E,eAAe,CACzB5H,IAAI,EACJ,gBAAgBkI,cAAc,SAASxI,UAAU,CAAC8H,OAAO,CACvDxH,IAAI,CAACC,MAAM,CACZ,GAAG,CACL;;;;MAKP;MACA,KAAK,MAAMU,SAAS,IAAIX,IAAI,CAACS,UAAU,EAAE;QACvC,IACEE,SAAS,CAAC3C,IAAI,KAAKT,OAAA,CAAAqD,cAAc,CAACC,eAAe,IACjDF,SAAS,CAACH,UAAU,KAAK,MAAM,EAC/B;UACA,OAAOoD,yCAAyC,CAACd,KAAK,EAAEnC,SAAS,CAAC;;;IAGxE;IAEA,UAAU6C,2BAA2BA,CACnCV,KAAyB,EACzBH,MAAyB,EACzBxC,aAA4B;MAE5B,MAAM;QAAEH;MAAI,CAAE,GAAG2C,MAAM;MAEvB,MAAM;QAAEoB,gBAAgB;QAAEC,kBAAkB;QAAEG;MAAe,CAAE,GAC7DL,iBAAiB,CAAC9D,IAAI,CAAC;MAEzB,IAAIgE,kBAAkB,EAAE;QACtB;QACA,OAAON,2CAA2C,CAACZ,KAAK,EAAE9C,IAAI,CAAC;QAC/D;OACD,MAAM,IAAI+D,gBAAgB,EAAE;QAC3B,IACEpB,MAAM,CAACzB,eAAe,CAAC2E,QAAQ,CAAC9B,gBAAgB,CAAC,IACjDI,eAAe,CAAC3C,MAAM,KAAK,CAAC,EAC5B;UACA;UACA,OAAOkC,2CAA2C,CAACZ,KAAK,EAAE9C,IAAI,CAAC;UAC/D;;OAEH,MAAM;QACL,IACEmE,eAAe,CAACzD,KAAK,CAACC,SAAS,IAC7BgC,MAAM,CAACzB,eAAe,CAAC2E,QAAQ,CAAClF,SAAS,CAAC,CAC3C,EACD;UACA;UACA,OAAO+C,2CAA2C,CAACZ,KAAK,EAAE9C,IAAI,CAAC;UAC/D;;;MAIJ;MACA;MACA;MACA,MAAMmI,oBAAoB,GAAGhE,eAAe,CAACC,MAAM,CAACzD,SAAS,IAC3DgC,MAAM,CAACzB,eAAe,CAAC2E,QAAQ,CAAClF,SAAS,CAAC,CAC3C;MAED,MAAM0G,oBAAoB,GAAGhD,uBAAuB,CAClDvB,KAAK,EACL9C,IAAI,EACJmI,oBAAoB,EACpBhE,eAAe,CAChB;MACD,MAAMmD,UAAU,GAAuB,EAAE;MACzC,IAAIa,oBAAoB,CAAC3G,MAAM,EAAE;QAC/B,IAAIrB,aAAa,CAACG,oBAAoB,EAAE;UACtC,MAAMiH,yBAAyB,GAC7Bd,4CAA4C,CAC1C3D,KAAK,EACL3C,aAAa,CAACG,oBAAoB,EAClC+G,oBAAoB,CAAC7C,uBAAuB,CAC7C;UACH,IAAIrE,aAAa,CAACG,oBAAoB,CAACiF,KAAK,CAAC,CAAC,CAAC,IAAIvF,IAAI,CAACuF,KAAK,CAAC,CAAC,CAAC,EAAE;YAChE,MAAMgC,yBAAyB;WAChC,MAAM;YACLD,UAAU,CAAClG,IAAI,CAACmG,yBAAyB,CAAC;;SAE7C,MAAM;UACL;UACA;UACA,MAAMzE,KAAK,CAAC+D,gBAAgB,CAC1B7G,IAAI,EACJ,WACEqH,oBAAoB,CAAC7C,uBACvB,UAAU9E,UAAU,CAAC8H,OAAO,CAACxH,IAAI,CAACC,MAAM,CAAC,KAAK,CAC/C;;;MAIL,OAAOoH,oBAAoB,CAAC5C,yBAAyB;MAErD,OAAO6C,UAAU;IACnB;IAEA,UAAU5D,2CAA2CA,CACnDZ,KAAyB,EACzB9C,IAAgC;;MAEhC;MACA;MACA,MAAM0H,WAAW,GAAGjK,IAAI,CAACmH,UAAU,CACjClF,UAAU,CAACkH,aAAa,CAAC5G,IAAI,EAAEvC,IAAI,CAACkK,eAAe,CAAC,EACpDlK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,QAAQ,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACzD;MACD,MAAMoK,SAAS,GAAG3K,IAAI,CAACmH,UAAU,CAC/BlF,UAAU,CAAC0F,oBAAoB,CAC7BsC,WAAW,EACX,CAAAjI,EAAA,IAAAD,EAAA,GAAAQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,cAAAjB,EAAA,uBAAAA,EAAA,CAAE2D,KAAK,cAAA1D,EAAA,cAAAA,EAAA,GAAIO,IAAI,CAACC,MAAM,EACxCxC,IAAI,CAAC4K,aAAa,CACnB,EACD5K,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,MAAM,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACvD;MACD,MAAM+J,UAAU,GAAGtK,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAAC8G,aAAa,CAAC4B,SAAS,EAAE;QAAEJ,eAAe,EAAE;MAAI,CAAE,CAAC,EAC9DvK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,WAAW,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CAC5D;MACD,MAAM8E,KAAK,CAACwC,WAAW,CAAC,CAAC8C,SAAS,CAAC7C,KAAK,CAAC,CAAC,CAAC,EAAEwC,UAAU,CAACxC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpE;IAEA,UAAU3B,yCAAyCA,CACjDd,KAAyB,EACzB9C,IAA8B;MAE9B;MACA;MACA,MAAMoI,SAAS,GAAG3K,IAAI,CAACmH,UAAU,CAC/BlF,UAAU,CAACkH,aAAa,CAAC5G,IAAI,EAAEvC,IAAI,CAAC4K,aAAa,CAAC,EAClD5K,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,MAAM,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CACvD;MACD,MAAM+J,UAAU,GAAGtK,IAAI,CAACmH,UAAU,CAChClF,UAAU,CAAC8G,aAAa,CAAC4B,SAAS,EAAE;QAAEJ,eAAe,EAAE;MAAI,CAAE,CAAC,EAC9DvK,IAAI,CAACsH,iBAAiB,CAACC,YAAY,CAAC,WAAW,EAAEhF,IAAI,CAAChC,IAAI,CAAC,CAC5D;MACD,MAAM8E,KAAK,CAACwC,WAAW,CAAC,CAAC8C,SAAS,CAAC7C,KAAK,CAAC,CAAC,CAAC,EAAEwC,UAAU,CAACxC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpE;EACF;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}