{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = retry;\nvar _wrapAsync = require('./internal/wrapAsync.js');\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\nvar _promiseCallback = require('./internal/promiseCallback.js');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction constant(value) {\n  return function () {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\nfunction retry(opts, task, callback) {\n  var options = {\n    times: DEFAULT_TIMES,\n    intervalFunc: constant(DEFAULT_INTERVAL)\n  };\n  if (arguments.length < 3 && typeof opts === 'function') {\n    callback = task || (0, _promiseCallback.promiseCallback)();\n    task = opts;\n  } else {\n    parseTimes(options, opts);\n    callback = callback || (0, _promiseCallback.promiseCallback)();\n  }\n  if (typeof task !== 'function') {\n    throw new Error(\"Invalid arguments for async.retry\");\n  }\n  var _task = (0, _wrapAsync2.default)(task);\n  var attempt = 1;\n  function retryAttempt() {\n    _task((err, ...args) => {\n      if (err === false) return;\n      if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n      } else {\n        callback(err, ...args);\n      }\n    });\n  }\n  retryAttempt();\n  return callback[_promiseCallback.PROMISE_SYMBOL];\n}\nfunction parseTimes(acc, t) {\n  if (typeof t === 'object') {\n    acc.times = +t.times || DEFAULT_TIMES;\n    acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n    acc.errorFilter = t.errorFilter;\n  } else if (typeof t === 'number' || typeof t === 'string') {\n    acc.times = +t || DEFAULT_TIMES;\n  } else {\n    throw new Error(\"Invalid arguments for async.retry\");\n  }\n}\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","retry","_wrapAsync","require","_wrapAsync2","_interopRequireDefault","_promiseCallback","obj","__esModule","constant","DEFAULT_TIMES","DEFAULT_INTERVAL","opts","task","callback","options","times","intervalFunc","arguments","length","promiseCallback","parseTimes","Error","_task","attempt","retryAttempt","err","args","errorFilter","setTimeout","PROMISE_SYMBOL","acc","t","interval","module"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/async/retry.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction constant(value) {\n    return function () {\n        return value;\n    };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant(DEFAULT_INTERVAL)\n    };\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || (0, _promiseCallback.promiseCallback)();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || (0, _promiseCallback.promiseCallback)();\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = (0, _wrapAsync2.default)(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args) => {\n            if (err === false) return;\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n\n    retryAttempt();\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\n\nfunction parseTimes(acc, t) {\n    if (typeof t === 'object') {\n        acc.times = +t.times || DEFAULT_TIMES;\n\n        acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);\n\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\nmodule.exports = exports.default;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,KAAK;AAEvB,IAAIC,UAAU,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AAEnD,IAAIC,WAAW,GAAGC,sBAAsB,CAACH,UAAU,CAAC;AAEpD,IAAII,gBAAgB,GAAGH,OAAO,CAAC,+BAA+B,CAAC;AAE/D,SAASE,sBAAsBA,CAACE,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAEP,OAAO,EAAEO;EAAI,CAAC;AAAE;AAE9F,SAASE,QAAQA,CAACV,KAAK,EAAE;EACrB,OAAO,YAAY;IACf,OAAOA,KAAK;EAChB,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMW,aAAa,GAAG,CAAC;AACvB,MAAMC,gBAAgB,GAAG,CAAC;AAE1B,SAASV,KAAKA,CAACW,IAAI,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACjC,IAAIC,OAAO,GAAG;IACVC,KAAK,EAAEN,aAAa;IACpBO,YAAY,EAAER,QAAQ,CAACE,gBAAgB;EAC3C,CAAC;EAED,IAAIO,SAAS,CAACC,MAAM,GAAG,CAAC,IAAI,OAAOP,IAAI,KAAK,UAAU,EAAE;IACpDE,QAAQ,GAAGD,IAAI,IAAI,CAAC,CAAC,EAAEP,gBAAgB,CAACc,eAAe,EAAE,CAAC;IAC1DP,IAAI,GAAGD,IAAI;EACf,CAAC,MAAM;IACHS,UAAU,CAACN,OAAO,EAAEH,IAAI,CAAC;IACzBE,QAAQ,GAAGA,QAAQ,IAAI,CAAC,CAAC,EAAER,gBAAgB,CAACc,eAAe,EAAE,CAAC;EAClE;EAEA,IAAI,OAAOP,IAAI,KAAK,UAAU,EAAE;IAC5B,MAAM,IAAIS,KAAK,CAAC,mCAAmC,CAAC;EACxD;EAEA,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAEnB,WAAW,CAACJ,OAAO,EAAEa,IAAI,CAAC;EAE1C,IAAIW,OAAO,GAAG,CAAC;EACf,SAASC,YAAYA,CAAA,EAAG;IACpBF,KAAK,CAAC,CAACG,GAAG,EAAE,GAAGC,IAAI,KAAK;MACpB,IAAID,GAAG,KAAK,KAAK,EAAE;MACnB,IAAIA,GAAG,IAAIF,OAAO,EAAE,GAAGT,OAAO,CAACC,KAAK,KAAK,OAAOD,OAAO,CAACa,WAAW,IAAI,UAAU,IAAIb,OAAO,CAACa,WAAW,CAACF,GAAG,CAAC,CAAC,EAAE;QAC5GG,UAAU,CAACJ,YAAY,EAAEV,OAAO,CAACE,YAAY,CAACO,OAAO,GAAG,CAAC,CAAC,CAAC;MAC/D,CAAC,MAAM;QACHV,QAAQ,CAACY,GAAG,EAAE,GAAGC,IAAI,CAAC;MAC1B;IACJ,CAAC,CAAC;EACN;EAEAF,YAAY,CAAC,CAAC;EACd,OAAOX,QAAQ,CAACR,gBAAgB,CAACwB,cAAc,CAAC;AACpD;AAEA,SAAST,UAAUA,CAACU,GAAG,EAAEC,CAAC,EAAE;EACxB,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;IACvBD,GAAG,CAACf,KAAK,GAAG,CAACgB,CAAC,CAAChB,KAAK,IAAIN,aAAa;IAErCqB,GAAG,CAACd,YAAY,GAAG,OAAOe,CAAC,CAACC,QAAQ,KAAK,UAAU,GAAGD,CAAC,CAACC,QAAQ,GAAGxB,QAAQ,CAAC,CAACuB,CAAC,CAACC,QAAQ,IAAItB,gBAAgB,CAAC;IAE5GoB,GAAG,CAACH,WAAW,GAAGI,CAAC,CAACJ,WAAW;EACnC,CAAC,MAAM,IAAI,OAAOI,CAAC,KAAK,QAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;IACvDD,GAAG,CAACf,KAAK,GAAG,CAACgB,CAAC,IAAItB,aAAa;EACnC,CAAC,MAAM;IACH,MAAM,IAAIY,KAAK,CAAC,mCAAmC,CAAC;EACxD;AACJ;AACAY,MAAM,CAACpC,OAAO,GAAGA,OAAO,CAACE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}