{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n})(this, function (exports) {\n  'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    (function c(node, st, override) {\n      var type = override || node.type,\n        found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) {\n        found(node, st);\n      }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    (function c(node, st, override) {\n      var type = override || node.type,\n        found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) {\n        ancestors.push(node);\n      }\n      baseVisitor[type](node, st, c);\n      if (found) {\n        found(node, st || ancestors, ancestors);\n      }\n      if (isNew) {\n        ancestors.pop();\n      }\n    })(node, state, override);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n    (function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n  function makeTest(test) {\n    if (typeof test === \"string\") {\n      return function (type) {\n        return type === test;\n      };\n    } else if (!test) {\n      return function () {\n        return true;\n      };\n    } else {\n      return test;\n    }\n  }\n  var Found = function Found(node, state) {\n    this.node = node;\n    this.state = state;\n  };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    (function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (!override) {\n        callback(node, st, type);\n      }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    var ancestors = [];\n    (function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) {\n        ancestors.push(node);\n      }\n      baseVisitor[type](node, st, c);\n      if (!override) {\n        callback(node, st || ancestors, ancestors, type);\n      }\n      if (isNew) {\n        ancestors.pop();\n      }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) && (end == null || node.end >= end)) {\n          baseVisitor[type](node, st, c);\n        }\n        if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {\n          throw new Found(node, st);\n        }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) {\n          return;\n        }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) {\n          throw new Found(node, st);\n        }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) {\n          return;\n        }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) {\n          throw new Found(node, st);\n        }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n    var max;\n    (function c(node, st, override) {\n      if (node.start > pos) {\n        return;\n      }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n        max = new Found(node, st);\n      }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max;\n  }\n\n  // Fallback to an Object.create polyfill for older environments.\n  var create = Object.create || function (proto) {\n    function Ctor() {}\n    Ctor.prototype = proto;\n    return new Ctor();\n  };\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = create(baseVisitor || base);\n    for (var type in funcs) {\n      visitor[type] = funcs[type];\n    }\n    return visitor;\n  }\n  function skipThrough(node, st, c) {\n    c(node, st);\n  }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n  base.Program = base.BlockStatement = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n      var stmt = list[i];\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function (node, st, c) {\n    return c(node.expression, st, \"Expression\");\n  };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) {\n      c(node.alternate, st, \"Statement\");\n    }\n  };\n  base.LabeledStatement = function (node, st, c) {\n    return c(node.body, st, \"Statement\");\n  };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n      if (cs.test) {\n        c(cs.test, st, \"Expression\");\n      }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1) {\n        var cons = list[i];\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) {\n      c(node.test, st, \"Expression\");\n    }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n      var cons = list[i];\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) {\n      c(node.argument, st, \"Expression\");\n    }\n  };\n  base.ThrowStatement = base.SpreadElement = function (node, st, c) {\n    return c(node.argument, st, \"Expression\");\n  };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) {\n      c(node.handler, st);\n    }\n    if (node.finalizer) {\n      c(node.finalizer, st, \"Statement\");\n    }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) {\n      c(node.param, st, \"Pattern\");\n    }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) {\n      c(node.init, st, \"ForInit\");\n    }\n    if (node.test) {\n      c(node.test, st, \"Expression\");\n    }\n    if (node.update) {\n      c(node.update, st, \"Expression\");\n    }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") {\n      c(node, st);\n    } else {\n      c(node, st, \"Expression\");\n    }\n  };\n  base.DebuggerStatement = ignore;\n  base.FunctionDeclaration = function (node, st, c) {\n    return c(node, st, \"Function\");\n  };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n      var decl = list[i];\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) {\n      c(node.init, st, \"Expression\");\n    }\n  };\n  base.Function = function (node, st, c) {\n    if (node.id) {\n      c(node.id, st, \"Pattern\");\n    }\n    for (var i = 0, list = node.params; i < list.length; i += 1) {\n      var param = list[i];\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\") {\n      c(node, st, \"VariablePattern\");\n    } else if (node.type === \"MemberExpression\") {\n      c(node, st, \"MemberPattern\");\n    } else {\n      c(node, st);\n    }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) {\n    return c(node.argument, st, \"Pattern\");\n  };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n      if (elt) {\n        c(elt, st, \"Pattern\");\n      }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      if (prop.type === \"Property\") {\n        if (prop.computed) {\n          c(prop.key, st, \"Expression\");\n        }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n      if (elt) {\n        c(elt, st, \"Expression\");\n      }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n      var expr = list[i];\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n      var quasi = list[i];\n      c(quasi, st);\n    }\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n      var expr = list$1[i$1];\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments) {\n      for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n        var arg = list[i];\n        c(arg, st, \"Expression\");\n      }\n    }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) {\n      c(node.property, st, \"Expression\");\n    }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration) {\n      c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n    }\n    if (node.source) {\n      c(node.source, st, \"Expression\");\n    }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported) {\n      c(node.exported, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n      var spec = list[i];\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) {\n    return c(node, st, \"Class\");\n  };\n  base.Class = function (node, st, c) {\n    if (node.id) {\n      c(node.id, st, \"Pattern\");\n    }\n    if (node.superClass) {\n      c(node.superClass, st, \"Expression\");\n    }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n      var elt = list[i];\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.Property = function (node, st, c) {\n    if (node.computed) {\n      c(node.key, st, \"Expression\");\n    }\n    c(node.value, st, \"Expression\");\n  };\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","acorn","walk","simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","ChainExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","i$1","list$1","cases","cs","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","expressions","expr","TemplateLiteral","quasis","quasi","TemplateElement","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","exported","ImportDeclaration","specifiers","spec","ImportExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","TaggedTemplateExpression","tag","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","Property","defineProperty"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/acorn-walk/dist/walk.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n}(this, (function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state, override);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st, type); }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = []\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st || ancestors, ancestors, type); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Fallback to an Object.create polyfill for older environments.\n  var create = Object.create || function(proto) {\n    function Ctor() {}\n    Ctor.prototype = proto;\n    return new Ctor\n  };\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) { c(cs.test, st, \"Expression\"); }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n        {\n        var cons = list[i];\n\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported)\n      { c(node.exported, st); }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    c(node.value, st, \"Expression\");\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}