{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, opt) => {\n  api.assertVersion(\"^7.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const {\n    types: t,\n    template\n  } = api;\n  const {\n    loose\n  } = opt;\n  const classWeakSets = new WeakMap();\n  const fieldsWeakSets = new WeakMap();\n  function unshadow(name, targetScope, scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n  function injectToFieldInit(fieldPath, expr, before = false) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n  function injectInitialization(classPath, init) {\n    let firstFieldPath;\n    let constructorPath;\n    for (const el of classPath.get(\"body.body\")) {\n      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = el;\n      }\n    }\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);\n    }\n  }\n  function getWeakSetId(weakSets, outerClass, reference, name = \"\", inject) {\n    let id = weakSets.get(reference.node);\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      (0, _helperAnnotateAsPure.default)(newExpr);\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n    return t.cloneNode(id);\n  }\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits: api.version[0] === \"8\" ? undefined : require(\"@babel/plugin-syntax-private-property-in-object\").default,\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n        const {\n          name\n        } = node.left.id;\n        let privateElement;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n          privateElement = path.get(\"body.body\").find(({\n            node\n          }) => t.isPrivate(node) && node.key.id.name === name);\n          return !!privateElement;\n        });\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);\n          return;\n        }\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}\n              `);\n          } else {\n            var _outerClass$node$id;\n            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);\n            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n          }\n        } else {\n          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);\n          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","_helperAnnotateAsPure","_default","exports","default","declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","constructorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","inherits","version","undefined","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right","_outerClass$node$id"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-private-property-in-object\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let constructorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, constructorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<t.Node, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expression: t.Expression,\n      before?: boolean,\n    ) => void,\n  ) {\n    let id = weakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      annotateAsPure(newExpr);\n\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits:\n      USE_ESM || IS_STANDALONE || api.version[0] === \"8\"\n        ? undefined\n        : // eslint-disable-next-line no-restricted-globals\n          require(\"@babel/plugin-syntax-private-property-in-object\").default,\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const { node } = path;\n        const { file } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n\n        const { name } = node.left.id;\n\n        let privateElement: NodePath<\n          t.ClassPrivateMethod | t.ClassPrivateProperty\n        >;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n\n          privateElement = path.get(\"body.body\").find(\n            ({ node }) =>\n              // fixme: Support class accessor property\n              t.isPrivate(node) && node.key.id.name === name,\n          ) as NodePath<t.ClassPrivateMethod | t.ClassPrivateProperty>;\n\n          return !!privateElement;\n        }) as NodePath<t.Class>;\n\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(\n            template.ast`(() => ${outerClass.node})()` as t.Statement,\n          );\n          // The injected class will be queued and eventually transformed when visited\n          return;\n        }\n\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(\n              template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${buildCheckInRHS(\n                  node.right,\n                  file,\n                )}\n              `,\n            );\n          } else {\n            const id = getWeakSetId(\n              classWeakSets,\n              outerClass,\n              outerClass,\n              outerClass.node.id?.name,\n              injectInitialization,\n            );\n\n            path.replaceWith(\n              template.expression.ast`${id}.has(${buildCheckInRHS(\n                node.right,\n                file,\n              )})`,\n            );\n          }\n        } else {\n          // Private fields might not all be initialized: see the 'halfConstructed'\n          // example at https://v8.dev/features/private-brand-checks.\n\n          const id = getWeakSetId<t.ClassPrivateProperty>(\n            fieldsWeakSets,\n            outerClass,\n            privateElement as NodePath<t.ClassPrivateProperty>,\n            privateElement.node.key.id.name,\n            injectToFieldInit,\n          );\n\n          path.replaceWith(\n            template.expression.ast`${id}.has(${buildCheckInRHS(\n              node.right,\n              file,\n            )})`,\n          );\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}