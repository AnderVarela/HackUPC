{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'strict-boolean-expressions',\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    hasSuggestions: true,\n    docs: {\n      description: 'Disallow certain types in boolean expressions',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowString: {\n          type: 'boolean'\n        },\n        allowNumber: {\n          type: 'boolean'\n        },\n        allowNullableObject: {\n          type: 'boolean'\n        },\n        allowNullableBoolean: {\n          type: 'boolean'\n        },\n        allowNullableString: {\n          type: 'boolean'\n        },\n        allowNullableNumber: {\n          type: 'boolean'\n        },\n        allowNullableEnum: {\n          type: 'boolean'\n        },\n        allowAny: {\n          type: 'boolean'\n        },\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      conditionErrorOther: 'Unexpected value in conditional. ' + 'A boolean expression is required.',\n      conditionErrorAny: 'Unexpected any value in conditional. ' + 'An explicit comparison or type cast is required.',\n      conditionErrorNullish: 'Unexpected nullish value in conditional. ' + 'The condition is always false.',\n      conditionErrorNullableBoolean: 'Unexpected nullable boolean value in conditional. ' + 'Please handle the nullish case explicitly.',\n      conditionErrorString: 'Unexpected string value in conditional. ' + 'An explicit empty string check is required.',\n      conditionErrorNullableString: 'Unexpected nullable string value in conditional. ' + 'Please handle the nullish/empty cases explicitly.',\n      conditionErrorNumber: 'Unexpected number value in conditional. ' + 'An explicit zero/NaN check is required.',\n      conditionErrorNullableNumber: 'Unexpected nullable number value in conditional. ' + 'Please handle the nullish/zero/NaN cases explicitly.',\n      conditionErrorObject: 'Unexpected object value in conditional. ' + 'The condition is always true.',\n      conditionErrorNullableObject: 'Unexpected nullable object value in conditional. ' + 'An explicit null check is required.',\n      conditionErrorNullableEnum: 'Unexpected nullable enum value in conditional. ' + 'Please handle the nullish/zero/NaN cases explicitly.',\n      noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',\n      conditionFixDefaultFalse: 'Explicitly treat nullish value the same as false (`value ?? false`)',\n      conditionFixDefaultEmptyString: 'Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)',\n      conditionFixDefaultZero: 'Explicitly treat nullish value the same as 0 (`value ?? 0`)',\n      conditionFixCompareNullish: 'Change condition to check for null/undefined (`value != null`)',\n      conditionFixCastBoolean: 'Explicitly cast value to a boolean (`Boolean(value)`)',\n      conditionFixCompareTrue: 'Change condition to check if true (`value === true`)',\n      conditionFixCompareFalse: 'Change condition to check if false (`value === false`)',\n      conditionFixCompareStringLength: \"Change condition to check string's length (`value.length !== 0`)\",\n      conditionFixCompareEmptyString: 'Change condition to check for empty string (`value !== \"\"`)',\n      conditionFixCompareZero: 'Change condition to check for 0 (`value !== 0`)',\n      conditionFixCompareNaN: 'Change condition to check for NaN (`!Number.isNaN(value)`)'\n    }\n  },\n  defaultOptions: [{\n    allowString: true,\n    allowNumber: true,\n    allowNullableObject: true,\n    allowNullableBoolean: false,\n    allowNullableString: false,\n    allowNullableNumber: false,\n    allowNullableEnum: true,\n    allowAny: false,\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false\n  }],\n  create(context, [options]) {\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const compilerOptions = parserServices.program.getCompilerOptions();\n    const sourceCode = context.getSourceCode();\n    const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');\n    if (!isStrictNullChecks && options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n      context.report({\n        loc: {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        },\n        messageId: 'noStrictNullCheck'\n      });\n    }\n    const traversedNodes = new Set();\n    return {\n      ConditionalExpression: traverseTestExpression,\n      DoWhileStatement: traverseTestExpression,\n      ForStatement: traverseTestExpression,\n      IfStatement: traverseTestExpression,\n      WhileStatement: traverseTestExpression,\n      'LogicalExpression[operator!=\"??\"]': traverseLogicalExpression,\n      'UnaryExpression[operator=\"!\"]': traverseUnaryLogicalExpression\n    };\n    /**\n     * Inspects condition of a test expression. (`if`, `while`, `for`, etc.)\n     */\n    function traverseTestExpression(node) {\n      if (node.test == null) {\n        return;\n      }\n      traverseNode(node.test, true);\n    }\n    /**\n     * Inspects the argument of a unary logical expression (`!`).\n     */\n    function traverseUnaryLogicalExpression(node) {\n      traverseNode(node.argument, true);\n    }\n    /**\n     * Inspects the arguments of a logical expression (`&&`, `||`).\n     *\n     * If the logical expression is a descendant of a test expression,\n     * the `isCondition` flag should be set to true.\n     * Otherwise, if the logical expression is there on it's own,\n     * it's used for control flow and is not a condition itself.\n     */\n    function traverseLogicalExpression(node, isCondition = false) {\n      // left argument is always treated as a condition\n      traverseNode(node.left, true);\n      // if the logical expression is used for control flow,\n      // then it's right argument is used for it's side effects only\n      traverseNode(node.right, isCondition);\n    }\n    /**\n     * Inspects any node.\n     *\n     * If it's a logical expression then it recursively traverses its arguments.\n     * If it's any other kind of node then it's type is finally checked against the rule,\n     * unless `isCondition` flag is set to false, in which case\n     * it's assumed to be used for side effects only and is skipped.\n     */\n    function traverseNode(node, isCondition) {\n      // prevent checking the same node multiple times\n      if (traversedNodes.has(node)) {\n        return;\n      }\n      traversedNodes.add(node);\n      // for logical operator, we check its operands\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.operator !== '??') {\n        traverseLogicalExpression(node, isCondition);\n        return;\n      }\n      // skip if node is not a condition\n      if (!isCondition) {\n        return;\n      }\n      checkNode(node);\n    }\n    /**\n     * This function does the actual type check on a node.\n     * It analyzes the type of a node and checks if it is allowed in a boolean context.\n     */\n    function checkNode(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const type = util.getConstrainedTypeAtLocation(typeChecker, tsNode);\n      const types = inspectVariantTypes(tsutils.unionTypeParts(type));\n      const is = (...wantedTypes) => types.size === wantedTypes.length && wantedTypes.every(type => types.has(type));\n      // boolean\n      if (is('boolean') || is('truthy boolean')) {\n        // boolean is always okay\n        return;\n      }\n      // never\n      if (is('never')) {\n        // never is always okay\n        return;\n      }\n      // nullish\n      if (is('nullish')) {\n        // condition is always false\n        context.report({\n          node,\n          messageId: 'conditionErrorNullish'\n        });\n        return;\n      }\n      // Known edge case: boolean `true` and nullish values are always valid boolean expressions\n      if (is('nullish', 'truthy boolean')) {\n        return;\n      }\n      // nullable boolean\n      if (is('nullish', 'boolean')) {\n        if (!options.allowNullableBoolean) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableBoolean)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableBoolean',\n              suggest: [{\n                messageId: 'conditionFixDefaultFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? false`\n                })\n              }, {\n                messageId: 'conditionFixCompareFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === false`\n                })\n              }]\n            });\n          } else {\n            // if (nullableBoolean)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableBoolean',\n              suggest: [{\n                messageId: 'conditionFixDefaultFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? false`\n                })\n              }, {\n                messageId: 'conditionFixCompareTrue',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} === true`\n                })\n              }]\n            });\n          }\n        }\n        return;\n      }\n      // Known edge case: truthy primitives and nullish values are always valid boolean expressions\n      if (options.allowNumber && is('nullish', 'truthy number') || options.allowString && is('nullish', 'truthy string')) {\n        return;\n      }\n      // string\n      if (is('string') || is('truthy string')) {\n        if (!options.allowString) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!string)\n            context.report({\n              node,\n              messageId: 'conditionErrorString',\n              suggest: [{\n                messageId: 'conditionFixCompareStringLength',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code}.length === 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (string)\n            context.report({\n              node,\n              messageId: 'conditionErrorString',\n              suggest: [{\n                messageId: 'conditionFixCompareStringLength',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code}.length > 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} !== \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n        return;\n      }\n      // nullable string\n      if (is('nullish', 'string')) {\n        if (!options.allowNullableString) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableString)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableString',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} == null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (nullableString)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableString',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} != null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n        return;\n      }\n      // number\n      if (is('number') || is('truthy number')) {\n        if (!options.allowNumber) {\n          if (isArrayLengthExpression(node, typeChecker, parserServices)) {\n            if (isLogicalNegationExpression(node.parent)) {\n              // if (!array.length)\n              context.report({\n                node,\n                messageId: 'conditionErrorNumber',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === 0`\n                })\n              });\n            } else {\n              // if (array.length)\n              context.report({\n                node,\n                messageId: 'conditionErrorNumber',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} > 0`\n                })\n              });\n            }\n          } else if (isLogicalNegationExpression(node.parent)) {\n            // if (!number)\n            context.report({\n              node,\n              messageId: 'conditionErrorNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  // TODO: we have to compare to 0n if the type is bigint\n                  wrap: code => `${code} === 0`\n                })\n              }, {\n                // TODO: don't suggest this for bigint because it can't be NaN\n                messageId: 'conditionFixCompareNaN',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `Number.isNaN(${code})`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (number)\n            context.report({\n              node,\n              messageId: 'conditionErrorNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} !== 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareNaN',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `!Number.isNaN(${code})`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n        return;\n      }\n      // nullable number\n      if (is('nullish', 'number')) {\n        if (!options.allowNullableNumber) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableNumber)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} == null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? 0`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (nullableNumber)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} != null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? 0`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n        return;\n      }\n      // object\n      if (is('object')) {\n        // condition is always true\n        context.report({\n          node,\n          messageId: 'conditionErrorObject'\n        });\n        return;\n      }\n      // nullable object\n      if (is('nullish', 'object')) {\n        if (!options.allowNullableObject) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableObject)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableObject',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node: node.parent,\n                innerNode: node,\n                wrap: code => `${code} == null`\n              })\n            });\n          } else {\n            // if (nullableObject)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableObject',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node,\n                wrap: code => `${code} != null`\n              })\n            });\n          }\n        }\n        return;\n      }\n      // nullable enum\n      if (is('nullish', 'number', 'enum') || is('nullish', 'string', 'enum') || is('nullish', 'truthy number', 'enum') || is('nullish', 'truthy string', 'enum') ||\n      // mixed enums\n      is('nullish', 'truthy number', 'truthy string', 'enum') || is('nullish', 'truthy number', 'string', 'enum') || is('nullish', 'truthy string', 'number', 'enum') || is('nullish', 'number', 'string', 'enum')) {\n        if (!options.allowNullableEnum) {\n          if (isLogicalNegationExpression(node.parent)) {\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableEnum',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node: node.parent,\n                innerNode: node,\n                wrap: code => `${code} == null`\n              })\n            });\n          } else {\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableEnum',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node,\n                wrap: code => `${code} != null`\n              })\n            });\n          }\n        }\n        return;\n      }\n      // any\n      if (is('any')) {\n        if (!options.allowAny) {\n          context.report({\n            node,\n            messageId: 'conditionErrorAny',\n            suggest: [{\n              messageId: 'conditionFixCastBoolean',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node,\n                wrap: code => `Boolean(${code})`\n              })\n            }]\n          });\n        }\n        return;\n      }\n      // other\n      context.report({\n        node,\n        messageId: 'conditionErrorOther'\n      });\n    }\n    /**\n     * Check union variants for the types we care about\n     */\n    function inspectVariantTypes(types) {\n      const variantTypes = new Set();\n      if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {\n        variantTypes.add('nullish');\n      }\n      const booleans = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));\n      // If incoming type is either \"true\" or \"false\", there will be one type\n      // object with intrinsicName set accordingly\n      // If incoming type is boolean, there will be two type objects with\n      // intrinsicName set \"true\" and \"false\" each because of tsutils.unionTypeParts()\n      if (booleans.length === 1) {\n        tsutils.isBooleanLiteralType(booleans[0], true) ? variantTypes.add('truthy boolean') : variantTypes.add('boolean');\n      } else if (booleans.length === 2) {\n        variantTypes.add('boolean');\n      }\n      const strings = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));\n      if (strings.length) {\n        if (strings.every(type => type.isStringLiteral() && type.value !== '')) {\n          variantTypes.add('truthy string');\n        } else {\n          variantTypes.add('string');\n        }\n      }\n      const numbers = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));\n      if (numbers.length) {\n        if (numbers.every(type => type.isNumberLiteral() && type.value !== 0)) {\n          variantTypes.add('truthy number');\n        } else {\n          variantTypes.add('number');\n        }\n      }\n      if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {\n        variantTypes.add('enum');\n      }\n      if (types.some(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike | ts.TypeFlags.BooleanLike | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike | ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Never))) {\n        variantTypes.add('object');\n      }\n      if (types.some(type => util.isTypeFlagSet(type, ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown))) {\n        variantTypes.add('any');\n      }\n      if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {\n        variantTypes.add('never');\n      }\n      return variantTypes;\n    }\n  }\n});\nfunction isLogicalNegationExpression(node) {\n  return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!';\n}\nfunction isArrayLengthExpression(node, typeChecker, parserServices) {\n  if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n    return false;\n  }\n  if (node.computed) {\n    return false;\n  }\n  if (node.property.name !== 'length') {\n    return false;\n  }\n  const objectTsNode = parserServices.esTreeNodeToTSNodeMap.get(node.object);\n  const objectType = util.getConstrainedTypeAtLocation(typeChecker, objectTsNode);\n  return util.isTypeArrayTypeOrUnionOfArrayTypes(objectType, typeChecker);\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","exports","default","createRule","name","meta","type","fixable","hasSuggestions","docs","description","recommended","requiresTypeChecking","schema","properties","allowString","allowNumber","allowNullableObject","allowNullableBoolean","allowNullableString","allowNullableNumber","allowNullableEnum","allowAny","allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing","additionalProperties","messages","conditionErrorOther","conditionErrorAny","conditionErrorNullish","conditionErrorNullableBoolean","conditionErrorString","conditionErrorNullableString","conditionErrorNumber","conditionErrorNullableNumber","conditionErrorObject","conditionErrorNullableObject","conditionErrorNullableEnum","noStrictNullCheck","conditionFixDefaultFalse","conditionFixDefaultEmptyString","conditionFixDefaultZero","conditionFixCompareNullish","conditionFixCastBoolean","conditionFixCompareTrue","conditionFixCompareFalse","conditionFixCompareStringLength","conditionFixCompareEmptyString","conditionFixCompareZero","conditionFixCompareNaN","defaultOptions","create","context","options","parserServices","getParserServices","typeChecker","program","getTypeChecker","compilerOptions","getCompilerOptions","sourceCode","getSourceCode","isStrictNullChecks","isStrictCompilerOptionEnabled","report","loc","start","line","column","end","messageId","traversedNodes","Set","ConditionalExpression","traverseTestExpression","DoWhileStatement","ForStatement","IfStatement","WhileStatement","traverseLogicalExpression","traverseUnaryLogicalExpression","node","test","traverseNode","argument","isCondition","left","right","has","add","AST_NODE_TYPES","LogicalExpression","operator","checkNode","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","types","inspectVariantTypes","unionTypeParts","is","wantedTypes","size","length","every","isLogicalNegationExpression","parent","suggest","fix","getWrappingFixer","wrap","code","innerNode","isArrayLengthExpression","variantTypes","some","isTypeFlagSet","TypeFlags","Null","Undefined","VoidLike","booleans","filter","BooleanLike","isBooleanLiteralType","strings","StringLike","isStringLiteral","value","numbers","NumberLike","BigIntLike","isNumberLiteral","EnumLike","TypeParameter","Any","Unknown","Never","UnaryExpression","MemberExpression","computed","property","objectTsNode","object","objectType","isTypeArrayTypeOrUnionOfArrayTypes"],"sources":["../../src/rules/strict-boolean-expressions.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}