{"ast":null,"code":"import * as _acorn from \"acorn\";\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nexport function importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this.type === this.assertToken || this.type === tt._with) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this.type === this.assertToken || this.type === tt._with) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this.type === this.assertToken || this.type == tt._with) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n\n        // parse AssertionKey : IdentifierName, StringLiteral\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}","map":{"version":3,"names":["_acorn","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","importAssertions","Parser","acorn","tokTypes","tt","TokenType","constructor","args","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","obj","parseObj","arguments","parenR","finishNode","parseExport","exports","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","_with","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","value","key","has","raise","add","push"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/acorn-import-assertions/src/index.js"],"sourcesContent":["import * as _acorn from \"acorn\";\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\n\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4\n\nexport function importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const { tokTypes: tt, TokenType } = acorn;\n\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken || this.type === tt._with) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\")\n      }\n      if (this.eat(tt._default)) { // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) { this.next(); }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\")\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\")\n          { this.checkVariableExport(exports, node.declaration.declarations); }\n        else\n          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n        node.specifiers = [];\n        node.source = null;\n      } else { // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) { this.unexpected(); }\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken || this.type === tt._with) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\")\n    }\n\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source =\n          this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken || this.type == tt._with) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode();\n\n        // parse AssertionKey : IdentifierName, StringLiteral\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(\n            this.pos,\n            \"Only string is supported as an assertion value\"\n          );\n        }\n\n        node.value = this.parseLiteral(this.value);\n\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n  };\n}\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,OAAO;AAE/B,MAAMC,cAAc,GAAG,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC;AACxC,MAAMC,KAAK,GAAG,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC;AAE/B,MAAME,OAAO,GAAG,QAAQ;AACxB,MAAMC,cAAc,GAAG,CAAC;EAAEC,sBAAsB,GAAG,CAAC;EAAEC,gBAAgB,GAAG,CAAC;AAE1E,OAAO,SAASC,gBAAgBA,CAACC,MAAM,EAAE;EACvC;EACA;EACA;EACA;EACA;EACA,MAAMC,KAAK,GAAGD,MAAM,CAACC,KAAK,IAAIV,MAAM;EACpC,MAAM;IAAEW,QAAQ,EAAEC,EAAE;IAAEC;EAAU,CAAC,GAAGH,KAAK;EAEzC,OAAO,cAAcD,MAAM,CAAC;IAC1BK,WAAWA,CAAC,GAAGC,IAAI,EAAE;MACnB,KAAK,CAAC,GAAGA,IAAI,CAAC;MACd,IAAI,CAACC,WAAW,GAAG,IAAIH,SAAS,CAACT,OAAO,CAAC;IAC3C;IAEAa,OAAOA,CAACC,CAAC,EAAE;MACT,OAAO,IAAI,CAACC,KAAK,CAACjB,UAAU,CAACgB,CAAC,CAAC;IACjC;IAEAE,IAAIA,CAACC,CAAC,EAAE;MACN,IAAI,IAAI,CAACC,IAAI,KAAKD,CAAC,EAAE;QACnB,IAAI,CAACE,UAAU,CAAC,CAAC;MACnB;MACA,IAAI,CAACC,IAAI,CAAC,CAAC;IACb;IAEAC,SAASA,CAACC,IAAI,EAAE;MACd,IAAIR,CAAC,GAAG,CAAC;MACT,OAAOA,CAAC,GAAGd,OAAO,CAACuB,MAAM,EAAET,CAAC,EAAE,EAAE;QAC9B,IAAI,IAAI,CAACD,OAAO,CAAC,IAAI,CAACW,GAAG,GAAGV,CAAC,CAAC,KAAKd,OAAO,CAACF,UAAU,CAACgB,CAAC,CAAC,EAAE;UACxD,OAAO,KAAK,CAACO,SAAS,CAACC,IAAI,CAAC;QAC9B;MACF;;MAEA;MACA;MACA,QAAQR,CAAC,EAAE,EAAE;QACX,IAAI,IAAI,CAACD,OAAO,CAAC,IAAI,CAACW,GAAG,GAAGV,CAAC,CAAC,KAAKjB,cAAc,EAAE;UACjD;UACA;QACF,CAAC,MAAM,IAAI,IAAI,CAACgB,OAAO,CAAC,IAAI,CAACW,GAAG,GAAGV,CAAC,CAAC,KAAKf,KAAK,EAAE;UAC/C;UACA;QACF,CAAC,MAAM;UACL,OAAO,KAAK,CAACsB,SAAS,CAACC,IAAI,CAAC;QAC9B;MACF;;MAEA;MACA;MACA;MACA,IAAI,IAAI,CAACJ,IAAI,CAACO,KAAK,KAAK,GAAG,EAAE;QAC3B,OAAO,KAAK,CAACJ,SAAS,CAACC,IAAI,CAAC;MAC9B;MAEA,IAAI,CAACE,GAAG,IAAIxB,OAAO,CAACuB,MAAM;MAC1B,OAAO,IAAI,CAACG,WAAW,CAAC,IAAI,CAACd,WAAW,CAAC;IAC3C;IAEAe,kBAAkBA,CAACC,IAAI,EAAE;MACvB,IAAI,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC;;MAEb;MACAQ,IAAI,CAACC,MAAM,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;MAErC,IAAI,IAAI,CAACC,GAAG,CAACvB,EAAE,CAACwB,KAAK,CAAC,EAAE;QACtB,MAAMC,GAAG,GAAG,IAAI,CAACC,QAAQ,CAAC,KAAK,CAAC;QAChCN,IAAI,CAACO,SAAS,GAAG,CAACF,GAAG,CAAC;MACxB;MACA,IAAI,CAACjB,IAAI,CAACR,EAAE,CAAC4B,MAAM,CAAC;MACpB,OAAO,IAAI,CAACC,UAAU,CAACT,IAAI,EAAE,kBAAkB,CAAC;IAClD;;IAEA;IACAU,WAAWA,CAACV,IAAI,EAAEW,OAAO,EAAE;MACzB,IAAI,CAACnB,IAAI,CAAC,CAAC;MACX;MACA,IAAI,IAAI,CAACW,GAAG,CAACvB,EAAE,CAACgC,IAAI,CAAC,EAAE;QACrB,IAAI,IAAI,CAACC,OAAO,CAACC,WAAW,IAAI,EAAE,EAAE;UAClC,IAAI,IAAI,CAACC,aAAa,CAAC,IAAI,CAAC,EAAE;YAC5Bf,IAAI,CAACgB,QAAQ,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAAC;YACrC,IAAI,CAACC,WAAW,CAACP,OAAO,EAAEX,IAAI,CAACgB,QAAQ,CAACG,IAAI,EAAE,IAAI,CAACC,YAAY,CAAC;UAClE,CAAC,MAAM;YACLpB,IAAI,CAACgB,QAAQ,GAAG,IAAI;UACtB;QACF;QACA,IAAI,CAACK,gBAAgB,CAAC,MAAM,CAAC;QAC7B,IAAI,IAAI,CAAC/B,IAAI,KAAKV,EAAE,CAAC0C,MAAM,EAAE;UAAE,IAAI,CAAC/B,UAAU,CAAC,CAAC;QAAE;QAClDS,IAAI,CAACC,MAAM,GAAG,IAAI,CAACsB,aAAa,CAAC,CAAC;QAElC,IAAI,IAAI,CAACjC,IAAI,KAAK,IAAI,CAACN,WAAW,IAAI,IAAI,CAACM,IAAI,KAAKV,EAAE,CAAC4C,KAAK,EAAE;UAC5D,IAAI,CAAChC,IAAI,CAAC,CAAC;UACX,MAAMiC,UAAU,GAAG,IAAI,CAACC,qBAAqB,CAAC,CAAC;UAC/C,IAAID,UAAU,EAAE;YACdzB,IAAI,CAACyB,UAAU,GAAGA,UAAU;UAC9B;QACF;QAEA,IAAI,CAACE,SAAS,CAAC,CAAC;QAChB,OAAO,IAAI,CAAClB,UAAU,CAACT,IAAI,EAAE,sBAAsB,CAAC;MACtD;MACA,IAAI,IAAI,CAACG,GAAG,CAACvB,EAAE,CAACgD,QAAQ,CAAC,EAAE;QAAE;QAC3B,IAAI,CAACV,WAAW,CAACP,OAAO,EAAE,SAAS,EAAE,IAAI,CAACS,YAAY,CAAC;QACvD,IAAIS,OAAO;QACX,IAAI,IAAI,CAACvC,IAAI,KAAKV,EAAE,CAACkD,SAAS,KAAKD,OAAO,GAAG,IAAI,CAACE,eAAe,CAAC,CAAC,CAAC,EAAE;UACpE,IAAIC,KAAK,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;UAC5B,IAAI,CAACzC,IAAI,CAAC,CAAC;UACX,IAAIqC,OAAO,EAAE;YAAE,IAAI,CAACrC,IAAI,CAAC,CAAC;UAAE;UAC5BQ,IAAI,CAACkC,WAAW,GAAG,IAAI,CAACC,aAAa,CAACH,KAAK,EAAE3D,cAAc,GAAGE,gBAAgB,EAAE,KAAK,EAAEsD,OAAO,CAAC;QACjG,CAAC,MAAM,IAAI,IAAI,CAACvC,IAAI,KAAKV,EAAE,CAACwD,MAAM,EAAE;UAClC,IAAIC,KAAK,GAAG,IAAI,CAACJ,SAAS,CAAC,CAAC;UAC5BjC,IAAI,CAACkC,WAAW,GAAG,IAAI,CAACI,UAAU,CAACD,KAAK,EAAE,YAAY,CAAC;QACzD,CAAC,MAAM;UACLrC,IAAI,CAACkC,WAAW,GAAG,IAAI,CAAChC,gBAAgB,CAAC,CAAC;UAC1C,IAAI,CAACyB,SAAS,CAAC,CAAC;QAClB;QACA,OAAO,IAAI,CAAClB,UAAU,CAACT,IAAI,EAAE,0BAA0B,CAAC;MAC1D;MACA;MACA,IAAI,IAAI,CAACuC,0BAA0B,CAAC,CAAC,EAAE;QACrCvC,IAAI,CAACkC,WAAW,GAAG,IAAI,CAACM,cAAc,CAAC,IAAI,CAAC;QAC5C,IAAIxC,IAAI,CAACkC,WAAW,CAAC5C,IAAI,KAAK,qBAAqB,EACjD;UAAE,IAAI,CAACmD,mBAAmB,CAAC9B,OAAO,EAAEX,IAAI,CAACkC,WAAW,CAACQ,YAAY,CAAC;QAAE,CAAC,MAErE;UAAE,IAAI,CAACxB,WAAW,CAACP,OAAO,EAAEX,IAAI,CAACkC,WAAW,CAACS,EAAE,CAACxB,IAAI,EAAEnB,IAAI,CAACkC,WAAW,CAACS,EAAE,CAACC,KAAK,CAAC;QAAE;QACpF5C,IAAI,CAAC6C,UAAU,GAAG,EAAE;QACpB7C,IAAI,CAACC,MAAM,GAAG,IAAI;MACpB,CAAC,MAAM;QAAE;QACPD,IAAI,CAACkC,WAAW,GAAG,IAAI;QACvBlC,IAAI,CAAC6C,UAAU,GAAG,IAAI,CAACC,qBAAqB,CAACnC,OAAO,CAAC;QACrD,IAAI,IAAI,CAACI,aAAa,CAAC,MAAM,CAAC,EAAE;UAC9B,IAAI,IAAI,CAACzB,IAAI,KAAKV,EAAE,CAAC0C,MAAM,EAAE;YAAE,IAAI,CAAC/B,UAAU,CAAC,CAAC;UAAE;UAClDS,IAAI,CAACC,MAAM,GAAG,IAAI,CAACsB,aAAa,CAAC,CAAC;UAElC,IAAI,IAAI,CAACjC,IAAI,KAAK,IAAI,CAACN,WAAW,IAAI,IAAI,CAACM,IAAI,KAAKV,EAAE,CAAC4C,KAAK,EAAE;YAC5D,IAAI,CAAChC,IAAI,CAAC,CAAC;YACX,MAAMiC,UAAU,GAAG,IAAI,CAACC,qBAAqB,CAAC,CAAC;YAC/C,IAAID,UAAU,EAAE;cACdzB,IAAI,CAACyB,UAAU,GAAGA,UAAU;YAC9B;UACF;QACF,CAAC,MAAM;UACL,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAE6D,IAAI,GAAG/C,IAAI,CAAC6C,UAAU,EAAE3D,CAAC,GAAG6D,IAAI,CAACpD,MAAM,EAAET,CAAC,IAAI,CAAC,EAAE;YAC/D;YACA,IAAI8D,IAAI,GAAGD,IAAI,CAAC7D,CAAC,CAAC;YAElB,IAAI,CAAC+D,eAAe,CAACD,IAAI,CAACE,KAAK,CAAC;YAChC;YACA,IAAI,CAACC,gBAAgB,CAACH,IAAI,CAACE,KAAK,CAAC;UACnC;UAEAlD,IAAI,CAACC,MAAM,GAAG,IAAI;QACpB;QACA,IAAI,CAAC0B,SAAS,CAAC,CAAC;MAClB;MACA,OAAO,IAAI,CAAClB,UAAU,CAACT,IAAI,EAAE,wBAAwB,CAAC;IACxD;IAEAoD,WAAWA,CAACpD,IAAI,EAAE;MAChB,IAAI,CAACR,IAAI,CAAC,CAAC;MACX;MACA,IAAI,IAAI,CAACF,IAAI,KAAKV,EAAE,CAAC0C,MAAM,EAAE;QAC3BtB,IAAI,CAAC6C,UAAU,GAAG,EAAE;QACpB7C,IAAI,CAACC,MAAM,GAAG,IAAI,CAACsB,aAAa,CAAC,CAAC;MACpC,CAAC,MAAM;QACLvB,IAAI,CAAC6C,UAAU,GAAG,IAAI,CAACQ,qBAAqB,CAAC,CAAC;QAC9C,IAAI,CAAChC,gBAAgB,CAAC,MAAM,CAAC;QAC7BrB,IAAI,CAACC,MAAM,GACT,IAAI,CAACX,IAAI,KAAKV,EAAE,CAAC0C,MAAM,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC,GAAG,IAAI,CAAChC,UAAU,CAAC,CAAC;MACtE;MAEA,IAAI,IAAI,CAACD,IAAI,KAAK,IAAI,CAACN,WAAW,IAAI,IAAI,CAACM,IAAI,IAAIV,EAAE,CAAC4C,KAAK,EAAE;QAC3D,IAAI,CAAChC,IAAI,CAAC,CAAC;QACX,MAAMiC,UAAU,GAAG,IAAI,CAACC,qBAAqB,CAAC,CAAC;QAC/C,IAAID,UAAU,EAAE;UACdzB,IAAI,CAACyB,UAAU,GAAGA,UAAU;QAC9B;MACF;MACA,IAAI,CAACE,SAAS,CAAC,CAAC;MAChB,OAAO,IAAI,CAAClB,UAAU,CAACT,IAAI,EAAE,mBAAmB,CAAC;IACnD;IAEA0B,qBAAqBA,CAAA,EAAG;MACtB,IAAI,CAACtC,IAAI,CAACR,EAAE,CAAC0E,MAAM,CAAC;MACpB,MAAMC,KAAK,GAAG,IAAI,CAACC,kBAAkB,CAAC,CAAC;MACvC,IAAI,CAACpE,IAAI,CAACR,EAAE,CAAC6E,MAAM,CAAC;MACpB,OAAOF,KAAK;IACd;IAEAC,kBAAkBA,CAAA,EAAG;MACnB,MAAMD,KAAK,GAAG,EAAE;MAChB,MAAMG,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;MAE3B,GAAG;QACD,IAAI,IAAI,CAACrE,IAAI,KAAKV,EAAE,CAAC6E,MAAM,EAAE;UAC3B;QACF;QAEA,MAAMzD,IAAI,GAAG,IAAI,CAACiC,SAAS,CAAC,CAAC;;QAE7B;QACA,IAAI2B,gBAAgB;QACpB,IAAI,IAAI,CAACtE,IAAI,KAAKV,EAAE,CAAC0C,MAAM,EAAE;UAC3BsC,gBAAgB,GAAG,IAAI,CAACC,YAAY,CAAC,IAAI,CAACC,KAAK,CAAC;QAClD,CAAC,MAAM;UACLF,gBAAgB,GAAG,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC;QAC1C;QACA,IAAI,CAACzB,IAAI,CAAC,CAAC;QACXQ,IAAI,CAAC+D,GAAG,GAAGH,gBAAgB;;QAE3B;QACA;QACA;QACA,IAAIF,SAAS,CAACM,GAAG,CAAChE,IAAI,CAAC+D,GAAG,CAAC5C,IAAI,CAAC,EAAE;UAChC,IAAI,CAAC8C,KAAK,CAAC,IAAI,CAACrE,GAAG,EAAE,8BAA8B,CAAC;QACtD;QACA8D,SAAS,CAACQ,GAAG,CAAClE,IAAI,CAAC+D,GAAG,CAAC5C,IAAI,CAAC;QAE5B,IAAI,IAAI,CAAC7B,IAAI,KAAKV,EAAE,CAAC0C,MAAM,EAAE;UAC3B,IAAI,CAAC2C,KAAK,CACR,IAAI,CAACrE,GAAG,EACR,gDACF,CAAC;QACH;QAEAI,IAAI,CAAC8D,KAAK,GAAG,IAAI,CAACD,YAAY,CAAC,IAAI,CAACC,KAAK,CAAC;QAE1CP,KAAK,CAACY,IAAI,CAAC,IAAI,CAAC1D,UAAU,CAACT,IAAI,EAAE,iBAAiB,CAAC,CAAC;MACtD,CAAC,QAAQ,IAAI,CAACG,GAAG,CAACvB,EAAE,CAACwB,KAAK,CAAC;MAE3B,OAAOmD,KAAK;IACd;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}