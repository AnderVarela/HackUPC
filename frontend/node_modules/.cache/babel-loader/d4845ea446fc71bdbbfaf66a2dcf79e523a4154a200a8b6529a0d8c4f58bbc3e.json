{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertComments = void 0;\nconst util_1 = require(\"tsutils/util/util\");\nconst ts = __importStar(require(\"typescript\"));\nconst node_utils_1 = require(\"./node-utils\");\nconst ts_estree_1 = require(\"./ts-estree\");\n/**\n * Convert all comments for the given AST.\n * @param ast the AST object\n * @param code the TypeScript code\n * @returns the converted ESTreeComment\n * @private\n */\nfunction convertComments(ast, code) {\n  const comments = [];\n  (0, util_1.forEachComment)(ast, (_, comment) => {\n    const type = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? ts_estree_1.AST_TOKEN_TYPES.Line : ts_estree_1.AST_TOKEN_TYPES.Block;\n    const range = [comment.pos, comment.end];\n    const loc = (0, node_utils_1.getLocFor)(range[0], range[1], ast);\n    // both comments start with 2 characters - /* or //\n    const textStart = range[0] + 2;\n    const textEnd = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ?\n    // single line comments end at the end\n    range[1] - textStart :\n    // multiline comments end 2 characters early\n    range[1] - textStart - 2;\n    comments.push({\n      type,\n      value: code.slice(textStart, textStart + textEnd),\n      range,\n      loc\n    });\n  }, ast);\n  return comments;\n}\nexports.convertComments = convertComments;","map":{"version":3,"names":["util_1","require","ts","__importStar","node_utils_1","ts_estree_1","convertComments","ast","code","comments","forEachComment","_","comment","type","kind","SyntaxKind","SingleLineCommentTrivia","AST_TOKEN_TYPES","Line","Block","range","pos","end","loc","getLocFor","textStart","textEnd","push","value","slice","exports"],"sources":["../src/convert-comments.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,MAAA,GAAAC,OAAA;AACA,MAAAC,EAAA,GAAAC,YAAA,CAAAF,OAAA;AAEA,MAAAG,YAAA,GAAAH,OAAA;AAEA,MAAAI,WAAA,GAAAJ,OAAA;AAEA;;;;;;;AAOA,SAAgBK,eAAeA,CAC7BC,GAAkB,EAClBC,IAAY;EAEZ,MAAMC,QAAQ,GAAuB,EAAE;EAEvC,IAAAT,MAAA,CAAAU,cAAc,EACZH,GAAG,EACH,CAACI,CAAC,EAAEC,OAAO,KAAI;IACb,MAAMC,IAAI,GACRD,OAAO,CAACE,IAAI,KAAKZ,EAAE,CAACa,UAAU,CAACC,uBAAuB,GAClDX,WAAA,CAAAY,eAAe,CAACC,IAAI,GACpBb,WAAA,CAAAY,eAAe,CAACE,KAAK;IAC3B,MAAMC,KAAK,GAAmB,CAACR,OAAO,CAACS,GAAG,EAAET,OAAO,CAACU,GAAG,CAAC;IACxD,MAAMC,GAAG,GAAG,IAAAnB,YAAA,CAAAoB,SAAS,EAACJ,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEb,GAAG,CAAC;IAE9C;IACA,MAAMkB,SAAS,GAAGL,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;IAC9B,MAAMM,OAAO,GACXd,OAAO,CAACE,IAAI,KAAKZ,EAAE,CAACa,UAAU,CAACC,uBAAuB;IAClD;IACAI,KAAK,CAAC,CAAC,CAAC,GAAGK,SAAS;IACpB;IACAL,KAAK,CAAC,CAAC,CAAC,GAAGK,SAAS,GAAG,CAAC;IAC9BhB,QAAQ,CAACkB,IAAI,CAAC;MACZd,IAAI;MACJe,KAAK,EAAEpB,IAAI,CAACqB,KAAK,CAACJ,SAAS,EAAEA,SAAS,GAAGC,OAAO,CAAC;MACjDN,KAAK;MACLG;KACD,CAAC;EACJ,CAAC,EACDhB,GAAG,CACJ;EAED,OAAOE,QAAQ;AACjB;AAnCAqB,OAAA,CAAAxB,eAAA,GAAAA,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}