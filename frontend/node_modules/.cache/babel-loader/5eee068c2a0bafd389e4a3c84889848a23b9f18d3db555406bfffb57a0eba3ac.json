{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n  path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n  _v8Coverage = function () {\n    return data;\n  };\n  return data;\n}\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n  _chalk = function () {\n    return data;\n  };\n  return data;\n}\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n  _glob = function () {\n    return data;\n  };\n  return data;\n}\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n  fs = function () {\n    return data;\n  };\n  return data;\n}\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n  return data;\n}\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n  _istanbulLibReport = function () {\n    return data;\n  };\n  return data;\n}\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n  return data;\n}\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n  _istanbulReports = function () {\n    return data;\n  };\n  return data;\n}\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n  _v8ToIstanbul = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestUtil() {\n  const data = require('jest-util');\n  _jestUtil = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestWorker() {\n  const data = require('jest-worker');\n  _jestWorker = function () {\n    return data;\n  };\n  return data;\n}\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nconst FAIL_COLOR = _chalk().default.bold.red;\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\nclass CoverageReporter extends _BaseReporter.default {\n  constructor(globalConfig, options) {\n    super();\n    _defineProperty(this, '_coverageMap', void 0);\n    _defineProperty(this, '_globalConfig', void 0);\n    _defineProperty(this, '_sourceMapStore', void 0);\n    _defineProperty(this, '_options', void 0);\n    _defineProperty(this, '_v8CoverageResults', void 0);\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n    this._options = options || {};\n  }\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n      return;\n    }\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n  async onRunComplete(contexts, aggregatedResults) {\n    await this._addUntestedFiles(contexts);\n    const {\n      map,\n      reportContext\n    } = await this._getCoverageResult();\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n        _istanbulReports().default.create(reporter, {\n          maxCols: process.stdout.columns || Infinity,\n          ...additionalOptions\n        }).execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(_chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `));\n    }\n    this._checkThreshold(map);\n  }\n  async _addUntestedFiles(contexts) {\n    const files = [];\n    contexts.forEach(context => {\n      const config = context.config;\n      if (this._globalConfig.collectCoverageFrom && this._globalConfig.collectCoverageFrom.length) {\n        context.hasteFS.matchFilesWithGlob(this._globalConfig.collectCoverageFrom, config.rootDir).forEach(filePath => files.push({\n          config,\n          path: filePath\n        }));\n      }\n    });\n    if (!files.length) {\n      return;\n    }\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));\n    }\n    let worker;\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n      const hasCoverageData = this._v8CoverageResults.some(v8Res => v8Res.some(innerRes => innerRes.result.url === filename));\n      if (!hasCoverageData && !this._coverageMap.data[filename] && 'worker' in worker) {\n        try {\n          const result = await worker.worker({\n            config,\n            globalConfig: this._globalConfig,\n            options: {\n              ...this._options,\n              changedFiles: this._options.changedFiles && Array.from(this._options.changedFiles),\n              sourcesRelatedToTestsInChangedFiles: this._options.sourcesRelatedToTestsInChangedFiles && Array.from(this._options.sourcesRelatedToTestsInChangedFiles)\n            },\n            path: filename\n          });\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([{\n                codeTransformResult: undefined,\n                result: result.result\n              }]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(_chalk().default.red([`Failed to collect coverage from ${filename}`, `ERROR: ${error.message}`, `STACK: ${error.stack}`].join('\\n')));\n        }\n      }\n    });\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n  _checkThreshold(map) {\n    const {\n      coverageThreshold\n    } = this._globalConfig;\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n          if (threshold !== undefined) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(`Jest: Uncovered count for ${key} (${actualUncovered}) ` + `exceeds ${name} threshold (${-1 * threshold})`);\n              }\n            } else if (actual < threshold) {\n              errors.push(`Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`);\n            }\n          }\n          return errors;\n        }, []);\n      }\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce((agg, thresholdGroup) => {\n          const absoluteThresholdGroup = path().resolve(thresholdGroup); // The threshold group might be a path:\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          } // If the threshold group is not a path it might be a glob:\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = _glob().default.sync(absoluteThresholdGroup).map(filePath => path().resolve(filePath));\n          }\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n          return agg;\n        }, []);\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        } // A covered file that doesn't have a threshold:\n\n        return files.concat([[file, undefined]]);\n      }, []);\n      const getFilesInThresholdGroup = thresholdGroup => coveredFilesSortedIntoThresholdGroup.filter(fileAndGroup => fileAndGroup[1] === thresholdGroup).map(fileAndGroup => fileAndGroup[0]);\n      function combineCoverage(filePaths) {\n        return filePaths.map(filePath => map.fileCoverageFor(filePath)).reduce((combinedCoverage, nextFileCoverage) => {\n          if (combinedCoverage === undefined || combinedCoverage === null) {\n            return nextFileCoverage.toSummary();\n          }\n          return combinedCoverage.merge(nextFileCoverage.toSummary());\n        }, undefined);\n      }\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n              break;\n            }\n          case THRESHOLD_GROUP_TYPES.PATH:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));\n              }\n              break;\n            }\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(fileMatchingGlob => {\n              errors = errors.concat(check(fileMatchingGlob, coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));\n            });\n            break;\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(`Jest: Coverage data for ${thresholdGroup} was not found.`);\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(err => err !== undefined && err !== null && err.length > 0);\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(this._v8CoverageResults.map(cov => ({\n        result: cov.map(r => r.result)\n      })));\n      const fileTransforms = new Map();\n      this._v8CoverageResults.forEach(res => res.forEach(r => {\n        if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n          fileTransforms.set(r.result.url, r.codeTransformResult);\n        }\n      }));\n      const transformedCoverage = await Promise.all(mergedCoverages.result.map(async res => {\n        var _fileTransform$wrappe;\n        const fileTransform = fileTransforms.get(res.url);\n        let sourcemapContent = undefined;\n        if (fileTransform !== null && fileTransform !== void 0 && fileTransform.sourceMapPath && fs().existsSync(fileTransform.sourceMapPath)) {\n          sourcemapContent = JSON.parse(fs().readFileSync(fileTransform.sourceMapPath, 'utf8'));\n        }\n        const converter = (0, _v8ToIstanbul().default)(res.url, (_fileTransform$wrappe = fileTransform === null || fileTransform === void 0 ? void 0 : fileTransform.wrapperLength) !== null && _fileTransform$wrappe !== void 0 ? _fileTransform$wrappe : 0, fileTransform && sourcemapContent ? {\n          originalSource: fileTransform.originalCode,\n          source: fileTransform.code,\n          sourceMap: {\n            sourcemap: {\n              file: res.url,\n              ...sourcemapContent\n            }\n          }\n        } : {\n          source: fs().readFileSync(res.url, 'utf8')\n        });\n        await converter.load();\n        converter.applyCoverage(res.functions);\n        const istanbulData = converter.toIstanbul();\n        converter.destroy();\n        return istanbulData;\n      }));\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n      transformedCoverage.forEach(res => map.merge(res));\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n      return {\n        map,\n        reportContext\n      };\n    }\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n    return {\n      map,\n      reportContext\n    };\n  }\n}\nexports.default = CoverageReporter;\n_defineProperty(CoverageReporter, 'filename', __filename);","map":{"version":3,"names":["Object","defineProperty","exports","value","default","path","data","_interopRequireWildcard","require","_v8Coverage","_chalk","_interopRequireDefault","_glob","fs","_istanbulLibCoverage","_istanbulLibReport","_istanbulLibSourceMaps","_istanbulReports","_v8ToIstanbul","_jestUtil","_jestWorker","_BaseReporter","_getWatermarks","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","FAIL_COLOR","bold","red","RUNNING_TEST_COLOR","dim","CoverageReporter","constructor","globalConfig","options","_coverageMap","createCoverageMap","_globalConfig","_sourceMapStore","createSourceMapStore","_v8CoverageResults","_options","onTestResult","_test","testResult","v8Coverage","push","coverage","merge","onRunComplete","contexts","aggregatedResults","_addUntestedFiles","map","reportContext","_getCoverageResult","coverageReporters","useStderr","length","forEach","reporter","additionalOptions","Array","isArray","create","maxCols","process","stdout","columns","Infinity","execute","coverageMap","e","console","error","toString","stack","_checkThreshold","files","context","config","collectCoverageFrom","hasteFS","matchFilesWithGlob","rootDir","filePath","isInteractive","stderr","write","worker","maxWorkers","Worker","resolve","exposedMethods","maxRetries","numWorkers","instrumentation","fileObj","filename","hasCoverageData","some","v8Res","innerRes","result","url","changedFiles","from","sourcesRelatedToTestsInChangedFiles","kind","codeTransformResult","undefined","addFileCoverage","message","join","Promise","all","clearLine","end","coverageThreshold","check","name","thresholds","actuals","reduce","errors","actual","pct","actualUncovered","total","covered","threshold","THRESHOLD_GROUP_TYPES","GLOB","GLOBAL","PATH","coveredFiles","thresholdGroups","keys","groupTypeByThresholdGroup","filesByGlob","coveredFilesSortedIntoThresholdGroup","file","pathOrGlobMatches","agg","thresholdGroup","absoluteThresholdGroup","indexOf","concat","sync","getFilesInThresholdGroup","filter","fileAndGroup","combineCoverage","filePaths","fileCoverageFor","combinedCoverage","nextFileCoverage","toSummary","fileMatchingGlob","err","log","_setError","Error","coverageProvider","mergedCoverages","mergeProcessCovs","cov","r","fileTransforms","Map","res","transformedCoverage","_fileTransform$wrappe","fileTransform","sourcemapContent","sourceMapPath","existsSync","JSON","parse","readFileSync","converter","wrapperLength","originalSource","originalCode","source","code","sourceMap","sourcemap","load","applyCoverage","functions","istanbulData","toIstanbul","destroy","createContext","dir","coverageDirectory","watermarks","transformCoverage","sourceFinder","__filename"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/reporters/build/CoverageReporter.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8Coverage() {\n  const data = require('@bcoe/v8-coverage');\n\n  _v8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v8ToIstanbul() {\n  const data = _interopRequireDefault(require('v8-to-istanbul'));\n\n  _v8ToIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = require('jest-worker');\n\n  _jestWorker = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _BaseReporter = _interopRequireDefault(require('./BaseReporter'));\n\nvar _getWatermarks = _interopRequireDefault(require('./getWatermarks'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== 'function') return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _BaseReporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_v8CoverageResults', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore =\n      _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._v8CoverageResults = [];\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult) {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  async onRunComplete(contexts, aggregatedResults) {\n    await this._addUntestedFiles(contexts);\n    const {map, reportContext} = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length < 1) {\n        coverageReporters.push('text-summary');\n      }\n\n      coverageReporters.forEach(reporter => {\n        let additionalOptions = {};\n\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n\n        _istanbulReports()\n          .default.create(reporter, {\n            maxCols: process.stdout.columns || Infinity,\n            ...additionalOptions\n          })\n          .execute(reportContext);\n      });\n      aggregatedResults.coverageMap = map;\n    } catch (e) {\n      console.error(\n        _chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `)\n      );\n    }\n\n    this._checkThreshold(map);\n  }\n\n  async _addUntestedFiles(contexts) {\n    const files = [];\n    contexts.forEach(context => {\n      const config = context.config;\n\n      if (\n        this._globalConfig.collectCoverageFrom &&\n        this._globalConfig.collectCoverageFrom.length\n      ) {\n        context.hasteFS\n          .matchFilesWithGlob(\n            this._globalConfig.collectCoverageFrom,\n            config.rootDir\n          )\n          .forEach(filePath =>\n            files.push({\n              config,\n              path: filePath\n            })\n          );\n      }\n    });\n\n    if (!files.length) {\n      return;\n    }\n\n    if (_jestUtil().isInteractive) {\n      process.stderr.write(\n        RUNNING_TEST_COLOR('Running coverage on untested files...')\n      );\n    }\n\n    let worker;\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new (_jestWorker().Worker)(require.resolve('./CoverageWorker'), {\n        exposedMethods: ['worker'],\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers\n      });\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res =>\n        v8Res.some(innerRes => innerRes.result.url === filename)\n      );\n\n      if (\n        !hasCoverageData &&\n        !this._coverageMap.data[filename] &&\n        'worker' in worker\n      ) {\n        try {\n          const result = await worker.worker({\n            config,\n            globalConfig: this._globalConfig,\n            options: {\n              ...this._options,\n              changedFiles:\n                this._options.changedFiles &&\n                Array.from(this._options.changedFiles),\n              sourcesRelatedToTestsInChangedFiles:\n                this._options.sourcesRelatedToTestsInChangedFiles &&\n                Array.from(this._options.sourcesRelatedToTestsInChangedFiles)\n            },\n            path: filename\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([\n                {\n                  codeTransformResult: undefined,\n                  result: result.result\n                }\n              ]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error) {\n          console.error(\n            _chalk().default.red(\n              [\n                `Failed to collect coverage from ${filename}`,\n                `ERROR: ${error.message}`,\n                `STACK: ${error.stack}`\n              ].join('\\n')\n            )\n          );\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n\n    if (_jestUtil().isInteractive) {\n      (0, _jestUtil().clearLine)(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  _checkThreshold(map) {\n    const {coverageThreshold} = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce(\n          (errors, key) => {\n            const actual = actuals[key].pct;\n            const actualUncovered = actuals[key].total - actuals[key].covered;\n            const threshold = thresholds[key];\n\n            if (threshold !== undefined) {\n              if (threshold < 0) {\n                if (threshold * -1 < actualUncovered) {\n                  errors.push(\n                    `Jest: Uncovered count for ${key} (${actualUncovered}) ` +\n                      `exceeds ${name} threshold (${-1 * threshold})`\n                  );\n                }\n              } else if (actual < threshold) {\n                errors.push(\n                  `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`\n                );\n              }\n            }\n\n            return errors;\n          },\n          []\n        );\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(\n        (files, file) => {\n          const pathOrGlobMatches = thresholdGroups.reduce(\n            (agg, thresholdGroup) => {\n              const absoluteThresholdGroup = path().resolve(thresholdGroup); // The threshold group might be a path:\n\n              if (file.indexOf(absoluteThresholdGroup) === 0) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.PATH;\n                return agg.concat([[file, thresholdGroup]]);\n              } // If the threshold group is not a path it might be a glob:\n              // Note: glob.sync is slow. By memoizing the files matching each glob\n              // (rather than recalculating it for each covered file) we save a tonne\n              // of execution time.\n\n              if (filesByGlob[absoluteThresholdGroup] === undefined) {\n                filesByGlob[absoluteThresholdGroup] = _glob()\n                  .default.sync(absoluteThresholdGroup)\n                  .map(filePath => path().resolve(filePath));\n              }\n\n              if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.GLOB;\n                return agg.concat([[file, thresholdGroup]]);\n              }\n\n              return agg;\n            },\n            []\n          );\n\n          if (pathOrGlobMatches.length > 0) {\n            return files.concat(pathOrGlobMatches);\n          } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n              THRESHOLD_GROUP_TYPES.GLOBAL;\n            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n          } // A covered file that doesn't have a threshold:\n\n          return files.concat([[file, undefined]]);\n        },\n        []\n      );\n\n      const getFilesInThresholdGroup = thresholdGroup =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce((combinedCoverage, nextFileCoverage) => {\n            if (combinedCoverage === undefined || combinedCoverage === null) {\n              return nextFileCoverage.toSummary();\n            }\n\n            return combinedCoverage.merge(nextFileCoverage.toSummary());\n          }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(\n              fileMatchingGlob => {\n                errors = errors.concat(\n                  check(\n                    fileMatchingGlob,\n                    coverageThreshold[thresholdGroup],\n                    map.fileCoverageFor(fileMatchingGlob).toSummary()\n                  )\n                );\n              }\n            );\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\n                `Jest: Coverage data for ${thresholdGroup} was not found.`\n              );\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  async _getCoverageResult() {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(\n        this._v8CoverageResults.map(cov => ({\n          result: cov.map(r => r.result)\n        }))\n      );\n      const fileTransforms = new Map();\n\n      this._v8CoverageResults.forEach(res =>\n        res.forEach(r => {\n          if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n            fileTransforms.set(r.result.url, r.codeTransformResult);\n          }\n        })\n      );\n\n      const transformedCoverage = await Promise.all(\n        mergedCoverages.result.map(async res => {\n          var _fileTransform$wrappe;\n\n          const fileTransform = fileTransforms.get(res.url);\n          let sourcemapContent = undefined;\n\n          if (\n            fileTransform !== null &&\n            fileTransform !== void 0 &&\n            fileTransform.sourceMapPath &&\n            fs().existsSync(fileTransform.sourceMapPath)\n          ) {\n            sourcemapContent = JSON.parse(\n              fs().readFileSync(fileTransform.sourceMapPath, 'utf8')\n            );\n          }\n\n          const converter = (0, _v8ToIstanbul().default)(\n            res.url,\n            (_fileTransform$wrappe =\n              fileTransform === null || fileTransform === void 0\n                ? void 0\n                : fileTransform.wrapperLength) !== null &&\n              _fileTransform$wrappe !== void 0\n              ? _fileTransform$wrappe\n              : 0,\n            fileTransform && sourcemapContent\n              ? {\n                  originalSource: fileTransform.originalCode,\n                  source: fileTransform.code,\n                  sourceMap: {\n                    sourcemap: {\n                      file: res.url,\n                      ...sourcemapContent\n                    }\n                  }\n                }\n              : {\n                  source: fs().readFileSync(res.url, 'utf8')\n                }\n          );\n          await converter.load();\n          converter.applyCoverage(res.functions);\n          const istanbulData = converter.toIstanbul();\n          converter.destroy();\n          return istanbulData;\n        })\n      );\n\n      const map = _istanbulLibCoverage().default.createCoverageMap({});\n\n      transformedCoverage.forEach(res => map.merge(res));\n\n      const reportContext = _istanbulLibReport().default.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: (0, _getWatermarks.default)(this._globalConfig)\n      });\n\n      return {\n        map,\n        reportContext\n      };\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n\n    const reportContext = _istanbulLibReport().default.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: (0, _getWatermarks.default)(this._globalConfig)\n    });\n\n    return {\n      map,\n      reportContext\n    };\n  }\n}\n\nexports.default = CoverageReporter;\n\n_defineProperty(CoverageReporter, 'filename', __filename);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}