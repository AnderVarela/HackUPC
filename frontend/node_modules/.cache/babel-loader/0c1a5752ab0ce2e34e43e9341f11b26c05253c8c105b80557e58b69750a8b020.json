{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ToRawFixed_1 = require(\"./ToRawFixed\");\nvar digit_mapping_generated_1 = require(\"./digit-mapping.generated\");\nvar regex_generated_1 = require(\"../regex.generated\");\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(regex_generated_1.S_UNICODE_REGEX.source));\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(regex_generated_1.S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nfunction formatToParts(numberResult, data, pl, options) {\n  var sign = numberResult.sign,\n    exponent = numberResult.exponent,\n    magnitude = numberResult.magnitude;\n  var notation = options.notation,\n    style = options.style,\n    numberingSystem = options.numberingSystem;\n  var defaultNumberingSystem = data.numbers.nu[0];\n  // #region Part 1: partition and interpolate the CLDR number pattern.\n  // ----------------------------------------------------------\n  var compactNumberPattern = null;\n  if (notation === 'compact' && magnitude) {\n    compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n  }\n  // This is used multiple times\n  var nonNameCurrencyPart;\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var byCurrencyDisplay = data.currencies[options.currency];\n    if (byCurrencyDisplay) {\n      switch (options.currencyDisplay) {\n        case 'code':\n          nonNameCurrencyPart = options.currency;\n          break;\n        case 'symbol':\n          nonNameCurrencyPart = byCurrencyDisplay.symbol;\n          break;\n        default:\n          nonNameCurrencyPart = byCurrencyDisplay.narrow;\n          break;\n      }\n    } else {\n      // Fallback for unknown currency\n      nonNameCurrencyPart = options.currency;\n    }\n  }\n  var numberPattern;\n  if (!compactNumberPattern) {\n    // Note: if the style is unit, or is currency and the currency display is name,\n    // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n    if (style === 'decimal' || style === 'unit' || style === 'currency' && options.currencyDisplay === 'name') {\n      // Shortcut for decimal\n      var decimalData = data.numbers.decimal[numberingSystem] || data.numbers.decimal[defaultNumberingSystem];\n      numberPattern = getPatternForSign(decimalData.standard, sign);\n    } else if (style === 'currency') {\n      var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n      // We replace number pattern part with `0` for easier postprocessing.\n      numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n    } else {\n      // percent\n      var percentPattern = data.numbers.percent[numberingSystem] || data.numbers.percent[defaultNumberingSystem];\n      numberPattern = getPatternForSign(percentPattern, sign);\n    }\n  } else {\n    numberPattern = compactNumberPattern;\n  }\n  // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n  // used to infer decimal group sizes.\n  var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n  // Now we start to substitute patterns\n  // 1. replace strings like `0` and `#,##0.00` with `{0}`\n  // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n  numberPattern = numberPattern.replace(CLDR_NUMBER_PATTERN, '{0}').replace(/'(.)'/g, '$1');\n  // Handle currency spacing (both compact and non-compact).\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n    // See `currencySpacing` substitution rule in TR-35.\n    // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n    //\n    // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n    // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n    // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n    //\n    // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n    // and number, because `$` does not match \"[:^S:]\".\n    //\n    // Implementation note: here we do the best effort to infer the insertion.\n    // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n    var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n    if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\".concat(afterCurrency, \"{0}\"));\n    }\n    var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n    if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\u00A4\"));\n    }\n  }\n  // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n  var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n  var numberParts = [];\n  var symbols = data.numbers.symbols[numberingSystem] || data.numbers.symbols[defaultNumberingSystem];\n  for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n    var part = numberPatternParts_1[_i];\n    if (!part) {\n      continue;\n    }\n    switch (part) {\n      case '{0}':\n        {\n          // We only need to handle scientific and engineering notation here.\n          numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem,\n          // If compact number pattern exists, do not insert group separators.\n          !compactNumberPattern && Boolean(options.useGrouping), decimalNumberPattern));\n          break;\n        }\n      case '-':\n        numberParts.push({\n          type: 'minusSign',\n          value: symbols.minusSign\n        });\n        break;\n      case '+':\n        numberParts.push({\n          type: 'plusSign',\n          value: symbols.plusSign\n        });\n        break;\n      case '%':\n        numberParts.push({\n          type: 'percentSign',\n          value: symbols.percentSign\n        });\n        break;\n      case '¤':\n        // Computed above when handling currency spacing.\n        numberParts.push({\n          type: 'currency',\n          value: nonNameCurrencyPart\n        });\n        break;\n      default:\n        if (/^\\{c:/.test(part)) {\n          numberParts.push({\n            type: 'compact',\n            value: part.substring(3, part.length - 1)\n          });\n        } else {\n          // literal\n          numberParts.push({\n            type: 'literal',\n            value: part\n          });\n        }\n        break;\n    }\n  }\n  // #endregion\n  // #region Part 2: interpolate unit pattern if necessary.\n  // ----------------------------------------------\n  switch (style) {\n    case 'currency':\n      {\n        // `currencyDisplay: 'name'` has similar pattern handling as units.\n        if (options.currencyDisplay === 'name') {\n          var unitPattern = (data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]).unitPattern;\n          // Select plural\n          var unitName = void 0;\n          var currencyNameData = data.currencies[options.currency];\n          if (currencyNameData) {\n            unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n          } else {\n            // Fallback for unknown currency\n            unitName = options.currency;\n          }\n          // Do {0} and {1} substitution\n          var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n          var result = [];\n          for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n            var part = unitPatternParts_1[_a];\n            switch (part) {\n              case '{0}':\n                result.push.apply(result, numberParts);\n                break;\n              case '{1}':\n                result.push({\n                  type: 'currency',\n                  value: unitName\n                });\n                break;\n              default:\n                if (part) {\n                  result.push({\n                    type: 'literal',\n                    value: part\n                  });\n                }\n                break;\n            }\n          }\n          return result;\n        } else {\n          return numberParts;\n        }\n      }\n    case 'unit':\n      {\n        var unit = options.unit,\n          unitDisplay = options.unitDisplay;\n        var unitData = data.units.simple[unit];\n        var unitPattern = void 0;\n        if (unitData) {\n          // Simple unit pattern\n          unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n        } else {\n          // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n          // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n          // Implementation note: we are not following TR-35 here because we need to format to parts!\n          var _b = unit.split('-per-'),\n            numeratorUnit = _b[0],\n            denominatorUnit = _b[1];\n          unitData = data.units.simple[numeratorUnit];\n          var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n          var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n          if (perUnitPattern) {\n            // perUnitPattern exists, combine it with numeratorUnitPattern\n            unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n          } else {\n            // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n            // the denominator pattern in singular form.\n            var perPattern = data.units.compound.per[unitDisplay];\n            var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n            unitPattern = unitPattern = perPattern.replace('{0}', numeratorUnitPattern).replace('{1}', denominatorPattern.replace('{0}', ''));\n          }\n        }\n        var result = [];\n        // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n        for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n          var part = _d[_c];\n          var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n          if (interpolateMatch) {\n            // Space before \"{0}\"\n            if (interpolateMatch[1]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[1]\n              });\n            }\n            // \"{0}\" itself\n            result.push.apply(result, numberParts);\n            // Space after \"{0}\"\n            if (interpolateMatch[2]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[2]\n              });\n            }\n          } else if (part) {\n            result.push({\n              type: 'unit',\n              value: part\n            });\n          }\n        }\n        return result;\n      }\n    default:\n      return numberParts;\n  }\n  // #endregion\n}\nexports.default = formatToParts;\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping,\n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n  var result = [];\n  // eslint-disable-next-line prefer-const\n  var n = numberResult.formattedString,\n    x = numberResult.roundedNumber;\n  if (isNaN(x)) {\n    return [{\n      type: 'nan',\n      value: n\n    }];\n  } else if (!isFinite(x)) {\n    return [{\n      type: 'infinity',\n      value: n\n    }];\n  }\n  var digitReplacementTable = digit_mapping_generated_1.digitMapping[numberingSystem];\n  if (digitReplacementTable) {\n    n = n.replace(/\\d/g, function (digit) {\n      return digitReplacementTable[+digit] || digit;\n    });\n  }\n  // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n  // representation of n in the given numbering system.\n  var decimalSepIndex = n.indexOf('.');\n  var integer;\n  var fraction;\n  if (decimalSepIndex > 0) {\n    integer = n.slice(0, decimalSepIndex);\n    fraction = n.slice(decimalSepIndex + 1);\n  } else {\n    integer = n;\n  }\n  // #region Grouping integer digits\n  // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n  // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n  // unless the rounded number is greater than 10000:\n  //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n  //   NumberFormat('de').format(1234) //=> \"1.234\"\n  if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n    var groupSepSymbol = symbols.group;\n    var groups = [];\n    // > There may be two different grouping sizes: The primary grouping size used for the least\n    // > significant integer group, and the secondary grouping size used for more significant groups.\n    // > If a pattern contains multiple grouping separators, the interval between the last one and the\n    // > end of the integer defines the primary grouping size, and the interval between the last two\n    // > defines the secondary grouping size. All others are ignored.\n    var integerNumberPattern = decimalNumberPattern.split('.')[0];\n    var patternGroups = integerNumberPattern.split(',');\n    var primaryGroupingSize = 3;\n    var secondaryGroupingSize = 3;\n    if (patternGroups.length > 1) {\n      primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n    }\n    if (patternGroups.length > 2) {\n      secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n    }\n    var i = integer.length - primaryGroupingSize;\n    if (i > 0) {\n      // Slice the least significant integer group\n      groups.push(integer.slice(i, i + primaryGroupingSize));\n      // Then iteratively push the more signicant groups\n      // TODO: handle surrogate pairs in some numbering system digits\n      for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n        groups.push(integer.slice(i, i + secondaryGroupingSize));\n      }\n      groups.push(integer.slice(0, i + secondaryGroupingSize));\n    } else {\n      groups.push(integer);\n    }\n    while (groups.length > 0) {\n      var integerGroup = groups.pop();\n      result.push({\n        type: 'integer',\n        value: integerGroup\n      });\n      if (groups.length > 0) {\n        result.push({\n          type: 'group',\n          value: groupSepSymbol\n        });\n      }\n    }\n  } else {\n    result.push({\n      type: 'integer',\n      value: integer\n    });\n  }\n  // #endregion\n  if (fraction !== undefined) {\n    result.push({\n      type: 'decimal',\n      value: symbols.decimal\n    }, {\n      type: 'fraction',\n      value: fraction\n    });\n  }\n  if ((notation === 'scientific' || notation === 'engineering') && isFinite(x)) {\n    result.push({\n      type: 'exponentSeparator',\n      value: symbols.exponential\n    });\n    if (exponent < 0) {\n      result.push({\n        type: 'exponentMinusSign',\n        value: symbols.minusSign\n      });\n      exponent = -exponent;\n    }\n    var exponentResult = (0, ToRawFixed_1.ToRawFixed)(exponent, 0, 0);\n    result.push({\n      type: 'exponentInteger',\n      value: exponentResult.formattedString\n    });\n  }\n  return result;\n}\nfunction getPatternForSign(pattern, sign) {\n  if (pattern.indexOf(';') < 0) {\n    pattern = \"\".concat(pattern, \";-\").concat(pattern);\n  }\n  var _a = pattern.split(';'),\n    zeroPattern = _a[0],\n    negativePattern = _a[1];\n  switch (sign) {\n    case 0:\n      return zeroPattern;\n    case -1:\n      return negativePattern;\n    default:\n      return negativePattern.indexOf('-') >= 0 ? negativePattern.replace(/-/g, '+') : \"+\".concat(zeroPattern);\n  }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n  var _a;\n  var roundedNumber = numberResult.roundedNumber,\n    sign = numberResult.sign,\n    magnitude = numberResult.magnitude;\n  var magnitudeKey = String(Math.pow(10, magnitude));\n  var defaultNumberingSystem = data.numbers.nu[0];\n  var pattern;\n  if (style === 'currency' && currencyDisplay !== 'name') {\n    var byNumberingSystem = data.numbers.currency;\n    var currencyData = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    // NOTE: compact notation ignores currencySign!\n    var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n    if (!compactPluralRules) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n  } else {\n    var byNumberingSystem = data.numbers.decimal;\n    var byCompactDisplay = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n    if (!compactPlaralRule) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n  }\n  // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n  // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n  // > pattern for that sort of object is supplied.\n  if (pattern === '0') {\n    return null;\n  }\n  pattern = getPatternForSign(pattern, sign)\n  // Extract compact literal from the pattern\n  .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n  // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n  .replace(/0+/, '0');\n  return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n  return rules[pl.select(x)] || rules.other;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ToRawFixed_1","require","digit_mapping_generated_1","regex_generated_1","CARET_S_UNICODE_REGEX","RegExp","concat","S_UNICODE_REGEX","source","S_DOLLAR_UNICODE_REGEX","CLDR_NUMBER_PATTERN","formatToParts","numberResult","data","pl","options","sign","exponent","magnitude","notation","style","numberingSystem","defaultNumberingSystem","numbers","nu","compactNumberPattern","getCompactDisplayPattern","compactDisplay","currencyDisplay","nonNameCurrencyPart","byCurrencyDisplay","currencies","currency","symbol","narrow","numberPattern","decimalData","decimal","getPatternForSign","standard","currencyData","currencySign","percentPattern","percent","decimalNumberPattern","exec","replace","afterCurrency","currencySpacing","afterInsertBetween","test","beforeCurrency","beforeInsertBetween","numberPatternParts","split","numberParts","symbols","_i","numberPatternParts_1","length","part","push","apply","paritionNumberIntoParts","Boolean","useGrouping","type","minusSign","plusSign","percentSign","substring","unitPattern","unitName","currencyNameData","selectPlural","roundedNumber","Math","pow","displayName","unitPatternParts","result","_a","unitPatternParts_1","unit","unitDisplay","unitData","units","simple","_b","numeratorUnit","denominatorUnit","numeratorUnitPattern","perUnitPattern","perUnit","perPattern","compound","per","denominatorPattern","_c","_d","interpolateMatch","default","n","formattedString","x","isNaN","isFinite","digitReplacementTable","digitMapping","digit","decimalSepIndex","indexOf","integer","fraction","slice","groupSepSymbol","group","groups","integerNumberPattern","patternGroups","primaryGroupingSize","secondaryGroupingSize","i","integerGroup","pop","undefined","exponential","exponentResult","ToRawFixed","pattern","zeroPattern","negativePattern","magnitudeKey","String","byNumberingSystem","compactPluralRules","short","byCompactDisplay","compactPlaralRule","rules","select","other"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@formatjs/ecma402-abstract/NumberFormat/format_to_parts.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ToRawFixed_1 = require(\"./ToRawFixed\");\nvar digit_mapping_generated_1 = require(\"./digit-mapping.generated\");\nvar regex_generated_1 = require(\"../regex.generated\");\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(regex_generated_1.S_UNICODE_REGEX.source));\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(regex_generated_1.S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nfunction formatToParts(numberResult, data, pl, options) {\n    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;\n    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;\n    var defaultNumberingSystem = data.numbers.nu[0];\n    // #region Part 1: partition and interpolate the CLDR number pattern.\n    // ----------------------------------------------------------\n    var compactNumberPattern = null;\n    if (notation === 'compact' && magnitude) {\n        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n    }\n    // This is used multiple times\n    var nonNameCurrencyPart;\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var byCurrencyDisplay = data.currencies[options.currency];\n        if (byCurrencyDisplay) {\n            switch (options.currencyDisplay) {\n                case 'code':\n                    nonNameCurrencyPart = options.currency;\n                    break;\n                case 'symbol':\n                    nonNameCurrencyPart = byCurrencyDisplay.symbol;\n                    break;\n                default:\n                    nonNameCurrencyPart = byCurrencyDisplay.narrow;\n                    break;\n            }\n        }\n        else {\n            // Fallback for unknown currency\n            nonNameCurrencyPart = options.currency;\n        }\n    }\n    var numberPattern;\n    if (!compactNumberPattern) {\n        // Note: if the style is unit, or is currency and the currency display is name,\n        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n        if (style === 'decimal' ||\n            style === 'unit' ||\n            (style === 'currency' && options.currencyDisplay === 'name')) {\n            // Shortcut for decimal\n            var decimalData = data.numbers.decimal[numberingSystem] ||\n                data.numbers.decimal[defaultNumberingSystem];\n            numberPattern = getPatternForSign(decimalData.standard, sign);\n        }\n        else if (style === 'currency') {\n            var currencyData = data.numbers.currency[numberingSystem] ||\n                data.numbers.currency[defaultNumberingSystem];\n            // We replace number pattern part with `0` for easier postprocessing.\n            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n        }\n        else {\n            // percent\n            var percentPattern = data.numbers.percent[numberingSystem] ||\n                data.numbers.percent[defaultNumberingSystem];\n            numberPattern = getPatternForSign(percentPattern, sign);\n        }\n    }\n    else {\n        numberPattern = compactNumberPattern;\n    }\n    // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n    // used to infer decimal group sizes.\n    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n    // Now we start to substitute patterns\n    // 1. replace strings like `0` and `#,##0.00` with `{0}`\n    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n    numberPattern = numberPattern\n        .replace(CLDR_NUMBER_PATTERN, '{0}')\n        .replace(/'(.)'/g, '$1');\n    // Handle currency spacing (both compact and non-compact).\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var currencyData = data.numbers.currency[numberingSystem] ||\n            data.numbers.currency[defaultNumberingSystem];\n        // See `currencySpacing` substitution rule in TR-35.\n        // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n        //\n        // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n        // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n        // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n        //\n        // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n        // and number, because `$` does not match \"[:^S:]\".\n        //\n        // Implementation note: here we do the best effort to infer the insertion.\n        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\".concat(afterCurrency, \"{0}\"));\n        }\n        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\u00A4\"));\n        }\n    }\n    // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n    var numberParts = [];\n    var symbols = data.numbers.symbols[numberingSystem] ||\n        data.numbers.symbols[defaultNumberingSystem];\n    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n        var part = numberPatternParts_1[_i];\n        if (!part) {\n            continue;\n        }\n        switch (part) {\n            case '{0}': {\n                // We only need to handle scientific and engineering notation here.\n                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, \n                // If compact number pattern exists, do not insert group separators.\n                !compactNumberPattern && Boolean(options.useGrouping), decimalNumberPattern));\n                break;\n            }\n            case '-':\n                numberParts.push({ type: 'minusSign', value: symbols.minusSign });\n                break;\n            case '+':\n                numberParts.push({ type: 'plusSign', value: symbols.plusSign });\n                break;\n            case '%':\n                numberParts.push({ type: 'percentSign', value: symbols.percentSign });\n                break;\n            case '¤':\n                // Computed above when handling currency spacing.\n                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });\n                break;\n            default:\n                if (/^\\{c:/.test(part)) {\n                    numberParts.push({\n                        type: 'compact',\n                        value: part.substring(3, part.length - 1),\n                    });\n                }\n                else {\n                    // literal\n                    numberParts.push({ type: 'literal', value: part });\n                }\n                break;\n        }\n    }\n    // #endregion\n    // #region Part 2: interpolate unit pattern if necessary.\n    // ----------------------------------------------\n    switch (style) {\n        case 'currency': {\n            // `currencyDisplay: 'name'` has similar pattern handling as units.\n            if (options.currencyDisplay === 'name') {\n                var unitPattern = (data.numbers.currency[numberingSystem] ||\n                    data.numbers.currency[defaultNumberingSystem]).unitPattern;\n                // Select plural\n                var unitName = void 0;\n                var currencyNameData = data.currencies[options.currency];\n                if (currencyNameData) {\n                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n                }\n                else {\n                    // Fallback for unknown currency\n                    unitName = options.currency;\n                }\n                // Do {0} and {1} substitution\n                var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n                var result = [];\n                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n                    var part = unitPatternParts_1[_a];\n                    switch (part) {\n                        case '{0}':\n                            result.push.apply(result, numberParts);\n                            break;\n                        case '{1}':\n                            result.push({ type: 'currency', value: unitName });\n                            break;\n                        default:\n                            if (part) {\n                                result.push({ type: 'literal', value: part });\n                            }\n                            break;\n                    }\n                }\n                return result;\n            }\n            else {\n                return numberParts;\n            }\n        }\n        case 'unit': {\n            var unit = options.unit, unitDisplay = options.unitDisplay;\n            var unitData = data.units.simple[unit];\n            var unitPattern = void 0;\n            if (unitData) {\n                // Simple unit pattern\n                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n            }\n            else {\n                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n                // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n                // Implementation note: we are not following TR-35 here because we need to format to parts!\n                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];\n                unitData = data.units.simple[numeratorUnit];\n                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n                if (perUnitPattern) {\n                    // perUnitPattern exists, combine it with numeratorUnitPattern\n                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n                }\n                else {\n                    // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n                    // the denominator pattern in singular form.\n                    var perPattern = data.units.compound.per[unitDisplay];\n                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n                    unitPattern = unitPattern = perPattern\n                        .replace('{0}', numeratorUnitPattern)\n                        .replace('{1}', denominatorPattern.replace('{0}', ''));\n                }\n            }\n            var result = [];\n            // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n            for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n                var part = _d[_c];\n                var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n                if (interpolateMatch) {\n                    // Space before \"{0}\"\n                    if (interpolateMatch[1]) {\n                        result.push({ type: 'literal', value: interpolateMatch[1] });\n                    }\n                    // \"{0}\" itself\n                    result.push.apply(result, numberParts);\n                    // Space after \"{0}\"\n                    if (interpolateMatch[2]) {\n                        result.push({ type: 'literal', value: interpolateMatch[2] });\n                    }\n                }\n                else if (part) {\n                    result.push({ type: 'unit', value: part });\n                }\n            }\n            return result;\n        }\n        default:\n            return numberParts;\n    }\n    // #endregion\n}\nexports.default = formatToParts;\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, \n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n    var result = [];\n    // eslint-disable-next-line prefer-const\n    var n = numberResult.formattedString, x = numberResult.roundedNumber;\n    if (isNaN(x)) {\n        return [{ type: 'nan', value: n }];\n    }\n    else if (!isFinite(x)) {\n        return [{ type: 'infinity', value: n }];\n    }\n    var digitReplacementTable = digit_mapping_generated_1.digitMapping[numberingSystem];\n    if (digitReplacementTable) {\n        n = n.replace(/\\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });\n    }\n    // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n    // representation of n in the given numbering system.\n    var decimalSepIndex = n.indexOf('.');\n    var integer;\n    var fraction;\n    if (decimalSepIndex > 0) {\n        integer = n.slice(0, decimalSepIndex);\n        fraction = n.slice(decimalSepIndex + 1);\n    }\n    else {\n        integer = n;\n    }\n    // #region Grouping integer digits\n    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n    // unless the rounded number is greater than 10000:\n    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n    //   NumberFormat('de').format(1234) //=> \"1.234\"\n    if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n        var groupSepSymbol = symbols.group;\n        var groups = [];\n        // > There may be two different grouping sizes: The primary grouping size used for the least\n        // > significant integer group, and the secondary grouping size used for more significant groups.\n        // > If a pattern contains multiple grouping separators, the interval between the last one and the\n        // > end of the integer defines the primary grouping size, and the interval between the last two\n        // > defines the secondary grouping size. All others are ignored.\n        var integerNumberPattern = decimalNumberPattern.split('.')[0];\n        var patternGroups = integerNumberPattern.split(',');\n        var primaryGroupingSize = 3;\n        var secondaryGroupingSize = 3;\n        if (patternGroups.length > 1) {\n            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n        }\n        if (patternGroups.length > 2) {\n            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n        }\n        var i = integer.length - primaryGroupingSize;\n        if (i > 0) {\n            // Slice the least significant integer group\n            groups.push(integer.slice(i, i + primaryGroupingSize));\n            // Then iteratively push the more signicant groups\n            // TODO: handle surrogate pairs in some numbering system digits\n            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n                groups.push(integer.slice(i, i + secondaryGroupingSize));\n            }\n            groups.push(integer.slice(0, i + secondaryGroupingSize));\n        }\n        else {\n            groups.push(integer);\n        }\n        while (groups.length > 0) {\n            var integerGroup = groups.pop();\n            result.push({ type: 'integer', value: integerGroup });\n            if (groups.length > 0) {\n                result.push({ type: 'group', value: groupSepSymbol });\n            }\n        }\n    }\n    else {\n        result.push({ type: 'integer', value: integer });\n    }\n    // #endregion\n    if (fraction !== undefined) {\n        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });\n    }\n    if ((notation === 'scientific' || notation === 'engineering') &&\n        isFinite(x)) {\n        result.push({ type: 'exponentSeparator', value: symbols.exponential });\n        if (exponent < 0) {\n            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });\n            exponent = -exponent;\n        }\n        var exponentResult = (0, ToRawFixed_1.ToRawFixed)(exponent, 0, 0);\n        result.push({\n            type: 'exponentInteger',\n            value: exponentResult.formattedString,\n        });\n    }\n    return result;\n}\nfunction getPatternForSign(pattern, sign) {\n    if (pattern.indexOf(';') < 0) {\n        pattern = \"\".concat(pattern, \";-\").concat(pattern);\n    }\n    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];\n    switch (sign) {\n        case 0:\n            return zeroPattern;\n        case -1:\n            return negativePattern;\n        default:\n            return negativePattern.indexOf('-') >= 0\n                ? negativePattern.replace(/-/g, '+')\n                : \"+\".concat(zeroPattern);\n    }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n    var _a;\n    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;\n    var magnitudeKey = String(Math.pow(10, magnitude));\n    var defaultNumberingSystem = data.numbers.nu[0];\n    var pattern;\n    if (style === 'currency' && currencyDisplay !== 'name') {\n        var byNumberingSystem = data.numbers.currency;\n        var currencyData = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        // NOTE: compact notation ignores currencySign!\n        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n        if (!compactPluralRules) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n    }\n    else {\n        var byNumberingSystem = data.numbers.decimal;\n        var byCompactDisplay = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n        if (!compactPlaralRule) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n    }\n    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n    // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n    // > pattern for that sort of object is supplied.\n    if (pattern === '0') {\n        return null;\n    }\n    pattern = getPatternForSign(pattern, sign)\n        // Extract compact literal from the pattern\n        .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n        .replace(/0+/, '0');\n    return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n    return rules[pl.select(x)] || rules.other;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}