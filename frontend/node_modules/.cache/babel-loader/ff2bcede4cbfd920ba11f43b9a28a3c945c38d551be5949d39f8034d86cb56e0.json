{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getExportSpecifierName = getExportSpecifierName;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\nvar _core = require(\"@babel/core\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nconst buildTemplate = _core.template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\nconst buildExportAll = _core.template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-transform-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-transform-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\nfunction getExportSpecifierName(node, stringSpecifiers) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);\n  }\n}\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {\n  const statements = [];\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n    } else {\n      const objectProperties = [];\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));\n      }\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n  return statements;\n}\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const reassignmentVisited = new WeakSet();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n      const arg = path.isAssignmentExpression() ? path.get(\"left\") : path.get(\"argument\");\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n      const isPostUpdateExpression = _core.types.isUpdateExpression(node, {\n        prefix: false\n      });\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n      path.replaceWith(node);\n    }\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n    visitor: {\n      [\"CallExpression\" + (api.types.importExpression ? \"|ImportExpression\" : \"\")](path, state) {\n        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;\n        if (path.isCallExpression()) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n        } else {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            throw new Error(MISSING_PLUGIN_ERROR);\n          }\n        }\n        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, true, specifier => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [specifier])));\n      },\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const {\n            contextIdent,\n            stringSpecifiers\n          } = state;\n          const exportMap = Object.create(null);\n          const modules = [];\n          const beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n            module[key] = module[key].concat(specifiers);\n          }\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(_core.types.cloneNode(path.node.id));\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isVariableDeclaration()) {\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n              if (_core.types.isClassDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (_core.types.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                }\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n              if (declar) {\n                path.replaceWith(declar);\n                if (_core.types.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (_core.types.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(declar.id));\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));\n                  addExportName(name, name);\n                } else {\n                  if (_core.types.isVariableDeclaration(declar)) {\n                    declar.kind = \"var\";\n                  }\n                  for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n                if (specifiers != null && specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n                    for (const specifier of specifiers) {\n                      const {\n                        local,\n                        exported\n                      } = specifier;\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(exportedName);\n                        exportValues.push(_core.types.cloneNode(local));\n                      } else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n                      addExportName(local.name, exportedName);\n                    }\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n              if (_core.types.isImportSpecifier(specifier)) {\n                const {\n                  imported\n                } = specifier;\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === \"StringLiteral\"))));\n              }\n            }\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);\n                  exportNames.push(exportedName);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));\n                } else {}\n              }\n              setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));\n            }\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {\n            variableIds.push(id);\n            if (!hasInit && name in exportMap) {\n              for (const exported of exportMap[name]) {\n                exportNames.push(exported);\n                exportValues.push(scope.buildUndefinedNode());\n              }\n            }\n          });\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n          if (exportNames.length) {\n            beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));\n          }\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope\n          });\n          for (const path of removedPaths) {\n            path.remove();\n          }\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n            Function(path) {\n              path.skip();\n            },\n            noScope: true\n          });\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),\n            SOURCES: _core.types.arrayExpression(sources),\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n          path.requeue(path.get(\"body.0\"));\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperHoistVariables","_core","_helperModuleTransforms","_helperValidatorIdentifier","buildTemplate","template","statement","buildExportAll","MISSING_PLUGIN_WARNING","MISSING_PLUGIN_ERROR","getExportSpecifierName","node","stringSpecifiers","type","name","stringValue","value","isIdentifierName","add","Error","constructExportCall","path","exportIdent","exportNames","exportValues","exportStarTarget","statements","length","push","types","expressionStatement","callExpression","stringLiteral","objectProperties","i","exportName","exportValue","objectProperty","has","identifier","objectExpression","exportObj","scope","generateUid","variableDeclaration","variableDeclarator","KEY","generateUidIdentifier","EXPORT_OBJ","TARGET","assignmentExpression","memberExpression","_default","exports","default","declare","api","options","assertVersion","systemGlobal","allowTopLevelThis","reassignmentVisited","WeakSet","reassignmentVisitor","AssignmentExpression|UpdateExpression","arg","isAssignmentExpression","get","isObjectPattern","isArrayPattern","exprs","Object","keys","getBindingIdentifiers","getBinding","exportedNames","exportedName","buildCall","expression","replaceWith","sequenceExpression","isIdentifier","isPostUpdateExpression","isUpdateExpression","prefix","binaryExpression","operator","unaryExpression","cloneNode","argument","numericLiteral","pre","file","set","visitor","importExpression","state","isCallExpression","isImport","callee","console","warn","buildDynamicImport","specifier","contextIdent","MetaProperty","meta","property","ReferencedIdentifier","hasBinding","Program","enter","Set","rewriteThis","exit","exportMap","create","modules","beforeBody","setters","sources","variableIds","removedPaths","addExportName","key","val","pushModule","source","specifiers","module","forEach","m","imports","concat","buildExportCall","body","isFunctionDeclaration","isClassDeclaration","id","toExpression","isVariableDeclaration","kind","isImportDeclaration","removeBinding","remove","isExportAllDeclaration","isExportDefaultDeclaration","declar","declaration","buildUndefinedNode","isExportNamedDeclaration","isFunction","isClass","nodes","local","exported","binding","replaceWithMultiple","setterBody","target","isImportNamespaceSpecifier","isImportDefaultSpecifier","importSpecifier","isImportSpecifier","imported","hasExportStar","isExportSpecifier","isStringLiteral","functionExpression","blockStatement","moduleName","getModuleName","opts","hasInit","unshift","map","traverse","hasTLA","AwaitExpression","stop","Function","skip","noScope","SYSTEM_REGISTER","BEFORE_BODY","MODULE_NAME","SETTERS","arrayExpression","EXECUTE","SOURCES","EXPORT_IDENTIFIER","CONTEXT_IDENTIFIER","requeue"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-modules-systemjs\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\nimport { template, types as t, type PluginPass } from \"@babel/core\";\nimport {\n  buildDynamicImport,\n  getModuleName,\n  rewriteThis,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nconst buildTemplate = template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\n\nconst buildExportAll = template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\n\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-transform-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-transform-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\n//todo: use getExportSpecifierName in `helper-module-transforms` when this library is refactored to NodePath usage.\n\nexport function getExportSpecifierName(\n  node: t.Node,\n  stringSpecifiers: Set<string>,\n): string {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`,\n    );\n  }\n}\n\ntype PluginState = {\n  contextIdent: string;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n};\n\ntype ModuleMetadata = {\n  key: string;\n  imports: any[];\n  exports: any[];\n};\n\nfunction constructExportCall(\n  path: NodePath<t.Program>,\n  exportIdent: t.Identifier,\n  exportNames: string[],\n  exportValues: t.Expression[],\n  exportStarTarget: t.Identifier | null,\n  stringSpecifiers: Set<string>,\n) {\n  const statements = [];\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [\n            t.stringLiteral(exportNames[0]),\n            exportValues[0],\n          ]),\n        ),\n      );\n    } else {\n      const objectProperties = [];\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(\n          t.objectProperty(\n            stringSpecifiers.has(exportName)\n              ? t.stringLiteral(exportName)\n              : t.identifier(exportName),\n            exportValue,\n          ),\n        );\n      }\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [t.objectExpression(objectProperties)]),\n        ),\n      );\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n\n    statements.push(\n      t.variableDeclaration(\"var\", [\n        t.variableDeclarator(t.identifier(exportObj), t.objectExpression([])),\n      ]),\n    );\n\n    statements.push(\n      buildExportAll({\n        KEY: path.scope.generateUidIdentifier(\"key\"),\n        EXPORT_OBJ: t.identifier(exportObj),\n        TARGET: exportStarTarget,\n      }),\n    );\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n\n      statements.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(\n              t.identifier(exportObj),\n              t.identifier(exportName),\n            ),\n            exportValue,\n          ),\n        ),\n      );\n    }\n\n    statements.push(\n      t.expressionStatement(\n        t.callExpression(exportIdent, [t.identifier(exportObj)]),\n      ),\n    );\n  }\n  return statements;\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  systemGlobal?: string;\n}\n\ntype ReassignmentVisitorState = {\n  scope: Scope;\n  exports: any;\n  buildCall: (name: string, value: t.Expression) => t.ExpressionStatement;\n};\n\nexport default declare<PluginState>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { systemGlobal = \"System\", allowTopLevelThis = false } = options;\n  const reassignmentVisited = new WeakSet();\n\n  const reassignmentVisitor: Visitor<ReassignmentVisitorState> = {\n    \"AssignmentExpression|UpdateExpression\"(\n      path: NodePath<t.AssignmentExpression | t.UpdateExpression>,\n    ) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n\n      const arg = path.isAssignmentExpression()\n        ? path.get(\"left\")\n        : path.get(\"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs: t.SequenceExpression[\"expressions\"] = [path.node];\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n          for (const exportedName of exportedNames) {\n            exprs.push(\n              this.buildCall(exportedName, t.identifier(name)).expression,\n            );\n          }\n        }\n        path.replaceWith(t.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n\n      const name = arg.node.name;\n\n      // redeclared in this scope\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n\n      let node: t.Expression = path.node;\n\n      // if it is a non-prefix update expression (x++ etc)\n      // then we must replace with the expression (_export('x', x + 1), x++)\n      // in order to ensure the same update expression value\n      const isPostUpdateExpression = t.isUpdateExpression(node, {\n        prefix: false,\n      });\n      if (isPostUpdateExpression) {\n        node = t.binaryExpression(\n          // @ts-expect-error The operator of a post-update expression must be \"++\" | \"--\"\n          node.operator[0],\n          t.unaryExpression(\n            \"+\",\n            t.cloneNode(\n              // @ts-expect-error node is UpdateExpression\n              node.argument,\n            ),\n          ),\n          t.numericLiteral(1),\n        );\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = t.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    },\n  };\n\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      [\"CallExpression\" +\n        (api.types.importExpression ? \"|ImportExpression\" : \"\")](\n        this: PluginPass & PluginState,\n        path: NodePath<t.CallExpression | t.ImportExpression>,\n        state: PluginState,\n      ) {\n        if (path.isCallExpression() && !t.isImport(path.node.callee)) return;\n        if (path.isCallExpression()) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            if (process.env.BABEL_8_BREAKING) {\n              throw new Error(MISSING_PLUGIN_ERROR);\n            } else {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n        } else {\n          // when createImportExpressions is true, we require the dynamic import transform\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            throw new Error(MISSING_PLUGIN_ERROR);\n          }\n        }\n        path.replaceWith(\n          buildDynamicImport(path.node, false, true, specifier =>\n            t.callExpression(\n              t.memberExpression(\n                t.identifier(state.contextIdent),\n                t.identifier(\"import\"),\n              ),\n              [specifier],\n            ),\n          ),\n        );\n      },\n\n      MetaProperty(path, state: PluginState) {\n        if (\n          path.node.meta.name === \"import\" &&\n          path.node.property.name === \"meta\"\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"meta\"),\n            ),\n          );\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (\n          path.node.name === \"__moduleName\" &&\n          !path.scope.hasBinding(\"__moduleName\")\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"id\"),\n            ),\n          );\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n          if (!allowTopLevelThis) {\n            rewriteThis(path);\n          }\n        },\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const { contextIdent, stringSpecifiers } = state;\n\n          const exportMap: Record<string, string[]> = Object.create(null);\n          const modules: ModuleMetadata[] = [];\n\n          const beforeBody = [];\n          const setters: t.Expression[] = [];\n          const sources: t.StringLiteral[] = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key: string, val: string) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(\n            source: string,\n            key: \"imports\" | \"exports\",\n            specifiers: t.ModuleSpecifier[] | t.ExportAllDeclaration,\n          ) {\n            let module: ModuleMetadata;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n            if (!module) {\n              modules.push(\n                (module = { key: source, imports: [], exports: [] }),\n              );\n            }\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name: string, val: t.Expression) {\n            return t.expressionStatement(\n              t.callExpression(t.identifier(exportIdent), [\n                t.stringLiteral(name),\n                val,\n              ]),\n            );\n          }\n\n          const exportNames = [];\n          const exportValues: t.Expression[] = [];\n\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(t.cloneNode(path.node.id));\n              path.replaceWith(\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(path.node.id),\n                    t.toExpression(path.node),\n                  ),\n                ),\n              );\n            } else if (path.isVariableDeclaration()) {\n              // Convert top-level variable declarations to \"var\",\n              // because they must be hoisted\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(t.identifier(name));\n              }\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n              if (t.isClassDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (t.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                }\n                removedPaths.push(path);\n              } else {\n                // @ts-expect-error TSDeclareFunction is not expected here\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n\n              if (declar) {\n                path.replaceWith(declar);\n\n                if (t.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(t.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (t.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(declar.id));\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(declar.id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                  addExportName(name, name);\n                } else {\n                  if (t.isVariableDeclaration(declar)) {\n                    // Convert top-level variable declarations to \"var\",\n                    // because they must be hoisted\n                    declar.kind = \"var\";\n                  }\n                  for (const name of Object.keys(\n                    t.getBindingIdentifiers(declar),\n                  )) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n                if (specifiers?.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      // @ts-expect-error This isn't an \"export ... from\" declaration\n                      // because path.node.source is falsy, so the local specifier exists.\n                      const { local, exported } = specifier;\n\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(\n                        exported,\n                        stringSpecifiers,\n                      );\n                      // hoisted function export\n                      if (\n                        binding &&\n                        t.isFunctionDeclaration(binding.path.node)\n                      ) {\n                        exportNames.push(exportedName);\n                        exportValues.push(t.cloneNode(local));\n                      }\n                      // only globals also exported this way\n                      else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n                      addExportName(local.name, exportedName);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (t.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.identifier(target),\n                    ),\n                  ),\n                );\n              } else if (t.isImportDefaultSpecifier(specifier)) {\n                specifier = t.importSpecifier(\n                  specifier.local,\n                  t.identifier(\"default\"),\n                );\n              }\n\n              if (t.isImportSpecifier(specifier)) {\n                const { imported } = specifier;\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.memberExpression(\n                        t.identifier(target),\n                        specifier.imported,\n                        /* computed */ imported.type === \"StringLiteral\",\n                      ),\n                    ),\n                  ),\n                );\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (t.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (t.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(\n                    node.exported,\n                    stringSpecifiers,\n                  );\n                  exportNames.push(exportedName);\n                  exportValues.push(\n                    t.memberExpression(\n                      t.identifier(target),\n                      node.local,\n                      t.isStringLiteral(node.local),\n                    ),\n                  );\n                } else {\n                  // todo\n                }\n              }\n\n              setterBody.push(\n                ...constructExportCall(\n                  path,\n                  t.identifier(exportIdent),\n                  exportNames,\n                  exportValues,\n                  hasExportStar ? t.identifier(target) : null,\n                  stringSpecifiers,\n                ),\n              );\n            }\n\n            sources.push(t.stringLiteral(specifiers.key));\n            setters.push(\n              t.functionExpression(\n                null,\n                [t.identifier(target)],\n                t.blockStatement(setterBody),\n              ),\n            );\n          });\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          hoistVariables(path, (id, name, hasInit) => {\n            variableIds.push(id);\n            if (!hasInit && name in exportMap) {\n              for (const exported of exportMap[name]) {\n                exportNames.push(exported);\n                exportValues.push(scope.buildUndefinedNode());\n              }\n            }\n          });\n\n          if (variableIds.length) {\n            beforeBody.unshift(\n              t.variableDeclaration(\n                \"var\",\n                variableIds.map(id => t.variableDeclarator(id)),\n              ),\n            );\n          }\n\n          if (exportNames.length) {\n            beforeBody.push(\n              ...constructExportCall(\n                path,\n                t.identifier(exportIdent),\n                exportNames,\n                exportValues,\n                null,\n                stringSpecifiers,\n              ),\n            );\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope,\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n            Function(path) {\n              path.skip();\n            },\n            // @ts-expect-error - todo: add noScope to type definitions\n            noScope: true,\n          });\n\n          path.node.body = [\n            buildTemplate({\n              SYSTEM_REGISTER: t.memberExpression(\n                t.identifier(systemGlobal),\n                t.identifier(\"register\"),\n              ),\n              BEFORE_BODY: beforeBody,\n              MODULE_NAME: moduleName,\n              SETTERS: t.arrayExpression(setters),\n              EXECUTE: t.functionExpression(\n                null,\n                [],\n                t.blockStatement(path.node.body),\n                false,\n                hasTLA,\n              ),\n              SOURCES: t.arrayExpression(sources),\n              EXPORT_IDENTIFIER: t.identifier(exportIdent),\n              CONTEXT_IDENTIFIER: t.identifier(contextIdent),\n            }),\n          ];\n          path.requeue(path.get(\"body.0\"));\n        },\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}