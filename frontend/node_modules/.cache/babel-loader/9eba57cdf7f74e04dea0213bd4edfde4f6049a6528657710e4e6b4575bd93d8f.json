{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyOperations = applyOperations;\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\nvar _encoder = require(\"@webassemblyjs/wasm-gen/lib/encoder\");\nvar _ast = require(\"@webassemblyjs/ast\");\nvar _helperWasmSection = require(\"@webassemblyjs/helper-wasm-section\");\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\nvar _helperWasmBytecode = require(\"@webassemblyjs/helper-wasm-bytecode\");\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction shiftLocNodeByDelta(node, delta) {\n  (0, _ast.assertHasLoc)(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    oldNode = _ref2[0],\n    newNode = _ref2[1];\n  var deltaElements = 0;\n  (0, _ast.assertHasLoc)(oldNode);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(newNode);\n  var replacementByteArray = (0, _wasmGen.encodeNode)(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer,\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column,\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    (0, _ast.traverse)(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          (0, _ast.assertHasLoc)(node);\n          var oldNodeSize = (0, _wasmGen.encodeNode)(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = (0, _encoder.encodeU32)(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n  var deltaBytes = replacementByteArray.length - (oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column =\n  // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  (0, _ast.assertHasLoc)(node);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  if (sectionName === \"start\") {\n    var sectionMetadata = (0, _ast.getSectionMetadata)(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = (0, _helperWasmSection.removeSections)(ast, uint8Buffer, \"start\");\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n  var replacement = [];\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer,\n  // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column,\n  // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  var sectionMetadata = (0, _ast.getSectionMetadata)(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = (0, _helperWasmSection.createEmptySection)(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n  if ((0, _ast.isFunc)(node)) {\n    // $FlowIgnore\n    var body = node.body;\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  if ((0, _ast.isGlobal)(node)) {\n    // $FlowIgnore\n    var body = node.init;\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n  var newByteArray = (0, _wasmGen.encodeNode)(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = (0, _ast.getEndOfSection)(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n  if (node.type !== \"IndexInFuncSection\") {\n    (0, _ast.orderedInsertNode)(ast.body[0], node);\n  }\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\nfunction applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionVecSize)(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionByteSize)(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","applyOperations","_wasmGen","require","_encoder","_ast","_helperWasmSection","_helperBuffer","_helperWasmBytecode","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","err","isArray","shiftLocNodeByDelta","node","delta","assertHasLoc","loc","start","column","end","applyUpdate","ast","uint8Buffer","_ref","_ref2","oldNode","newNode","deltaElements","sectionName","getSectionForNode","replacementByteArray","encodeNode","overrideBytesInBuffer","traverse","Func","_ref3","funcHasThisIntr","body","find","undefined","oldNodeSize","bodySizeDeltaBytes","newValue","metadata","bodySize","newByteArray","encodeU32","deltaBytes","line","applyDelete","sectionMetadata","getSectionMetadata","removeSections","_deltaBytes","size","replacement","applyAdd","res","createEmptySection","isFunc","id","Error","isGlobal","init","getEndOfSection","type","orderedInsertNode","ops","forEach","op","state","kind","oldBufferLength","resizeSectionVecSize","_oldBufferLength","resizeSectionByteSize"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/wasm-edit/lib/apply.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyOperations = applyOperations;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _encoder = require(\"@webassemblyjs/wasm-gen/lib/encoder\");\n\nvar _ast = require(\"@webassemblyjs/ast\");\n\nvar _helperWasmSection = require(\"@webassemblyjs/helper-wasm-section\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = require(\"@webassemblyjs/helper-wasm-bytecode\");\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction shiftLocNodeByDelta(node, delta) {\n  (0, _ast.assertHasLoc)(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  (0, _ast.assertHasLoc)(oldNode);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(newNode);\n  var replacementByteArray = (0, _wasmGen.encodeNode)(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    (0, _ast.traverse)(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          (0, _ast.assertHasLoc)(node);\n          var oldNodeSize = (0, _wasmGen.encodeNode)(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = (0, _encoder.encodeU32)(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - (oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  (0, _ast.assertHasLoc)(node);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = (0, _ast.getSectionMetadata)(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = (0, _helperWasmSection.removeSections)(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  var sectionMetadata = (0, _ast.getSectionMetadata)(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = (0, _helperWasmSection.createEmptySection)(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if ((0, _ast.isFunc)(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if ((0, _ast.isGlobal)(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = (0, _wasmGen.encodeNode)(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = (0, _ast.getEndOfSection)(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    (0, _ast.orderedInsertNode)(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionVecSize)(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionByteSize)(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}