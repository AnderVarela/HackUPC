{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nfunction parseChecksVoidReturn(checksVoidReturn) {\n  var _a, _b, _c, _d, _e;\n  switch (checksVoidReturn) {\n    case false:\n      return false;\n    case true:\n    case undefined:\n      return {\n        arguments: true,\n        attributes: true,\n        properties: true,\n        returns: true,\n        variables: true\n      };\n    default:\n      return {\n        arguments: (_a = checksVoidReturn.arguments) !== null && _a !== void 0 ? _a : true,\n        attributes: (_b = checksVoidReturn.attributes) !== null && _b !== void 0 ? _b : true,\n        properties: (_c = checksVoidReturn.properties) !== null && _c !== void 0 ? _c : true,\n        returns: (_d = checksVoidReturn.returns) !== null && _d !== void 0 ? _d : true,\n        variables: (_e = checksVoidReturn.variables) !== null && _e !== void 0 ? _e : true\n      };\n  }\n}\nexports.default = util.createRule({\n  name: 'no-misused-promises',\n  meta: {\n    docs: {\n      description: 'Disallow Promises in places not designed to handle them',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      voidReturnArgument: 'Promise returned in function argument where a void return was expected.',\n      voidReturnVariable: 'Promise-returning function provided to variable where a void return was expected.',\n      voidReturnProperty: 'Promise-returning function provided to property where a void return was expected.',\n      voidReturnReturnValue: 'Promise-returning function provided to return value where a void return was expected.',\n      voidReturnAttribute: 'Promise-returning function provided to attribute where a void return was expected.',\n      conditional: 'Expected non-Promise value in a boolean conditional.',\n      spread: 'Expected a non-Promise value to be spreaded in an object.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        checksConditionals: {\n          type: 'boolean'\n        },\n        checksVoidReturn: {\n          oneOf: [{\n            type: 'boolean'\n          }, {\n            additionalProperties: false,\n            properties: {\n              arguments: {\n                type: 'boolean'\n              },\n              attributes: {\n                type: 'boolean'\n              },\n              properties: {\n                type: 'boolean'\n              },\n              returns: {\n                type: 'boolean'\n              },\n              variables: {\n                type: 'boolean'\n              }\n            },\n            type: 'object'\n          }]\n        },\n        checksSpreads: {\n          type: 'boolean'\n        }\n      }\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    checksConditionals: true,\n    checksVoidReturn: true,\n    checksSpreads: true\n  }],\n  create(context, [{\n    checksConditionals,\n    checksVoidReturn,\n    checksSpreads\n  }]) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const checkedNodes = new Set();\n    const conditionalChecks = {\n      ConditionalExpression: checkTestConditional,\n      DoWhileStatement: checkTestConditional,\n      ForStatement: checkTestConditional,\n      IfStatement: checkTestConditional,\n      LogicalExpression: checkConditional,\n      'UnaryExpression[operator=\"!\"]'(node) {\n        checkConditional(node.argument, true);\n      },\n      WhileStatement: checkTestConditional\n    };\n    checksVoidReturn = parseChecksVoidReturn(checksVoidReturn);\n    const voidReturnChecks = checksVoidReturn ? Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, checksVoidReturn.arguments && {\n      CallExpression: checkArguments,\n      NewExpression: checkArguments\n    }), checksVoidReturn.attributes && {\n      JSXAttribute: checkJSXAttribute\n    }), checksVoidReturn.properties && {\n      Property: checkProperty\n    }), checksVoidReturn.returns && {\n      ReturnStatement: checkReturnStatement\n    }), checksVoidReturn.variables && {\n      AssignmentExpression: checkAssignment,\n      VariableDeclarator: checkVariableDeclaration\n    }) : {};\n    const spreadChecks = {\n      SpreadElement: checkSpread\n    };\n    function checkTestConditional(node) {\n      if (node.test) {\n        checkConditional(node.test, true);\n      }\n    }\n    /**\n     * This function analyzes the type of a node and checks if it is a Promise in a boolean conditional.\n     * It uses recursion when checking nested logical operators.\n     * @param node The AST node to check.\n     * @param isTestExpr Whether the node is a descendant of a test expression.\n     */\n    function checkConditional(node, isTestExpr = false) {\n      // prevent checking the same node multiple times\n      if (checkedNodes.has(node)) {\n        return;\n      }\n      checkedNodes.add(node);\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n        // ignore the left operand for nullish coalescing expressions not in a context of a test expression\n        if (node.operator !== '??' || isTestExpr) {\n          checkConditional(node.left, isTestExpr);\n        }\n        // we ignore the right operand when not in a context of a test expression\n        if (isTestExpr) {\n          checkConditional(node.right, isTestExpr);\n        }\n        return;\n      }\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      if (isAlwaysThenable(checker, tsNode)) {\n        context.report({\n          messageId: 'conditional',\n          node\n        });\n      }\n    }\n    function checkArguments(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const voidArgs = voidFunctionArguments(checker, tsNode);\n      if (voidArgs.size === 0) {\n        return;\n      }\n      for (const [index, argument] of node.arguments.entries()) {\n        if (!voidArgs.has(index)) {\n          continue;\n        }\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(argument);\n        if (returnsThenable(checker, tsNode)) {\n          context.report({\n            messageId: 'voidReturnArgument',\n            node: argument\n          });\n        }\n      }\n    }\n    function checkAssignment(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const varType = checker.getTypeAtLocation(tsNode.left);\n      if (!isVoidReturningFunctionType(checker, tsNode.left, varType)) {\n        return;\n      }\n      if (returnsThenable(checker, tsNode.right)) {\n        context.report({\n          messageId: 'voidReturnVariable',\n          node: node.right\n        });\n      }\n    }\n    function checkVariableDeclaration(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      if (tsNode.initializer === undefined || node.init == null) {\n        return;\n      }\n      const varType = checker.getTypeAtLocation(tsNode.name);\n      if (!isVoidReturningFunctionType(checker, tsNode.initializer, varType)) {\n        return;\n      }\n      if (returnsThenable(checker, tsNode.initializer)) {\n        context.report({\n          messageId: 'voidReturnVariable',\n          node: node.init\n        });\n      }\n    }\n    function checkProperty(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      if (ts.isPropertyAssignment(tsNode)) {\n        const contextualType = checker.getContextualType(tsNode.initializer);\n        if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.initializer, contextualType) && returnsThenable(checker, tsNode.initializer)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n      } else if (ts.isShorthandPropertyAssignment(tsNode)) {\n        const contextualType = checker.getContextualType(tsNode.name);\n        if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.name, contextualType) && returnsThenable(checker, tsNode.name)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n      } else if (ts.isMethodDeclaration(tsNode)) {\n        if (ts.isComputedPropertyName(tsNode.name)) {\n          return;\n        }\n        const obj = tsNode.parent;\n        // Below condition isn't satisfied unless something goes wrong,\n        // but is needed for type checking.\n        // 'node' does not include class method declaration so 'obj' is\n        // always an object literal expression, but after converting 'node'\n        // to TypeScript AST, its type includes MethodDeclaration which\n        // does include the case of class method declaration.\n        if (!ts.isObjectLiteralExpression(obj)) {\n          return;\n        }\n        if (!returnsThenable(checker, tsNode)) {\n          return;\n        }\n        const objType = checker.getContextualType(obj);\n        if (objType === undefined) {\n          return;\n        }\n        const propertySymbol = checker.getPropertyOfType(objType, tsNode.name.text);\n        if (propertySymbol === undefined) {\n          return;\n        }\n        const contextualType = checker.getTypeOfSymbolAtLocation(propertySymbol, tsNode.name);\n        if (isVoidReturningFunctionType(checker, tsNode.name, contextualType)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n        return;\n      }\n    }\n    function checkReturnStatement(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      if (tsNode.expression === undefined || node.argument == null) {\n        return;\n      }\n      const contextualType = checker.getContextualType(tsNode.expression);\n      if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.expression, contextualType) && returnsThenable(checker, tsNode.expression)) {\n        context.report({\n          messageId: 'voidReturnReturnValue',\n          node: node.argument\n        });\n      }\n    }\n    function checkJSXAttribute(node) {\n      if (node.value == null || node.value.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer) {\n        return;\n      }\n      const expressionContainer = parserServices.esTreeNodeToTSNodeMap.get(node.value);\n      const expression = parserServices.esTreeNodeToTSNodeMap.get(node.value.expression);\n      const contextualType = checker.getContextualType(expressionContainer);\n      if (contextualType !== undefined && isVoidReturningFunctionType(checker, expressionContainer, contextualType) && returnsThenable(checker, expression)) {\n        context.report({\n          messageId: 'voidReturnAttribute',\n          node: node.value\n        });\n      }\n    }\n    function checkSpread(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      if (isSometimesThenable(checker, tsNode.expression)) {\n        context.report({\n          messageId: 'spread',\n          node: node.argument\n        });\n      }\n    }\n    return Object.assign(Object.assign(Object.assign({}, checksConditionals ? conditionalChecks : {}), checksVoidReturn ? voidReturnChecks : {}), checksSpreads ? spreadChecks : {});\n  }\n});\nfunction isSometimesThenable(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n  for (const subType of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    if (tsutils.isThenableType(checker, node, subType)) {\n      return true;\n    }\n  }\n  return false;\n}\n// Variation on the thenable check which requires all forms of the type (read:\n// alternates in a union) to be thenable. Otherwise, you might be trying to\n// check if something is defined or undefined and get caught because one of the\n// branches is thenable.\nfunction isAlwaysThenable(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n  for (const subType of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    const thenProp = subType.getProperty('then');\n    // If one of the alternates has no then property, it is not thenable in all\n    // cases.\n    if (thenProp === undefined) {\n      return false;\n    }\n    // We walk through each variation of the then property. Since we know it\n    // exists at this point, we just need at least one of the alternates to\n    // be of the right form to consider it thenable.\n    const thenType = checker.getTypeOfSymbolAtLocation(thenProp, node);\n    let hasThenableSignature = false;\n    for (const subType of tsutils.unionTypeParts(thenType)) {\n      for (const signature of subType.getCallSignatures()) {\n        if (signature.parameters.length !== 0 && isFunctionParam(checker, signature.parameters[0], node)) {\n          hasThenableSignature = true;\n          break;\n        }\n      }\n      // We only need to find one variant of the then property that has a\n      // function signature for it to be thenable.\n      if (hasThenableSignature) {\n        break;\n      }\n    }\n    // If no flavors of the then property are thenable, we don't consider the\n    // overall type to be thenable\n    if (!hasThenableSignature) {\n      return false;\n    }\n  }\n  // If all variants are considered thenable (i.e. haven't returned false), we\n  // consider the overall type thenable\n  return true;\n}\nfunction isFunctionParam(checker, param, node) {\n  const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n  for (const subType of tsutils.unionTypeParts(type)) {\n    if (subType.getCallSignatures().length !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction checkThenableOrVoidArgument(checker, node, type, index, thenableReturnIndices, voidReturnIndices) {\n  if (isThenableReturningFunctionType(checker, node.expression, type)) {\n    thenableReturnIndices.add(index);\n  } else if (isVoidReturningFunctionType(checker, node.expression, type)) {\n    // If a certain argument accepts both thenable and void returns,\n    // a promise-returning function is valid\n    if (!thenableReturnIndices.has(index)) {\n      voidReturnIndices.add(index);\n    }\n  }\n}\n// Get the positions of arguments which are void functions (and not also\n// thenable functions). These are the candidates for the void-return check at\n// the current call site.\n// If the function parameters end with a 'rest' parameter, then we consider\n// the array type parameter (e.g. '...args:Array<SomeType>') when determining\n// if trailing arguments are candidates.\nfunction voidFunctionArguments(checker, node) {\n  // 'new' can be used without any arguments, as in 'let b = new Object;'\n  // In this case, there are no argument positions to check, so return early.\n  if (!node.arguments) {\n    return new Set();\n  }\n  const thenableReturnIndices = new Set();\n  const voidReturnIndices = new Set();\n  const type = checker.getTypeAtLocation(node.expression);\n  // We can't use checker.getResolvedSignature because it prefers an early '() => void' over a later '() => Promise<void>'\n  // See https://github.com/microsoft/TypeScript/issues/48077\n  for (const subType of tsutils.unionTypeParts(type)) {\n    // Standard function calls and `new` have two different types of signatures\n    const signatures = ts.isCallExpression(node) ? subType.getCallSignatures() : subType.getConstructSignatures();\n    for (const signature of signatures) {\n      for (const [index, parameter] of signature.parameters.entries()) {\n        const decl = parameter.valueDeclaration;\n        let type = checker.getTypeOfSymbolAtLocation(parameter, node.expression);\n        // If this is a array 'rest' parameter, check all of the argument indices\n        // from the current argument to the end.\n        // Note - we currently do not support 'spread' arguments - adding support for them\n        // is tracked in https://github.com/typescript-eslint/typescript-eslint/issues/5744\n        if (decl && ts.isParameter(decl) && decl.dotDotDotToken) {\n          if (checker.isArrayType(type)) {\n            // Unwrap 'Array<MaybeVoidFunction>' to 'MaybeVoidFunction',\n            // so that we'll handle it in the same way as a non-rest\n            // 'param: MaybeVoidFunction'\n            type = util.getTypeArguments(type, checker)[0];\n            for (let i = index; i < node.arguments.length; i++) {\n              checkThenableOrVoidArgument(checker, node, type, i, thenableReturnIndices, voidReturnIndices);\n            }\n          } else if (checker.isTupleType(type)) {\n            // Check each type in the tuple - for example, [boolean, () => void] would\n            // add the index of the second tuple parameter to 'voidReturnIndices'\n            const typeArgs = util.getTypeArguments(type, checker);\n            for (let i = index; i < node.arguments.length && i - index < typeArgs.length; i++) {\n              checkThenableOrVoidArgument(checker, node, typeArgs[i - index], i, thenableReturnIndices, voidReturnIndices);\n            }\n          }\n        } else {\n          checkThenableOrVoidArgument(checker, node, type, index, thenableReturnIndices, voidReturnIndices);\n        }\n      }\n    }\n  }\n  for (const index of thenableReturnIndices) {\n    voidReturnIndices.delete(index);\n  }\n  return voidReturnIndices;\n}\n/**\n * @returns Whether any call signature of the type has a thenable return type.\n */\nfunction anySignatureIsThenableType(checker, node, type) {\n  for (const signature of type.getCallSignatures()) {\n    const returnType = signature.getReturnType();\n    if (tsutils.isThenableType(checker, node, returnType)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * @returns Whether type is a thenable-returning function.\n */\nfunction isThenableReturningFunctionType(checker, node, type) {\n  for (const subType of tsutils.unionTypeParts(type)) {\n    if (anySignatureIsThenableType(checker, node, subType)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * @returns Whether type is a void-returning function.\n */\nfunction isVoidReturningFunctionType(checker, node, type) {\n  let hadVoidReturn = false;\n  for (const subType of tsutils.unionTypeParts(type)) {\n    for (const signature of subType.getCallSignatures()) {\n      const returnType = signature.getReturnType();\n      // If a certain positional argument accepts both thenable and void returns,\n      // a promise-returning function is valid\n      if (tsutils.isThenableType(checker, node, returnType)) {\n        return false;\n      }\n      hadVoidReturn || (hadVoidReturn = tsutils.isTypeFlagSet(returnType, ts.TypeFlags.Void));\n    }\n  }\n  return hadVoidReturn;\n}\n/**\n * @returns Whether expression is a function that returns a thenable.\n */\nfunction returnsThenable(checker, node) {\n  const type = checker.getApparentType(checker.getTypeAtLocation(node));\n  if (anySignatureIsThenableType(checker, node, type)) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","parseChecksVoidReturn","checksVoidReturn","undefined","arguments","attributes","properties","returns","variables","_a","_b","_c","_d","_e","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","voidReturnArgument","voidReturnVariable","voidReturnProperty","voidReturnReturnValue","voidReturnAttribute","conditional","spread","schema","type","checksConditionals","oneOf","additionalProperties","checksSpreads","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","checkedNodes","Set","conditionalChecks","ConditionalExpression","checkTestConditional","DoWhileStatement","ForStatement","IfStatement","LogicalExpression","checkConditional","UnaryExpression[operator=\"!\"]","node","argument","WhileStatement","voidReturnChecks","Object","assign","CallExpression","checkArguments","NewExpression","JSXAttribute","checkJSXAttribute","Property","checkProperty","ReturnStatement","checkReturnStatement","AssignmentExpression","checkAssignment","VariableDeclarator","checkVariableDeclaration","spreadChecks","SpreadElement","checkSpread","test","isTestExpr","has","add","AST_NODE_TYPES","operator","left","right","tsNode","esTreeNodeToTSNodeMap","get","isAlwaysThenable","report","messageId","voidArgs","voidFunctionArguments","size","index","entries","returnsThenable","varType","getTypeAtLocation","isVoidReturningFunctionType","initializer","init","isPropertyAssignment","contextualType","getContextualType","value","isShorthandPropertyAssignment","isMethodDeclaration","isComputedPropertyName","obj","parent","isObjectLiteralExpression","objType","propertySymbol","getPropertyOfType","text","getTypeOfSymbolAtLocation","expression","JSXExpressionContainer","expressionContainer","isSometimesThenable","subType","unionTypeParts","getApparentType","isThenableType","thenProp","getProperty","thenType","hasThenableSignature","signature","getCallSignatures","parameters","length","isFunctionParam","param","checkThenableOrVoidArgument","thenableReturnIndices","voidReturnIndices","isThenableReturningFunctionType","signatures","isCallExpression","getConstructSignatures","parameter","decl","valueDeclaration","isParameter","dotDotDotToken","isArrayType","getTypeArguments","i","isTupleType","typeArgs","delete","anySignatureIsThenableType","returnType","getReturnType","hadVoidReturn","isTypeFlagSet","TypeFlags","Void"],"sources":["../../src/rules/no-misused-promises.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}