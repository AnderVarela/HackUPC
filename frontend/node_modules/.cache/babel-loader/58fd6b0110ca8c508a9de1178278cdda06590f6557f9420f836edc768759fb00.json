{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-unnecessary-qualifier',\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary namespace qualifiers',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryQualifier: \"Qualifier is unnecessary since '{{ name }}' is in scope.\"\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n  create(context) {\n    const namespacesInScope = [];\n    let currentFailedNamespaceExpression = null;\n    const parserServices = util.getParserServices(context);\n    const esTreeNodeToTSNodeMap = parserServices.esTreeNodeToTSNodeMap;\n    const program = parserServices.program;\n    const checker = program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    function tryGetAliasedSymbol(symbol, checker) {\n      return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : null;\n    }\n    function symbolIsNamespaceInScope(symbol) {\n      var _a;\n      const symbolDeclarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n      if (symbolDeclarations.some(decl => namespacesInScope.some(ns => ns === decl))) {\n        return true;\n      }\n      const alias = tryGetAliasedSymbol(symbol, checker);\n      return alias != null && symbolIsNamespaceInScope(alias);\n    }\n    function getSymbolInScope(node, flags, name) {\n      // TODO:PERF `getSymbolsInScope` gets a long list. Is there a better way?\n      const scope = checker.getSymbolsInScope(node, flags);\n      return scope.find(scopeSymbol => scopeSymbol.name === name);\n    }\n    function symbolsAreEqual(accessed, inScope) {\n      return accessed === checker.getExportSymbolOfSymbol(inScope);\n    }\n    function qualifierIsUnnecessary(qualifier, name) {\n      const tsQualifier = esTreeNodeToTSNodeMap.get(qualifier);\n      const tsName = esTreeNodeToTSNodeMap.get(name);\n      const namespaceSymbol = checker.getSymbolAtLocation(tsQualifier);\n      if (namespaceSymbol === undefined || !symbolIsNamespaceInScope(namespaceSymbol)) {\n        return false;\n      }\n      const accessedSymbol = checker.getSymbolAtLocation(tsName);\n      if (accessedSymbol === undefined) {\n        return false;\n      }\n      // If the symbol in scope is different, the qualifier is necessary.\n      const fromScope = getSymbolInScope(tsQualifier, accessedSymbol.flags, sourceCode.getText(name));\n      return fromScope === undefined || symbolsAreEqual(accessedSymbol, fromScope);\n    }\n    function visitNamespaceAccess(node, qualifier, name) {\n      // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.\n      if (!currentFailedNamespaceExpression && qualifierIsUnnecessary(qualifier, name)) {\n        currentFailedNamespaceExpression = node;\n        context.report({\n          node: qualifier,\n          messageId: 'unnecessaryQualifier',\n          data: {\n            name: sourceCode.getText(name)\n          },\n          fix(fixer) {\n            return fixer.removeRange([qualifier.range[0], name.range[0]]);\n          }\n        });\n      }\n    }\n    function enterDeclaration(node) {\n      namespacesInScope.push(esTreeNodeToTSNodeMap.get(node));\n    }\n    function exitDeclaration() {\n      namespacesInScope.pop();\n    }\n    function resetCurrentNamespaceExpression(node) {\n      if (node === currentFailedNamespaceExpression) {\n        currentFailedNamespaceExpression = null;\n      }\n    }\n    function isPropertyAccessExpression(node) {\n      return node.type === utils_1.AST_NODE_TYPES.MemberExpression && !node.computed;\n    }\n    function isEntityNameExpression(node) {\n      return node.type === utils_1.AST_NODE_TYPES.Identifier || isPropertyAccessExpression(node) && isEntityNameExpression(node.object);\n    }\n    return {\n      TSModuleDeclaration: enterDeclaration,\n      TSEnumDeclaration: enterDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSModuleDeclaration\"]': enterDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSEnumDeclaration\"]': enterDeclaration,\n      'TSModuleDeclaration:exit': exitDeclaration,\n      'TSEnumDeclaration:exit': exitDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSModuleDeclaration\"]:exit': exitDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSEnumDeclaration\"]:exit': exitDeclaration,\n      TSQualifiedName(node) {\n        visitNamespaceAccess(node, node.left, node.right);\n      },\n      'MemberExpression[computed=false]': function (node) {\n        const property = node.property;\n        if (isEntityNameExpression(node.object)) {\n          visitNamespaceAccess(node, node.object, property);\n        }\n      },\n      'TSQualifiedName:exit': resetCurrentNamespaceExpression,\n      'MemberExpression:exit': resetCurrentNamespaceExpression\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryQualifier","schema","type","defaultOptions","create","context","namespacesInScope","currentFailedNamespaceExpression","parserServices","getParserServices","esTreeNodeToTSNodeMap","program","checker","getTypeChecker","sourceCode","getSourceCode","tryGetAliasedSymbol","symbol","isSymbolFlagSet","SymbolFlags","Alias","getAliasedSymbol","symbolIsNamespaceInScope","symbolDeclarations","_a","getDeclarations","some","decl","ns","alias","getSymbolInScope","node","flags","scope","getSymbolsInScope","find","scopeSymbol","symbolsAreEqual","accessed","inScope","getExportSymbolOfSymbol","qualifierIsUnnecessary","qualifier","tsQualifier","get","tsName","namespaceSymbol","getSymbolAtLocation","undefined","accessedSymbol","fromScope","getText","visitNamespaceAccess","report","messageId","data","fix","fixer","removeRange","range","enterDeclaration","push","exitDeclaration","pop","resetCurrentNamespaceExpression","isPropertyAccessExpression","AST_NODE_TYPES","MemberExpression","computed","isEntityNameExpression","Identifier","object","TSModuleDeclaration","TSEnumDeclaration","TSQualifiedName","left","right","MemberExpression[computed=false]","property"],"sources":["../../src/rules/no-unnecessary-qualifier.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}