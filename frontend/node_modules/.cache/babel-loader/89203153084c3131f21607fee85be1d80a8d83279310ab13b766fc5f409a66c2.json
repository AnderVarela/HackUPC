{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-inferrable-types',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow explicit type declarations for variables or parameters initialized to a number, string, or boolean',\n      recommended: 'error'\n    },\n    fixable: 'code',\n    messages: {\n      noInferrableType: 'Type {{type}} trivially inferred from a {{type}} literal, remove type annotation.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreParameters: {\n          type: 'boolean'\n        },\n        ignoreProperties: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    ignoreParameters: false,\n    ignoreProperties: false\n  }],\n  create(context, [{\n    ignoreParameters,\n    ignoreProperties\n  }]) {\n    const sourceCode = context.getSourceCode();\n    function isFunctionCall(init, callName) {\n      if (init.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        return isFunctionCall(init.expression, callName);\n      }\n      return init.type === utils_1.AST_NODE_TYPES.CallExpression && init.callee.type === utils_1.AST_NODE_TYPES.Identifier && init.callee.name === callName;\n    }\n    function isLiteral(init, typeName) {\n      return init.type === utils_1.AST_NODE_TYPES.Literal && typeof init.value === typeName;\n    }\n    function isIdentifier(init, ...names) {\n      return init.type === utils_1.AST_NODE_TYPES.Identifier && names.includes(init.name);\n    }\n    function hasUnaryPrefix(init, ...operators) {\n      return init.type === utils_1.AST_NODE_TYPES.UnaryExpression && operators.includes(init.operator);\n    }\n    const keywordMap = {\n      [utils_1.AST_NODE_TYPES.TSBigIntKeyword]: 'bigint',\n      [utils_1.AST_NODE_TYPES.TSBooleanKeyword]: 'boolean',\n      [utils_1.AST_NODE_TYPES.TSNumberKeyword]: 'number',\n      [utils_1.AST_NODE_TYPES.TSNullKeyword]: 'null',\n      [utils_1.AST_NODE_TYPES.TSStringKeyword]: 'string',\n      [utils_1.AST_NODE_TYPES.TSSymbolKeyword]: 'symbol',\n      [utils_1.AST_NODE_TYPES.TSUndefinedKeyword]: 'undefined'\n    };\n    /**\n     * Returns whether a node has an inferrable value or not\n     */\n    function isInferrable(annotation, init) {\n      switch (annotation.type) {\n        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:\n          {\n            // note that bigint cannot have + prefixed to it\n            const unwrappedInit = hasUnaryPrefix(init, '-') ? init.argument : init;\n            return isFunctionCall(unwrappedInit, 'BigInt') || unwrappedInit.type === utils_1.AST_NODE_TYPES.Literal && 'bigint' in unwrappedInit;\n          }\n        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n          return hasUnaryPrefix(init, '!') || isFunctionCall(init, 'Boolean') || isLiteral(init, 'boolean');\n        case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n          {\n            const unwrappedInit = hasUnaryPrefix(init, '+', '-') ? init.argument : init;\n            return isIdentifier(unwrappedInit, 'Infinity', 'NaN') || isFunctionCall(unwrappedInit, 'Number') || isLiteral(unwrappedInit, 'number');\n          }\n        case utils_1.AST_NODE_TYPES.TSNullKeyword:\n          return init.type === utils_1.AST_NODE_TYPES.Literal && init.value == null;\n        case utils_1.AST_NODE_TYPES.TSStringKeyword:\n          return isFunctionCall(init, 'String') || isLiteral(init, 'string') || init.type === utils_1.AST_NODE_TYPES.TemplateLiteral;\n        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:\n          return isFunctionCall(init, 'Symbol');\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n          {\n            if (annotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier && annotation.typeName.name === 'RegExp') {\n              const isRegExpLiteral = init.type === utils_1.AST_NODE_TYPES.Literal && init.value instanceof RegExp;\n              const isRegExpNewCall = init.type === utils_1.AST_NODE_TYPES.NewExpression && init.callee.type === utils_1.AST_NODE_TYPES.Identifier && init.callee.name === 'RegExp';\n              const isRegExpCall = isFunctionCall(init, 'RegExp');\n              return isRegExpLiteral || isRegExpCall || isRegExpNewCall;\n            }\n            return false;\n          }\n        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:\n          return hasUnaryPrefix(init, 'void') || isIdentifier(init, 'undefined');\n      }\n      return false;\n    }\n    /**\n     * Reports an inferrable type declaration, if any\n     */\n    function reportInferrableType(node, typeNode, initNode) {\n      if (!typeNode || !initNode || !typeNode.typeAnnotation) {\n        return;\n      }\n      if (!isInferrable(typeNode.typeAnnotation, initNode)) {\n        return;\n      }\n      const type = typeNode.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference ?\n      // TODO - if we add more references\n      'RegExp' : keywordMap[typeNode.typeAnnotation.type];\n      context.report({\n        node,\n        messageId: 'noInferrableType',\n        data: {\n          type\n        },\n        *fix(fixer) {\n          if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern && node.left.optional || node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && node.definite) {\n            yield fixer.remove(sourceCode.getTokenBefore(typeNode));\n          }\n          yield fixer.remove(typeNode);\n        }\n      });\n    }\n    function inferrableVariableVisitor(node) {\n      if (!node.id) {\n        return;\n      }\n      reportInferrableType(node, node.id.typeAnnotation, node.init);\n    }\n    function inferrableParameterVisitor(node) {\n      if (ignoreParameters || !node.params) {\n        return;\n      }\n      node.params.filter(param => param.type === utils_1.AST_NODE_TYPES.AssignmentPattern && param.left && param.right).forEach(param => {\n        reportInferrableType(param, param.left.typeAnnotation, param.right);\n      });\n    }\n    function inferrablePropertyVisitor(node) {\n      // We ignore `readonly` because of Microsoft/TypeScript#14416\n      // Essentially a readonly property without a type\n      // will result in its value being the type, leading to\n      // compile errors if the type is stripped.\n      if (ignoreProperties || node.readonly || node.optional) {\n        return;\n      }\n      reportInferrableType(node, node.typeAnnotation, node.value);\n    }\n    return {\n      VariableDeclarator: inferrableVariableVisitor,\n      FunctionExpression: inferrableParameterVisitor,\n      FunctionDeclaration: inferrableParameterVisitor,\n      ArrowFunctionExpression: inferrableParameterVisitor,\n      PropertyDefinition: inferrablePropertyVisitor\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","fixable","messages","noInferrableType","schema","properties","ignoreParameters","ignoreProperties","additionalProperties","defaultOptions","create","context","sourceCode","getSourceCode","isFunctionCall","init","callName","AST_NODE_TYPES","ChainExpression","expression","CallExpression","callee","Identifier","isLiteral","typeName","Literal","value","isIdentifier","names","includes","hasUnaryPrefix","operators","UnaryExpression","operator","keywordMap","TSBigIntKeyword","TSBooleanKeyword","TSNumberKeyword","TSNullKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","isInferrable","annotation","unwrappedInit","argument","TemplateLiteral","TSTypeReference","isRegExpLiteral","RegExp","isRegExpNewCall","NewExpression","isRegExpCall","reportInferrableType","node","typeNode","initNode","typeAnnotation","report","messageId","data","fix","fixer","AssignmentPattern","left","optional","PropertyDefinition","definite","remove","getTokenBefore","inferrableVariableVisitor","id","inferrableParameterVisitor","params","filter","param","right","forEach","inferrablePropertyVisitor","readonly","VariableDeclarator","FunctionExpression","FunctionDeclaration","ArrowFunctionExpression"],"sources":["../../src/rules/no-inferrable-types.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}