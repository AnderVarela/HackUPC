{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'func-call-spacing',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require or disallow spacing between function identifiers and their invocations',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'whitespace',\n    schema: {\n      anyOf: [{\n        type: 'array',\n        items: [{\n          enum: ['never']\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: 'array',\n        items: [{\n          enum: ['always']\n        }, {\n          type: 'object',\n          properties: {\n            allowNewlines: {\n              type: 'boolean'\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpectedWhitespace: 'Unexpected whitespace between function name and paren.',\n      unexpectedNewline: 'Unexpected newline between function name and paren.',\n      missing: 'Missing space between function name and paren.'\n    }\n  },\n  defaultOptions: ['never', {}],\n  create(context, [option, config]) {\n    const sourceCode = context.getSourceCode();\n    const text = sourceCode.getText();\n    /**\n     * Check if open space is present in a function name\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkSpacing(node) {\n      var _a;\n      const isOptionalCall = util.isOptionalCallExpression(node);\n      const closingParenToken = sourceCode.getLastToken(node);\n      const lastCalleeTokenWithoutPossibleParens = sourceCode.getLastToken((_a = node.typeParameters) !== null && _a !== void 0 ? _a : node.callee);\n      const openingParenToken = sourceCode.getFirstTokenBetween(lastCalleeTokenWithoutPossibleParens, closingParenToken, util.isOpeningParenToken);\n      if (!openingParenToken || openingParenToken.range[1] >= node.range[1]) {\n        // new expression with no parens...\n        return;\n      }\n      const lastCalleeToken = sourceCode.getTokenBefore(openingParenToken, util.isNotOptionalChainPunctuator);\n      const textBetweenTokens = text.slice(lastCalleeToken.range[1], openingParenToken.range[0]).replace(/\\/\\*.*?\\*\\//gu, '');\n      const hasWhitespace = /\\s/u.test(textBetweenTokens);\n      const hasNewline = hasWhitespace && util.LINEBREAK_MATCHER.test(textBetweenTokens);\n      if (option === 'never') {\n        if (hasWhitespace) {\n          return context.report({\n            node,\n            loc: lastCalleeToken.loc.start,\n            messageId: 'unexpectedWhitespace',\n            fix(fixer) {\n              /*\n               * Only autofix if there is no newline\n               * https://github.com/eslint/eslint/issues/7787\n               */\n              if (!hasNewline &&\n              // don't fix optional calls\n              !isOptionalCall) {\n                return fixer.removeRange([lastCalleeToken.range[1], openingParenToken.range[0]]);\n              }\n              return null;\n            }\n          });\n        }\n      } else if (isOptionalCall) {\n        // disallow:\n        // foo?. ();\n        // foo ?.();\n        // foo ?. ();\n        if (hasWhitespace || hasNewline) {\n          context.report({\n            node,\n            loc: lastCalleeToken.loc.start,\n            messageId: 'unexpectedWhitespace'\n          });\n        }\n      } else {\n        if (!hasWhitespace) {\n          context.report({\n            node,\n            loc: lastCalleeToken.loc.start,\n            messageId: 'missing',\n            fix(fixer) {\n              return fixer.insertTextBefore(openingParenToken, ' ');\n            }\n          });\n        } else if (!config.allowNewlines && hasNewline) {\n          context.report({\n            node,\n            loc: lastCalleeToken.loc.start,\n            messageId: 'unexpectedNewline',\n            fix(fixer) {\n              return fixer.replaceTextRange([lastCalleeToken.range[1], openingParenToken.range[0]], ' ');\n            }\n          });\n        }\n      }\n    }\n    return {\n      CallExpression: checkSpacing,\n      NewExpression: checkSpacing\n    };\n  }\n});","map":{"version":3,"names":["util","__importStar","require","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","schema","anyOf","items","enum","minItems","maxItems","properties","allowNewlines","additionalProperties","messages","unexpectedWhitespace","unexpectedNewline","missing","defaultOptions","create","context","option","config","sourceCode","getSourceCode","text","getText","checkSpacing","node","isOptionalCall","isOptionalCallExpression","closingParenToken","getLastToken","lastCalleeTokenWithoutPossibleParens","_a","typeParameters","callee","openingParenToken","getFirstTokenBetween","isOpeningParenToken","range","lastCalleeToken","getTokenBefore","isNotOptionalChainPunctuator","textBetweenTokens","slice","replace","hasWhitespace","test","hasNewline","LINEBREAK_MATCHER","report","loc","start","messageId","fix","fixer","removeRange","insertTextBefore","replaceTextRange","CallExpression","NewExpression"],"sources":["../../src/rules/func-call-spacing.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}