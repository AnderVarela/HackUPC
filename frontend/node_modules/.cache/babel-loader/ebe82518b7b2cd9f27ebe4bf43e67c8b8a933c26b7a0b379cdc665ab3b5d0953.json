{"ast":null,"code":"\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === 'left') {\n      return exclusive ? '>' : '>=';\n    }\n    return exclusive ? '<' : '<=';\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator('right', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator('left', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = 'should be';\n    result += ` ${Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? 'and' : 'or';\n    result += ` ${Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ? /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax : /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n    if (j > -1) {\n      return values[j];\n    }\n    return [Infinity, true];\n  }\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return '';\n    }\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? '' : '!'}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n}\nmodule.exports = Range;","map":{"version":3,"names":["Range","getOperator","side","exclusive","formatRight","value","logic","formatLeft","formatRange","start","end","startExclusive","endExclusive","result","getRangeValue","values","minMax","Infinity","j","predicate","i","length","constructor","_left","_right","left","push","right","format","leftExclusive","rightExclusive","Number","isFinite","realStart","realEnd","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-loader/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === 'left') {\n      return exclusive ? '>' : '>=';\n    }\n\n    return exclusive ? '<' : '<=';\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('right', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('left', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = 'should be';\n    result += ` ${Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? 'and' : 'or';\n    result += ` ${Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return '';\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? '' : '!'}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}