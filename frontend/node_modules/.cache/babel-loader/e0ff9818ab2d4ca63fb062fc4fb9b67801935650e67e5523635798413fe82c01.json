{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-invalid-void-type',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow `void` type outside of generic or return types',\n      recommended: 'strict'\n    },\n    messages: {\n      invalidVoidForGeneric: '{{ generic }} may not have void as a type argument.',\n      invalidVoidNotReturnOrGeneric: 'void is only valid as a return type or generic type argument.',\n      invalidVoidNotReturn: 'void is only valid as a return type.',\n      invalidVoidNotReturnOrThisParam: 'void is only valid as return type or type of `this` parameter.',\n      invalidVoidNotReturnOrThisParamOrGeneric: 'void is only valid as a return type or generic type argument or the type of a `this` parameter.',\n      invalidVoidUnionConstituent: 'void is not valid as a constituent in a union type'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowInGenericTypeArguments: {\n          oneOf: [{\n            type: 'boolean'\n          }, {\n            type: 'array',\n            items: {\n              type: 'string'\n            },\n            minLength: 1\n          }]\n        },\n        allowAsThisParameter: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowInGenericTypeArguments: true,\n    allowAsThisParameter: false\n  }],\n  create(context, [{\n    allowInGenericTypeArguments,\n    allowAsThisParameter\n  }]) {\n    const validParents = [utils_1.AST_NODE_TYPES.TSTypeAnnotation //\n    ];\n    const invalidGrandParents = [utils_1.AST_NODE_TYPES.TSPropertySignature, utils_1.AST_NODE_TYPES.CallExpression, utils_1.AST_NODE_TYPES.PropertyDefinition, utils_1.AST_NODE_TYPES.Identifier];\n    const validUnionMembers = [utils_1.AST_NODE_TYPES.TSVoidKeyword, utils_1.AST_NODE_TYPES.TSNeverKeyword];\n    if (allowInGenericTypeArguments === true) {\n      validParents.push(utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation);\n    }\n    /**\n     * @brief check if the given void keyword is used as a valid generic type\n     *\n     * reports if the type parametrized by void is not in the whitelist, or\n     * allowInGenericTypeArguments is false.\n     * no-op if the given void keyword is not used as generic type\n     */\n    function checkGenericTypeArgument(node) {\n      var _a, _b;\n      // only matches T<..., void, ...>\n      // extra check for precaution\n      /* istanbul ignore next */\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation || ((_b = node.parent.parent) === null || _b === void 0 ? void 0 : _b.type) !== utils_1.AST_NODE_TYPES.TSTypeReference) {\n        return;\n      }\n      // check whitelist\n      if (Array.isArray(allowInGenericTypeArguments)) {\n        const sourceCode = context.getSourceCode();\n        const fullyQualifiedName = sourceCode.getText(node.parent.parent.typeName).replace(/ /gu, '');\n        if (!allowInGenericTypeArguments.map(s => s.replace(/ /gu, '')).includes(fullyQualifiedName)) {\n          context.report({\n            messageId: 'invalidVoidForGeneric',\n            data: {\n              generic: fullyQualifiedName\n            },\n            node\n          });\n        }\n        return;\n      }\n      if (!allowInGenericTypeArguments) {\n        context.report({\n          messageId: allowAsThisParameter ? 'invalidVoidNotReturnOrThisParam' : 'invalidVoidNotReturn',\n          node\n        });\n      }\n    }\n    /**\n     * @brief checks if the generic type parameter defaults to void\n     */\n    function checkDefaultVoid(node, parentNode) {\n      if (parentNode.default !== node) {\n        context.report({\n          messageId: getNotReturnOrGenericMessageId(node),\n          node\n        });\n      }\n    }\n    /**\n     * @brief checks that a union containing void is valid\n     * @return true if every member of the union is specified as a valid type in\n     * validUnionMembers, or is a valid generic type parametrized by void\n     */\n    function isValidUnionType(node) {\n      return node.types.every(member => {\n        var _a, _b;\n        return validUnionMembers.includes(member.type) ||\n        // allows any T<..., void, ...> here, checked by checkGenericTypeArgument\n        member.type === utils_1.AST_NODE_TYPES.TSTypeReference && ((_a = member.typeParameters) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation && ((_b = member.typeParameters) === null || _b === void 0 ? void 0 : _b.params.map(param => param.type).includes(utils_1.AST_NODE_TYPES.TSVoidKeyword));\n      });\n    }\n    return {\n      TSVoidKeyword(node) {\n        var _a, _b;\n        /* istanbul ignore next */\n        if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) {\n          return;\n        }\n        // checks T<..., void, ...> against specification of allowInGenericArguments option\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation && node.parent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n          checkGenericTypeArgument(node);\n          return;\n        }\n        // allow <T = void> if allowInGenericTypeArguments is specified, and report if the generic type parameter extends void\n        if (allowInGenericTypeArguments && node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameter && ((_b = node.parent.default) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSVoidKeyword) {\n          checkDefaultVoid(node, node.parent);\n          return;\n        }\n        // union w/ void must contain types from validUnionMembers, or a valid generic void type\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType && isValidUnionType(node.parent)) {\n          return;\n        }\n        // this parameter is ok to be void.\n        if (allowAsThisParameter && node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation && node.parent.parent.type === utils_1.AST_NODE_TYPES.Identifier && node.parent.parent.name === 'this') {\n          return;\n        }\n        // default cases\n        if (validParents.includes(node.parent.type) && !invalidGrandParents.includes(node.parent.parent.type)) {\n          return;\n        }\n        context.report({\n          messageId: allowInGenericTypeArguments && allowAsThisParameter ? 'invalidVoidNotReturnOrThisParamOrGeneric' : allowInGenericTypeArguments ? getNotReturnOrGenericMessageId(node) : allowAsThisParameter ? 'invalidVoidNotReturnOrThisParam' : 'invalidVoidNotReturn',\n          node\n        });\n      }\n    };\n  }\n});\nfunction getNotReturnOrGenericMessageId(node) {\n  return node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType ? 'invalidVoidUnionConstituent' : 'invalidVoidNotReturnOrGeneric';\n}","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","messages","invalidVoidForGeneric","invalidVoidNotReturnOrGeneric","invalidVoidNotReturn","invalidVoidNotReturnOrThisParam","invalidVoidNotReturnOrThisParamOrGeneric","invalidVoidUnionConstituent","schema","properties","allowInGenericTypeArguments","oneOf","items","minLength","allowAsThisParameter","additionalProperties","defaultOptions","create","context","validParents","AST_NODE_TYPES","TSTypeAnnotation","invalidGrandParents","TSPropertySignature","CallExpression","PropertyDefinition","Identifier","validUnionMembers","TSVoidKeyword","TSNeverKeyword","push","TSTypeParameterInstantiation","checkGenericTypeArgument","node","_a","parent","_b","TSTypeReference","Array","isArray","sourceCode","getSourceCode","fullyQualifiedName","getText","typeName","replace","map","s","includes","report","messageId","data","generic","checkDefaultVoid","parentNode","getNotReturnOrGenericMessageId","isValidUnionType","types","every","member","typeParameters","params","param","TSTypeParameter","TSUnionType"],"sources":["../../src/rules/no-invalid-void-type.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}