{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n  name: 'switch-exhaustiveness-check',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Require switch-case statements to be exhaustive with union type',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      switchIsNotExhaustive: 'Switch is not exhaustive. Cases not matched: {{missingBranches}}',\n      addMissingCases: 'Add branches for missing cases.'\n    }\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const service = (0, util_1.getParserServices)(context);\n    const checker = service.program.getTypeChecker();\n    const compilerOptions = service.program.getCompilerOptions();\n    function getNodeType(node) {\n      const tsNode = service.esTreeNodeToTSNodeMap.get(node);\n      return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);\n    }\n    function fixSwitch(fixer, node, missingBranchTypes, symbolName) {\n      var _a;\n      const lastCase = node.cases.length > 0 ? node.cases[node.cases.length - 1] : null;\n      const caseIndent = lastCase ? ' '.repeat(lastCase.loc.start.column) :\n      // if there are no cases, use indentation of the switch statement\n      // and leave it to user to format it correctly\n      ' '.repeat(node.loc.start.column);\n      const missingCases = [];\n      for (const missingBranchType of missingBranchTypes) {\n        // While running this rule on checker.ts of TypeScript project\n        // the fix introduced a compiler error due to:\n        //\n        // type __String = (string & {\n        //         __escapedIdentifier: void;\n        //     }) | (void & {\n        //         __escapedIdentifier: void;\n        //     }) | InternalSymbolName;\n        //\n        // The following check fixes it.\n        if (missingBranchType.isIntersection()) {\n          continue;\n        }\n        const missingBranchName = (_a = missingBranchType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName;\n        let caseTest = checker.typeToString(missingBranchType);\n        if (symbolName && (missingBranchName || missingBranchName === '') && (0, util_1.requiresQuoting)(missingBranchName.toString(), compilerOptions.target)) {\n          caseTest = `${symbolName}['${missingBranchName}']`;\n        }\n        const errorMessage = `Not implemented yet: ${caseTest} case`;\n        missingCases.push(`case ${caseTest}: { throw new Error('${errorMessage}') }`);\n      }\n      const fixString = missingCases.map(code => `${caseIndent}${code}`).join('\\n');\n      if (lastCase) {\n        return fixer.insertTextAfter(lastCase, `\\n${fixString}`);\n      }\n      // there were no existing cases\n      const openingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isOpeningBraceToken);\n      const closingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isClosingBraceToken);\n      return fixer.replaceTextRange([openingBrace.range[0], closingBrace.range[1]], ['{', fixString, `${caseIndent}}`].join('\\n'));\n    }\n    function checkSwitchExhaustive(node) {\n      var _a;\n      const discriminantType = getNodeType(node.discriminant);\n      const symbolName = (_a = discriminantType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName;\n      if (discriminantType.isUnion()) {\n        const unionTypes = (0, tsutils_1.unionTypeParts)(discriminantType);\n        const caseTypes = new Set();\n        for (const switchCase of node.cases) {\n          if (switchCase.test == null) {\n            // Switch has 'default' branch - do nothing.\n            return;\n          }\n          caseTypes.add(getNodeType(switchCase.test));\n        }\n        const missingBranchTypes = unionTypes.filter(unionType => !caseTypes.has(unionType));\n        if (missingBranchTypes.length === 0) {\n          // All cases matched - do nothing.\n          return;\n        }\n        context.report({\n          node: node.discriminant,\n          messageId: 'switchIsNotExhaustive',\n          data: {\n            missingBranches: missingBranchTypes.map(missingType => {\n              var _a;\n              return (0, tsutils_1.isTypeFlagSet)(missingType, ts.TypeFlags.ESSymbolLike) ? `typeof ${(_a = missingType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName}` : checker.typeToString(missingType);\n            }).join(' | ')\n          },\n          suggest: [{\n            messageId: 'addMissingCases',\n            fix(fixer) {\n              return fixSwitch(fixer, node, missingBranchTypes, symbolName === null || symbolName === void 0 ? void 0 : symbolName.toString());\n            }\n          }]\n        });\n      }\n    }\n    return {\n      SwitchStatement: checkSwitchExhaustive\n    };\n  }\n});","map":{"version":3,"names":["tsutils_1","require","ts","__importStar","util_1","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","hasSuggestions","schema","messages","switchIsNotExhaustive","addMissingCases","defaultOptions","create","context","sourceCode","getSourceCode","service","getParserServices","checker","program","getTypeChecker","compilerOptions","getCompilerOptions","getNodeType","node","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","fixSwitch","fixer","missingBranchTypes","symbolName","lastCase","cases","length","caseIndent","repeat","loc","start","column","missingCases","missingBranchType","isIntersection","missingBranchName","_a","getSymbol","escapedName","caseTest","typeToString","requiresQuoting","toString","target","errorMessage","push","fixString","map","code","join","insertTextAfter","openingBrace","getTokenAfter","discriminant","isOpeningBraceToken","closingBrace","isClosingBraceToken","replaceTextRange","range","checkSwitchExhaustive","discriminantType","isUnion","unionTypes","unionTypeParts","caseTypes","Set","switchCase","test","add","filter","unionType","has","report","messageId","data","missingBranches","missingType","isTypeFlagSet","TypeFlags","ESSymbolLike","suggest","fix","SwitchStatement"],"sources":["../../src/rules/switch-exhaustiveness-check.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}