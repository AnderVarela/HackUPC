{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phrases = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.phrases = {\n  [utils_1.AST_NODE_TYPES.TSTypeLiteral]: 'Type literal',\n  [utils_1.AST_NODE_TYPES.TSInterfaceDeclaration]: 'Interface'\n};\nexports.default = util.createRule({\n  name: 'prefer-function-type',\n  meta: {\n    docs: {\n      description: 'Enforce using function types instead of interfaces with call signatures',\n      recommended: 'strict'\n    },\n    fixable: 'code',\n    messages: {\n      functionTypeOverCallableType: '{{ literalOrInterface }} only has a call signature, you should use a function type instead.',\n      unexpectedThisOnFunctionOnlyInterface: \"`this` refers to the function type '{{ interfaceName }}', did you intend to use a generic `this` parameter like `<Self>(this: Self, ...) => Self` instead?\"\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks if there the interface has exactly one supertype that isn't named 'Function'\n     * @param node The node being checked\n     */\n    function hasOneSupertype(node) {\n      if (!node.extends || node.extends.length === 0) {\n        return false;\n      }\n      if (node.extends.length !== 1) {\n        return true;\n      }\n      const expr = node.extends[0].expression;\n      return expr.type !== utils_1.AST_NODE_TYPES.Identifier || expr.name !== 'Function';\n    }\n    /**\n     * @param parent The parent of the call signature causing the diagnostic\n     */\n    function shouldWrapSuggestion(parent) {\n      if (!parent) {\n        return false;\n      }\n      switch (parent.type) {\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n        case utils_1.AST_NODE_TYPES.TSArrayType:\n          return true;\n        default:\n          return false;\n      }\n    }\n    /**\n     * @param member The TypeElement being checked\n     * @param node The parent of member being checked\n     * @param tsThisTypes\n     */\n    function checkMember(member, node, tsThisTypes = null) {\n      if ((member.type === utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration || member.type === utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration) && member.returnType !== undefined) {\n        if ((tsThisTypes === null || tsThisTypes === void 0 ? void 0 : tsThisTypes.length) && node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n          // the message can be confusing if we don't point directly to the `this` node instead of the whole member\n          // and in favour of generating at most one error we'll only report the first occurrence of `this` if there are multiple\n          context.report({\n            node: tsThisTypes[0],\n            messageId: 'unexpectedThisOnFunctionOnlyInterface',\n            data: {\n              interfaceName: node.id.name\n            }\n          });\n          return;\n        }\n        const fixable = node.parent && node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration;\n        const fix = fixable ? null : fixer => {\n          const fixes = [];\n          const start = member.range[0];\n          const colonPos = member.returnType.range[0] - start;\n          const text = sourceCode.getText().slice(start, member.range[1]);\n          const comments = sourceCode.getCommentsBefore(member).concat(sourceCode.getCommentsAfter(member));\n          let suggestion = `${text.slice(0, colonPos)} =>${text.slice(colonPos + 1)}`;\n          const lastChar = suggestion.endsWith(';') ? ';' : '';\n          if (lastChar) {\n            suggestion = suggestion.slice(0, -1);\n          }\n          if (shouldWrapSuggestion(node.parent)) {\n            suggestion = `(${suggestion})`;\n          }\n          if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n            if (node.typeParameters !== undefined) {\n              suggestion = `type ${sourceCode.getText().slice(node.id.range[0], node.typeParameters.range[1])} = ${suggestion}${lastChar}`;\n            } else {\n              suggestion = `type ${node.id.name} = ${suggestion}${lastChar}`;\n            }\n          }\n          const isParentExported = node.parent && node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;\n          if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration && isParentExported) {\n            const commentsText = comments.reduce((text, comment) => {\n              return text + (comment.type === utils_1.AST_TOKEN_TYPES.Line ? `//${comment.value}` : `/*${comment.value}*/`) + '\\n';\n            }, '');\n            // comments should move before export and not between export and interface declaration\n            fixes.push(fixer.insertTextBefore(node.parent, commentsText));\n          } else {\n            comments.forEach(comment => {\n              let commentText = comment.type === utils_1.AST_TOKEN_TYPES.Line ? `//${comment.value}` : `/*${comment.value}*/`;\n              const isCommentOnTheSameLine = comment.loc.start.line === member.loc.start.line;\n              if (!isCommentOnTheSameLine) {\n                commentText += '\\n';\n              } else {\n                commentText += ' ';\n              }\n              suggestion = commentText + suggestion;\n            });\n          }\n          const fixStart = node.range[0];\n          fixes.push(fixer.replaceTextRange([fixStart, node.range[1]], suggestion));\n          return fixes;\n        };\n        context.report({\n          node: member,\n          messageId: 'functionTypeOverCallableType',\n          data: {\n            literalOrInterface: exports.phrases[node.type]\n          },\n          fix\n        });\n      }\n    }\n    let tsThisTypes = null;\n    let literalNesting = 0;\n    return {\n      TSInterfaceDeclaration() {\n        // when entering an interface reset the count of `this`s to empty.\n        tsThisTypes = [];\n      },\n      'TSInterfaceDeclaration TSThisType'(node) {\n        // inside an interface keep track of all ThisType references.\n        // unless it's inside a nested type literal in which case it's invalid code anyway\n        // we don't want to incorrectly say \"it refers to name\" while typescript says it's completely invalid.\n        if (literalNesting === 0 && tsThisTypes != null) {\n          tsThisTypes.push(node);\n        }\n      },\n      'TSInterfaceDeclaration:exit'(node) {\n        if (!hasOneSupertype(node) && node.body.body.length === 1) {\n          checkMember(node.body.body[0], node, tsThisTypes);\n        }\n        // on exit check member and reset the array to nothing.\n        tsThisTypes = null;\n      },\n      // keep track of nested literals to avoid complaining about invalid `this` uses\n      'TSInterfaceDeclaration TSTypeLiteral'() {\n        literalNesting += 1;\n      },\n      'TSInterfaceDeclaration TSTypeLiteral:exit'() {\n        literalNesting -= 1;\n      },\n      'TSTypeLiteral[members.length = 1]'(node) {\n        checkMember(node.members[0], node);\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","phrases","AST_NODE_TYPES","TSTypeLiteral","TSInterfaceDeclaration","default","createRule","name","meta","docs","description","recommended","fixable","messages","functionTypeOverCallableType","unexpectedThisOnFunctionOnlyInterface","schema","type","defaultOptions","create","context","sourceCode","getSourceCode","hasOneSupertype","node","extends","length","expr","expression","Identifier","shouldWrapSuggestion","parent","TSUnionType","TSIntersectionType","TSArrayType","checkMember","member","tsThisTypes","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","returnType","undefined","report","messageId","data","interfaceName","id","ExportDefaultDeclaration","fix","fixer","fixes","start","range","colonPos","text","getText","slice","comments","getCommentsBefore","concat","getCommentsAfter","suggestion","lastChar","endsWith","typeParameters","isParentExported","ExportNamedDeclaration","commentsText","reduce","comment","AST_TOKEN_TYPES","Line","value","push","insertTextBefore","forEach","commentText","isCommentOnTheSameLine","loc","line","fixStart","replaceTextRange","literalOrInterface","literalNesting","TSInterfaceDeclaration TSThisType","TSInterfaceDeclaration:exit","body","TSInterfaceDeclaration TSTypeLiteral","TSInterfaceDeclaration TSTypeLiteral:exit","TSTypeLiteral[members.length = 1]","members"],"sources":["../../src/rules/prefer-function-type.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}