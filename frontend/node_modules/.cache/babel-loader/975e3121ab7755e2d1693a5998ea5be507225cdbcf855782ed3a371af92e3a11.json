{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst metadata_1 = require(\"./metadata\");\nconst nullable_1 = require(\"./nullable\");\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({\n    schemaCode\n  }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  error,\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      schemaValue,\n      parentSchema,\n      it\n    } = cxt;\n    if (schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    if (schema.length !== new Set(schema).size) throw new Error(\"enum items must be unique\");\n    let valid;\n    const isString = (0, codegen_1._)`typeof ${data} == \"string\"`;\n    if (schema.length >= it.opts.loopEnum) {\n      let cond;\n      [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);\n      gen.if(cond, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map(value => (0, codegen_1._)`${data} === ${value}`)));\n      if (parentSchema.nullable) valid = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid);\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.forOf(\"v\", schemaValue, v => gen.if((0, codegen_1._)`${valid} = ${data} === ${v}`, () => gen.break()));\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","metadata_1","nullable_1","error","message","params","schemaCode","_","def","keyword","schemaType","code","cxt","checkMetadata","gen","data","schema","schemaValue","parentSchema","it","length","Error","Set","size","valid","isString","opts","loopEnum","cond","checkNullable","if","Array","isArray","and","or","map","value","nullable","pass","forOf","v","break","exports","default"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition, ErrorObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, and, Code} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullable} from \"./nullable\"\n\nexport type JTDEnumError = ErrorObject<\"enum\", {allowedValues: string[]}, string[]>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, schemaValue, parentSchema, it} = cxt\n    if (schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    if (schema.length !== new Set(schema).size) throw new Error(\"enum items must be unique\")\n    let valid: Code\n    const isString = _`typeof ${data} == \"string\"`\n    if (schema.length >= it.opts.loopEnum) {\n      let cond: Code\n      ;[valid, cond] = checkNullable(cxt, isString)\n      gen.if(cond, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      valid = and(isString, or(...schema.map((value: string) => _`${data} === ${value}`)))\n      if (parentSchema.nullable) valid = or(_`${data} === null`, valid)\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.forOf(\"v\", schemaValue as Code, (v) =>\n        gen.if(_`${valid} = ${data} === ${v}`, () => gen.break())\n      )\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,UAAA,GAAAF,OAAA;AAIA,MAAMG,KAAK,GAA2B;EACpCC,OAAO,EAAE,4CAA4C;EACrDC,MAAM,EAAEA,CAAC;IAACC;EAAU,CAAC,KAAK,IAAAP,SAAA,CAAAQ,CAAC,oBAAmBD,UAAU;CACzD;AAED,MAAME,GAAG,GAA0B;EACjCC,OAAO,EAAE,MAAM;EACfC,UAAU,EAAE,OAAO;EACnBP,KAAK;EACLQ,IAAIA,CAACC,GAAe;IAClB,IAAAX,UAAA,CAAAY,aAAa,EAACD,GAAG,CAAC;IAClB,MAAM;MAACE,GAAG;MAAEC,IAAI;MAAEC,MAAM;MAAEC,WAAW;MAAEC,YAAY;MAAEC;IAAE,CAAC,GAAGP,GAAG;IAC9D,IAAII,MAAM,CAACI,MAAM,KAAK,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IAC1E,IAAIL,MAAM,CAACI,MAAM,KAAK,IAAIE,GAAG,CAACN,MAAM,CAAC,CAACO,IAAI,EAAE,MAAM,IAAIF,KAAK,CAAC,2BAA2B,CAAC;IACxF,IAAIG,KAAW;IACf,MAAMC,QAAQ,GAAG,IAAA1B,SAAA,CAAAQ,CAAC,WAAUQ,IAAI,cAAc;IAC9C,IAAIC,MAAM,CAACI,MAAM,IAAID,EAAE,CAACO,IAAI,CAACC,QAAQ,EAAE;MACrC,IAAIC,IAAU;MACb,CAACJ,KAAK,EAAEI,IAAI,CAAC,GAAG,IAAA1B,UAAA,CAAA2B,aAAa,EAACjB,GAAG,EAAEa,QAAQ,CAAC;MAC7CX,GAAG,CAACgB,EAAE,CAACF,IAAI,EAAED,QAAQ,CAAC;IACxB,CAAC,MAAM;MACL;MACA,IAAI,CAACI,KAAK,CAACC,OAAO,CAAChB,MAAM,CAAC,EAAE,MAAM,IAAIK,KAAK,CAAC,0BAA0B,CAAC;MACvEG,KAAK,GAAG,IAAAzB,SAAA,CAAAkC,GAAG,EAACR,QAAQ,EAAE,IAAA1B,SAAA,CAAAmC,EAAE,EAAC,GAAGlB,MAAM,CAACmB,GAAG,CAAEC,KAAa,IAAK,IAAArC,SAAA,CAAAQ,CAAC,IAAGQ,IAAI,QAAQqB,KAAK,EAAE,CAAC,CAAC,CAAC;MACpF,IAAIlB,YAAY,CAACmB,QAAQ,EAAEb,KAAK,GAAG,IAAAzB,SAAA,CAAAmC,EAAE,EAAC,IAAAnC,SAAA,CAAAQ,CAAC,IAAGQ,IAAI,WAAW,EAAES,KAAK,CAAC;IACnE;IACAZ,GAAG,CAAC0B,IAAI,CAACd,KAAK,CAAC;IAEf,SAASG,QAAQA,CAAA;MACfb,GAAG,CAACyB,KAAK,CAAC,GAAG,EAAEtB,WAAmB,EAAGuB,CAAC,IACpC1B,GAAG,CAACgB,EAAE,CAAC,IAAA/B,SAAA,CAAAQ,CAAC,IAAGiB,KAAK,MAAMT,IAAI,QAAQyB,CAAC,EAAE,EAAE,MAAM1B,GAAG,CAAC2B,KAAK,EAAE,CAAC,CAC1D;IACH;EACF;CACD;AAEDC,OAAA,CAAAC,OAAA,GAAenC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}