{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = diffSequence;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n// Input callback function compares items at indexes in the sequences.\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\nconst pkg = 'diff-sequences'; // for error messages\n\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\n\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n  return nCommon;\n}; // Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\n\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n  return nCommon;\n}; // A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\n\nconst extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n\n  aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF are odd when d is odd and even when d is even.\n\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n  return iMaxF;\n}; // A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\n\nconst extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n\n  aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR are odd when d is odd and even when d is even.\n\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);\n  }\n  return iMaxR;\n}; // A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\n\nconst extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert ? aLastPrev // vertical to insert from b\n    : aLastPrev + 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2; // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1); // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n\n        const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n        division.nCommonFollowing = nCommonF;\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}; // A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\n\nconst extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true\n) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert ? aLastPrev // vertical to insert from b\n    : aLastPrev - 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2; // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n        division.nChangeFollowing = d - 1;\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1); // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n\n          const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}; // Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\n\nconst divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart; // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n\n  const baDeltaLength = bLength - aLength; // Optimization: max diagonal in graph intersects corner of shorter side.\n\n  let iMaxF = aLength;\n  let iMaxR = aLength; // Initialize no changes yet in forward or reverse direction:\n\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n      // If a reverse path overlaps a forward path in the same diagonal,\n      // return a division of the index intervals at the middle change.\n      extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2; // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n      // If a forward path overlaps a reverse path in the same diagonal,\n      // return a division of the index intervals at the middle change.\n      extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {\n        return;\n      }\n    }\n  }\n  /* istanbul ignore next */\n\n  throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);\n}; // Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\n\nconst findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const {\n        foundSubsequence,\n        isCommon\n      } = callbacks[0];\n      callbacks[1] = {\n        foundSubsequence: (nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        },\n        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)\n      };\n    }\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n  const {\n    foundSubsequence,\n    isCommon\n  } = callbacks[transposed ? 1 : 0]; // Divide the index intervals at the middle change.\n\n  divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);\n  const {\n    nChangePreceding,\n    aEndPreceding,\n    bEndPreceding,\n    nCommonPreceding,\n    aCommonPreceding,\n    bCommonPreceding,\n    nCommonFollowing,\n    aCommonFollowing,\n    bCommonFollowing,\n    nChangeFollowing,\n    aStartFollowing,\n    bStartFollowing\n  } = division; // Unless either index interval is empty, they might contain common items.\n\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);\n  } // Return common subsequences that are adjacent to the middle change.\n\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  } // Unless either index interval is empty, they might contain common items.\n\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);\n  }\n};\nconst validateLength = (name, arg) => {\n  if (typeof arg !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n  }\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n}; // Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\n\nfunction diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence); // Count common items from the start in the forward direction.\n\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  } // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF; // Count common items from the end in the reverse direction.\n\n    const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon); // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR; // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n\n    const nCommonFR = nCommonF + nCommonR;\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n\n      const transposed = false; // call the original unwrapped functions\n\n      const callbacks = [{\n        foundSubsequence,\n        isCommon\n      }]; // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n\n      const aIndexesF = [NOT_YET_SET]; // from the end at bottom right in the reverse direction:\n\n      const aIndexesR = [NOT_YET_SET]; // Initialize one object as output of all calls to divide function.\n\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      }; // Find and return common subsequences in the trimmed index intervals.\n\n      findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);\n    }\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","diffSequence","pkg","NOT_YET_SET","countCommonItemsF","aIndex","aEnd","bIndex","bEnd","isCommon","nCommon","countCommonItemsR","aStart","bStart","extendPathsF","d","bF","aIndexesF","iMaxF","iF","kF","aFirst","aIndexPrev1","nF","extendPathsR","bR","aIndexesR","iMaxR","iR","kR","nR","extendOverlappablePathsF","division","aLength","bLength","baDeltaLength","kMinOverlapF","kMaxOverlapF","insert","aLastPrev","bFirst","nCommonF","aLast","bLastPrev","nCommonR","aIndexPrevFirst","bIndexPrevFirst","aEndPreceding","bEndPreceding","nChangePreceding","nCommonPreceding","aCommonPreceding","bCommonPreceding","nCommonFollowing","aCommonFollowing","bCommonFollowing","aStartFollowing","bStartFollowing","nChangeFollowing","extendOverlappablePathsR","kMinOverlapR","kMaxOverlapR","bLast","divide","nChange","dMin","dMax","Error","findSubsequences","transposed","callbacks","length","foundSubsequence","bCommon","aCommon","tStart","tEnd","validateLength","name","arg","TypeError","Number","isSafeInteger","RangeError","validateCallback","type","nCommonFR"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/globals/node_modules/diff-sequences/build/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = diffSequence;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n// Input callback function compares items at indexes in the sequences.\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\nconst pkg = 'diff-sequences'; // for error messages\n\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\n\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\n\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\n\nconst extendPathsF = (\n  d,\n  aEnd,\n  bEnd,\n  bF,\n  isCommon,\n  aIndexesF,\n  iMaxF // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n\n  aIndexesF[iF] += countCommonItemsF(\n    aFirst + 1,\n    aEnd,\n    bF + aFirst - kF + 1,\n    bEnd,\n    isCommon\n  ); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF are odd when d is odd and even when d is even.\n\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] =\n      aFirst +\n      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n\n  return iMaxF;\n}; // A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\n\nconst extendPathsR = (\n  d,\n  aStart,\n  bStart,\n  bR,\n  isCommon,\n  aIndexesR,\n  iMaxR // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n\n  aIndexesR[iR] -= countCommonItemsR(\n    aStart,\n    aFirst - 1,\n    bStart,\n    bR + aFirst - kR - 1,\n    isCommon\n  ); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR are odd when d is odd and even when d is even.\n\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] =\n      aFirst -\n      countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n  }\n\n  return iMaxR;\n}; // A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\n\nconst extendOverlappablePathsF = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev + 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bFirst + 1,\n      bEnd,\n      isCommon\n    );\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2; // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1); // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n\n        const nCommonR = countCommonItemsR(\n          aStart,\n          aLastPrev,\n          bStart,\n          bLastPrev,\n          isCommon\n        );\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n\n        division.nCommonFollowing = nCommonF;\n\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\n\nconst extendOverlappablePathsR = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev - 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bFirst - 1,\n      isCommon\n    );\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2; // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n\n        division.nChangeFollowing = d - 1;\n\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1); // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n\n          const nCommonF = countCommonItemsF(\n            aLastPrev,\n            aEnd,\n            bLastPrev,\n            bEnd,\n            isCommon\n          );\n          division.nCommonFollowing = nCommonF;\n\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\n\nconst divide = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  aIndexesR,\n  division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart; // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n\n  const baDeltaLength = bLength - aLength; // Optimization: max diagonal in graph intersects corner of shorter side.\n\n  let iMaxF = aLength;\n  let iMaxR = aLength; // Initialize no changes yet in forward or reverse direction:\n\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n        // If a reverse path overlaps a forward path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsR(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2; // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(\n        d - 1,\n        aStart,\n        bStart,\n        bR,\n        isCommon,\n        aIndexesR,\n        iMaxR\n      );\n\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n        // If a forward path overlaps a reverse path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsF(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  }\n  /* istanbul ignore next */\n\n  throw new Error(\n    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n  );\n}; // Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\n\nconst findSubsequences = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  transposed,\n  callbacks,\n  aIndexesF,\n  aIndexesR,\n  division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const {foundSubsequence, isCommon} = callbacks[0];\n      callbacks[1] = {\n        foundSubsequence: (nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        },\n        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)\n      };\n    }\n\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n\n  const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0]; // Divide the index intervals at the middle change.\n\n  divide(\n    nChange,\n    aStart,\n    aEnd,\n    bStart,\n    bEnd,\n    isCommon,\n    aIndexesF,\n    aIndexesR,\n    division\n  );\n  const {\n    nChangePreceding,\n    aEndPreceding,\n    bEndPreceding,\n    nCommonPreceding,\n    aCommonPreceding,\n    bCommonPreceding,\n    nCommonFollowing,\n    aCommonFollowing,\n    bCommonFollowing,\n    nChangeFollowing,\n    aStartFollowing,\n    bStartFollowing\n  } = division; // Unless either index interval is empty, they might contain common items.\n\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(\n      nChangePreceding,\n      aStart,\n      aEndPreceding,\n      bStart,\n      bEndPreceding,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  } // Return common subsequences that are adjacent to the middle change.\n\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  } // Unless either index interval is empty, they might contain common items.\n\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(\n      nChangeFollowing,\n      aStartFollowing,\n      aEnd,\n      bStartFollowing,\n      bEnd,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n};\n\nconst validateLength = (name, arg) => {\n  if (typeof arg !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n  }\n\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\n\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n}; // Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\n\nfunction diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence); // Count common items from the start in the forward direction.\n\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  } // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF; // Count common items from the end in the reverse direction.\n\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aLength - 1,\n      bStart,\n      bLength - 1,\n      isCommon\n    ); // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR; // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n\n    const nCommonFR = nCommonF + nCommonR;\n\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n\n      const transposed = false; // call the original unwrapped functions\n\n      const callbacks = [\n        {\n          foundSubsequence,\n          isCommon\n        }\n      ]; // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n\n      const aIndexesF = [NOT_YET_SET]; // from the end at bottom right in the reverse direction:\n\n      const aIndexesR = [NOT_YET_SET]; // Initialize one object as output of all calls to divide function.\n\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      }; // Find and return common subsequences in the trimmed index intervals.\n\n      findSubsequences(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}