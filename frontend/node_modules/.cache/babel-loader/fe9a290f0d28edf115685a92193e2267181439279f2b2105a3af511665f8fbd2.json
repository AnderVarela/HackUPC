{"ast":null,"code":"'use strict';\n\n/*eslint-disable no-use-before-define*/\nvar common = require('./common');\nvar YAMLException = require('./exception');\nvar DEFAULT_SCHEMA = require('./schema/default');\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_BOM = 0xFEFF;\nvar CHAR_TAB = 0x09; /* Tab */\nvar CHAR_LINE_FEED = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\nvar CHAR_SPACE = 0x20; /* Space */\nvar CHAR_EXCLAMATION = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE = 0x22; /* \" */\nvar CHAR_SHARP = 0x23; /* # */\nvar CHAR_PERCENT = 0x25; /* % */\nvar CHAR_AMPERSAND = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE = 0x27; /* ' */\nvar CHAR_ASTERISK = 0x2A; /* * */\nvar CHAR_COMMA = 0x2C; /* , */\nvar CHAR_MINUS = 0x2D; /* - */\nvar CHAR_COLON = 0x3A; /* : */\nvar CHAR_EQUALS = 0x3D; /* = */\nvar CHAR_GREATER_THAN = 0x3E; /* > */\nvar CHAR_QUESTION = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n    result[tag] = style;\n  }\n  return result;\n}\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\nvar QUOTING_TYPE_SINGLE = 1,\n  QUOTING_TYPE_DOUBLE = 2;\nfunction State(options) {\n  this.schema = options['schema'] || DEFAULT_SCHEMA;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.quotingType = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes = options['forceQuotes'] || false;\n  this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n    position = 0,\n    next = -1,\n    result = '',\n    line,\n    length = string.length;\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n  return result;\n}\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c) && c !== CHAR_BOM\n  // - b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n  // ns-plain-safe\n  inblock ?\n  // c = flow-in\n  cIsNsCharOrWhitespace : cIsNsCharOrWhitespace\n  // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET\n\n  // ns-plain-char\n  ) && c !== CHAR_SHARP // false on '#'\n  && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n  || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n  || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET\n  // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE\n  // | “%” | “@” | “`”)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos),\n    second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\nvar STYLE_PLAIN = 1,\n  STYLE_SINGLE = 2,\n  STYLE_LITERAL = 3,\n  STYLE_FOLDED = 4,\n  STYLE_DOUBLE = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n          // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n      }\n    }\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n    // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }();\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }();\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n      line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0,\n    end,\n    curr = 0,\n    next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while (match = breakRe.exec(line)) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1; // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n  return result;\n}\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n    _tag = state.tag,\n    index,\n    length,\n    value;\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n    _tag = state.tag,\n    index,\n    length,\n    value;\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n      _result += state.dump;\n    }\n  }\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n    _tag = state.tag,\n    objectKeyList = Object.keys(object),\n    index,\n    length,\n    objectKey,\n    objectValue,\n    pairBuffer;\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n    _tag = state.tag,\n    objectKeyList = Object.keys(object),\n    index,\n    length,\n    objectKey,\n    objectValue,\n    explicitPair,\n    pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n    pairBuffer += state.dump;\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n        state.dump = _result;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n    duplicateIndex,\n    duplicate;\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && state.dump.length !== 0) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n  return true;\n}\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n    duplicatesIndexes = [],\n    index,\n    length;\n  inspectNode(object, objects, duplicatesIndexes);\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  var value = input;\n  if (state.replacer) {\n    value = state.replacer.call({\n      '': value\n    }, '', value);\n  }\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n  return '';\n}\nmodule.exports.dump = dump;","map":{"version":3,"names":["common","require","YAMLException","DEFAULT_SCHEMA","_toString","Object","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_BOM","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","compileStyleMap","schema","map","result","keys","index","length","tag","style","type","String","slice","compiledTypeMap","call","styleAliases","encodeHex","character","string","handle","toUpperCase","repeat","QUOTING_TYPE_SINGLE","QUOTING_TYPE_DOUBLE","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","isNothing","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","c","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","isPlainSafeFirst","isPlainSafeLast","codePointAt","pos","first","charCodeAt","second","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","i","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","dump","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","escapeSeq","writeFlowSequence","object","_result","_tag","value","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","multi","representName","represent","defaultStyle","block","isblockseq","tagStr","objectOrArray","duplicateIndex","duplicate","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","Array","isArray","input","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/node_modules/js-yaml/lib/dumper.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}