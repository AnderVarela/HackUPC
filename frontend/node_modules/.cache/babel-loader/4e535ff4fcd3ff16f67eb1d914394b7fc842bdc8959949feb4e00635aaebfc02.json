{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extract = extract;\nexports.inject = inject;\nexports.getSign = getSign;\nexports.highOrder = highOrder;\nfunction extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n  result >>>= startBit;\n  return result;\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nfunction inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nfunction getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nfunction highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n    result--;\n  }\n  return result;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","extract","inject","getSign","highOrder","buffer","bitIndex","bitLength","defaultBit","Error","undefined","defaultByte","result","lastBit","startByte","Math","floor","startBit","endByte","endBit","get","index","lastByte","length","atByte","atBit","bit","fullyWrongByte","byteToCheck","i"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/leb128/lib/bits.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extract = extract;\nexports.inject = inject;\nexports.getSign = getSign;\nexports.highOrder = highOrder;\n\nfunction extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\n\nfunction inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\n\nfunction getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\n\nfunction highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}