{"ast":null,"code":"'use strict';\n\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  ArrayPrototypeUnshiftApply,\n  ObjectEntries,\n  ObjectPrototypeHasOwnProperty: ObjectHasOwn,\n  StringPrototypeCharAt,\n  StringPrototypeIndexOf,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith\n} = require('./internal/primordials');\nconst {\n  validateArray,\n  validateBoolean,\n  validateBooleanArray,\n  validateObject,\n  validateString,\n  validateStringArray,\n  validateUnion\n} = require('./internal/validators');\nconst {\n  kEmptyObject\n} = require('./internal/util');\nconst {\n  findLongOptionForShort,\n  isLoneLongOption,\n  isLoneShortOption,\n  isLongOptionAndValue,\n  isOptionValue,\n  isOptionLikeValue,\n  isShortOptionAndValue,\n  isShortOptionGroup,\n  useDefaultValueOption,\n  objectGetOwn,\n  optionsGetOwn\n} = require('./utils');\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_PARSE_ARGS_INVALID_OPTION_VALUE,\n    ERR_PARSE_ARGS_UNKNOWN_OPTION,\n    ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL\n  }\n} = require('./internal/errors');\nfunction getMainArgs() {\n  // Work out where to slice process.argv for user supplied arguments.\n\n  // Check node options for scenarios where user CLI args follow executable.\n  const execArgv = process.execArgv;\n  if (ArrayPrototypeIncludes(execArgv, '-e') || ArrayPrototypeIncludes(execArgv, '--eval') || ArrayPrototypeIncludes(execArgv, '-p') || ArrayPrototypeIncludes(execArgv, '--print')) {\n    return ArrayPrototypeSlice(process.argv, 1);\n  }\n\n  // Normally first two arguments are executable and script, then CLI arguments\n  return ArrayPrototypeSlice(process.argv, 2);\n}\n\n/**\n * In strict mode, throw for possible usage errors like --foo --bar\n *\n * @param {object} token - from tokens as available from parseArgs\n */\nfunction checkOptionLikeValue(token) {\n  if (!token.inlineValue && isOptionLikeValue(token.value)) {\n    // Only show short example if user used short option.\n    const example = StringPrototypeStartsWith(token.rawName, '--') ? `'${token.rawName}=-XYZ'` : `'--${token.name}=-XYZ' or '${token.rawName}-XYZ'`;\n    const errorMessage = `Option '${token.rawName}' argument is ambiguous.\nDid you forget to specify the option argument for '${token.rawName}'?\nTo specify an option argument starting with a dash use ${example}.`;\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(errorMessage);\n  }\n}\n\n/**\n * In strict mode, throw for usage errors.\n *\n * @param {object} config - from config passed to parseArgs\n * @param {object} token - from tokens as available from parseArgs\n */\nfunction checkOptionUsage(config, token) {\n  if (!ObjectHasOwn(config.options, token.name)) {\n    throw new ERR_PARSE_ARGS_UNKNOWN_OPTION(token.rawName, config.allowPositionals);\n  }\n  const short = optionsGetOwn(config.options, token.name, 'short');\n  const shortAndLong = `${short ? `-${short}, ` : ''}--${token.name}`;\n  const type = optionsGetOwn(config.options, token.name, 'type');\n  if (type === 'string' && typeof token.value !== 'string') {\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong} <value>' argument missing`);\n  }\n  // (Idiomatic test for undefined||null, expecting undefined.)\n  if (type === 'boolean' && token.value != null) {\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong}' does not take an argument`);\n  }\n}\n\n/**\n * Store the option value in `values`.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {string|undefined} optionValue - value from user args\n * @param {object} options - option configs, from parseArgs({ options })\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction storeOption(longOption, optionValue, options, values) {\n  if (longOption === '__proto__') {\n    return; // No. Just no.\n  }\n\n  // We store based on the option value rather than option type,\n  // preserving the users intent for author to deal with.\n  const newValue = optionValue ?? true;\n  if (optionsGetOwn(options, longOption, 'multiple')) {\n    // Always store value in array, including for boolean.\n    // values[longOption] starts out not present,\n    // first value is added as new array [newValue],\n    // subsequent values are pushed to existing array.\n    // (note: values has null prototype, so simpler usage)\n    if (values[longOption]) {\n      ArrayPrototypePush(values[longOption], newValue);\n    } else {\n      values[longOption] = [newValue];\n    }\n  } else {\n    values[longOption] = newValue;\n  }\n}\n\n/**\n * Store the default option value in `values`.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {string\n *         | boolean\n *         | string[]\n *         | boolean[]} optionValue - default value from option config\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction storeDefaultOption(longOption, optionValue, values) {\n  if (longOption === '__proto__') {\n    return; // No. Just no.\n  }\n  values[longOption] = optionValue;\n}\n\n/**\n * Process args and turn into identified tokens:\n * - option (along with value, if any)\n * - positional\n * - option-terminator\n *\n * @param {string[]} args - from parseArgs({ args }) or mainArgs\n * @param {object} options - option configs, from parseArgs({ options })\n */\nfunction argsToTokens(args, options) {\n  const tokens = [];\n  let index = -1;\n  let groupCount = 0;\n  const remainingArgs = ArrayPrototypeSlice(args);\n  while (remainingArgs.length > 0) {\n    const arg = ArrayPrototypeShift(remainingArgs);\n    const nextArg = remainingArgs[0];\n    if (groupCount > 0) groupCount--;else index++;\n\n    // Check if `arg` is an options terminator.\n    // Guideline 10 in https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html\n    if (arg === '--') {\n      // Everything after a bare '--' is considered a positional argument.\n      ArrayPrototypePush(tokens, {\n        kind: 'option-terminator',\n        index\n      });\n      ArrayPrototypePushApply(tokens, ArrayPrototypeMap(remainingArgs, arg => {\n        return {\n          kind: 'positional',\n          index: ++index,\n          value: arg\n        };\n      }));\n      break; // Finished processing args, leave while loop.\n    }\n    if (isLoneShortOption(arg)) {\n      // e.g. '-f'\n      const shortOption = StringPrototypeCharAt(arg, 1);\n      const longOption = findLongOptionForShort(shortOption, options);\n      let value;\n      let inlineValue;\n      if (optionsGetOwn(options, longOption, 'type') === 'string' && isOptionValue(nextArg)) {\n        // e.g. '-f', 'bar'\n        value = ArrayPrototypeShift(remainingArgs);\n        inlineValue = false;\n      }\n      ArrayPrototypePush(tokens, {\n        kind: 'option',\n        name: longOption,\n        rawName: arg,\n        index,\n        value,\n        inlineValue\n      });\n      if (value != null) ++index;\n      continue;\n    }\n    if (isShortOptionGroup(arg, options)) {\n      // Expand -fXzy to -f -X -z -y\n      const expanded = [];\n      for (let index = 1; index < arg.length; index++) {\n        const shortOption = StringPrototypeCharAt(arg, index);\n        const longOption = findLongOptionForShort(shortOption, options);\n        if (optionsGetOwn(options, longOption, 'type') !== 'string' || index === arg.length - 1) {\n          // Boolean option, or last short in group. Well formed.\n          ArrayPrototypePush(expanded, `-${shortOption}`);\n        } else {\n          // String option in middle. Yuck.\n          // Expand -abfFILE to -a -b -fFILE\n          ArrayPrototypePush(expanded, `-${StringPrototypeSlice(arg, index)}`);\n          break; // finished short group\n        }\n      }\n      ArrayPrototypeUnshiftApply(remainingArgs, expanded);\n      groupCount = expanded.length;\n      continue;\n    }\n    if (isShortOptionAndValue(arg, options)) {\n      // e.g. -fFILE\n      const shortOption = StringPrototypeCharAt(arg, 1);\n      const longOption = findLongOptionForShort(shortOption, options);\n      const value = StringPrototypeSlice(arg, 2);\n      ArrayPrototypePush(tokens, {\n        kind: 'option',\n        name: longOption,\n        rawName: `-${shortOption}`,\n        index,\n        value,\n        inlineValue: true\n      });\n      continue;\n    }\n    if (isLoneLongOption(arg)) {\n      // e.g. '--foo'\n      const longOption = StringPrototypeSlice(arg, 2);\n      let value;\n      let inlineValue;\n      if (optionsGetOwn(options, longOption, 'type') === 'string' && isOptionValue(nextArg)) {\n        // e.g. '--foo', 'bar'\n        value = ArrayPrototypeShift(remainingArgs);\n        inlineValue = false;\n      }\n      ArrayPrototypePush(tokens, {\n        kind: 'option',\n        name: longOption,\n        rawName: arg,\n        index,\n        value,\n        inlineValue\n      });\n      if (value != null) ++index;\n      continue;\n    }\n    if (isLongOptionAndValue(arg)) {\n      // e.g. --foo=bar\n      const equalIndex = StringPrototypeIndexOf(arg, '=');\n      const longOption = StringPrototypeSlice(arg, 2, equalIndex);\n      const value = StringPrototypeSlice(arg, equalIndex + 1);\n      ArrayPrototypePush(tokens, {\n        kind: 'option',\n        name: longOption,\n        rawName: `--${longOption}`,\n        index,\n        value,\n        inlineValue: true\n      });\n      continue;\n    }\n    ArrayPrototypePush(tokens, {\n      kind: 'positional',\n      index,\n      value: arg\n    });\n  }\n  return tokens;\n}\nconst parseArgs = (config = kEmptyObject) => {\n  const args = objectGetOwn(config, 'args') ?? getMainArgs();\n  const strict = objectGetOwn(config, 'strict') ?? true;\n  const allowPositionals = objectGetOwn(config, 'allowPositionals') ?? !strict;\n  const returnTokens = objectGetOwn(config, 'tokens') ?? false;\n  const options = objectGetOwn(config, 'options') ?? {\n    __proto__: null\n  };\n  // Bundle these up for passing to strict-mode checks.\n  const parseConfig = {\n    args,\n    strict,\n    options,\n    allowPositionals\n  };\n\n  // Validate input configuration.\n  validateArray(args, 'args');\n  validateBoolean(strict, 'strict');\n  validateBoolean(allowPositionals, 'allowPositionals');\n  validateBoolean(returnTokens, 'tokens');\n  validateObject(options, 'options');\n  ArrayPrototypeForEach(ObjectEntries(options), ({\n    0: longOption,\n    1: optionConfig\n  }) => {\n    validateObject(optionConfig, `options.${longOption}`);\n\n    // type is required\n    const optionType = objectGetOwn(optionConfig, 'type');\n    validateUnion(optionType, `options.${longOption}.type`, ['string', 'boolean']);\n    if (ObjectHasOwn(optionConfig, 'short')) {\n      const shortOption = optionConfig.short;\n      validateString(shortOption, `options.${longOption}.short`);\n      if (shortOption.length !== 1) {\n        throw new ERR_INVALID_ARG_VALUE(`options.${longOption}.short`, shortOption, 'must be a single character');\n      }\n    }\n    const multipleOption = objectGetOwn(optionConfig, 'multiple');\n    if (ObjectHasOwn(optionConfig, 'multiple')) {\n      validateBoolean(multipleOption, `options.${longOption}.multiple`);\n    }\n    const defaultValue = objectGetOwn(optionConfig, 'default');\n    if (defaultValue !== undefined) {\n      let validator;\n      switch (optionType) {\n        case 'string':\n          validator = multipleOption ? validateStringArray : validateString;\n          break;\n        case 'boolean':\n          validator = multipleOption ? validateBooleanArray : validateBoolean;\n          break;\n      }\n      validator(defaultValue, `options.${longOption}.default`);\n    }\n  });\n\n  // Phase 1: identify tokens\n  const tokens = argsToTokens(args, options);\n\n  // Phase 2: process tokens into parsed option values and positionals\n  const result = {\n    values: {\n      __proto__: null\n    },\n    positionals: []\n  };\n  if (returnTokens) {\n    result.tokens = tokens;\n  }\n  ArrayPrototypeForEach(tokens, token => {\n    if (token.kind === 'option') {\n      if (strict) {\n        checkOptionUsage(parseConfig, token);\n        checkOptionLikeValue(token);\n      }\n      storeOption(token.name, token.value, options, result.values);\n    } else if (token.kind === 'positional') {\n      if (!allowPositionals) {\n        throw new ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL(token.value);\n      }\n      ArrayPrototypePush(result.positionals, token.value);\n    }\n  });\n\n  // Phase 3: fill in default values for missing args\n  ArrayPrototypeForEach(ObjectEntries(options), ({\n    0: longOption,\n    1: optionConfig\n  }) => {\n    const mustSetDefault = useDefaultValueOption(longOption, optionConfig, result.values);\n    if (mustSetDefault) {\n      storeDefaultOption(longOption, objectGetOwn(optionConfig, 'default'), result.values);\n    }\n  });\n  return result;\n};\nmodule.exports = {\n  parseArgs\n};","map":{"version":3,"names":["ArrayPrototypeForEach","ArrayPrototypeIncludes","ArrayPrototypeMap","ArrayPrototypePush","ArrayPrototypePushApply","ArrayPrototypeShift","ArrayPrototypeSlice","ArrayPrototypeUnshiftApply","ObjectEntries","ObjectPrototypeHasOwnProperty","ObjectHasOwn","StringPrototypeCharAt","StringPrototypeIndexOf","StringPrototypeSlice","StringPrototypeStartsWith","require","validateArray","validateBoolean","validateBooleanArray","validateObject","validateString","validateStringArray","validateUnion","kEmptyObject","findLongOptionForShort","isLoneLongOption","isLoneShortOption","isLongOptionAndValue","isOptionValue","isOptionLikeValue","isShortOptionAndValue","isShortOptionGroup","useDefaultValueOption","objectGetOwn","optionsGetOwn","codes","ERR_INVALID_ARG_VALUE","ERR_PARSE_ARGS_INVALID_OPTION_VALUE","ERR_PARSE_ARGS_UNKNOWN_OPTION","ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL","getMainArgs","execArgv","process","argv","checkOptionLikeValue","token","inlineValue","value","example","rawName","name","errorMessage","checkOptionUsage","config","options","allowPositionals","short","shortAndLong","type","storeOption","longOption","optionValue","values","newValue","storeDefaultOption","argsToTokens","args","tokens","index","groupCount","remainingArgs","length","arg","nextArg","kind","shortOption","expanded","equalIndex","parseArgs","strict","returnTokens","__proto__","parseConfig","optionConfig","optionType","multipleOption","defaultValue","undefined","validator","result","positionals","mustSetDefault","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pkgjs/parseargs/index.js"],"sourcesContent":["'use strict';\n\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  ArrayPrototypeUnshiftApply,\n  ObjectEntries,\n  ObjectPrototypeHasOwnProperty: ObjectHasOwn,\n  StringPrototypeCharAt,\n  StringPrototypeIndexOf,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n} = require('./internal/primordials');\n\nconst {\n  validateArray,\n  validateBoolean,\n  validateBooleanArray,\n  validateObject,\n  validateString,\n  validateStringArray,\n  validateUnion,\n} = require('./internal/validators');\n\nconst {\n  kEmptyObject,\n} = require('./internal/util');\n\nconst {\n  findLongOptionForShort,\n  isLoneLongOption,\n  isLoneShortOption,\n  isLongOptionAndValue,\n  isOptionValue,\n  isOptionLikeValue,\n  isShortOptionAndValue,\n  isShortOptionGroup,\n  useDefaultValueOption,\n  objectGetOwn,\n  optionsGetOwn,\n} = require('./utils');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_PARSE_ARGS_INVALID_OPTION_VALUE,\n    ERR_PARSE_ARGS_UNKNOWN_OPTION,\n    ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL,\n  },\n} = require('./internal/errors');\n\nfunction getMainArgs() {\n  // Work out where to slice process.argv for user supplied arguments.\n\n  // Check node options for scenarios where user CLI args follow executable.\n  const execArgv = process.execArgv;\n  if (ArrayPrototypeIncludes(execArgv, '-e') ||\n      ArrayPrototypeIncludes(execArgv, '--eval') ||\n      ArrayPrototypeIncludes(execArgv, '-p') ||\n      ArrayPrototypeIncludes(execArgv, '--print')) {\n    return ArrayPrototypeSlice(process.argv, 1);\n  }\n\n  // Normally first two arguments are executable and script, then CLI arguments\n  return ArrayPrototypeSlice(process.argv, 2);\n}\n\n/**\n * In strict mode, throw for possible usage errors like --foo --bar\n *\n * @param {object} token - from tokens as available from parseArgs\n */\nfunction checkOptionLikeValue(token) {\n  if (!token.inlineValue && isOptionLikeValue(token.value)) {\n    // Only show short example if user used short option.\n    const example = StringPrototypeStartsWith(token.rawName, '--') ?\n      `'${token.rawName}=-XYZ'` :\n      `'--${token.name}=-XYZ' or '${token.rawName}-XYZ'`;\n    const errorMessage = `Option '${token.rawName}' argument is ambiguous.\nDid you forget to specify the option argument for '${token.rawName}'?\nTo specify an option argument starting with a dash use ${example}.`;\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(errorMessage);\n  }\n}\n\n/**\n * In strict mode, throw for usage errors.\n *\n * @param {object} config - from config passed to parseArgs\n * @param {object} token - from tokens as available from parseArgs\n */\nfunction checkOptionUsage(config, token) {\n  if (!ObjectHasOwn(config.options, token.name)) {\n    throw new ERR_PARSE_ARGS_UNKNOWN_OPTION(\n      token.rawName, config.allowPositionals);\n  }\n\n  const short = optionsGetOwn(config.options, token.name, 'short');\n  const shortAndLong = `${short ? `-${short}, ` : ''}--${token.name}`;\n  const type = optionsGetOwn(config.options, token.name, 'type');\n  if (type === 'string' && typeof token.value !== 'string') {\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong} <value>' argument missing`);\n  }\n  // (Idiomatic test for undefined||null, expecting undefined.)\n  if (type === 'boolean' && token.value != null) {\n    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong}' does not take an argument`);\n  }\n}\n\n\n/**\n * Store the option value in `values`.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {string|undefined} optionValue - value from user args\n * @param {object} options - option configs, from parseArgs({ options })\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction storeOption(longOption, optionValue, options, values) {\n  if (longOption === '__proto__') {\n    return; // No. Just no.\n  }\n\n  // We store based on the option value rather than option type,\n  // preserving the users intent for author to deal with.\n  const newValue = optionValue ?? true;\n  if (optionsGetOwn(options, longOption, 'multiple')) {\n    // Always store value in array, including for boolean.\n    // values[longOption] starts out not present,\n    // first value is added as new array [newValue],\n    // subsequent values are pushed to existing array.\n    // (note: values has null prototype, so simpler usage)\n    if (values[longOption]) {\n      ArrayPrototypePush(values[longOption], newValue);\n    } else {\n      values[longOption] = [newValue];\n    }\n  } else {\n    values[longOption] = newValue;\n  }\n}\n\n/**\n * Store the default option value in `values`.\n *\n * @param {string} longOption - long option name e.g. 'foo'\n * @param {string\n *         | boolean\n *         | string[]\n *         | boolean[]} optionValue - default value from option config\n * @param {object} values - option values returned in `values` by parseArgs\n */\nfunction storeDefaultOption(longOption, optionValue, values) {\n  if (longOption === '__proto__') {\n    return; // No. Just no.\n  }\n\n  values[longOption] = optionValue;\n}\n\n/**\n * Process args and turn into identified tokens:\n * - option (along with value, if any)\n * - positional\n * - option-terminator\n *\n * @param {string[]} args - from parseArgs({ args }) or mainArgs\n * @param {object} options - option configs, from parseArgs({ options })\n */\nfunction argsToTokens(args, options) {\n  const tokens = [];\n  let index = -1;\n  let groupCount = 0;\n\n  const remainingArgs = ArrayPrototypeSlice(args);\n  while (remainingArgs.length > 0) {\n    const arg = ArrayPrototypeShift(remainingArgs);\n    const nextArg = remainingArgs[0];\n    if (groupCount > 0)\n      groupCount--;\n    else\n      index++;\n\n    // Check if `arg` is an options terminator.\n    // Guideline 10 in https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html\n    if (arg === '--') {\n      // Everything after a bare '--' is considered a positional argument.\n      ArrayPrototypePush(tokens, { kind: 'option-terminator', index });\n      ArrayPrototypePushApply(\n        tokens, ArrayPrototypeMap(remainingArgs, (arg) => {\n          return { kind: 'positional', index: ++index, value: arg };\n        })\n      );\n      break; // Finished processing args, leave while loop.\n    }\n\n    if (isLoneShortOption(arg)) {\n      // e.g. '-f'\n      const shortOption = StringPrototypeCharAt(arg, 1);\n      const longOption = findLongOptionForShort(shortOption, options);\n      let value;\n      let inlineValue;\n      if (optionsGetOwn(options, longOption, 'type') === 'string' &&\n          isOptionValue(nextArg)) {\n        // e.g. '-f', 'bar'\n        value = ArrayPrototypeShift(remainingArgs);\n        inlineValue = false;\n      }\n      ArrayPrototypePush(\n        tokens,\n        { kind: 'option', name: longOption, rawName: arg,\n          index, value, inlineValue });\n      if (value != null) ++index;\n      continue;\n    }\n\n    if (isShortOptionGroup(arg, options)) {\n      // Expand -fXzy to -f -X -z -y\n      const expanded = [];\n      for (let index = 1; index < arg.length; index++) {\n        const shortOption = StringPrototypeCharAt(arg, index);\n        const longOption = findLongOptionForShort(shortOption, options);\n        if (optionsGetOwn(options, longOption, 'type') !== 'string' ||\n          index === arg.length - 1) {\n          // Boolean option, or last short in group. Well formed.\n          ArrayPrototypePush(expanded, `-${shortOption}`);\n        } else {\n          // String option in middle. Yuck.\n          // Expand -abfFILE to -a -b -fFILE\n          ArrayPrototypePush(expanded, `-${StringPrototypeSlice(arg, index)}`);\n          break; // finished short group\n        }\n      }\n      ArrayPrototypeUnshiftApply(remainingArgs, expanded);\n      groupCount = expanded.length;\n      continue;\n    }\n\n    if (isShortOptionAndValue(arg, options)) {\n      // e.g. -fFILE\n      const shortOption = StringPrototypeCharAt(arg, 1);\n      const longOption = findLongOptionForShort(shortOption, options);\n      const value = StringPrototypeSlice(arg, 2);\n      ArrayPrototypePush(\n        tokens,\n        { kind: 'option', name: longOption, rawName: `-${shortOption}`,\n          index, value, inlineValue: true });\n      continue;\n    }\n\n    if (isLoneLongOption(arg)) {\n      // e.g. '--foo'\n      const longOption = StringPrototypeSlice(arg, 2);\n      let value;\n      let inlineValue;\n      if (optionsGetOwn(options, longOption, 'type') === 'string' &&\n          isOptionValue(nextArg)) {\n        // e.g. '--foo', 'bar'\n        value = ArrayPrototypeShift(remainingArgs);\n        inlineValue = false;\n      }\n      ArrayPrototypePush(\n        tokens,\n        { kind: 'option', name: longOption, rawName: arg,\n          index, value, inlineValue });\n      if (value != null) ++index;\n      continue;\n    }\n\n    if (isLongOptionAndValue(arg)) {\n      // e.g. --foo=bar\n      const equalIndex = StringPrototypeIndexOf(arg, '=');\n      const longOption = StringPrototypeSlice(arg, 2, equalIndex);\n      const value = StringPrototypeSlice(arg, equalIndex + 1);\n      ArrayPrototypePush(\n        tokens,\n        { kind: 'option', name: longOption, rawName: `--${longOption}`,\n          index, value, inlineValue: true });\n      continue;\n    }\n\n    ArrayPrototypePush(tokens, { kind: 'positional', index, value: arg });\n  }\n\n  return tokens;\n}\n\nconst parseArgs = (config = kEmptyObject) => {\n  const args = objectGetOwn(config, 'args') ?? getMainArgs();\n  const strict = objectGetOwn(config, 'strict') ?? true;\n  const allowPositionals = objectGetOwn(config, 'allowPositionals') ?? !strict;\n  const returnTokens = objectGetOwn(config, 'tokens') ?? false;\n  const options = objectGetOwn(config, 'options') ?? { __proto__: null };\n  // Bundle these up for passing to strict-mode checks.\n  const parseConfig = { args, strict, options, allowPositionals };\n\n  // Validate input configuration.\n  validateArray(args, 'args');\n  validateBoolean(strict, 'strict');\n  validateBoolean(allowPositionals, 'allowPositionals');\n  validateBoolean(returnTokens, 'tokens');\n  validateObject(options, 'options');\n  ArrayPrototypeForEach(\n    ObjectEntries(options),\n    ({ 0: longOption, 1: optionConfig }) => {\n      validateObject(optionConfig, `options.${longOption}`);\n\n      // type is required\n      const optionType = objectGetOwn(optionConfig, 'type');\n      validateUnion(optionType, `options.${longOption}.type`, ['string', 'boolean']);\n\n      if (ObjectHasOwn(optionConfig, 'short')) {\n        const shortOption = optionConfig.short;\n        validateString(shortOption, `options.${longOption}.short`);\n        if (shortOption.length !== 1) {\n          throw new ERR_INVALID_ARG_VALUE(\n            `options.${longOption}.short`,\n            shortOption,\n            'must be a single character'\n          );\n        }\n      }\n\n      const multipleOption = objectGetOwn(optionConfig, 'multiple');\n      if (ObjectHasOwn(optionConfig, 'multiple')) {\n        validateBoolean(multipleOption, `options.${longOption}.multiple`);\n      }\n\n      const defaultValue = objectGetOwn(optionConfig, 'default');\n      if (defaultValue !== undefined) {\n        let validator;\n        switch (optionType) {\n          case 'string':\n            validator = multipleOption ? validateStringArray : validateString;\n            break;\n\n          case 'boolean':\n            validator = multipleOption ? validateBooleanArray : validateBoolean;\n            break;\n        }\n        validator(defaultValue, `options.${longOption}.default`);\n      }\n    }\n  );\n\n  // Phase 1: identify tokens\n  const tokens = argsToTokens(args, options);\n\n  // Phase 2: process tokens into parsed option values and positionals\n  const result = {\n    values: { __proto__: null },\n    positionals: [],\n  };\n  if (returnTokens) {\n    result.tokens = tokens;\n  }\n  ArrayPrototypeForEach(tokens, (token) => {\n    if (token.kind === 'option') {\n      if (strict) {\n        checkOptionUsage(parseConfig, token);\n        checkOptionLikeValue(token);\n      }\n      storeOption(token.name, token.value, options, result.values);\n    } else if (token.kind === 'positional') {\n      if (!allowPositionals) {\n        throw new ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL(token.value);\n      }\n      ArrayPrototypePush(result.positionals, token.value);\n    }\n  });\n\n  // Phase 3: fill in default values for missing args\n  ArrayPrototypeForEach(ObjectEntries(options), ({ 0: longOption,\n                                                   1: optionConfig }) => {\n    const mustSetDefault = useDefaultValueOption(longOption,\n                                                 optionConfig,\n                                                 result.values);\n    if (mustSetDefault) {\n      storeDefaultOption(longOption,\n                         objectGetOwn(optionConfig, 'default'),\n                         result.values);\n    }\n  });\n\n\n  return result;\n};\n\nmodule.exports = {\n  parseArgs,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}