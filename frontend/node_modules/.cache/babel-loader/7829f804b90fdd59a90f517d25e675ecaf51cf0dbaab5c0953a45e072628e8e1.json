{"ast":null,"code":"let {\n  list\n} = require('postcss');\nlet OldSelector = require('./old-selector');\nlet Prefixer = require('./prefixer');\nlet Browsers = require('./browsers');\nlet utils = require('./utils');\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all);\n    this.regexpCache = new Map();\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule);\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n    let cloned = this.clone(rule, {\n      selector: prefixeds[this.name][prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1;\n    while (index >= 0) {\n      let before = rule.parent.nodes[index];\n      if (before.type !== 'rule') {\n        return false;\n      }\n      let some = false;\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key];\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n      if (!some) {\n        return false;\n      }\n      index -= 1;\n    }\n    return false;\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp());\n    }\n    return false;\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix);\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes();\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`);\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds;\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {};\n    }\n    let prefixeds = {};\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector);\n      let toProcess = ruleParts.filter(el => el.includes(this.name));\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess.map(el => this.replace(el, prefix)).join(', ');\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix);\n      }\n    }\n    rule._autoprefixerPrefixeds[this.name] = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name;\n      this.regexpCache.set(prefix, new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi'));\n    }\n    return this.regexpCache.get(prefix);\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`);\n  }\n}\nmodule.exports = Selector;","map":{"version":3,"names":["list","require","OldSelector","Prefixer","Browsers","utils","Selector","constructor","name","prefixes","all","regexpCache","Map","add","rule","prefix","prefixeds","already","cloned","clone","selector","parent","insertBefore","index","before","nodes","type","some","key","prefixed","check","includes","match","regexp","old","possible","replace","_autoprefixerPrefixeds","ruleParts","comma","toProcess","filter","el","map","join","has","set","RegExp","escapeRegexp","get","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/autoprefixer/lib/selector.js"],"sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n}\n\nmodule.exports = Selector\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}