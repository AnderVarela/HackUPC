{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsUnified = exports.diffStringsRaw = void 0;\nvar _cleanupSemantic = require('./cleanupSemantic');\nvar _diffLines = require('./diffLines');\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n}; // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(isMultiline ? a + '\\n' : a, isMultiline ? b + '\\n' : b, true // cleanupSemantic\n    );\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);\n      const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);\n      return (0, _diffLines.printDiffLines)(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n  return (0, _diffLines.diffLinesUnified)(a.split('\\n'), b.split('\\n'), options);\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\nexports.diffStringsUnified = diffStringsUnified;\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n  return diffs;\n};\nexports.diffStringsRaw = diffStringsRaw;","map":{"version":3,"names":["Object","defineProperty","exports","value","diffStringsUnified","diffStringsRaw","_cleanupSemantic","require","_diffLines","_diffStrings","_interopRequireDefault","_getAlignedDiffs","_normalizeDiffOptions","obj","__esModule","default","hasCommonDiff","diffs","isMultiline","iLast","length","some","diff","i","DIFF_EQUAL","a","b","options","includes","optionsNormalized","normalizeDiffOptions","lines","changeColor","printDiffLines","diffLinesUnified","split","cleanup","cleanupSemantic"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/globals/node_modules/jest-diff/build/printDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsUnified = exports.diffStringsRaw = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n}; // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(\n      isMultiline ? a + '\\n' : a,\n      isMultiline ? b + '\\n' : b,\n      true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n        options\n      );\n      const lines = (0, _getAlignedDiffs.default)(\n        diffs,\n        optionsNormalized.changeColor\n      );\n      return (0, _diffLines.printDiffLines)(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n  return (0, _diffLines.diffLinesUnified)(\n    a.split('\\n'),\n    b.split('\\n'),\n    options\n  );\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}