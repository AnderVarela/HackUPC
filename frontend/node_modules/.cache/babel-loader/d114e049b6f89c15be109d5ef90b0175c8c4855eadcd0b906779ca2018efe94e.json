{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst explicitReturnTypeUtils_1 = require(\"../util/explicitReturnTypeUtils\");\nexports.default = util.createRule({\n  name: 'explicit-module-boundary-types',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: \"Require explicit return and argument types on exported functions' and classes' public class methods\",\n      recommended: false\n    },\n    messages: {\n      missingReturnType: 'Missing return type on function.',\n      missingArgType: \"Argument '{{name}}' should be typed.\",\n      missingArgTypeUnnamed: '{{type}} argument should be typed.',\n      anyTypedArg: \"Argument '{{name}}' should be typed with a non-any type.\",\n      anyTypedArgUnnamed: '{{type}} argument should be typed with a non-any type.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowArgumentsExplicitlyTypedAsAny: {\n          description: 'Whether to ignore arguments that are explicitly typed as `any`.',\n          type: 'boolean'\n        },\n        allowDirectConstAssertionInArrowFunctions: {\n          description: ['Whether to ignore return type annotations on body-less arrow functions that return an `as const` type assertion.', 'You must still type the parameters of the function.'].join('\\n'),\n          type: 'boolean'\n        },\n        allowedNames: {\n          description: 'An array of function/method names that will not have their arguments or return values checked.',\n          items: {\n            type: 'string'\n          },\n          type: 'array'\n        },\n        allowHigherOrderFunctions: {\n          description: ['Whether to ignore return type annotations on functions immediately returning another function expression.', 'You must still type the parameters of the function.'].join('\\n'),\n          type: 'boolean'\n        },\n        allowTypedFunctionExpressions: {\n          description: 'Whether to ignore type annotations on the variable of a function expresion.',\n          type: 'boolean'\n        },\n        // DEPRECATED - To be removed in next major\n        shouldTrackReferences: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowArgumentsExplicitlyTypedAsAny: false,\n    allowDirectConstAssertionInArrowFunctions: true,\n    allowedNames: [],\n    allowHigherOrderFunctions: true,\n    allowTypedFunctionExpressions: true\n  }],\n  create(context, [options]) {\n    const sourceCode = context.getSourceCode();\n    // tracks all of the functions we've already checked\n    const checkedFunctions = new Set();\n    // tracks functions that were found whilst traversing\n    const foundFunctions = [];\n    // all nodes visited, avoids infinite recursion for cyclic references\n    // (such as class member referring to itself)\n    const alreadyVisited = new Set();\n    /*\n    # How the rule works:\n         As the rule traverses the AST, it immediately checks every single function that it finds is exported.\n    \"exported\" means that it is either directly exported, or that its name is exported.\n         It also collects a list of every single function it finds on the way, but does not check them.\n    After it's finished traversing the AST, it then iterates through the list of found functions, and checks to see if\n    any of them are part of a higher-order function\n    */\n    return {\n      ExportDefaultDeclaration(node) {\n        checkNode(node.declaration);\n      },\n      'ExportNamedDeclaration:not([source])'(node) {\n        if (node.declaration) {\n          checkNode(node.declaration);\n        } else {\n          for (const specifier of node.specifiers) {\n            followReference(specifier.local);\n          }\n        }\n      },\n      TSExportAssignment(node) {\n        checkNode(node.expression);\n      },\n      'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression'(node) {\n        foundFunctions.push(node);\n      },\n      'Program:exit'() {\n        for (const func of foundFunctions) {\n          if (isExportedHigherOrderFunction(func)) {\n            checkNode(func);\n          }\n        }\n      }\n    };\n    function checkParameters(node) {\n      function checkParameter(param) {\n        function report(namedMessageId, unnamedMessageId) {\n          if (param.type === utils_1.AST_NODE_TYPES.Identifier) {\n            context.report({\n              node: param,\n              messageId: namedMessageId,\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n            context.report({\n              node: param,\n              messageId: unnamedMessageId,\n              data: {\n                type: 'Array pattern'\n              }\n            });\n          } else if (param.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n            context.report({\n              node: param,\n              messageId: unnamedMessageId,\n              data: {\n                type: 'Object pattern'\n              }\n            });\n          } else if (param.type === utils_1.AST_NODE_TYPES.RestElement) {\n            if (param.argument.type === utils_1.AST_NODE_TYPES.Identifier) {\n              context.report({\n                node: param,\n                messageId: namedMessageId,\n                data: {\n                  name: param.argument.name\n                }\n              });\n            } else {\n              context.report({\n                node: param,\n                messageId: unnamedMessageId,\n                data: {\n                  type: 'Rest'\n                }\n              });\n            }\n          }\n        }\n        switch (param.type) {\n          case utils_1.AST_NODE_TYPES.ArrayPattern:\n          case utils_1.AST_NODE_TYPES.Identifier:\n          case utils_1.AST_NODE_TYPES.ObjectPattern:\n          case utils_1.AST_NODE_TYPES.RestElement:\n            if (!param.typeAnnotation) {\n              report('missingArgType', 'missingArgTypeUnnamed');\n            } else if (options.allowArgumentsExplicitlyTypedAsAny !== true && param.typeAnnotation.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSAnyKeyword) {\n              report('anyTypedArg', 'anyTypedArgUnnamed');\n            }\n            return;\n          case utils_1.AST_NODE_TYPES.TSParameterProperty:\n            return checkParameter(param.parameter);\n          case utils_1.AST_NODE_TYPES.AssignmentPattern:\n            // ignored as it has a type via its assignment\n            return;\n        }\n      }\n      for (const arg of node.params) {\n        checkParameter(arg);\n      }\n    }\n    /**\n     * Checks if a function name is allowed and should not be checked.\n     */\n    function isAllowedName(node) {\n      var _a;\n      if (!node || !options.allowedNames || !options.allowedNames.length) {\n        return false;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator || node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {\n        return ((_a = node.id) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Identifier && options.allowedNames.includes(node.id.name);\n      } else if (node.type === utils_1.AST_NODE_TYPES.MethodDefinition || node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition || node.type === utils_1.AST_NODE_TYPES.Property && node.method || node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) {\n        if (node.key.type === utils_1.AST_NODE_TYPES.Literal && typeof node.key.value === 'string') {\n          return options.allowedNames.includes(node.key.value);\n        }\n        if (node.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral && node.key.expressions.length === 0) {\n          return options.allowedNames.includes(node.key.quasis[0].value.raw);\n        }\n        if (!node.computed && node.key.type === utils_1.AST_NODE_TYPES.Identifier) {\n          return options.allowedNames.includes(node.key.name);\n        }\n      }\n      return false;\n    }\n    function isExportedHigherOrderFunction(node) {\n      var _a;\n      let current = node.parent;\n      while (current) {\n        if (current.type === utils_1.AST_NODE_TYPES.ReturnStatement) {\n          // the parent of a return will always be a block statement, so we can skip over it\n          current = (_a = current.parent) === null || _a === void 0 ? void 0 : _a.parent;\n          continue;\n        }\n        if (!util.isFunction(current) || !(0, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)(current)) {\n          return false;\n        }\n        if (checkedFunctions.has(current)) {\n          return true;\n        }\n        current = current.parent;\n      }\n      return false;\n    }\n    function followReference(node) {\n      const scope = context.getScope();\n      const variable = scope.set.get(node.name);\n      /* istanbul ignore if */\n      if (!variable) {\n        return;\n      }\n      // check all of the definitions\n      for (const definition of variable.defs) {\n        // cases we don't care about in this rule\n        if ([scope_manager_1.DefinitionType.ImplicitGlobalVariable, scope_manager_1.DefinitionType.ImportBinding, scope_manager_1.DefinitionType.CatchClause, scope_manager_1.DefinitionType.Parameter].includes(definition.type)) {\n          continue;\n        }\n        checkNode(definition.node);\n      }\n      // follow references to find writes to the variable\n      for (const reference of variable.references) {\n        if (\n        // we don't want to check the initialization ref, as this is handled by the declaration check\n        !reference.init && reference.writeExpr) {\n          checkNode(reference.writeExpr);\n        }\n      }\n    }\n    function checkNode(node) {\n      if (node == null || alreadyVisited.has(node)) {\n        return;\n      }\n      alreadyVisited.add(node);\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        case utils_1.AST_NODE_TYPES.FunctionExpression:\n          return checkFunctionExpression(node);\n        case utils_1.AST_NODE_TYPES.ArrayExpression:\n          for (const element of node.elements) {\n            checkNode(element);\n          }\n          return;\n        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n          if (node.accessibility === 'private' || node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n            return;\n          }\n          return checkNode(node.value);\n        case utils_1.AST_NODE_TYPES.ClassDeclaration:\n        case utils_1.AST_NODE_TYPES.ClassExpression:\n          for (const element of node.body.body) {\n            checkNode(element);\n          }\n          return;\n        case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n          return checkFunction(node);\n        case utils_1.AST_NODE_TYPES.MethodDefinition:\n        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n          if (node.accessibility === 'private' || node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n            return;\n          }\n          return checkNode(node.value);\n        case utils_1.AST_NODE_TYPES.Identifier:\n          return followReference(node);\n        case utils_1.AST_NODE_TYPES.ObjectExpression:\n          for (const property of node.properties) {\n            checkNode(property);\n          }\n          return;\n        case utils_1.AST_NODE_TYPES.Property:\n          return checkNode(node.value);\n        case utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:\n          return checkEmptyBodyFunctionExpression(node);\n        case utils_1.AST_NODE_TYPES.VariableDeclaration:\n          for (const declaration of node.declarations) {\n            checkNode(declaration);\n          }\n          return;\n        case utils_1.AST_NODE_TYPES.VariableDeclarator:\n          return checkNode(node.init);\n      }\n    }\n    function checkEmptyBodyFunctionExpression(node) {\n      var _a, _b, _c;\n      const isConstructor = ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.MethodDefinition && node.parent.kind === 'constructor';\n      const isSetAccessor = (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition || ((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) === utils_1.AST_NODE_TYPES.MethodDefinition) && node.parent.kind === 'set';\n      if (!isConstructor && !isSetAccessor && !node.returnType) {\n        context.report({\n          node,\n          messageId: 'missingReturnType'\n        });\n      }\n      checkParameters(node);\n    }\n    function checkFunctionExpression(node) {\n      if (checkedFunctions.has(node)) {\n        return;\n      }\n      checkedFunctions.add(node);\n      if (isAllowedName(node.parent) || (0, explicitReturnTypeUtils_1.isTypedFunctionExpression)(node, options) || (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {\n        return;\n      }\n      (0, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)(node, options, sourceCode, loc => {\n        context.report({\n          node,\n          loc,\n          messageId: 'missingReturnType'\n        });\n      });\n      checkParameters(node);\n    }\n    function checkFunction(node) {\n      if (checkedFunctions.has(node)) {\n        return;\n      }\n      checkedFunctions.add(node);\n      if (isAllowedName(node) || (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {\n        return;\n      }\n      (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(node, options, sourceCode, loc => {\n        context.report({\n          node,\n          loc,\n          messageId: 'missingReturnType'\n        });\n      });\n      checkParameters(node);\n    }\n  }\n});","map":{"version":3,"names":["scope_manager_1","require","utils_1","util","__importStar","explicitReturnTypeUtils_1","exports","default","createRule","name","meta","type","docs","description","recommended","messages","missingReturnType","missingArgType","missingArgTypeUnnamed","anyTypedArg","anyTypedArgUnnamed","schema","properties","allowArgumentsExplicitlyTypedAsAny","allowDirectConstAssertionInArrowFunctions","join","allowedNames","items","allowHigherOrderFunctions","allowTypedFunctionExpressions","shouldTrackReferences","additionalProperties","defaultOptions","create","context","options","sourceCode","getSourceCode","checkedFunctions","Set","foundFunctions","alreadyVisited","ExportDefaultDeclaration","node","checkNode","declaration","ExportNamedDeclaration:not([source])","specifier","specifiers","followReference","local","TSExportAssignment","expression","ArrowFunctionExpression, FunctionDeclaration, FunctionExpression","push","Program:exit","func","isExportedHigherOrderFunction","checkParameters","checkParameter","param","report","namedMessageId","unnamedMessageId","AST_NODE_TYPES","Identifier","messageId","data","ArrayPattern","ObjectPattern","RestElement","argument","typeAnnotation","TSAnyKeyword","TSParameterProperty","parameter","AssignmentPattern","arg","params","isAllowedName","length","VariableDeclarator","FunctionDeclaration","_a","id","includes","MethodDefinition","TSAbstractMethodDefinition","Property","method","PropertyDefinition","key","Literal","value","TemplateLiteral","expressions","quasis","raw","computed","current","parent","ReturnStatement","isFunction","doesImmediatelyReturnFunctionExpression","has","scope","getScope","variable","set","get","definition","defs","DefinitionType","ImplicitGlobalVariable","ImportBinding","CatchClause","Parameter","reference","references","init","writeExpr","add","ArrowFunctionExpression","FunctionExpression","checkFunctionExpression","ArrayExpression","element","elements","accessibility","PrivateIdentifier","ClassDeclaration","ClassExpression","body","checkFunction","ObjectExpression","property","TSEmptyBodyFunctionExpression","checkEmptyBodyFunctionExpression","VariableDeclaration","declarations","isConstructor","kind","isSetAccessor","_b","_c","returnType","isTypedFunctionExpression","ancestorHasReturnType","checkFunctionExpressionReturnType","loc","checkFunctionReturnType"],"sources":["../../src/rules/explicit-module-boundary-types.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}