{"ast":null,"code":"var t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\nexport function transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n  if (!typeInstructions.length) {\n    return;\n  }\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n    return signature;\n  }\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n      Func.toString = function () {\n        return _Func.toString();\n      };\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}","map":{"version":3,"names":["t","require","transform","ast","typeInstructions","traverse","TypeInstruction","_ref","node","push","length","denormalizeSignature","signature","type","identifier","typeInstruction","find","id","value","Error","concat","JSON","stringify","functype","signatureRef","_typeInstruction","Func","_Func","_x","apply","arguments","toString","_ref2","CallIndirectInstruction","_ref3"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/esm/transform/denormalize-type-references/index.js"],"sourcesContent":["var t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\n\nexport function transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n\n  if (!typeInstructions.length) {\n    return;\n  }\n\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n\n    return signature;\n  }\n\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,OAAO,SAASC,SAASA,CAACC,GAAG,EAAE;EAC7B,IAAIC,gBAAgB,GAAG,EAAE;EACzBJ,CAAC,CAACK,QAAQ,CAACF,GAAG,EAAE;IACdG,eAAe,EAAE,SAASA,eAAeA,CAACC,IAAI,EAAE;MAC9C,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAI;MACpBJ,gBAAgB,CAACK,IAAI,CAACD,IAAI,CAAC;IAC7B;EACF,CAAC,CAAC;EAEF,IAAI,CAACJ,gBAAgB,CAACM,MAAM,EAAE;IAC5B;EACF;EAEA,SAASC,oBAAoBA,CAACC,SAAS,EAAE;IACvC;IACA,IAAIA,SAAS,CAACC,IAAI,KAAK,YAAY,EAAE;MACnC,IAAIC,UAAU,GAAGF,SAAS;MAC1B,IAAIG,eAAe,GAAGX,gBAAgB,CAACY,IAAI,CAAC,UAAUhB,CAAC,EAAE;QACvD,OAAOA,CAAC,CAACiB,EAAE,CAACJ,IAAI,KAAKC,UAAU,CAACD,IAAI,IAAIb,CAAC,CAACiB,EAAE,CAACC,KAAK,KAAKJ,UAAU,CAACI,KAAK;MACzE,CAAC,CAAC;MAEF,IAAI,CAACH,eAAe,EAAE;QACpB,MAAM,IAAII,KAAK,CAAC,6CAA6C,CAACC,MAAM,CAACC,IAAI,CAACC,SAAS,CAACV,SAAS,CAAC,CAAC,CAAC;MAClG;MAEA,OAAOG,eAAe,CAACQ,QAAQ;IACjC,CAAC,CAAC;;IAGF,IAAIX,SAAS,CAACC,IAAI,KAAK,eAAe,EAAE;MACtC,IAAIW,YAAY,GAAGZ,SAAS;MAC5B,IAAIa,gBAAgB,GAAGrB,gBAAgB,CAACoB,YAAY,CAACN,KAAK,CAAC;MAC3D,OAAOO,gBAAgB,CAACF,QAAQ;IAClC;IAEA,OAAOX,SAAS;EAClB;EAEAZ,CAAC,CAACK,QAAQ,CAACF,GAAG,EAAE;IACduB,IAAI,EAAE,UAAUC,KAAK,EAAE;MACrB,SAASD,IAAIA,CAACE,EAAE,EAAE;QAChB,OAAOD,KAAK,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACrC;MAEAJ,IAAI,CAACK,QAAQ,GAAG,YAAY;QAC1B,OAAOJ,KAAK,CAACI,QAAQ,CAAC,CAAC;MACzB,CAAC;MAED,OAAOL,IAAI;IACb,CAAC,CAAC,UAAUM,KAAK,EAAE;MACjB,IAAIxB,IAAI,GAAGwB,KAAK,CAACxB,IAAI;MACrBA,IAAI,CAACI,SAAS,GAAGD,oBAAoB,CAACH,IAAI,CAACI,SAAS,CAAC;IACvD,CAAC,CAAC;IACFqB,uBAAuB,EAAE,SAASA,uBAAuBA,CAACC,KAAK,EAAE;MAC/D,IAAI1B,IAAI,GAAG0B,KAAK,CAAC1B,IAAI;MACrBA,IAAI,CAACI,SAAS,GAAGD,oBAAoB,CAACH,IAAI,CAACI,SAAS,CAAC;IACvD;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}