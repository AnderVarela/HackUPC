{"ast":null,"code":"'use strict';\n\n// This is an example of using tokens to add a custom behaviour.\n//\n// Require the use of `=` for long options and values by blocking\n// the use of space separated values.\n// So allow `--foo=bar`, and not allow `--foo bar`.\n//\n// Note: this is not a common behaviour, most CLIs allow both forms.\n\n// 1. const { parseArgs } = require('node:util'); // from node\n// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package\nconst {\n  parseArgs\n} = require('..'); // in repo\n\nconst options = {\n  file: {\n    short: 'f',\n    type: 'string'\n  },\n  log: {\n    type: 'string'\n  }\n};\nconst {\n  values,\n  tokens\n} = parseArgs({\n  options,\n  tokens: true\n});\nconst badToken = tokens.find(token => token.kind === 'option' && token.value != null && token.rawName.startsWith('--') && !token.inlineValue);\nif (badToken) {\n  throw new Error(`Option value for '${badToken.rawName}' must be inline, like '${badToken.rawName}=VALUE'`);\n}\nconsole.log(values);\n\n// Try the following:\n//    node limit-long-syntax.js -f FILE --log=LOG\n//    node limit-long-syntax.js --file FILE","map":{"version":3,"names":["parseArgs","require","options","file","short","type","log","values","tokens","badToken","find","token","kind","value","rawName","startsWith","inlineValue","Error","console"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pkgjs/parseargs/examples/limit-long-syntax.js"],"sourcesContent":["'use strict';\n\n// This is an example of using tokens to add a custom behaviour.\n//\n// Require the use of `=` for long options and values by blocking\n// the use of space separated values.\n// So allow `--foo=bar`, and not allow `--foo bar`.\n//\n// Note: this is not a common behaviour, most CLIs allow both forms.\n\n// 1. const { parseArgs } = require('node:util'); // from node\n// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package\nconst { parseArgs } = require('..'); // in repo\n\nconst options = {\n  file: { short: 'f', type: 'string' },\n  log: { type: 'string' },\n};\n\nconst { values, tokens } = parseArgs({ options, tokens: true });\n\nconst badToken = tokens.find((token) => token.kind === 'option' &&\n  token.value != null &&\n  token.rawName.startsWith('--') &&\n  !token.inlineValue\n);\nif (badToken) {\n  throw new Error(`Option value for '${badToken.rawName}' must be inline, like '${badToken.rawName}=VALUE'`);\n}\n\nconsole.log(values);\n\n// Try the following:\n//    node limit-long-syntax.js -f FILE --log=LOG\n//    node limit-long-syntax.js --file FILE\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;EAAEA;AAAU,CAAC,GAAGC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;;AAErC,MAAMC,OAAO,GAAG;EACdC,IAAI,EAAE;IAAEC,KAAK,EAAE,GAAG;IAAEC,IAAI,EAAE;EAAS,CAAC;EACpCC,GAAG,EAAE;IAAED,IAAI,EAAE;EAAS;AACxB,CAAC;AAED,MAAM;EAAEE,MAAM;EAAEC;AAAO,CAAC,GAAGR,SAAS,CAAC;EAAEE,OAAO;EAAEM,MAAM,EAAE;AAAK,CAAC,CAAC;AAE/D,MAAMC,QAAQ,GAAGD,MAAM,CAACE,IAAI,CAAEC,KAAK,IAAKA,KAAK,CAACC,IAAI,KAAK,QAAQ,IAC7DD,KAAK,CAACE,KAAK,IAAI,IAAI,IACnBF,KAAK,CAACG,OAAO,CAACC,UAAU,CAAC,IAAI,CAAC,IAC9B,CAACJ,KAAK,CAACK,WACT,CAAC;AACD,IAAIP,QAAQ,EAAE;EACZ,MAAM,IAAIQ,KAAK,CAAE,qBAAoBR,QAAQ,CAACK,OAAQ,2BAA0BL,QAAQ,CAACK,OAAQ,SAAQ,CAAC;AAC5G;AAEAI,OAAO,CAACZ,GAAG,CAACC,MAAM,CAAC;;AAEnB;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}