{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\types\\index.ts"],"sourcesContent":["import * as URI from \"uri-js\"\nimport type {CodeGen, Code, Name, ScopeValueSets, ValueScopeName} from \"../compile/codegen\"\nimport type {SchemaEnv, SchemaCxt, SchemaObjCxt} from \"../compile\"\nimport type {JSONType} from \"../compile/rules\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport type Ajv from \"../core\"\n\ninterface _SchemaObject {\n  id?: string\n  $id?: string\n  $schema?: string\n  [x: string]: any // TODO\n}\n\nexport interface SchemaObject extends _SchemaObject {\n  id?: string\n  $id?: string\n  $schema?: string\n  $async?: false\n  [x: string]: any // TODO\n}\n\nexport interface AsyncSchema extends _SchemaObject {\n  $async: true\n}\n\nexport type AnySchemaObject = SchemaObject | AsyncSchema\n\nexport type Schema = SchemaObject | boolean\n\nexport type AnySchema = Schema | AsyncSchema\n\nexport type SchemaMap = {[Key in string]?: AnySchema}\n\nexport interface SourceCode {\n  validateName: ValueScopeName\n  validateCode: string\n  scopeValues: ScopeValueSets\n  evaluated?: Code\n}\n\nexport interface DataValidationCxt<T extends string | number = string | number> {\n  instancePath: string\n  parentData: {[K in T]: any} // object or array\n  parentDataProperty: T // string or number\n  rootData: Record<string, any> | any[]\n  dynamicAnchors: {[Ref in string]?: ValidateFunction}\n}\n\nexport interface ValidateFunction<T = unknown> {\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  (this: Ajv | any, data: any, dataCxt?: DataValidationCxt): data is T\n  errors?: null | ErrorObject[]\n  evaluated?: Evaluated\n  schema: AnySchema\n  schemaEnv: SchemaEnv\n  source?: SourceCode\n}\n\nexport interface JTDParser<T = unknown> {\n  (json: string): T | undefined\n  message?: string\n  position?: number\n}\n\nexport type EvaluatedProperties = {[K in string]?: true} | true\n\nexport type EvaluatedItems = number | true\n\nexport interface Evaluated {\n  // determined at compile time if staticProps/Items is true\n  props?: EvaluatedProperties\n  items?: EvaluatedItems\n  // whether props/items determined at compile time\n  dynamicProps: boolean\n  dynamicItems: boolean\n}\n\nexport interface AsyncValidateFunction<T = unknown> extends ValidateFunction<T> {\n  (...args: Parameters<ValidateFunction<T>>): Promise<T>\n  $async: true\n}\n\nexport type AnyValidateFunction<T = any> = ValidateFunction<T> | AsyncValidateFunction<T>\n\nexport interface ErrorObject<K extends string = string, P = Record<string, any>, S = unknown> {\n  keyword: K\n  instancePath: string\n  schemaPath: string\n  params: P\n  // Added to validation errors of \"propertyNames\" keyword schema\n  propertyName?: string\n  // Excluded if option `messages` set to false.\n  message?: string\n  // These are added with the `verbose` option.\n  schema?: S\n  parentSchema?: AnySchemaObject\n  data?: unknown\n}\n\nexport type ErrorNoParams<K extends string, S = unknown> = ErrorObject<K, Record<string, never>, S>\n\ninterface _KeywordDef {\n  keyword: string | string[]\n  type?: JSONType | JSONType[] // data types that keyword applies to\n  schemaType?: JSONType | JSONType[] // allowed type(s) of keyword value in the schema\n  allowUndefined?: boolean // used for keywords that can be invoked by other keywords, not being present in the schema\n  $data?: boolean // keyword supports [$data reference](../../docs/guide/combining-schemas.md#data-reference)\n  implements?: string[] // other schema keywords that this keyword implements\n  before?: string // keyword should be executed before this keyword (should be applicable to the same type)\n  post?: boolean // keyword should be executed after other keywords without post flag\n  metaSchema?: AnySchemaObject // meta-schema for keyword schema value - it is better to use schemaType where applicable\n  validateSchema?: AnyValidateFunction // compiled keyword metaSchema - should not be passed\n  dependencies?: string[] // keywords that must be present in the same schema\n  error?: KeywordErrorDefinition\n  $dataError?: KeywordErrorDefinition\n}\n\nexport interface CodeKeywordDefinition extends _KeywordDef {\n  code: (cxt: KeywordCxt, ruleType?: string) => void\n  trackErrors?: boolean\n}\n\nexport type MacroKeywordFunc = (\n  schema: any,\n  parentSchema: AnySchemaObject,\n  it: SchemaCxt\n) => AnySchema\n\nexport type CompileKeywordFunc = (\n  schema: any,\n  parentSchema: AnySchemaObject,\n  it: SchemaObjCxt\n) => DataValidateFunction\n\nexport interface DataValidateFunction {\n  (...args: Parameters<ValidateFunction>): boolean | Promise<any>\n  errors?: Partial<ErrorObject>[]\n}\n\nexport interface SchemaValidateFunction {\n  (\n    schema: any,\n    data: any,\n    parentSchema?: AnySchemaObject,\n    dataCxt?: DataValidationCxt\n  ): boolean | Promise<any>\n  errors?: Partial<ErrorObject>[]\n}\n\nexport interface FuncKeywordDefinition extends _KeywordDef {\n  validate?: SchemaValidateFunction | DataValidateFunction\n  compile?: CompileKeywordFunc\n  // schema: false makes validate not to expect schema (DataValidateFunction)\n  schema?: boolean // requires \"validate\"\n  modifying?: boolean\n  async?: boolean\n  valid?: boolean\n  errors?: boolean | \"full\"\n}\n\nexport interface MacroKeywordDefinition extends FuncKeywordDefinition {\n  macro: MacroKeywordFunc\n}\n\nexport type KeywordDefinition =\n  | CodeKeywordDefinition\n  | FuncKeywordDefinition\n  | MacroKeywordDefinition\n\nexport type AddedKeywordDefinition = KeywordDefinition & {\n  type: JSONType[]\n  schemaType: JSONType[]\n}\n\nexport interface KeywordErrorDefinition {\n  message: string | Code | ((cxt: KeywordErrorCxt) => string | Code)\n  params?: Code | ((cxt: KeywordErrorCxt) => Code)\n}\n\nexport type Vocabulary = (KeywordDefinition | string)[]\n\nexport interface KeywordErrorCxt {\n  gen: CodeGen\n  keyword: string\n  data: Name\n  $data?: string | false\n  schema: any // TODO\n  parentSchema?: AnySchemaObject\n  schemaCode: Code | number | boolean\n  schemaValue: Code | number | boolean\n  schemaType?: JSONType[]\n  errsCount?: Name\n  params: KeywordCxtParams\n  it: SchemaCxt\n}\n\nexport type KeywordCxtParams = {[P in string]?: Code | string | number}\n\nexport type FormatValidator<T extends string | number> = (data: T) => boolean\n\nexport type FormatCompare<T extends string | number> = (data1: T, data2: T) => number | undefined\n\nexport type AsyncFormatValidator<T extends string | number> = (data: T) => Promise<boolean>\n\nexport interface FormatDefinition<T extends string | number> {\n  type?: T extends string ? \"string\" | undefined : \"number\"\n  validate: FormatValidator<T> | (T extends string ? string | RegExp : never)\n  async?: false | undefined\n  compare?: FormatCompare<T>\n}\n\nexport interface AsyncFormatDefinition<T extends string | number> {\n  type?: T extends string ? \"string\" | undefined : \"number\"\n  validate: AsyncFormatValidator<T>\n  async: true\n  compare?: FormatCompare<T>\n}\n\nexport type AddedFormat =\n  | true\n  | RegExp\n  | FormatValidator<string>\n  | FormatDefinition<string>\n  | FormatDefinition<number>\n  | AsyncFormatDefinition<string>\n  | AsyncFormatDefinition<number>\n\nexport type Format = AddedFormat | string\n\nexport interface RegExpEngine {\n  (pattern: string, u: string): RegExpLike\n  code: string\n}\n\nexport interface RegExpLike {\n  test: (s: string) => boolean\n}\n\nexport interface UriResolver {\n  parse(uri: string): URI.URIComponents\n  resolve(base: string, path: string): string\n  serialize(component: URI.URIComponents): string\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}