{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToRawPrecision = void 0;\nvar utils_1 = require(\"../utils\");\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n  var p = maxPrecision;\n  var m;\n  var e;\n  var xFinal;\n  if (x === 0) {\n    m = (0, utils_1.repeat)('0', p);\n    e = 0;\n    xFinal = 0;\n  } else {\n    var xToString = x.toString();\n    // If xToString is formatted as scientific notation, the number is either very small or very\n    // large. If the precision of the formatted string is lower that requested max precision, we\n    // should still infer them from the formatted string, otherwise the formatted result might have\n    // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n    var xToStringExponentIndex = xToString.indexOf('e');\n    var _a = xToString.split('e'),\n      xToStringMantissa = _a[0],\n      xToStringExponent = _a[1];\n    var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n    if (xToStringExponentIndex >= 0 && xToStringMantissaWithoutDecimalPoint.length <= p) {\n      e = +xToStringExponent;\n      m = xToStringMantissaWithoutDecimalPoint + (0, utils_1.repeat)('0', p - xToStringMantissaWithoutDecimalPoint.length);\n      xFinal = x;\n    } else {\n      e = (0, utils_1.getMagnitude)(x);\n      var decimalPlaceOffset = e - p + 1;\n      // n is the integer containing the required precision digits. To derive the formatted string,\n      // we will adjust its decimal place in the logic below.\n      var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));\n      // The rounding caused the change of magnitude, so we should increment `e` by 1.\n      if (adjustDecimalPlace(n, p - 1) >= 10) {\n        e = e + 1;\n        // Divide n by 10 to swallow one precision.\n        n = Math.floor(n / 10);\n      }\n      m = n.toString();\n      // Equivalent of n * 10 ** (e - p + 1)\n      xFinal = adjustDecimalPlace(n, p - 1 - e);\n    }\n  }\n  var int;\n  if (e >= p - 1) {\n    m = m + (0, utils_1.repeat)('0', e - p + 1);\n    int = e + 1;\n  } else if (e >= 0) {\n    m = \"\".concat(m.slice(0, e + 1), \".\").concat(m.slice(e + 1));\n    int = e + 1;\n  } else {\n    m = \"0.\".concat((0, utils_1.repeat)('0', -e - 1)).concat(m);\n    int = 1;\n  }\n  if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n    var cut = maxPrecision - minPrecision;\n    while (cut > 0 && m[m.length - 1] === '0') {\n      m = m.slice(0, -1);\n      cut--;\n    }\n    if (m[m.length - 1] === '.') {\n      m = m.slice(0, -1);\n    }\n  }\n  return {\n    formattedString: m,\n    roundedNumber: xFinal,\n    integerDigitsCount: int\n  };\n  // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n  function adjustDecimalPlace(x, magnitude) {\n    return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n  }\n}\nexports.ToRawPrecision = ToRawPrecision;","map":{"version":3,"names":["Object","defineProperty","exports","value","ToRawPrecision","utils_1","require","x","minPrecision","maxPrecision","p","m","e","xFinal","repeat","xToString","toString","xToStringExponentIndex","indexOf","_a","split","xToStringMantissa","xToStringExponent","xToStringMantissaWithoutDecimalPoint","replace","length","getMagnitude","decimalPlaceOffset","n","Math","round","adjustDecimalPlace","floor","int","concat","slice","cut","formattedString","roundedNumber","integerDigitsCount","magnitude","pow"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@formatjs/ecma402-abstract/NumberFormat/ToRawPrecision.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToRawPrecision = void 0;\nvar utils_1 = require(\"../utils\");\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n    var p = maxPrecision;\n    var m;\n    var e;\n    var xFinal;\n    if (x === 0) {\n        m = (0, utils_1.repeat)('0', p);\n        e = 0;\n        xFinal = 0;\n    }\n    else {\n        var xToString = x.toString();\n        // If xToString is formatted as scientific notation, the number is either very small or very\n        // large. If the precision of the formatted string is lower that requested max precision, we\n        // should still infer them from the formatted string, otherwise the formatted result might have\n        // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n        var xToStringExponentIndex = xToString.indexOf('e');\n        var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];\n        var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n        if (xToStringExponentIndex >= 0 &&\n            xToStringMantissaWithoutDecimalPoint.length <= p) {\n            e = +xToStringExponent;\n            m =\n                xToStringMantissaWithoutDecimalPoint +\n                    (0, utils_1.repeat)('0', p - xToStringMantissaWithoutDecimalPoint.length);\n            xFinal = x;\n        }\n        else {\n            e = (0, utils_1.getMagnitude)(x);\n            var decimalPlaceOffset = e - p + 1;\n            // n is the integer containing the required precision digits. To derive the formatted string,\n            // we will adjust its decimal place in the logic below.\n            var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));\n            // The rounding caused the change of magnitude, so we should increment `e` by 1.\n            if (adjustDecimalPlace(n, p - 1) >= 10) {\n                e = e + 1;\n                // Divide n by 10 to swallow one precision.\n                n = Math.floor(n / 10);\n            }\n            m = n.toString();\n            // Equivalent of n * 10 ** (e - p + 1)\n            xFinal = adjustDecimalPlace(n, p - 1 - e);\n        }\n    }\n    var int;\n    if (e >= p - 1) {\n        m = m + (0, utils_1.repeat)('0', e - p + 1);\n        int = e + 1;\n    }\n    else if (e >= 0) {\n        m = \"\".concat(m.slice(0, e + 1), \".\").concat(m.slice(e + 1));\n        int = e + 1;\n    }\n    else {\n        m = \"0.\".concat((0, utils_1.repeat)('0', -e - 1)).concat(m);\n        int = 1;\n    }\n    if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n        var cut = maxPrecision - minPrecision;\n        while (cut > 0 && m[m.length - 1] === '0') {\n            m = m.slice(0, -1);\n            cut--;\n        }\n        if (m[m.length - 1] === '.') {\n            m = m.slice(0, -1);\n        }\n    }\n    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };\n    // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n    function adjustDecimalPlace(x, magnitude) {\n        return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n    }\n}\nexports.ToRawPrecision = ToRawPrecision;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}