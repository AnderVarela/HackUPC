{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isStrongPrecedenceNode = exports.getWrappingFixer = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\n/**\n * Wraps node with some code. Adds parenthesis as necessary.\n * @returns Fixer which adds the specified code and parens if necessary.\n */\nfunction getWrappingFixer(params) {\n  const {\n    sourceCode,\n    node,\n    innerNode = node,\n    wrap\n  } = params;\n  const innerNodes = Array.isArray(innerNode) ? innerNode : [innerNode];\n  return fixer => {\n    const innerCodes = innerNodes.map(innerNode => {\n      let code = sourceCode.getText(innerNode);\n      // check the inner expression's precedence\n      if (!isStrongPrecedenceNode(innerNode)) {\n        // the code we are adding might have stronger precedence than our wrapped node\n        // let's wrap our node in parens in case it has a weaker precedence than the code we are wrapping it in\n        code = `(${code})`;\n      }\n      return code;\n    });\n    // do the wrapping\n    let code = wrap(...innerCodes);\n    // check the outer expression's precedence\n    if (isWeakPrecedenceParent(node)) {\n      // we wrapped the node in some expression which very likely has a different precedence than original wrapped node\n      // let's wrap the whole expression in parens just in case\n      if (!utils_1.ASTUtils.isParenthesized(node, sourceCode)) {\n        code = `(${code})`;\n      }\n    }\n    // check if we need to insert semicolon\n    if (/^[`([]/.exec(code) && isMissingSemicolonBefore(node, sourceCode)) {\n      code = `;${code}`;\n    }\n    return fixer.replaceText(node, code);\n  };\n}\nexports.getWrappingFixer = getWrappingFixer;\n/**\n * Check if a node will always have the same precedence if it's parent changes.\n */\nfunction isStrongPrecedenceNode(innerNode) {\n  return innerNode.type === utils_1.AST_NODE_TYPES.Literal || innerNode.type === utils_1.AST_NODE_TYPES.Identifier || innerNode.type === utils_1.AST_NODE_TYPES.ArrayExpression || innerNode.type === utils_1.AST_NODE_TYPES.ObjectExpression || innerNode.type === utils_1.AST_NODE_TYPES.MemberExpression || innerNode.type === utils_1.AST_NODE_TYPES.CallExpression || innerNode.type === utils_1.AST_NODE_TYPES.NewExpression || innerNode.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression;\n}\nexports.isStrongPrecedenceNode = isStrongPrecedenceNode;\n/**\n * Check if a node's parent could have different precedence if the node changes.\n */\nfunction isWeakPrecedenceParent(node) {\n  const parent = node.parent;\n  if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression || parent.type === utils_1.AST_NODE_TYPES.UnaryExpression || parent.type === utils_1.AST_NODE_TYPES.BinaryExpression || parent.type === utils_1.AST_NODE_TYPES.LogicalExpression || parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression || parent.type === utils_1.AST_NODE_TYPES.AwaitExpression) {\n    return true;\n  }\n  if (parent.type === utils_1.AST_NODE_TYPES.MemberExpression && parent.object === node) {\n    return true;\n  }\n  if ((parent.type === utils_1.AST_NODE_TYPES.CallExpression || parent.type === utils_1.AST_NODE_TYPES.NewExpression) && parent.callee === node) {\n    return true;\n  }\n  if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression && parent.tag === node) {\n    return true;\n  }\n  return false;\n}\n/**\n * Returns true if a node is at the beginning of expression statement and the statement above doesn't end with semicolon.\n * Doesn't check if the node begins with `(`, `[` or `` ` ``.\n */\nfunction isMissingSemicolonBefore(node, sourceCode) {\n  for (;;) {\n    const parent = node.parent;\n    if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n      const block = parent.parent;\n      if (block.type === utils_1.AST_NODE_TYPES.Program || block.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n        // parent is an expression statement in a block\n        const statementIndex = block.body.indexOf(parent);\n        const previousStatement = block.body[statementIndex - 1];\n        if (statementIndex > 0 && sourceCode.getLastToken(previousStatement).value !== ';') {\n          return true;\n        }\n      }\n    }\n    if (!isLeftHandSide(node)) {\n      return false;\n    }\n    node = parent;\n  }\n}\n/**\n * Checks if a node is LHS of an operator.\n */\nfunction isLeftHandSide(node) {\n  const parent = node.parent;\n  // a++\n  if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression) {\n    return true;\n  }\n  // a + b\n  if ((parent.type === utils_1.AST_NODE_TYPES.BinaryExpression || parent.type === utils_1.AST_NODE_TYPES.LogicalExpression || parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) && node === parent.left) {\n    return true;\n  }\n  // a ? b : c\n  if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression && node === parent.test) {\n    return true;\n  }\n  // a(b)\n  if (parent.type === utils_1.AST_NODE_TYPES.CallExpression && node === parent.callee) {\n    return true;\n  }\n  // a`b`\n  if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression && node === parent.tag) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["utils_1","require","getWrappingFixer","params","sourceCode","node","innerNode","wrap","innerNodes","Array","isArray","fixer","innerCodes","map","code","getText","isStrongPrecedenceNode","isWeakPrecedenceParent","ASTUtils","isParenthesized","exec","isMissingSemicolonBefore","replaceText","exports","type","AST_NODE_TYPES","Literal","Identifier","ArrayExpression","ObjectExpression","MemberExpression","CallExpression","NewExpression","TaggedTemplateExpression","parent","UpdateExpression","UnaryExpression","BinaryExpression","LogicalExpression","ConditionalExpression","AwaitExpression","object","callee","tag","ExpressionStatement","block","Program","BlockStatement","statementIndex","body","indexOf","previousStatement","getLastToken","value","isLeftHandSide","AssignmentExpression","left","test"],"sources":["../../src/util/getWrappingFixer.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}