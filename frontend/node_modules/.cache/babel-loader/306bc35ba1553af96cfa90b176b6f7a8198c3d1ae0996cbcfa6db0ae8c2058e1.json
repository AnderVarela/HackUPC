{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst shared_1 = require(\"./enum-utils/shared\");\n/**\n * @returns Whether the right type is an unsafe comparison against any left type.\n */\nfunction typeViolates(leftTypeParts, right) {\n  const leftValueKinds = new Set(leftTypeParts.map(getEnumValueType));\n  return leftValueKinds.has(ts.TypeFlags.Number) && tsutils.isTypeFlagSet(right, ts.TypeFlags.Number | ts.TypeFlags.NumberLike) || leftValueKinds.has(ts.TypeFlags.String) && tsutils.isTypeFlagSet(right, ts.TypeFlags.String | ts.TypeFlags.StringLike);\n}\n/**\n * @returns What type a type's enum value is (number or string), if either.\n */\nfunction getEnumValueType(type) {\n  return util.isTypeFlagSet(type, ts.TypeFlags.EnumLike) ? util.isTypeFlagSet(type, ts.TypeFlags.NumberLiteral) ? ts.TypeFlags.Number : ts.TypeFlags.String : undefined;\n}\nexports.default = util.createRule({\n  name: 'no-unsafe-enum-comparison',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow comparing an enum value with a non-enum value',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      mismatched: 'The two values in this comparison do not have a shared enum type.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    function getTypeFromNode(node) {\n      return typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node));\n    }\n    return {\n      'BinaryExpression[operator=/=|<|>/]'(node) {\n        const left = getTypeFromNode(node.left);\n        const right = getTypeFromNode(node.right);\n        // Allow comparisons that don't have anything to do with enums:\n        //\n        // ```ts\n        // 1 === 2;\n        // ```\n        const leftEnumTypes = (0, shared_1.getEnumTypes)(typeChecker, left);\n        const rightEnumTypes = new Set((0, shared_1.getEnumTypes)(typeChecker, right));\n        if (leftEnumTypes.length === 0 && rightEnumTypes.size === 0) {\n          return;\n        }\n        // Allow comparisons that share an enum type:\n        //\n        // ```ts\n        // Fruit.Apple === Fruit.Banana;\n        // ```\n        for (const leftEnumType of leftEnumTypes) {\n          if (rightEnumTypes.has(leftEnumType)) {\n            return;\n          }\n        }\n        const leftTypeParts = tsutils.unionTypeParts(left);\n        const rightTypeParts = tsutils.unionTypeParts(right);\n        // If a type exists in both sides, we consider this comparison safe:\n        //\n        // ```ts\n        // declare const fruit: Fruit.Apple | 0;\n        // fruit === 0;\n        // ```\n        for (const leftTypePart of leftTypeParts) {\n          if (rightTypeParts.includes(leftTypePart)) {\n            return;\n          }\n        }\n        if (typeViolates(leftTypeParts, right) || typeViolates(rightTypeParts, left)) {\n          context.report({\n            messageId: 'mismatched',\n            node\n          });\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["tsutils","__importStar","require","ts","util","shared_1","typeViolates","leftTypeParts","right","leftValueKinds","Set","map","getEnumValueType","has","TypeFlags","Number","isTypeFlagSet","NumberLike","String","StringLike","type","EnumLike","NumberLiteral","undefined","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","mismatched","schema","defaultOptions","create","context","parserServices","getParserServices","typeChecker","program","getTypeChecker","getTypeFromNode","node","getTypeAtLocation","esTreeNodeToTSNodeMap","get","BinaryExpression[operator=/=|<|>/]","left","leftEnumTypes","getEnumTypes","rightEnumTypes","length","size","leftEnumType","unionTypeParts","rightTypeParts","leftTypePart","includes","report","messageId"],"sources":["../../src/rules/no-unsafe-enum-comparison.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}