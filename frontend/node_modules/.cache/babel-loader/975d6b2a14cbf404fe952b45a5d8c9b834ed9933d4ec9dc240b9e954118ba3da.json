{"ast":null,"code":"/* eslint-disable no-param-reassign */\n\nfunction isInside(scope, regex) {\n  if (!scope.hub.file.opts) {\n    return true;\n  }\n  const filename = scope.hub.file.opts.filename;\n  if (!filename) {\n    return true;\n  }\n  if (!regex) {\n    return false;\n  }\n  return regex.test(filename);\n}\n\n// Remove a specific path.\nexport default function remove(path, globalOptions, options) {\n  const {\n    visitedKey,\n    unsafeWrapTemplate,\n    wrapTemplate,\n    mode,\n    ignoreFilenames,\n    types\n  } = globalOptions;\n  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {\n    return;\n  }\n\n  // Prevent infinity loop.\n  if (path.node[visitedKey]) {\n    return;\n  }\n  path.node[visitedKey] = true;\n  if (mode === 'remove') {\n    // remove() crash in some conditions.\n    if (path.parentPath.type === 'ConditionalExpression') {\n      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)));\n    } else {\n      path.remove();\n    }\n    return;\n  }\n  if (mode === 'wrap' || mode === 'unsafe-wrap') {\n    switch (options.type) {\n      // This is legacy, we do not optimize it.\n      case 'createClass':\n        break;\n\n      // Inspired from babel-plugin-transform-class-properties.\n      case 'class static':\n        {\n          let ref;\n          let pathClassDeclaration = options.pathClassDeclaration;\n          if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {\n            ref = pathClassDeclaration.node.id;\n          } else {\n            // Class without name not supported\n            return;\n          }\n          const node = types.expressionStatement(types.assignmentExpression('=', types.memberExpression(ref, path.node.key), path.node.value));\n\n          // We need to append the node at the parent level in this case.\n          if (pathClassDeclaration.parentPath.isExportDeclaration()) {\n            pathClassDeclaration = pathClassDeclaration.parentPath;\n          }\n          pathClassDeclaration.insertAfter(node);\n          path.remove();\n          break;\n        }\n      case 'assign':\n        if (mode === 'unsafe-wrap') {\n          path.replaceWith(unsafeWrapTemplate({\n            NODE: path.node\n          }));\n        } else {\n          path.replaceWith(wrapTemplate({\n            LEFT: path.node.left,\n            RIGHT: path.node.right\n          }));\n        }\n        path.node[visitedKey] = true;\n        break;\n      case 'declarator':\n        path.replaceWith(wrapTemplate({\n          LEFT: path.node.id,\n          RIGHT: path.node.init\n        }, {\n          as: 'variableDeclarator'\n        }));\n        path.node[visitedKey] = true;\n        break;\n      default:\n        break;\n    }\n    return;\n  }\n  throw new Error(`transform-react-remove-prop-type: unsupported mode ${mode}.`);\n}","map":{"version":3,"names":["isInside","scope","regex","hub","file","opts","filename","test","remove","path","globalOptions","options","visitedKey","unsafeWrapTemplate","wrapTemplate","mode","ignoreFilenames","types","node","parentPath","type","replaceWith","unaryExpression","numericLiteral","ref","pathClassDeclaration","isClassExpression","id","expressionStatement","assignmentExpression","memberExpression","key","value","isExportDeclaration","insertAfter","NODE","LEFT","left","RIGHT","right","init","as","Error"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/src/remove.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\n\nfunction isInside(scope, regex) {\n  if (!scope.hub.file.opts) {\n    return true\n  }\n\n  const filename = scope.hub.file.opts.filename\n\n  if (!filename) {\n    return true\n  }\n\n  if (!regex) {\n    return false\n  }\n\n  return regex.test(filename)\n}\n\n// Remove a specific path.\nexport default function remove(path, globalOptions, options) {\n  const {\n    visitedKey,\n    unsafeWrapTemplate,\n    wrapTemplate,\n    mode,\n    ignoreFilenames,\n    types,\n  } = globalOptions\n\n  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {\n    return\n  }\n\n  // Prevent infinity loop.\n  if (path.node[visitedKey]) {\n    return\n  }\n\n  path.node[visitedKey] = true\n\n  if (mode === 'remove') {\n    // remove() crash in some conditions.\n    if (path.parentPath.type === 'ConditionalExpression') {\n      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)))\n    } else {\n      path.remove()\n    }\n\n    return\n  }\n\n  if (mode === 'wrap' || mode === 'unsafe-wrap') {\n    switch (options.type) {\n      // This is legacy, we do not optimize it.\n      case 'createClass':\n        break\n\n      // Inspired from babel-plugin-transform-class-properties.\n      case 'class static': {\n        let ref\n        let pathClassDeclaration = options.pathClassDeclaration\n\n        if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {\n          ref = pathClassDeclaration.node.id\n        } else {\n          // Class without name not supported\n          return\n        }\n\n        const node = types.expressionStatement(\n          types.assignmentExpression(\n            '=',\n            types.memberExpression(ref, path.node.key),\n            path.node.value\n          )\n        )\n\n        // We need to append the node at the parent level in this case.\n        if (pathClassDeclaration.parentPath.isExportDeclaration()) {\n          pathClassDeclaration = pathClassDeclaration.parentPath\n        }\n        pathClassDeclaration.insertAfter(node)\n        path.remove()\n        break\n      }\n\n      case 'assign':\n        if (mode === 'unsafe-wrap') {\n          path.replaceWith(\n            unsafeWrapTemplate({\n              NODE: path.node,\n            })\n          )\n        } else {\n          path.replaceWith(\n            wrapTemplate({\n              LEFT: path.node.left,\n              RIGHT: path.node.right,\n            })\n          )\n        }\n        path.node[visitedKey] = true\n        break\n\n      case 'declarator':\n        path.replaceWith(\n          wrapTemplate(\n            {\n              LEFT: path.node.id,\n              RIGHT: path.node.init,\n            },\n            { as: 'variableDeclarator' }\n          )\n        )\n        path.node[visitedKey] = true\n        break\n\n      default:\n        break\n    }\n\n    return\n  }\n\n  throw new Error(`transform-react-remove-prop-type: unsupported mode ${mode}.`)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}