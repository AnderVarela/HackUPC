{"ast":null,"code":"/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport fs from \"fs\";\nimport importFresh from \"import-fresh\";\nimport { createRequire } from \"module\";\nimport path from \"path\";\nimport stripComments from \"strip-json-comments\";\nimport { ConfigArray, ConfigDependency, IgnorePattern, OverrideTester } from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport * as naming from \"./shared/naming.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\nconst require = createRequire(import.meta.url);\nconst debug = debugOrig(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\".eslintrc.js\", \".eslintrc.cjs\", \".eslintrc.yaml\", \".eslintrc.yml\", \".eslintrc.json\", \".eslintrc\", \"package.json\"];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/** @type {WeakMap<object, Plugin>} */\nconst normalizedPlugins = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n  return /^\\.{1,2}[/\\\\]/u.test(nameOrPath) || path.isAbsolute(nameOrPath);\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n  debug(`Loading YAML config file: ${filePath}`);\n\n  // lazy load YAML to improve performance when not used\n  const yaml = require(\"js-yaml\");\n  try {\n    // empty YAML file can be null, so always use\n    return yaml.load(readFile(filePath)) || {};\n  } catch (e) {\n    debug(`Error reading YAML file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n  debug(`Loading JSON config file: ${filePath}`);\n  try {\n    return JSON.parse(stripComments(readFile(filePath)));\n  } catch (e) {\n    debug(`Error reading JSON file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    e.messageTemplate = \"failed-to-read-json\";\n    e.messageData = {\n      path: filePath,\n      message: e.message\n    };\n    throw e;\n  }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n  debug(`Loading legacy config file: ${filePath}`);\n\n  // lazy load YAML to improve performance when not used\n  const yaml = require(\"js-yaml\");\n  try {\n    return yaml.load(stripComments(readFile(filePath))) || /* istanbul ignore next */{};\n  } catch (e) {\n    debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n  debug(`Loading JS config file: ${filePath}`);\n  try {\n    return importFresh(filePath);\n  } catch (e) {\n    debug(`Error reading JavaScript file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n  debug(`Loading package.json config file: ${filePath}`);\n  try {\n    const packageData = loadJSONConfigFile(filePath);\n    if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n      throw Object.assign(new Error(\"package.json file doesn't have 'eslintConfig' field.\"), {\n        code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\"\n      });\n    }\n    return packageData.eslintConfig;\n  } catch (e) {\n    debug(`Error reading package.json file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n  debug(`Loading .eslintignore file: ${filePath}`);\n  try {\n    return readFile(filePath).split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading .eslintignore file: ${filePath}`);\n    e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n  return Object.assign(new Error(`Failed to load config \"${configName}\" to extend from.`), {\n    messageTemplate,\n    messageData: {\n      configName,\n      importerName\n    }\n  });\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n  switch (path.extname(filePath)) {\n    case \".js\":\n    case \".cjs\":\n      return loadJSConfigFile(filePath);\n    case \".json\":\n      if (path.basename(filePath) === \"package.json\") {\n        return loadPackageJSONConfigFile(filePath);\n      }\n      return loadJSONConfigFile(filePath);\n    case \".yaml\":\n    case \".yml\":\n      return loadYAMLConfigFile(filePath);\n    default:\n      return loadLegacyConfigFile(filePath);\n  }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n  /* istanbul ignore next */\n  if (debug.enabled) {\n    let nameAndVersion = null;\n    try {\n      const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);\n      const {\n        version = \"unknown\"\n      } = require(packageJsonPath);\n      nameAndVersion = `${request}@${version}`;\n    } catch (error) {\n      debug(\"package.json was not found:\", error.message);\n      nameAndVersion = request;\n    }\n    debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n  }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext({\n  cwd,\n  resolvePluginsRelativeTo\n}, providedType, providedName, providedFilePath, providedMatchBasePath) {\n  const filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : \"\";\n  const matchBasePath = providedMatchBasePath && path.resolve(cwd, providedMatchBasePath) || filePath && path.dirname(filePath) || cwd;\n  const name = providedName || filePath && path.relative(cwd, filePath) || \"\";\n  const pluginBasePath = resolvePluginsRelativeTo || filePath && path.dirname(filePath) || cwd;\n  const type = providedType || \"config\";\n  return {\n    filePath,\n    matchBasePath,\n    name,\n    pluginBasePath,\n    type\n  };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n  // first check the cache\n  let normalizedPlugin = normalizedPlugins.get(plugin);\n  if (normalizedPlugin) {\n    return normalizedPlugin;\n  }\n  normalizedPlugin = {\n    configs: plugin.configs || {},\n    environments: plugin.environments || {},\n    processors: plugin.processors || {},\n    rules: plugin.rules || {}\n  };\n\n  // save the reference for later\n  normalizedPlugins.set(plugin, normalizedPlugin);\n  return normalizedPlugin;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n  /**\n   * Initialize this instance.\n   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n   */\n  constructor({\n    additionalPluginPool = new Map(),\n    cwd = process.cwd(),\n    resolvePluginsRelativeTo,\n    builtInRules,\n    resolver = ModuleResolver,\n    eslintAllPath,\n    getEslintAllConfig,\n    eslintRecommendedPath,\n    getEslintRecommendedConfig\n  } = {}) {\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo: resolvePluginsRelativeTo && path.resolve(cwd, resolvePluginsRelativeTo),\n      builtInRules,\n      resolver,\n      eslintAllPath,\n      getEslintAllConfig,\n      eslintRecommendedPath,\n      getEslintRecommendedConfig\n    });\n  }\n\n  /**\n   * Create `ConfigArray` instance from a config data.\n   * @param {ConfigData|null} configData The config data to create.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.filePath] The path to this config data.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n  create(configData, {\n    basePath,\n    filePath,\n    name\n  } = {}) {\n    if (!configData) {\n      return new ConfigArray();\n    }\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    const elements = this._normalizeConfigData(configData, ctx);\n    return new ConfigArray(...elements);\n  }\n\n  /**\n   * Load a config file.\n   * @param {string} filePath The path to a config file.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n  loadFile(filePath, {\n    basePath,\n    name\n  } = {}) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    return new ConfigArray(...this._loadConfigData(ctx));\n  }\n\n  /**\n   * Load the config file on a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadInDirectory(directoryPath, {\n    basePath,\n    name\n  } = {}) {\n    const slots = internalSlotsMap.get(this);\n    for (const filename of configFilenames) {\n      const ctx = createContext(slots, \"config\", name, path.join(directoryPath, filename), basePath);\n      if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n        let configData;\n        try {\n          configData = loadConfigFile(ctx.filePath);\n        } catch (error) {\n          if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n            throw error;\n          }\n        }\n        if (configData) {\n          debug(`Config file found: ${ctx.filePath}`);\n          return new ConfigArray(...this._normalizeConfigData(configData, ctx));\n        }\n      }\n    }\n    debug(`Config file not found on ${directoryPath}`);\n    return new ConfigArray();\n  }\n\n  /**\n   * Check if a config file on a given directory exists or not.\n   * @param {string} directoryPath The path to a directory.\n   * @returns {string | null} The path to the found config file. If not found then null.\n   */\n  static getPathToConfigFileInDirectory(directoryPath) {\n    for (const filename of configFilenames) {\n      const filePath = path.join(directoryPath, filename);\n      if (fs.existsSync(filePath)) {\n        if (filename === \"package.json\") {\n          try {\n            loadPackageJSONConfigFile(filePath);\n            return filePath;\n          } catch {/* ignore */}\n        } else {\n          return filePath;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Load `.eslintignore` file.\n   * @param {string} filePath The path to a `.eslintignore` file to load.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadESLintIgnore(filePath) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"ignore\", void 0, filePath, slots.cwd);\n    const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n    return new ConfigArray(...this._normalizeESLintIgnoreData(ignorePatterns, ctx));\n  }\n\n  /**\n   * Load `.eslintignore` file in the current working directory.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n  loadDefaultESLintIgnore() {\n    const slots = internalSlotsMap.get(this);\n    const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n    const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n    if (fs.existsSync(eslintIgnorePath)) {\n      return this.loadESLintIgnore(eslintIgnorePath);\n    }\n    if (fs.existsSync(packageJsonPath)) {\n      const data = loadJSONConfigFile(packageJsonPath);\n      if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n        if (!Array.isArray(data.eslintIgnore)) {\n          throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n        }\n        const ctx = createContext(slots, \"ignore\", \"eslintIgnore in package.json\", packageJsonPath, slots.cwd);\n        return new ConfigArray(...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx));\n      }\n    }\n    return new ConfigArray();\n  }\n\n  /**\n   * Load a given config file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n   * @private\n   */\n  _loadConfigData(ctx) {\n    return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n  }\n\n  /**\n   * Normalize a given `.eslintignore` data to config array elements.\n   * @param {string[]} ignorePatterns The patterns to ignore files.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n    const elements = this._normalizeObjectConfigData({\n      ignorePatterns\n    }, ctx);\n\n    // Set `ignorePattern.loose` flag for backward compatibility.\n    for (const element of elements) {\n      if (element.ignorePattern) {\n        element.ignorePattern.loose = true;\n      }\n      yield element;\n    }\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _normalizeConfigData(configData, ctx) {\n    const validator = new ConfigValidator();\n    validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n    return this._normalizeObjectConfigData(configData, ctx);\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeObjectConfigData(configData, ctx) {\n    const {\n      files,\n      excludedFiles,\n      ...configBody\n    } = configData;\n    const criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);\n    const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n    // Apply the criteria to every element.\n    for (const element of elements) {\n      /*\n       * Merge the criteria.\n       * This is for the `overrides` entries that came from the\n       * configurations of `overrides[].extends`.\n       */\n      element.criteria = OverrideTester.and(criteria, element.criteria);\n\n      /*\n       * Remove `root` property to ignore `root` settings which came from\n       * `extends` in `overrides`.\n       */\n      if (element.criteria) {\n        element.root = void 0;\n      }\n      yield element;\n    }\n  }\n\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  *_normalizeObjectConfigDataBody({\n    env,\n    extends: extend,\n    globals,\n    ignorePatterns,\n    noInlineConfig,\n    parser: parserName,\n    parserOptions,\n    plugins: pluginList,\n    processor,\n    reportUnusedDisableDirectives,\n    root,\n    rules,\n    settings,\n    overrides: overrideList = []\n  }, ctx) {\n    const extendList = Array.isArray(extend) ? extend : [extend];\n    const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath);\n\n    // Flatten `extends`.\n    for (const extendName of extendList.filter(Boolean)) {\n      yield* this._loadExtends(extendName, ctx);\n    }\n\n    // Load parser & plugins.\n    const parser = parserName && this._loadParser(parserName, ctx);\n    const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n    // Yield pseudo config data for file extension processors.\n    if (plugins) {\n      yield* this._takeFileExtensionProcessors(plugins, ctx);\n    }\n\n    // Yield the config data except `extends` and `overrides`.\n    yield {\n      // Debug information.\n      type: ctx.type,\n      name: ctx.name,\n      filePath: ctx.filePath,\n      // Config data.\n      criteria: null,\n      env,\n      globals,\n      ignorePattern,\n      noInlineConfig,\n      parser,\n      parserOptions,\n      plugins,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings\n    };\n\n    // Flatten `overries`.\n    for (let i = 0; i < overrideList.length; ++i) {\n      yield* this._normalizeObjectConfigData(overrideList[i], {\n        ...ctx,\n        name: `${ctx.name}#overrides[${i}]`\n      });\n    }\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtends(extendName, ctx) {\n    debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n    try {\n      if (extendName.startsWith(\"eslint:\")) {\n        return this._loadExtendedBuiltInConfig(extendName, ctx);\n      }\n      if (extendName.startsWith(\"plugin:\")) {\n        return this._loadExtendedPluginConfig(extendName, ctx);\n      }\n      return this._loadExtendedShareableConfig(extendName, ctx);\n    } catch (error) {\n      error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n      throw error;\n    }\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedBuiltInConfig(extendName, ctx) {\n    const {\n      eslintAllPath,\n      getEslintAllConfig,\n      eslintRecommendedPath,\n      getEslintRecommendedConfig\n    } = internalSlotsMap.get(this);\n    if (extendName === \"eslint:recommended\") {\n      const name = `${ctx.name} » ${extendName}`;\n      if (getEslintRecommendedConfig) {\n        if (typeof getEslintRecommendedConfig !== \"function\") {\n          throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);\n        }\n        return this._normalizeConfigData(getEslintRecommendedConfig(), {\n          ...ctx,\n          name,\n          filePath: \"\"\n        });\n      }\n      return this._loadConfigData({\n        ...ctx,\n        name,\n        filePath: eslintRecommendedPath\n      });\n    }\n    if (extendName === \"eslint:all\") {\n      const name = `${ctx.name} » ${extendName}`;\n      if (getEslintAllConfig) {\n        if (typeof getEslintAllConfig !== \"function\") {\n          throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);\n        }\n        return this._normalizeConfigData(getEslintAllConfig(), {\n          ...ctx,\n          name,\n          filePath: \"\"\n        });\n      }\n      return this._loadConfigData({\n        ...ctx,\n        name,\n        filePath: eslintAllPath\n      });\n    }\n    throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedPluginConfig(extendName, ctx) {\n    const slashIndex = extendName.lastIndexOf(\"/\");\n    if (slashIndex === -1) {\n      throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n    }\n    const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n    const configName = extendName.slice(slashIndex + 1);\n    if (isFilePath(pluginName)) {\n      throw new Error(\"'extends' cannot use a file path for plugins.\");\n    }\n    const plugin = this._loadPlugin(pluginName, ctx);\n    const configData = plugin.definition && plugin.definition.configs[configName];\n    if (configData) {\n      return this._normalizeConfigData(configData, {\n        ...ctx,\n        filePath: plugin.filePath || ctx.filePath,\n        name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n      });\n    }\n    throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n  }\n\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n  _loadExtendedShareableConfig(extendName, ctx) {\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    let request;\n    if (isFilePath(extendName)) {\n      request = extendName;\n    } else if (extendName.startsWith(\".\")) {\n      request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n    } else {\n      request = naming.normalizePackageName(extendName, \"eslint-config\");\n    }\n    let filePath;\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (error) {\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n      }\n      throw error;\n    }\n    writeDebugLogForLoading(request, relativeTo, filePath);\n    return this._loadConfigData({\n      ...ctx,\n      filePath,\n      name: `${ctx.name} » ${request}`\n    });\n  }\n\n  /**\n   * Load given plugins.\n   * @param {string[]} names The plugin names to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {Record<string,DependentPlugin>} The loaded parser.\n   * @private\n   */\n  _loadPlugins(names, ctx) {\n    return names.reduce((map, name) => {\n      if (isFilePath(name)) {\n        throw new Error(\"Plugins array cannot includes file paths.\");\n      }\n      const plugin = this._loadPlugin(name, ctx);\n      map[plugin.id] = plugin;\n      return map;\n    }, {});\n  }\n\n  /**\n   * Load a given parser.\n   * @param {string} nameOrPath The package name or the path to a parser file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentParser} The loaded parser.\n   */\n  _loadParser(nameOrPath, ctx) {\n    debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    try {\n      const filePath = resolver.resolve(nameOrPath, relativeTo);\n      writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n      return new ConfigDependency({\n        definition: require(filePath),\n        filePath,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } catch (error) {\n      // If the parser name is \"espree\", load the espree of ESLint.\n      if (nameOrPath === \"espree\") {\n        debug(\"Fallback espree.\");\n        return new ConfigDependency({\n          definition: require(\"espree\"),\n          filePath: require.resolve(\"espree\"),\n          id: nameOrPath,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      }\n      debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n      error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n      return new ConfigDependency({\n        error,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n  }\n\n  /**\n   * Load a given plugin.\n   * @param {string} name The plugin name to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentPlugin} The loaded plugin.\n   * @private\n   */\n  _loadPlugin(name, ctx) {\n    debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n    const {\n      additionalPluginPool,\n      resolver\n    } = internalSlotsMap.get(this);\n    const request = naming.normalizePackageName(name, \"eslint-plugin\");\n    const id = naming.getShorthandName(request, \"eslint-plugin\");\n    const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n    if (name.match(/\\s+/u)) {\n      const error = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {\n        messageTemplate: \"whitespace-found\",\n        messageData: {\n          pluginName: request\n        }\n      });\n      return new ConfigDependency({\n        error,\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n\n    // Check for additional pool.\n    const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);\n    if (plugin) {\n      return new ConfigDependency({\n        definition: normalizePlugin(plugin),\n        original: plugin,\n        filePath: \"\",\n        // It's unknown where the plugin came from.\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n    let filePath;\n    let error;\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (resolveError) {\n      error = resolveError;\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        error.messageTemplate = \"plugin-missing\";\n        error.messageData = {\n          pluginName: request,\n          resolvePluginsRelativeTo: ctx.pluginBasePath,\n          importerName: ctx.name\n        };\n      }\n    }\n    if (filePath) {\n      try {\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        const startTime = Date.now();\n        const pluginDefinition = require(filePath);\n        debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n        return new ConfigDependency({\n          definition: normalizePlugin(pluginDefinition),\n          original: pluginDefinition,\n          filePath,\n          id,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      } catch (loadError) {\n        error = loadError;\n      }\n    }\n    debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n    error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n    return new ConfigDependency({\n      error,\n      id,\n      importerName: ctx.name,\n      importerPath: ctx.filePath\n    });\n  }\n\n  /**\n   * Take file expression processors as config array elements.\n   * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n   * @private\n   */\n  *_takeFileExtensionProcessors(plugins, ctx) {\n    for (const pluginId of Object.keys(plugins)) {\n      const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;\n      if (!processors) {\n        continue;\n      }\n      for (const processorId of Object.keys(processors)) {\n        if (processorId.startsWith(\".\")) {\n          yield* this._normalizeObjectConfigData({\n            files: [`*${processorId}`],\n            processor: `${pluginId}/${processorId}`\n          }, {\n            ...ctx,\n            type: \"implicit-processor\",\n            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n          });\n        }\n      }\n    }\n  }\n}\nexport { ConfigArrayFactory, createContext };","map":{"version":3,"names":["debugOrig","fs","importFresh","createRequire","path","stripComments","ConfigArray","ConfigDependency","IgnorePattern","OverrideTester","ConfigValidator","naming","ModuleResolver","require","import","meta","url","debug","configFilenames","internalSlotsMap","WeakMap","normalizedPlugins","isFilePath","nameOrPath","test","isAbsolute","readFile","filePath","readFileSync","replace","loadYAMLConfigFile","yaml","load","e","message","loadJSONConfigFile","JSON","parse","messageTemplate","messageData","loadLegacyConfigFile","loadJSConfigFile","loadPackageJSONConfigFile","packageData","Object","hasOwnProperty","call","assign","Error","code","eslintConfig","loadESLintIgnoreFile","split","filter","line","trim","startsWith","configInvalidError","configName","importerName","loadConfigFile","extname","basename","writeDebugLogForLoading","request","relativeTo","enabled","nameAndVersion","packageJsonPath","resolve","version","error","createContext","cwd","resolvePluginsRelativeTo","providedType","providedName","providedFilePath","providedMatchBasePath","matchBasePath","dirname","name","relative","pluginBasePath","type","normalizePlugin","plugin","normalizedPlugin","get","configs","environments","processors","rules","set","ConfigArrayFactory","constructor","additionalPluginPool","Map","process","builtInRules","resolver","eslintAllPath","getEslintAllConfig","eslintRecommendedPath","getEslintRecommendedConfig","create","configData","basePath","slots","ctx","elements","_normalizeConfigData","loadFile","_loadConfigData","loadInDirectory","directoryPath","filename","join","existsSync","statSync","isFile","getPathToConfigFileInDirectory","loadESLintIgnore","ignorePatterns","_normalizeESLintIgnoreData","loadDefaultESLintIgnore","eslintIgnorePath","data","Array","isArray","eslintIgnore","_normalizeObjectConfigData","element","ignorePattern","loose","validator","validateConfigSchema","files","excludedFiles","configBody","criteria","_normalizeObjectConfigDataBody","and","root","env","extends","extend","globals","noInlineConfig","parser","parserName","parserOptions","plugins","pluginList","processor","reportUnusedDisableDirectives","settings","overrides","overrideList","extendList","extendName","Boolean","_loadExtends","_loadParser","_loadPlugins","_takeFileExtensionProcessors","i","length","_loadExtendedBuiltInConfig","_loadExtendedPluginConfig","_loadExtendedShareableConfig","slashIndex","lastIndexOf","pluginName","slice","_loadPlugin","definition","id","normalizePackageName","names","reduce","map","importerPath","getShorthandName","match","original","resolveError","startTime","Date","now","pluginDefinition","loadError","pluginId","keys","processorId"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/lib/config-array-factory.js"],"sourcesContent":["/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport fs from \"fs\";\nimport importFresh from \"import-fresh\";\nimport { createRequire } from \"module\";\nimport path from \"path\";\nimport stripComments from \"strip-json-comments\";\n\nimport {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport * as naming from \"./shared/naming.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\n\nconst require = createRequire(import.meta.url);\n\nconst debug = debugOrig(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/** @type {WeakMap<object, Plugin>} */\nconst normalizedPlugins = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.load(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.load(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate,\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext(\n    { cwd, resolvePluginsRelativeTo },\n    providedType,\n    providedName,\n    providedFilePath,\n    providedMatchBasePath\n) {\n    const filePath = providedFilePath\n        ? path.resolve(cwd, providedFilePath)\n        : \"\";\n    const matchBasePath =\n        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const name =\n        providedName ||\n        (filePath && path.relative(cwd, filePath)) ||\n        \"\";\n    const pluginBasePath =\n        resolvePluginsRelativeTo ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const type = providedType || \"config\";\n\n    return { filePath, matchBasePath, name, pluginBasePath, type };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n\n    // first check the cache\n    let normalizedPlugin = normalizedPlugins.get(plugin);\n\n    if (normalizedPlugin) {\n        return normalizedPlugin;\n    }\n\n    normalizedPlugin = {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n\n    // save the reference for later\n    normalizedPlugins.set(plugin, normalizedPlugin);\n\n    return normalizedPlugin;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo,\n        builtInRules,\n        resolver = ModuleResolver,\n        eslintAllPath,\n        getEslintAllConfig,\n        eslintRecommendedPath,\n        getEslintRecommendedConfig\n    } = {}) {\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo:\n                resolvePluginsRelativeTo &&\n                path.resolve(cwd, resolvePluginsRelativeTo),\n            builtInRules,\n            resolver,\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { basePath, filePath, name } = {}) {\n        if (!configData) {\n            return new ConfigArray();\n        }\n\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n        const elements = this._normalizeConfigData(configData, ctx);\n\n        return new ConfigArray(...elements);\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n        return new ConfigArray(...this._loadConfigData(ctx));\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n\n        for (const filename of configFilenames) {\n            const ctx = createContext(\n                slots,\n                \"config\",\n                name,\n                path.join(directoryPath, filename),\n                basePath\n            );\n\n            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(ctx.filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${ctx.filePath}`);\n                    return new ConfigArray(\n                        ...this._normalizeConfigData(configData, ctx)\n                    );\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return new ConfigArray();\n    }\n\n    /**\n     * Check if a config file on a given directory exists or not.\n     * @param {string} directoryPath The path to a directory.\n     * @returns {string | null} The path to the found config file. If not found then null.\n     */\n    static getPathToConfigFileInDirectory(directoryPath) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                if (filename === \"package.json\") {\n                    try {\n                        loadPackageJSONConfigFile(filePath);\n                        return filePath;\n                    } catch { /* ignore */ }\n                } else {\n                    return filePath;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(\n            slots,\n            \"ignore\",\n            void 0,\n            filePath,\n            slots.cwd\n        );\n        const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n\n        return new ConfigArray(\n            ...this._normalizeESLintIgnoreData(ignorePatterns, ctx)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const slots = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                const ctx = createContext(\n                    slots,\n                    \"ignore\",\n                    \"eslintIgnore in package.json\",\n                    packageJsonPath,\n                    slots.cwd\n                );\n\n                return new ConfigArray(\n                    ...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(ctx) {\n        return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            ctx\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, ctx) {\n        const validator = new ConfigValidator();\n\n        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n        return this._normalizeObjectConfigData(configData, ctx);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, ctx) {\n        const { files, excludedFiles, ...configBody } = configData;\n        const criteria = OverrideTester.create(\n            files,\n            excludedFiles,\n            ctx.matchBasePath\n        );\n        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            /*\n             * Merge the criteria.\n             * This is for the `overrides` entries that came from the\n             * configurations of `overrides[].extends`.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        ctx\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            ctx.matchBasePath\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, ctx);\n        }\n\n        // Load parser & plugins.\n        const parser = parserName && this._loadParser(parserName, ctx);\n        const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, ctx);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            type: ctx.type,\n            name: ctx.name,\n            filePath: ctx.filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                { ...ctx, name: `${ctx.name}#overrides[${i}]` }\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, ctx) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(extendName, ctx);\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(extendName, ctx);\n            }\n            return this._loadExtendedShareableConfig(extendName, ctx);\n        } catch (error) {\n            error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, ctx) {\n        const {\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        } = internalSlotsMap.get(this);\n\n        if (extendName === \"eslint:recommended\") {\n            const name = `${ctx.name} » ${extendName}`;\n\n            if (getEslintRecommendedConfig) {\n                if (typeof getEslintRecommendedConfig !== \"function\") {\n                    throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintRecommendedPath\n            });\n        }\n        if (extendName === \"eslint:all\") {\n            const name = `${ctx.name} » ${extendName}`;\n\n            if (getEslintAllConfig) {\n                if (typeof getEslintAllConfig !== \"function\") {\n                    throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintAllPath\n            });\n        }\n\n        throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, ctx) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n\n        if (slashIndex === -1) {\n            throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n        }\n\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, ctx);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(configData, {\n                ...ctx,\n                filePath: plugin.filePath || ctx.filePath,\n                name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n            });\n        }\n\n        throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, ctx) {\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData({\n            ...ctx,\n            filePath,\n            name: `${ctx.name} » ${request}`\n        });\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, ctx) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, ctx);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, ctx) {\n        debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = resolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, ctx) {\n        debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n\n        const { additionalPluginPool, resolver } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                original: plugin,\n                filePath: \"\", // It's unknown where the plugin came from.\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo: ctx.pluginBasePath,\n                    importerName: ctx.name\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    original: pluginDefinition,\n                    filePath,\n                    id,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n        error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName: ctx.name,\n            importerPath: ctx.filePath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, ctx) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        {\n                            ...ctx,\n                            type: \"implicit-processor\",\n                            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n\nexport { ConfigArrayFactory, createContext };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAOA,SAAS,MAAM,OAAO;AAC7B,OAAOC,EAAE,MAAM,IAAI;AACnB,OAAOC,WAAW,MAAM,cAAc;AACtC,SAASC,aAAa,QAAQ,QAAQ;AACtC,OAAOC,IAAI,MAAM,MAAM;AACvB,OAAOC,aAAa,MAAM,qBAAqB;AAE/C,SACIC,WAAW,EACXC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,QACX,yBAAyB;AAChC,OAAOC,eAAe,MAAM,8BAA8B;AAC1D,OAAO,KAAKC,MAAM,MAAM,oBAAoB;AAC5C,OAAO,KAAKC,cAAc,MAAM,sCAAsC;AAEtE,MAAMC,OAAO,GAAGV,aAAa,CAACW,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC;AAE9C,MAAMC,KAAK,GAAGjB,SAAS,CAAC,+BAA+B,CAAC;;AAExD;AACA;AACA;;AAEA,MAAMkB,eAAe,GAAG,CACpB,cAAc,EACd,eAAe,EACf,gBAAgB,EAChB,eAAe,EACf,gBAAgB,EAChB,WAAW,EACX,cAAc,CACjB;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMC,gBAAgB,GAAG,IAAIC,OAAO,CAAC,CAAC;;AAEtC;AACA,MAAMC,iBAAiB,GAAG,IAAID,OAAO,CAAC,CAAC;;AAEvC;AACA;AACA;AACA;AACA;AACA,SAASE,UAAUA,CAACC,UAAU,EAAE;EAC5B,OACI,gBAAgB,CAACC,IAAI,CAACD,UAAU,CA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}