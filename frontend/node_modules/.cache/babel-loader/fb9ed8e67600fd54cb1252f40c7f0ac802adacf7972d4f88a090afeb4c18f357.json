{"ast":null,"code":"// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n\n'use strict';\n\n/*\n * Text wrapping and filling.\n */\n\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/;\nclass TextWrapper {\n  /*\n   *  Object for wrapping/filling text.  The public interface consists of\n   *  the wrap() and fill() methods; the other methods are just there for\n   *  subclasses to override in order to tweak the default behaviour.\n   *  If you want to completely replace the main wrapping algorithm,\n   *  you'll probably have to override _wrap_chunks().\n   *\n   *  Several instance attributes control various aspects of wrapping:\n   *    width (default: 70)\n   *      the maximum width of wrapped lines (unless break_long_words\n   *      is false)\n   *    initial_indent (default: \"\")\n   *      string that will be prepended to the first line of wrapped\n   *      output.  Counts towards the line's width.\n   *    subsequent_indent (default: \"\")\n   *      string that will be prepended to all lines save the first\n   *      of wrapped output; also counts towards each line's width.\n   *    expand_tabs (default: true)\n   *      Expand tabs in input text to spaces before further processing.\n   *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n   *      in its line.  If false, each tab is treated as a single character.\n   *    tabsize (default: 8)\n   *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n   *      'expand_tabs' is false.\n   *    replace_whitespace (default: true)\n   *      Replace all whitespace characters in the input text by spaces\n   *      after tab expansion.  Note that if expand_tabs is false and\n   *      replace_whitespace is true, every tab will be converted to a\n   *      single space!\n   *    fix_sentence_endings (default: false)\n   *      Ensure that sentence-ending punctuation is always followed\n   *      by two spaces.  Off by default because the algorithm is\n   *      (unavoidably) imperfect.\n   *    break_long_words (default: true)\n   *      Break words longer than 'width'.  If false, those words will not\n   *      be broken, and some lines might be longer than 'width'.\n   *    break_on_hyphens (default: true)\n   *      Allow breaking hyphenated words. If true, wrapping will occur\n   *      preferably on whitespaces and right after hyphens part of\n   *      compound words.\n   *    drop_whitespace (default: true)\n   *      Drop leading and trailing whitespace from lines.\n   *    max_lines (default: None)\n   *      Truncate wrapped lines.\n   *    placeholder (default: ' [...]')\n   *      Append to the last line of truncated text.\n   */\n\n  constructor(options = {}) {\n    let {\n      width = 70,\n      initial_indent = '',\n      subsequent_indent = '',\n      expand_tabs = true,\n      replace_whitespace = true,\n      fix_sentence_endings = false,\n      break_long_words = true,\n      drop_whitespace = true,\n      break_on_hyphens = true,\n      tabsize = 8,\n      max_lines = undefined,\n      placeholder = ' [...]'\n    } = options;\n    this.width = width;\n    this.initial_indent = initial_indent;\n    this.subsequent_indent = subsequent_indent;\n    this.expand_tabs = expand_tabs;\n    this.replace_whitespace = replace_whitespace;\n    this.fix_sentence_endings = fix_sentence_endings;\n    this.break_long_words = break_long_words;\n    this.drop_whitespace = drop_whitespace;\n    this.break_on_hyphens = break_on_hyphens;\n    this.tabsize = tabsize;\n    this.max_lines = max_lines;\n    this.placeholder = placeholder;\n  }\n\n  // -- Private methods -----------------------------------------------\n  // (possibly useful for subclasses to override)\n\n  _munge_whitespace(text) {\n    /*\n     *  _munge_whitespace(text : string) -> string\n     *\n     *  Munge whitespace in text: expand tabs and convert all other\n     *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n     *  becomes \" foo    bar  baz\".\n     */\n    if (this.expand_tabs) {\n      text = text.replace(/\\t/g, ' '.repeat(this.tabsize)); // not strictly correct in js\n    }\n    if (this.replace_whitespace) {\n      text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ');\n    }\n    return text;\n  }\n  _split(text) {\n    /*\n     *  _split(text : string) -> [string]\n     *\n     *  Split the text to wrap into indivisible chunks.  Chunks are\n     *  not quite the same as words; see _wrap_chunks() for full\n     *  details.  As an example, the text\n     *    Look, goof-ball -- use the -b option!\n     *  breaks into the following chunks:\n     *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n     *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n     *  if break_on_hyphens is True, or in:\n     *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n     *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n     *  otherwise.\n     */\n    let chunks = text.split(wordsep_simple_re);\n    chunks = chunks.filter(Boolean);\n    return chunks;\n  }\n  _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n    /*\n     *  _handle_long_word(chunks : [string],\n     *                    cur_line : [string],\n     *                    cur_len : int, width : int)\n     *\n     *  Handle a chunk of text (most likely a word, not whitespace) that\n     *  is too long to fit in any line.\n     */\n    // Figure out when indent is larger than the specified width, and make\n    // sure at least one character is stripped off on every pass\n    let space_left;\n    if (width < 1) {\n      space_left = 1;\n    } else {\n      space_left = width - cur_len;\n    }\n\n    // If we're allowed to break long words, then do so: put as much\n    // of the next chunk onto the current line as will fit.\n    if (this.break_long_words) {\n      cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left));\n      reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left);\n\n      // Otherwise, we have to preserve the long word intact.  Only add\n      // it to the current line if there's nothing already there --\n      // that minimizes how much we violate the width constraint.\n    } else if (!cur_line) {\n      cur_line.push(...reversed_chunks.pop());\n    }\n\n    // If we're not allowed to break long words, and there's already\n    // text on the current line, do nothing.  Next time through the\n    // main loop of _wrap_chunks(), we'll wind up here again, but\n    // cur_len will be zero, so the next line will be entirely\n    // devoted to the long word that we can't handle right now.\n  }\n  _wrap_chunks(chunks) {\n    /*\n     *  _wrap_chunks(chunks : [string]) -> [string]\n     *\n     *  Wrap a sequence of text chunks and return a list of lines of\n     *  length 'self.width' or less.  (If 'break_long_words' is false,\n     *  some lines may be longer than this.)  Chunks correspond roughly\n     *  to words and the whitespace between them: each chunk is\n     *  indivisible (modulo 'break_long_words'), but a line break can\n     *  come between any two chunks.  Chunks should not have internal\n     *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n     *  Whitespace chunks will be removed from the beginning and end of\n     *  lines, but apart from that whitespace is preserved.\n     */\n    let lines = [];\n    let indent;\n    if (this.width <= 0) {\n      throw Error(`invalid width ${this.width} (must be > 0)`);\n    }\n    if (this.max_lines !== undefined) {\n      if (this.max_lines > 1) {\n        indent = this.subsequent_indent;\n      } else {\n        indent = this.initial_indent;\n      }\n      if (indent.length + this.placeholder.trimStart().length > this.width) {\n        throw Error('placeholder too large for max width');\n      }\n    }\n\n    // Arrange in reverse order so items can be efficiently popped\n    // from a stack of chucks.\n    chunks = chunks.reverse();\n    while (chunks.length > 0) {\n      // Start the list of chunks that will make up the current line.\n      // cur_len is just the length of all the chunks in cur_line.\n      let cur_line = [];\n      let cur_len = 0;\n\n      // Figure out which static string will prefix this line.\n      let indent;\n      if (lines) {\n        indent = this.subsequent_indent;\n      } else {\n        indent = this.initial_indent;\n      }\n\n      // Maximum width for this line.\n      let width = this.width - indent.length;\n\n      // First chunk on line is whitespace -- drop it, unless this\n      // is the very beginning of the text (ie. no lines started yet).\n      if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n        chunks.pop();\n      }\n      while (chunks.length > 0) {\n        let l = chunks[chunks.length - 1].length;\n\n        // Can at least squeeze this chunk onto the current line.\n        if (cur_len + l <= width) {\n          cur_line.push(chunks.pop());\n          cur_len += l;\n\n          // Nope, this line is full.\n        } else {\n          break;\n        }\n      }\n\n      // The current line is full, and the next chunk is too big to\n      // fit on *any* line (not just this one).\n      if (chunks.length && chunks[chunks.length - 1].length > width) {\n        this._handle_long_word(chunks, cur_line, cur_len, width);\n        cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0);\n      }\n\n      // If the last chunk on this line is all whitespace, drop it.\n      if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n        cur_len -= cur_line[cur_line.length - 1].length;\n        cur_line.pop();\n      }\n      if (cur_line) {\n        if (this.max_lines === undefined || lines.length + 1 < this.max_lines || (chunks.length === 0 || this.drop_whitespace && chunks.length === 1 && !chunks[0].trim()) && cur_len <= width) {\n          // Convert current line back to a string and store it in\n          // list of all lines (return value).\n          lines.push(indent + cur_line.join(''));\n        } else {\n          let had_break = false;\n          while (cur_line) {\n            if (cur_line[cur_line.length - 1].trim() && cur_len + this.placeholder.length <= width) {\n              cur_line.push(this.placeholder);\n              lines.push(indent + cur_line.join(''));\n              had_break = true;\n              break;\n            }\n            cur_len -= cur_line[-1].length;\n            cur_line.pop();\n          }\n          if (!had_break) {\n            if (lines) {\n              let prev_line = lines[lines.length - 1].trimEnd();\n              if (prev_line.length + this.placeholder.length <= this.width) {\n                lines[lines.length - 1] = prev_line + this.placeholder;\n                break;\n              }\n            }\n            lines.push(indent + this.placeholder.lstrip());\n          }\n          break;\n        }\n      }\n    }\n    return lines;\n  }\n  _split_chunks(text) {\n    text = this._munge_whitespace(text);\n    return this._split(text);\n  }\n\n  // -- Public interface ----------------------------------------------\n\n  wrap(text) {\n    /*\n     *  wrap(text : string) -> [string]\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of\n     *  no more than 'self.width' columns, and return a list of wrapped\n     *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n     *  and all other whitespace characters (including newline) are\n     *  converted to space.\n     */\n    let chunks = this._split_chunks(text);\n    // not implemented in js\n    //if (this.fix_sentence_endings) {\n    //    this._fix_sentence_endings(chunks)\n    //}\n    return this._wrap_chunks(chunks);\n  }\n  fill(text) {\n    /*\n     *  fill(text : string) -> string\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no\n     *  more than 'self.width' columns, and return a new string\n     *  containing the entire wrapped paragraph.\n     */\n    return this.wrap(text).join('\\n');\n  }\n}\n\n// -- Convenience interface ---------------------------------------------\n\nfunction wrap(text, options = {}) {\n  /*\n   *  Wrap a single paragraph of text, returning a list of wrapped lines.\n   *\n   *  Reformat the single paragraph in 'text' so it fits in lines of no\n   *  more than 'width' columns, and return a list of wrapped lines.  By\n   *  default, tabs in 'text' are expanded with string.expandtabs(), and\n   *  all other whitespace characters (including newline) are converted to\n   *  space.  See TextWrapper class for available keyword args to customize\n   *  wrapping behaviour.\n   */\n  let {\n    width = 70,\n    ...kwargs\n  } = options;\n  let w = new TextWrapper(Object.assign({\n    width\n  }, kwargs));\n  return w.wrap(text);\n}\nfunction fill(text, options = {}) {\n  /*\n   *  Fill a single paragraph of text, returning a new string.\n   *\n   *  Reformat the single paragraph in 'text' to fit in lines of no more\n   *  than 'width' columns, and return a new string containing the entire\n   *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n   *  whitespace characters converted to space.  See TextWrapper class for\n   *  available keyword args to customize wrapping behaviour.\n   */\n  let {\n    width = 70,\n    ...kwargs\n  } = options;\n  let w = new TextWrapper(Object.assign({\n    width\n  }, kwargs));\n  return w.fill(text);\n}\n\n// -- Loosely related functionality -------------------------------------\n\nlet _whitespace_only_re = /^[ \\t]+$/mg;\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg;\nfunction dedent(text) {\n  /*\n   *  Remove any common leading whitespace from every line in `text`.\n   *\n   *  This can be used to make triple-quoted strings line up with the left\n   *  edge of the display, while still presenting them in the source code\n   *  in indented form.\n   *\n   *  Note that tabs and spaces are both treated as whitespace, but they\n   *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n   *  considered to have no common leading whitespace.\n   *\n   *  Entirely blank lines are normalized to a newline character.\n   */\n  // Look for the longest leading string of spaces and tabs common to\n  // all lines.\n  let margin = undefined;\n  text = text.replace(_whitespace_only_re, '');\n  let indents = text.match(_leading_whitespace_re) || [];\n  for (let indent of indents) {\n    indent = indent.slice(0, -1);\n    if (margin === undefined) {\n      margin = indent;\n\n      // Current line more deeply indented than previous winner:\n      // no change (previous winner is still on top).\n    } else if (indent.startsWith(margin)) {\n      // pass\n\n      // Current line consistent with and no deeper than previous winner:\n      // it's the new winner.\n    } else if (margin.startsWith(indent)) {\n      margin = indent;\n\n      // Find the largest common whitespace between current line and previous\n      // winner.\n    } else {\n      for (let i = 0; i < margin.length && i < indent.length; i++) {\n        if (margin[i] !== indent[i]) {\n          margin = margin.slice(0, i);\n          break;\n        }\n      }\n    }\n  }\n  if (margin) {\n    text = text.replace(new RegExp('^' + margin, 'mg'), '');\n  }\n  return text;\n}\nmodule.exports = {\n  wrap,\n  fill,\n  dedent\n};","map":{"version":3,"names":["wordsep_simple_re","TextWrapper","constructor","options","width","initial_indent","subsequent_indent","expand_tabs","replace_whitespace","fix_sentence_endings","break_long_words","drop_whitespace","break_on_hyphens","tabsize","max_lines","undefined","placeholder","_munge_whitespace","text","replace","repeat","_split","chunks","split","filter","Boolean","_handle_long_word","reversed_chunks","cur_line","cur_len","space_left","push","length","slice","pop","_wrap_chunks","lines","indent","Error","trimStart","reverse","trim","l","map","reduce","a","b","join","had_break","prev_line","trimEnd","lstrip","_split_chunks","wrap","fill","kwargs","w","Object","assign","_whitespace_only_re","_leading_whitespace_re","dedent","margin","indents","match","startsWith","i","RegExp","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/node_modules/argparse/lib/textwrap.js"],"sourcesContent":["// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n\n'use strict'\n\n/*\n * Text wrapping and filling.\n */\n\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/\n\nclass TextWrapper {\n    /*\n     *  Object for wrapping/filling text.  The public interface consists of\n     *  the wrap() and fill() methods; the other methods are just there for\n     *  subclasses to override in order to tweak the default behaviour.\n     *  If you want to completely replace the main wrapping algorithm,\n     *  you'll probably have to override _wrap_chunks().\n     *\n     *  Several instance attributes control various aspects of wrapping:\n     *    width (default: 70)\n     *      the maximum width of wrapped lines (unless break_long_words\n     *      is false)\n     *    initial_indent (default: \"\")\n     *      string that will be prepended to the first line of wrapped\n     *      output.  Counts towards the line's width.\n     *    subsequent_indent (default: \"\")\n     *      string that will be prepended to all lines save the first\n     *      of wrapped output; also counts towards each line's width.\n     *    expand_tabs (default: true)\n     *      Expand tabs in input text to spaces before further processing.\n     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n     *      in its line.  If false, each tab is treated as a single character.\n     *    tabsize (default: 8)\n     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n     *      'expand_tabs' is false.\n     *    replace_whitespace (default: true)\n     *      Replace all whitespace characters in the input text by spaces\n     *      after tab expansion.  Note that if expand_tabs is false and\n     *      replace_whitespace is true, every tab will be converted to a\n     *      single space!\n     *    fix_sentence_endings (default: false)\n     *      Ensure that sentence-ending punctuation is always followed\n     *      by two spaces.  Off by default because the algorithm is\n     *      (unavoidably) imperfect.\n     *    break_long_words (default: true)\n     *      Break words longer than 'width'.  If false, those words will not\n     *      be broken, and some lines might be longer than 'width'.\n     *    break_on_hyphens (default: true)\n     *      Allow breaking hyphenated words. If true, wrapping will occur\n     *      preferably on whitespaces and right after hyphens part of\n     *      compound words.\n     *    drop_whitespace (default: true)\n     *      Drop leading and trailing whitespace from lines.\n     *    max_lines (default: None)\n     *      Truncate wrapped lines.\n     *    placeholder (default: ' [...]')\n     *      Append to the last line of truncated text.\n     */\n\n    constructor(options = {}) {\n        let {\n            width = 70,\n            initial_indent = '',\n            subsequent_indent = '',\n            expand_tabs = true,\n            replace_whitespace = true,\n            fix_sentence_endings = false,\n            break_long_words = true,\n            drop_whitespace = true,\n            break_on_hyphens = true,\n            tabsize = 8,\n            max_lines = undefined,\n            placeholder=' [...]'\n        } = options\n\n        this.width = width\n        this.initial_indent = initial_indent\n        this.subsequent_indent = subsequent_indent\n        this.expand_tabs = expand_tabs\n        this.replace_whitespace = replace_whitespace\n        this.fix_sentence_endings = fix_sentence_endings\n        this.break_long_words = break_long_words\n        this.drop_whitespace = drop_whitespace\n        this.break_on_hyphens = break_on_hyphens\n        this.tabsize = tabsize\n        this.max_lines = max_lines\n        this.placeholder = placeholder\n    }\n\n\n    // -- Private methods -----------------------------------------------\n    // (possibly useful for subclasses to override)\n\n    _munge_whitespace(text) {\n        /*\n         *  _munge_whitespace(text : string) -> string\n         *\n         *  Munge whitespace in text: expand tabs and convert all other\n         *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n         *  becomes \" foo    bar  baz\".\n         */\n        if (this.expand_tabs) {\n            text = text.replace(/\\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js\n        }\n        if (this.replace_whitespace) {\n            text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ')\n        }\n        return text\n    }\n\n    _split(text) {\n        /*\n         *  _split(text : string) -> [string]\n         *\n         *  Split the text to wrap into indivisible chunks.  Chunks are\n         *  not quite the same as words; see _wrap_chunks() for full\n         *  details.  As an example, the text\n         *    Look, goof-ball -- use the -b option!\n         *  breaks into the following chunks:\n         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n         *  if break_on_hyphens is True, or in:\n         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n         *  otherwise.\n         */\n        let chunks = text.split(wordsep_simple_re)\n        chunks = chunks.filter(Boolean)\n        return chunks\n    }\n\n    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n        /*\n         *  _handle_long_word(chunks : [string],\n         *                    cur_line : [string],\n         *                    cur_len : int, width : int)\n         *\n         *  Handle a chunk of text (most likely a word, not whitespace) that\n         *  is too long to fit in any line.\n         */\n        // Figure out when indent is larger than the specified width, and make\n        // sure at least one character is stripped off on every pass\n        let space_left\n        if (width < 1) {\n            space_left = 1\n        } else {\n            space_left = width - cur_len\n        }\n\n        // If we're allowed to break long words, then do so: put as much\n        // of the next chunk onto the current line as will fit.\n        if (this.break_long_words) {\n            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))\n            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)\n\n        // Otherwise, we have to preserve the long word intact.  Only add\n        // it to the current line if there's nothing already there --\n        // that minimizes how much we violate the width constraint.\n        } else if (!cur_line) {\n            cur_line.push(...reversed_chunks.pop())\n        }\n\n        // If we're not allowed to break long words, and there's already\n        // text on the current line, do nothing.  Next time through the\n        // main loop of _wrap_chunks(), we'll wind up here again, but\n        // cur_len will be zero, so the next line will be entirely\n        // devoted to the long word that we can't handle right now.\n    }\n\n    _wrap_chunks(chunks) {\n        /*\n         *  _wrap_chunks(chunks : [string]) -> [string]\n         *\n         *  Wrap a sequence of text chunks and return a list of lines of\n         *  length 'self.width' or less.  (If 'break_long_words' is false,\n         *  some lines may be longer than this.)  Chunks correspond roughly\n         *  to words and the whitespace between them: each chunk is\n         *  indivisible (modulo 'break_long_words'), but a line break can\n         *  come between any two chunks.  Chunks should not have internal\n         *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n         *  Whitespace chunks will be removed from the beginning and end of\n         *  lines, but apart from that whitespace is preserved.\n         */\n        let lines = []\n        let indent\n        if (this.width <= 0) {\n            throw Error(`invalid width ${this.width} (must be > 0)`)\n        }\n        if (this.max_lines !== undefined) {\n            if (this.max_lines > 1) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n            if (indent.length + this.placeholder.trimStart().length > this.width) {\n                throw Error('placeholder too large for max width')\n            }\n        }\n\n        // Arrange in reverse order so items can be efficiently popped\n        // from a stack of chucks.\n        chunks = chunks.reverse()\n\n        while (chunks.length > 0) {\n\n            // Start the list of chunks that will make up the current line.\n            // cur_len is just the length of all the chunks in cur_line.\n            let cur_line = []\n            let cur_len = 0\n\n            // Figure out which static string will prefix this line.\n            let indent\n            if (lines) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n\n            // Maximum width for this line.\n            let width = this.width - indent.length\n\n            // First chunk on line is whitespace -- drop it, unless this\n            // is the very beginning of the text (ie. no lines started yet).\n            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n                chunks.pop()\n            }\n\n            while (chunks.length > 0) {\n                let l = chunks[chunks.length - 1].length\n\n                // Can at least squeeze this chunk onto the current line.\n                if (cur_len + l <= width) {\n                    cur_line.push(chunks.pop())\n                    cur_len += l\n\n                // Nope, this line is full.\n                } else {\n                    break\n                }\n            }\n\n            // The current line is full, and the next chunk is too big to\n            // fit on *any* line (not just this one).\n            if (chunks.length && chunks[chunks.length - 1].length > width) {\n                this._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)\n            }\n\n            // If the last chunk on this line is all whitespace, drop it.\n            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n                cur_len -= cur_line[cur_line.length - 1].length\n                cur_line.pop()\n            }\n\n            if (cur_line) {\n                if (this.max_lines === undefined ||\n                    lines.length + 1 < this.max_lines ||\n                    (chunks.length === 0 ||\n                     this.drop_whitespace &&\n                     chunks.length === 1 &&\n                     !chunks[0].trim()) && cur_len <= width) {\n                    // Convert current line back to a string and store it in\n                    // list of all lines (return value).\n                    lines.push(indent + cur_line.join(''))\n                } else {\n                    let had_break = false\n                    while (cur_line) {\n                        if (cur_line[cur_line.length - 1].trim() &&\n                            cur_len + this.placeholder.length <= width) {\n                            cur_line.push(this.placeholder)\n                            lines.push(indent + cur_line.join(''))\n                            had_break = true\n                            break\n                        }\n                        cur_len -= cur_line[-1].length\n                        cur_line.pop()\n                    }\n                    if (!had_break) {\n                        if (lines) {\n                            let prev_line = lines[lines.length - 1].trimEnd()\n                            if (prev_line.length + this.placeholder.length <=\n                                    this.width) {\n                                lines[lines.length - 1] = prev_line + this.placeholder\n                                break\n                            }\n                        }\n                        lines.push(indent + this.placeholder.lstrip())\n                    }\n                    break\n                }\n            }\n        }\n\n        return lines\n    }\n\n    _split_chunks(text) {\n        text = this._munge_whitespace(text)\n        return this._split(text)\n    }\n\n    // -- Public interface ----------------------------------------------\n\n    wrap(text) {\n        /*\n         *  wrap(text : string) -> [string]\n         *\n         *  Reformat the single paragraph in 'text' so it fits in lines of\n         *  no more than 'self.width' columns, and return a list of wrapped\n         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n         *  and all other whitespace characters (including newline) are\n         *  converted to space.\n         */\n        let chunks = this._split_chunks(text)\n        // not implemented in js\n        //if (this.fix_sentence_endings) {\n        //    this._fix_sentence_endings(chunks)\n        //}\n        return this._wrap_chunks(chunks)\n    }\n\n    fill(text) {\n        /*\n         *  fill(text : string) -> string\n         *\n         *  Reformat the single paragraph in 'text' to fit in lines of no\n         *  more than 'self.width' columns, and return a new string\n         *  containing the entire wrapped paragraph.\n         */\n        return this.wrap(text).join('\\n')\n    }\n}\n\n\n// -- Convenience interface ---------------------------------------------\n\nfunction wrap(text, options = {}) {\n    /*\n     *  Wrap a single paragraph of text, returning a list of wrapped lines.\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of no\n     *  more than 'width' columns, and return a list of wrapped lines.  By\n     *  default, tabs in 'text' are expanded with string.expandtabs(), and\n     *  all other whitespace characters (including newline) are converted to\n     *  space.  See TextWrapper class for available keyword args to customize\n     *  wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.wrap(text)\n}\n\nfunction fill(text, options = {}) {\n    /*\n     *  Fill a single paragraph of text, returning a new string.\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no more\n     *  than 'width' columns, and return a new string containing the entire\n     *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n     *  whitespace characters converted to space.  See TextWrapper class for\n     *  available keyword args to customize wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.fill(text)\n}\n\n// -- Loosely related functionality -------------------------------------\n\nlet _whitespace_only_re = /^[ \\t]+$/mg\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg\n\nfunction dedent(text) {\n    /*\n     *  Remove any common leading whitespace from every line in `text`.\n     *\n     *  This can be used to make triple-quoted strings line up with the left\n     *  edge of the display, while still presenting them in the source code\n     *  in indented form.\n     *\n     *  Note that tabs and spaces are both treated as whitespace, but they\n     *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n     *  considered to have no common leading whitespace.\n     *\n     *  Entirely blank lines are normalized to a newline character.\n     */\n    // Look for the longest leading string of spaces and tabs common to\n    // all lines.\n    let margin = undefined\n    text = text.replace(_whitespace_only_re, '')\n    let indents = text.match(_leading_whitespace_re) || []\n    for (let indent of indents) {\n        indent = indent.slice(0, -1)\n\n        if (margin === undefined) {\n            margin = indent\n\n        // Current line more deeply indented than previous winner:\n        // no change (previous winner is still on top).\n        } else if (indent.startsWith(margin)) {\n            // pass\n\n        // Current line consistent with and no deeper than previous winner:\n        // it's the new winner.\n        } else if (margin.startsWith(indent)) {\n            margin = indent\n\n        // Find the largest common whitespace between current line and previous\n        // winner.\n        } else {\n            for (let i = 0; i < margin.length && i < indent.length; i++) {\n                if (margin[i] !== indent[i]) {\n                    margin = margin.slice(0, i)\n                    break\n                }\n            }\n        }\n    }\n\n    if (margin) {\n        text = text.replace(new RegExp('^' + margin, 'mg'), '')\n    }\n    return text\n}\n\nmodule.exports = { wrap, fill, dedent }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}