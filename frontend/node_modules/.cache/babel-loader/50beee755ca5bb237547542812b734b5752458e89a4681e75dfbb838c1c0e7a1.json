{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst normalize_1 = require(\"./normalize\");\nconst range_tree_1 = require(\"./range-tree\");\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\nfunction mergeProcessCovs(processCovs) {\n  if (processCovs.length === 0) {\n    return {\n      result: []\n    };\n  }\n  const urlToScripts = new Map();\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs = urlToScripts.get(scriptCov.url);\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n      scriptCovs.push(scriptCov);\n    }\n  }\n  const result = [];\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts));\n  }\n  const merged = {\n    result\n  };\n  normalize_1.normalizeProcessCov(merged);\n  return merged;\n}\nexports.mergeProcessCovs = mergeProcessCovs;\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\nfunction mergeScriptCovs(scriptCovs) {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged = scriptCovs[0];\n    normalize_1.deepNormalizeScriptCov(merged);\n    return merged;\n  }\n  const first = scriptCovs[0];\n  const scriptId = first.scriptId;\n  const url = first.url;\n  const rangeToFuncs = new Map();\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange = stringifyFunctionRootRange(funcCov);\n      let funcCovs = rangeToFuncs.get(rootRange);\n      if (funcCovs === undefined ||\n      // if the entry in rangeToFuncs is function-level granularity and\n      // the new coverage is block-level, prefer block-level.\n      !funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n      funcCovs.push(funcCov);\n    }\n  }\n  const functions = [];\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs));\n  }\n  const merged = {\n    scriptId,\n    url,\n    functions\n  };\n  normalize_1.normalizeScriptCov(merged);\n  return merged;\n}\nexports.mergeScriptCovs = mergeScriptCovs;\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\nfunction stringifyFunctionRootRange(funcCov) {\n  const rootRange = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\nfunction mergeFunctionCovs(funcCovs) {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged = funcCovs[0];\n    normalize_1.normalizeFunctionCov(merged);\n    return merged;\n  }\n  const functionName = funcCovs[0].functionName;\n  const trees = [];\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(range_tree_1.RangeTree.fromSortedRanges(funcCov.ranges));\n  }\n  // assert: `trees.length > 0`\n  const mergedTree = mergeRangeTrees(trees);\n  normalize_1.normalizeRangeTree(mergedTree);\n  const ranges = mergedTree.toRanges();\n  const isBlockCoverage = !(ranges.length === 1 && ranges[0].count === 0);\n  const merged = {\n    functionName,\n    ranges,\n    isBlockCoverage\n  };\n  // assert: `merged` is normalized\n  return merged;\n}\nexports.mergeFunctionCovs = mergeFunctionCovs;\n/**\n * @precondition Same `start` and `end` for all the trees\n */\nfunction mergeRangeTrees(trees) {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n  const first = trees[0];\n  let delta = 0;\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n  const children = mergeRangeTreeChildren(trees);\n  return new range_tree_1.RangeTree(first.start, first.end, delta, children);\n}\nclass RangeTreeWithParent {\n  constructor(parentIndex, tree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n}\nclass StartEvent {\n  constructor(offset, trees) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n  static compare(a, b) {\n    return a.offset - b.offset;\n  }\n}\nclass StartEventQueue {\n  constructor(queue) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n  static fromParentTrees(parentTrees) {\n    const startToTrees = new Map();\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees = startToTrees.get(child.start);\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n    const queue = [];\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n  setPendingOffset(offset) {\n    this.pendingOffset = offset;\n  }\n  pushPendingTree(tree) {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n    this.pendingTrees.push(tree);\n  }\n  next() {\n    const pendingTrees = this.pendingTrees;\n    const nextEvent = this.queue[this.nextIndex];\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n}\nfunction mergeRangeTreeChildren(parentTrees) {\n  const result = [];\n  const startEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested = new Map();\n  let openRange;\n  while (true) {\n    const event = startEventQueue.next();\n    if (event === undefined) {\n      break;\n    }\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n    if (openRange === undefined) {\n      let openRangeEnd = event.offset + 1;\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {\n        start: event.offset,\n        end: openRangeEnd\n      };\n    } else {\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        if (tree.end > openRange.end) {\n          const right = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n  return result;\n}\nfunction insertChild(parentToNested, parentIndex, tree) {\n  let nested = parentToNested.get(parentIndex);\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n  nested.push(tree);\n}\nfunction nextChild(openRange, parentToNested) {\n  const matchingTrees = [];\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new range_tree_1.RangeTree(openRange.start, openRange.end, 0, nested));\n    }\n  }\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees);\n}","map":{"version":3,"names":["normalize_1","require","range_tree_1","mergeProcessCovs","processCovs","length","result","urlToScripts","Map","processCov","scriptCov","scriptCovs","get","url","undefined","set","push","scripts","values","mergeScriptCovs","merged","normalizeProcessCov","exports","deepNormalizeScriptCov","first","scriptId","rangeToFuncs","funcCov","functions","rootRange","stringifyFunctionRootRange","funcCovs","isBlockCoverage","mergeFunctionCovs","normalizeScriptCov","ranges","startOffset","toString","endOffset","normalizeFunctionCov","functionName","trees","RangeTree","fromSortedRanges","mergedTree","mergeRangeTrees","normalizeRangeTree","toRanges","count","delta","tree","children","mergeRangeTreeChildren","start","end","RangeTreeWithParent","constructor","parentIndex","StartEvent","offset","compare","a","b","StartEventQueue","queue","nextIndex","pendingOffset","pendingTrees","fromParentTrees","parentTrees","startToTrees","parentTree","entries","child","sort","setPendingOffset","pushPendingTree","next","nextEvent","startEventQueue","parentToNested","openRange","event","nextChild","openRangeEnd","Math","max","insertChild","right","split","nested","matchingTrees","clear"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\merge.ts"],"sourcesContent":["import {\n  deepNormalizeScriptCov,\n  normalizeFunctionCov,\n  normalizeProcessCov,\n  normalizeRangeTree,\n  normalizeScriptCov,\n} from \"./normalize\";\nimport { RangeTree } from \"./range-tree\";\nimport { FunctionCov, ProcessCov, Range, RangeCov, ScriptCov } from \"./types\";\n\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\nexport function mergeProcessCovs(processCovs: ReadonlyArray<ProcessCov>): ProcessCov {\n  if (processCovs.length === 0) {\n    return {result: []};\n  }\n\n  const urlToScripts: Map<string, ScriptCov[]> = new Map();\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs: ScriptCov[] | undefined = urlToScripts.get(scriptCov.url);\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n      scriptCovs.push(scriptCov);\n    }\n  }\n\n  const result: ScriptCov[] = [];\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts)!);\n  }\n  const merged: ProcessCov = {result};\n\n  normalizeProcessCov(merged);\n  return merged;\n}\n\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\nexport function mergeScriptCovs(scriptCovs: ReadonlyArray<ScriptCov>): ScriptCov | undefined {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged: ScriptCov = scriptCovs[0];\n    deepNormalizeScriptCov(merged);\n    return merged;\n  }\n\n  const first: ScriptCov = scriptCovs[0];\n  const scriptId: string = first.scriptId;\n  const url: string = first.url;\n\n  const rangeToFuncs: Map<string, FunctionCov[]> = new Map();\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange: string = stringifyFunctionRootRange(funcCov);\n      let funcCovs: FunctionCov[] | undefined = rangeToFuncs.get(rootRange);\n\n      if (funcCovs === undefined ||\n        // if the entry in rangeToFuncs is function-level granularity and\n        // the new coverage is block-level, prefer block-level.\n        (!funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage)) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n      funcCovs.push(funcCov);\n    }\n  }\n\n  const functions: FunctionCov[] = [];\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs)!);\n  }\n\n  const merged: ScriptCov = {scriptId, url, functions};\n  normalizeScriptCov(merged);\n  return merged;\n}\n\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\nfunction stringifyFunctionRootRange(funcCov: Readonly<FunctionCov>): string {\n  const rootRange: RangeCov = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\nexport function mergeFunctionCovs(funcCovs: ReadonlyArray<FunctionCov>): FunctionCov | undefined {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged: FunctionCov = funcCovs[0];\n    normalizeFunctionCov(merged);\n    return merged;\n  }\n\n  const functionName: string = funcCovs[0].functionName;\n\n  const trees: RangeTree[] = [];\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(RangeTree.fromSortedRanges(funcCov.ranges)!);\n  }\n\n  // assert: `trees.length > 0`\n  const mergedTree: RangeTree = mergeRangeTrees(trees)!;\n  normalizeRangeTree(mergedTree);\n  const ranges: RangeCov[] = mergedTree.toRanges();\n  const isBlockCoverage: boolean = !(ranges.length === 1 && ranges[0].count === 0);\n\n  const merged: FunctionCov = {functionName, ranges, isBlockCoverage};\n  // assert: `merged` is normalized\n  return merged;\n}\n\n/**\n * @precondition Same `start` and `end` for all the trees\n */\nfunction mergeRangeTrees(trees: ReadonlyArray<RangeTree>): RangeTree | undefined {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n  const first: RangeTree = trees[0];\n  let delta: number = 0;\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n  const children: RangeTree[] = mergeRangeTreeChildren(trees);\n  return new RangeTree(first.start, first.end, delta, children);\n}\n\nclass RangeTreeWithParent {\n  readonly parentIndex: number;\n  readonly tree: RangeTree;\n\n  constructor(parentIndex: number, tree: RangeTree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n}\n\nclass StartEvent {\n  readonly offset: number;\n  readonly trees: RangeTreeWithParent[];\n\n  constructor(offset: number, trees: RangeTreeWithParent[]) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n\n  static compare(a: StartEvent, b: StartEvent): number {\n    return a.offset - b.offset;\n  }\n}\n\nclass StartEventQueue {\n  private readonly queue: StartEvent[];\n  private nextIndex: number;\n  private pendingOffset: number;\n  private pendingTrees: RangeTreeWithParent[] | undefined;\n\n  private constructor(queue: StartEvent[]) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n\n  static fromParentTrees(parentTrees: ReadonlyArray<RangeTree>): StartEventQueue {\n    const startToTrees: Map<number, RangeTreeWithParent[]> = new Map();\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees: RangeTreeWithParent[] | undefined = startToTrees.get(child.start);\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n    const queue: StartEvent[] = [];\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n\n  setPendingOffset(offset: number): void {\n    this.pendingOffset = offset;\n  }\n\n  pushPendingTree(tree: RangeTreeWithParent): void {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n    this.pendingTrees.push(tree);\n  }\n\n  next(): StartEvent | undefined {\n    const pendingTrees: RangeTreeWithParent[] | undefined = this.pendingTrees;\n    const nextEvent: StartEvent | undefined = this.queue[this.nextIndex];\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n}\n\nfunction mergeRangeTreeChildren(parentTrees: ReadonlyArray<RangeTree>): RangeTree[] {\n  const result: RangeTree[] = [];\n  const startEventQueue: StartEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested: Map<number, RangeTree[]> = new Map();\n  let openRange: Range | undefined;\n\n  while (true) {\n    const event: StartEvent | undefined = startEventQueue.next();\n    if (event === undefined) {\n      break;\n    }\n\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n\n    if (openRange === undefined) {\n      let openRangeEnd: number = event.offset + 1;\n      for (const {parentIndex, tree} of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {start: event.offset, end: openRangeEnd};\n    } else {\n      for (const {parentIndex, tree} of event.trees) {\n        if (tree.end > openRange.end) {\n          const right: RangeTree = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n\n  return result;\n}\n\nfunction insertChild(parentToNested: Map<number, RangeTree[]>, parentIndex: number, tree: RangeTree): void {\n  let nested: RangeTree[] | undefined = parentToNested.get(parentIndex);\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n  nested.push(tree);\n}\n\nfunction nextChild(openRange: Range, parentToNested: Map<number, RangeTree[]>): RangeTree {\n  const matchingTrees: RangeTree[] = [];\n\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new RangeTree(\n        openRange.start,\n        openRange.end,\n        0,\n        nested,\n      ));\n    }\n  }\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees)!;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}