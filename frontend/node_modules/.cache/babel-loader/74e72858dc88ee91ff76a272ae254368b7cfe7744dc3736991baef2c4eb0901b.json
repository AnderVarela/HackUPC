{"ast":null,"code":"const {\n  humanReadableArgName\n} = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName).helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter(option => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = option => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    }\n    ;\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + (\n    // simplistic check for non-help option\n    args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push(\n      // use stringify to match the display of the default value\n      `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n    return option.description;\n  }\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n      // use stringify to match the display of the default value\n      `choices: ${argument.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    ;\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map(argument => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map(option => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map(cmd => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));\n  }\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return (i > 0 ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\nexports.Help = Help;","map":{"version":3,"names":["humanReadableArgName","require","Help","constructor","helpWidth","undefined","sortSubcommands","sortOptions","visibleCommands","cmd","commands","filter","_hidden","_hasImplicitHelpCommand","helpName","helpArgs","_helpCommandnameAndArgs","match","helpCommand","createCommand","helpOption","description","_helpCommandDescription","arguments","push","sort","a","b","name","localeCompare","visibleOptions","options","option","hidden","showShortHelpFlag","_hasHelpOption","_helpShortFlag","_findOption","showLongHelpFlag","_helpLongFlag","createOption","_helpDescription","_helpFlags","getSortKey","short","replace","long","visibleArguments","_argsDescription","_args","forEach","argument","find","subcommandTerm","args","map","arg","join","_name","_aliases","length","optionTerm","flags","argumentTerm","longestSubcommandTermLength","helper","reduce","max","command","Math","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","parent","usage","commandDescription","subcommandDescription","optionDescription","extraInfo","argChoices","negate","choice","JSON","stringify","defaultValue","defaultValueDescription","envVar","argumentDescription","extraDescripton","formatHelp","termWidth","padWidth","itemIndentWidth","itemSeparatorWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","concat","argumentList","optionList","commandList","str","width","indent","minColumnWidth","columnWidth","leadingStr","substr","columnText","indentString","regex","RegExp","lines","line","i","slice","trimRight","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/commander/lib/help.js"],"sourcesContent":["const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    };\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  };\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}