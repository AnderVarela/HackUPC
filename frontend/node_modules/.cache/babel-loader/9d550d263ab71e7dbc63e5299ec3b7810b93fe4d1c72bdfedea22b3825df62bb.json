{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst regexpp_1 = require(\"@eslint-community/regexpp\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-includes',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce `includes` method over `indexOf` method',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      preferIncludes: \"Use 'includes()' method instead.\",\n      preferStringIncludes: 'Use `String#includes()` method with a string instead.'\n    },\n    schema: []\n  },\n  create(context) {\n    const globalScope = context.getScope();\n    const services = (0, util_1.getParserServices)(context);\n    const types = services.program.getTypeChecker();\n    function isNumber(node, value) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && evaluated.value === value;\n    }\n    function isPositiveCheck(node) {\n      switch (node.operator) {\n        case '!==':\n        case '!=':\n        case '>':\n          return isNumber(node.right, -1);\n        case '>=':\n          return isNumber(node.right, 0);\n        default:\n          return false;\n      }\n    }\n    function isNegativeCheck(node) {\n      switch (node.operator) {\n        case '===':\n        case '==':\n        case '<=':\n          return isNumber(node.right, -1);\n        case '<':\n          return isNumber(node.right, 0);\n        default:\n          return false;\n      }\n    }\n    function hasSameParameters(nodeA, nodeB) {\n      if (!ts.isFunctionLike(nodeA) || !ts.isFunctionLike(nodeB)) {\n        return false;\n      }\n      const paramsA = nodeA.parameters;\n      const paramsB = nodeB.parameters;\n      if (paramsA.length !== paramsB.length) {\n        return false;\n      }\n      for (let i = 0; i < paramsA.length; ++i) {\n        const paramA = paramsA[i];\n        const paramB = paramsB[i];\n        // Check name, type, and question token once.\n        if (paramA.getText() !== paramB.getText()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Parse a given node if it's a `RegExp` instance.\n     * @param node The node to parse.\n     */\n    function parseRegExp(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n        return null;\n      }\n      const {\n        pattern,\n        flags\n      } = (0, regexpp_1.parseRegExpLiteral)(evaluated.value);\n      if (pattern.alternatives.length !== 1 || flags.ignoreCase || flags.global) {\n        return null;\n      }\n      // Check if it can determine a unique string.\n      const chars = pattern.alternatives[0].elements;\n      if (!chars.every(c => c.type === 'Character')) {\n        return null;\n      }\n      // To string.\n      return String.fromCodePoint(...chars.map(c => c.value));\n    }\n    function escapeString(str) {\n      const EscapeMap = {\n        '\\0': '\\\\0',\n        \"'\": \"\\\\'\",\n        '\\\\': '\\\\\\\\',\n        '\\n': '\\\\n',\n        '\\r': '\\\\r',\n        '\\v': '\\\\v',\n        '\\t': '\\\\t',\n        '\\f': '\\\\f'\n        // \"\\b\" cause unexpected replacements\n        // '\\b': '\\\\b',\n      };\n      const replaceRegex = new RegExp(Object.values(EscapeMap).join('|'), 'g');\n      return str.replace(replaceRegex, char => EscapeMap[char]);\n    }\n    function checkArrayIndexOf(node, allowFixing) {\n      var _a, _b, _c;\n      // Check if the comparison is equivalent to `includes()`.\n      const callNode = node.parent;\n      const compareNode = ((_a = callNode.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? callNode.parent.parent : callNode.parent;\n      const negative = isNegativeCheck(compareNode);\n      if (!negative && !isPositiveCheck(compareNode)) {\n        return;\n      }\n      // Get the symbol of `indexOf` method.\n      const tsNode = services.esTreeNodeToTSNodeMap.get(node.property);\n      const indexofMethodDeclarations = (_b = types.getSymbolAtLocation(tsNode)) === null || _b === void 0 ? void 0 : _b.getDeclarations();\n      if (indexofMethodDeclarations == null || indexofMethodDeclarations.length === 0) {\n        return;\n      }\n      // Check if every declaration of `indexOf` method has `includes` method\n      // and the two methods have the same parameters.\n      for (const instanceofMethodDecl of indexofMethodDeclarations) {\n        const typeDecl = instanceofMethodDecl.parent;\n        const type = types.getTypeAtLocation(typeDecl);\n        const includesMethodDecl = (_c = type.getProperty('includes')) === null || _c === void 0 ? void 0 : _c.getDeclarations();\n        if (includesMethodDecl == null || !includesMethodDecl.some(includesMethodDecl => hasSameParameters(includesMethodDecl, instanceofMethodDecl))) {\n          return;\n        }\n      }\n      // Report it.\n      context.report(Object.assign({\n        node: compareNode,\n        messageId: 'preferIncludes'\n      }, allowFixing && {\n        *fix(fixer) {\n          if (negative) {\n            yield fixer.insertTextBefore(callNode, '!');\n          }\n          yield fixer.replaceText(node.property, 'includes');\n          yield fixer.removeRange([callNode.range[1], compareNode.range[1]]);\n        }\n      }));\n    }\n    return {\n      // a.indexOf(b) !== 1\n      \"BinaryExpression > CallExpression.left > MemberExpression.callee[property.name='indexOf'][computed=false]\"(node) {\n        checkArrayIndexOf(node, /* allowFixing */true);\n      },\n      // a?.indexOf(b) !== 1\n      \"BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name='indexOf'][computed=false]\"(node) {\n        checkArrayIndexOf(node, /* allowFixing */false);\n      },\n      // /bar/.test(foo)\n      'CallExpression[arguments.length=1] > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n        var _a;\n        const callNode = node.parent;\n        const text = parseRegExp(node.object);\n        if (text == null) {\n          return;\n        }\n        //check the argument type of test methods\n        const argument = callNode.arguments[0];\n        const tsNode = services.esTreeNodeToTSNodeMap.get(argument);\n        const type = (0, util_1.getConstrainedTypeAtLocation)(types, tsNode);\n        const includesMethodDecl = (_a = type.getProperty('includes')) === null || _a === void 0 ? void 0 : _a.getDeclarations();\n        if (includesMethodDecl == null) {\n          return;\n        }\n        context.report({\n          node: callNode,\n          messageId: 'preferStringIncludes',\n          *fix(fixer) {\n            const argNode = callNode.arguments[0];\n            const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal && argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== utils_1.AST_NODE_TYPES.Identifier && argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n            yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n            yield fixer.removeRange([argNode.range[1], callNode.range[1]]);\n            if (needsParen) {\n              yield fixer.insertTextBefore(argNode, '(');\n              yield fixer.insertTextAfter(argNode, ')');\n            }\n            yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}includes('${escapeString(text)}')`);\n          }\n        });\n      }\n    };\n  }\n});","map":{"version":3,"names":["regexpp_1","require","utils_1","ts","__importStar","util_1","exports","default","createRule","name","defaultOptions","meta","type","docs","description","recommended","requiresTypeChecking","fixable","messages","preferIncludes","preferStringIncludes","schema","create","context","globalScope","getScope","services","getParserServices","types","program","getTypeChecker","isNumber","node","value","evaluated","getStaticValue","isPositiveCheck","operator","right","isNegativeCheck","hasSameParameters","nodeA","nodeB","isFunctionLike","paramsA","parameters","paramsB","length","i","paramA","paramB","getText","parseRegExp","RegExp","pattern","flags","parseRegExpLiteral","alternatives","ignoreCase","global","chars","elements","every","c","String","fromCodePoint","map","escapeString","str","EscapeMap","replaceRegex","Object","values","join","replace","char","checkArrayIndexOf","allowFixing","callNode","parent","compareNode","_a","AST_NODE_TYPES","ChainExpression","negative","tsNode","esTreeNodeToTSNodeMap","get","property","indexofMethodDeclarations","_b","getSymbolAtLocation","getDeclarations","instanceofMethodDecl","typeDecl","getTypeAtLocation","includesMethodDecl","_c","getProperty","some","report","assign","messageId","fix","fixer","insertTextBefore","replaceText","removeRange","range","BinaryExpression > CallExpression.left > MemberExpression.callee[property.name='indexOf'][computed=false]","BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name='indexOf'][computed=false]","CallExpression[arguments.length=1] > MemberExpression.callee[property.name=\"test\"][computed=false]","text","object","argument","arguments","getConstrainedTypeAtLocation","argNode","needsParen","Literal","TemplateLiteral","Identifier","MemberExpression","CallExpression","insertTextAfter","optional"],"sources":["../../src/rules/prefer-includes.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}