{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"buffer\").Buffer;\n// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer\n\n// == Extend Node primitives to use iconv-lite =================================\n\nmodule.exports = function (iconv) {\n  var original = undefined; // Place to keep original methods.\n\n  // Node authors rewrote Buffer internals to make it compatible with\n  // Uint8Array and we cannot patch key functions since then.\n  // Note: this does use older Buffer API on a purpose\n  iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n  iconv.extendNodeEncodings = function extendNodeEncodings() {\n    if (original) return;\n    original = {};\n    if (!iconv.supportsNodeEncodingsExtension) {\n      console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n      console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n      return;\n    }\n    var nodeNativeEncodings = {\n      'hex': true,\n      'utf8': true,\n      'utf-8': true,\n      'ascii': true,\n      'binary': true,\n      'base64': true,\n      'ucs2': true,\n      'ucs-2': true,\n      'utf16le': true,\n      'utf-16le': true\n    };\n    Buffer.isNativeEncoding = function (enc) {\n      return enc && nodeNativeEncodings[enc.toLowerCase()];\n    };\n\n    // -- SlowBuffer -----------------------------------------------------------\n    var SlowBuffer = require('buffer').SlowBuffer;\n    original.SlowBufferToString = SlowBuffer.prototype.toString;\n    SlowBuffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);\n\n      // Otherwise, use our decoding method.\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.SlowBufferWrite = SlowBuffer.prototype.write;\n    SlowBuffer.prototype.write = function (string, offset, length, encoding) {\n      // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n\n      // Otherwise, use our encoding method.\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n    };\n\n    // -- Buffer ---------------------------------------------------------------\n\n    original.BufferIsEncoding = Buffer.isEncoding;\n    Buffer.isEncoding = function (encoding) {\n      return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n    };\n    original.BufferByteLength = Buffer.byteLength;\n    Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);\n\n      // Slow, I know, but we don't have a better way yet.\n      return iconv.encode(str, encoding).length;\n    };\n    original.BufferToString = Buffer.prototype.toString;\n    Buffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);\n\n      // Otherwise, use our decoding method.\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.BufferWrite = Buffer.prototype.write;\n    Buffer.prototype.write = function (string, offset, length, encoding) {\n      var _offset = offset,\n        _length = length,\n        _encoding = encoding;\n      // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n\n      // Use native conversion when possible\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n\n      // Otherwise, use our encoding method.\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n\n      // TODO: Set _charsWritten.\n    };\n\n    // -- Readable -------------------------------------------------------------\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n      original.ReadableSetEncoding = Readable.prototype.setEncoding;\n      Readable.prototype.setEncoding = function setEncoding(enc, options) {\n        // Use our own decoder, it has the same interface.\n        // We cannot use original function as it doesn't handle BOM-s.\n        this._readableState.decoder = iconv.getDecoder(enc, options);\n        this._readableState.encoding = enc;\n      };\n      Readable.prototype.collect = iconv._collect;\n    }\n  };\n\n  // Remove iconv-lite Node primitive extensions.\n  iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n    if (!iconv.supportsNodeEncodingsExtension) return;\n    if (!original) throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\");\n    delete Buffer.isNativeEncoding;\n    var SlowBuffer = require('buffer').SlowBuffer;\n    SlowBuffer.prototype.toString = original.SlowBufferToString;\n    SlowBuffer.prototype.write = original.SlowBufferWrite;\n    Buffer.isEncoding = original.BufferIsEncoding;\n    Buffer.byteLength = original.BufferByteLength;\n    Buffer.prototype.toString = original.BufferToString;\n    Buffer.prototype.write = original.BufferWrite;\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n      Readable.prototype.setEncoding = original.ReadableSetEncoding;\n      delete Readable.prototype.collect;\n    }\n    original = undefined;\n  };\n};","map":{"version":3,"names":["Buffer","require","module","exports","iconv","original","undefined","supportsNodeEncodingsExtension","from","Uint8Array","extendNodeEncodings","console","error","nodeNativeEncodings","isNativeEncoding","enc","toLowerCase","SlowBuffer","SlowBufferToString","prototype","toString","encoding","start","end","String","call","length","decode","slice","SlowBufferWrite","write","string","offset","isFinite","swap","remaining","RangeError","buf","encode","copy","BufferIsEncoding","isEncoding","encodingExists","BufferByteLength","byteLength","str","BufferToString","BufferWrite","_offset","_length","_encoding","supportsStreams","Readable","ReadableSetEncoding","setEncoding","options","_readableState","decoder","getDecoder","collect","_collect","undoExtendNodeEncodings","Error"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/body-parser/node_modules/iconv-lite/lib/extend-node.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"buffer\").Buffer;\n// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer\n\n// == Extend Node primitives to use iconv-lite =================================\n\nmodule.exports = function (iconv) {\n    var original = undefined; // Place to keep original methods.\n\n    // Node authors rewrote Buffer internals to make it compatible with\n    // Uint8Array and we cannot patch key functions since then.\n    // Note: this does use older Buffer API on a purpose\n    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n\n    iconv.extendNodeEncodings = function extendNodeEncodings() {\n        if (original) return;\n        original = {};\n\n        if (!iconv.supportsNodeEncodingsExtension) {\n            console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n            console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n            return;\n        }\n\n        var nodeNativeEncodings = {\n            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, \n            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,\n        };\n\n        Buffer.isNativeEncoding = function(enc) {\n            return enc && nodeNativeEncodings[enc.toLowerCase()];\n        }\n\n        // -- SlowBuffer -----------------------------------------------------------\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        original.SlowBufferToString = SlowBuffer.prototype.toString;\n        SlowBuffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.SlowBufferWrite = SlowBuffer.prototype.write;\n        SlowBuffer.prototype.write = function(string, offset, length, encoding) {\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n        }\n\n        // -- Buffer ---------------------------------------------------------------\n\n        original.BufferIsEncoding = Buffer.isEncoding;\n        Buffer.isEncoding = function(encoding) {\n            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n        }\n\n        original.BufferByteLength = Buffer.byteLength;\n        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferByteLength.call(this, str, encoding);\n\n            // Slow, I know, but we don't have a better way yet.\n            return iconv.encode(str, encoding).length;\n        }\n\n        original.BufferToString = Buffer.prototype.toString;\n        Buffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.BufferWrite = Buffer.prototype.write;\n        Buffer.prototype.write = function(string, offset, length, encoding) {\n            var _offset = offset, _length = length, _encoding = encoding;\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n\n            // TODO: Set _charsWritten.\n        }\n\n\n        // -- Readable -------------------------------------------------------------\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            original.ReadableSetEncoding = Readable.prototype.setEncoding;\n            Readable.prototype.setEncoding = function setEncoding(enc, options) {\n                // Use our own decoder, it has the same interface.\n                // We cannot use original function as it doesn't handle BOM-s.\n                this._readableState.decoder = iconv.getDecoder(enc, options);\n                this._readableState.encoding = enc;\n            }\n\n            Readable.prototype.collect = iconv._collect;\n        }\n    }\n\n    // Remove iconv-lite Node primitive extensions.\n    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n        if (!iconv.supportsNodeEncodingsExtension)\n            return;\n        if (!original)\n            throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\")\n\n        delete Buffer.isNativeEncoding;\n\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        SlowBuffer.prototype.toString = original.SlowBufferToString;\n        SlowBuffer.prototype.write = original.SlowBufferWrite;\n\n        Buffer.isEncoding = original.BufferIsEncoding;\n        Buffer.byteLength = original.BufferByteLength;\n        Buffer.prototype.toString = original.BufferToString;\n        Buffer.prototype.write = original.BufferWrite;\n\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            Readable.prototype.setEncoding = original.ReadableSetEncoding;\n            delete Readable.prototype.collect;\n        }\n\n        original = undefined;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}