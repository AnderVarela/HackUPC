{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar path = require('path');\nvar builtinList = require('builtin-modules');\nvar deepMerge = require('deepmerge');\nvar isModule = require('is-module');\nvar fs = require('fs');\nvar util = require('util');\nvar url = require('url');\nvar resolve = require('resolve');\nvar pluginutils = require('@rollup/pluginutils');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar builtinList__default = /*#__PURE__*/_interopDefaultLegacy(builtinList);\nvar deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);\nvar isModule__default = /*#__PURE__*/_interopDefaultLegacy(isModule);\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar resolve__default = /*#__PURE__*/_interopDefaultLegacy(resolve);\nconst access = util.promisify(fs__default['default'].access);\nconst readFile = util.promisify(fs__default['default'].readFile);\nconst realpath = util.promisify(fs__default['default'].realpath);\nconst stat = util.promisify(fs__default['default'].stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\nconst onError = error => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\nconst makeCache = fn => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(param, fn(param).catch(err => {\n        cache.delete(param);\n        throw err;\n      }));\n    }\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n  wrapped.clear = () => cache.clear();\n  return wrapped;\n};\nconst isDirCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst isFileCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({\n      mainFields\n    } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let {\n    pkgPath\n  } = options;\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = fs.realpathSync(pkgPath);\n  }\n  const pkgRoot = path.dirname(pkgPath);\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: {\n      ...pkg\n    },\n    // path to package.json file\n    packageJsonPath: pkgPath,\n    // directory containing the package.json\n    root: pkgRoot,\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField: useBrowserOverrides && typeof pkg.browser === 'object' && Object.keys(pkg.browser).reduce((browser, key) => {\n      let resolved = pkg.browser[key];\n      if (resolved && resolved[0] === '.') {\n        resolved = path.resolve(pkgRoot, resolved);\n      }\n      /* eslint-disable no-param-reassign */\n      browser[key] = resolved;\n      if (key[0] === '.') {\n        const absoluteKey = path.resolve(pkgRoot, key);\n        browser[absoluteKey] = resolved;\n        if (!path.extname(key)) {\n          extensions.reduce((subBrowser, ext) => {\n            subBrowser[absoluteKey + ext] = subBrowser[key];\n            return subBrowser;\n          }, browser);\n        }\n      }\n      return browser;\n    }, {}),\n    packageInfo\n  };\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (useBrowserOverrides && typeof pkg.browser === 'object' &&\n  // eslint-disable-next-line no-prototype-builtins\n  browserMap.hasOwnProperty(pkg.main)) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = path.resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = pluginutils.createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = util.promisify(fs__default['default'].exists);\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some(dir => current.endsWith(dir));\n}\nasync function findPackageJson(base, moduleDirs) {\n  const {\n    root\n  } = path__default['default'].parse(base);\n  let current = base;\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path__default['default'].join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs__default['default'].readFileSync(pkgJsonPath, 'utf-8');\n      return {\n        pkgJson: JSON.parse(pkgJsonString),\n        pkgPath: current,\n        pkgJsonPath\n      };\n    }\n    current = path__default['default'].resolve(current, '..');\n  }\n  return null;\n}\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every(k => !k.startsWith('.'));\n}\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some(k => k.startsWith('.')) && keys.some(k => !k.startsWith('.'));\n}\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\nfunction createErrorMsg(context, reason, internal) {\n  const {\n    importSpecifier,\n    importer,\n    pkgJsonPath\n  } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\nclass ResolveError extends Error {}\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments.split('/').slice(1).some(t => ['.', '..', ...moduleDirs].includes(t));\n}\nasync function resolvePackageTarget(context, {\n  target,\n  subpath,\n  pattern,\n  internal\n}) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some(p => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(target.replace(/\\*/g, subpath), context.pkgURL.href);\n          return result ? url.pathToFileURL(result.location) : null;\n        }\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? url.pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(context, `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`);\n    }\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n  if (target === null) {\n    return null;\n  }\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, {\n  matchKey,\n  matchObj,\n  internal\n}) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, {\n      target,\n      subpath: '',\n      internal\n    });\n    return resolved;\n  }\n  const expansionKeys = Object.keys(matchObj).filter(k => k.endsWith('/') || k.endsWith('*')).sort((a, b) => b.length - a.length);\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        internal\n      });\n      return resolved;\n    }\n  }\n  throw new InvalidModuleSpecifierError(context, internal);\n}\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(context, 'All keys must either start with ./, or without one.');\n  }\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, {\n        target: mainExport,\n        subpath: ''\n      });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n  throw new InvalidModuleSpecifierError(context);\n}\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n  const {\n    pkgPath,\n    pkgJsonPath,\n    pkgJson\n  } = result;\n  const pkgURL = url.pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n  const {\n    imports\n  } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\nconst resolveImportPath = util.promisify(resolve__default['default']);\nconst readFile$1 = util.promisify(fs__default['default'].readFile);\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return {\n      pkgJsonPath,\n      pkgJson\n    };\n  } catch (_) {\n    return null;\n  }\n}\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    ({\n      packageInfo,\n      hasModuleSideEffects,\n      hasPackageEntry,\n      packageBrowserField\n    } = info);\n    return info.cachedPkg;\n  };\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n  let location;\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = url.fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n    if (result && result.pkgJson.exports) {\n      const {\n        pkgJson,\n        pkgJsonPath\n      } = result;\n      try {\n        const subpath = pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = url.pathToFileURL(pkgDr);\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(context, subpath, pkgJson.exports);\n        location = url.fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n  if (opts.customResolveOptions) {\n    const {\n      customResolveOptions\n    } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];\n      warnings.push('node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.');\n    }\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error('node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.');\n    }\n    ['basedir', 'package', 'extensions', 'includeCoreModules', 'readFile', 'isFile', 'isDirectory', 'realpath', 'packageFilter', 'pathFilter', 'paths', 'packageIterator'].forEach(resolveOption => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(`node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`);\n      }\n    });\n  }\n  return {\n    warnings\n  };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList__default['default']);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = object => {\n  Object.freeze(object);\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n  return object;\n};\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge__default['default']({}, defaults));\nfunction nodeResolve(opts = {}) {\n  const {\n    warnings\n  } = handleDeprecatedOptions(opts);\n  const options = {\n    ...defaults,\n    ...opts\n  };\n  const {\n    extensions,\n    jail,\n    moduleDirectories,\n    ignoreSideEffectsForRoot\n  } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = path.resolve(options.rootDir || process.cwd());\n  let {\n    dedupe\n  } = options;\n  let rollupOptions;\n  if (typeof dedupe !== 'function') {\n    dedupe = importee => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n  const resolveOnly = options.resolveOnly.map(pattern => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n  return {\n    name: 'node-resolve',\n    buildStart(options) {\n      rollupOptions = options;\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n      ({\n        preserveSymlinks\n      } = options);\n    },\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n      const baseDir = !importer || dedupe(importee) ? rootDir : path.dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = path.resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee = browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = path.resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n      if (!isRelativeImport && resolveOnly.length && !resolveOnly.some(pattern => pattern.test(id))) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n      const importSpecifierList = [];\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n      const importeeIsBuiltin = builtins.has(importee);\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n      importSpecifierList.push(importee);\n      const warn = (...args) => this.warn(...args);\n      const isRequire = opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n      const resolved = importeeIsBuiltin && preferBuiltins ? {\n        packageInfo: undefined,\n        hasModuleSideEffects: () => null,\n        hasPackageEntry: true,\n        packageBrowserField: false\n      } : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n      const {\n        packageInfo,\n        hasModuleSideEffects,\n        hasPackageEntry,\n        packageBrowserField\n      } = resolved;\n      let {\n        location\n      } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n      idToPackageInfo.set(location, packageInfo);\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(`preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`);\n          }\n          return false;\n        } else if (jail && location.indexOf(path.normalize(jail.trim(path.sep))) !== 0) {\n          return null;\n        }\n      }\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule__default['default'](code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\nexports.DEFAULTS = DEFAULTS;\nexports.default = nodeResolve;\nexports.nodeResolve = nodeResolve;","map":{"version":3,"names":["Object","defineProperty","exports","value","path","require","builtinList","deepMerge","isModule","fs","util","url","resolve","pluginutils","_interopDefaultLegacy","e","path__default","builtinList__default","deepMerge__default","isModule__default","fs__default","resolve__default","access","promisify","readFile","realpath","stat","exists","filePath","onError","error","code","makeCache","fn","cache","Map","wrapped","param","done","has","set","catch","err","delete","result","get","clear","isDirCached","file","stats","isDirectory","isFileCached","isFile","readCachedFile","getPackageName","id","startsWith","split","getMainFields","options","mainFields","browser","indexOf","concat","length","Error","getPackageInfo","extensions","pkg","preserveSymlinks","useBrowserOverrides","rootDir","ignoreSideEffectsForRoot","pkgPath","realpathSync","pkgRoot","dirname","packageInfo","packageJson","packageJsonPath","root","resolvedMainField","browserMappedMain","resolvedEntryPoint","overriddenMain","i","field","main","internalPackageInfo","cachedPkg","hasModuleSideEffects","hasPackageEntry","packageBrowserField","keys","reduce","key","resolved","absoluteKey","extname","subBrowser","ext","browserMap","hasOwnProperty","packageSideEffects","sideEffects","Array","isArray","createFilter","normalizeInput","input","values","fileExists","isModuleDir","current","moduleDirs","some","dir","endsWith","findPackageJson","base","parse","pkgJsonPath","join","pkgJsonString","readFileSync","pkgJson","JSON","isUrl","str","URL","_","isConditions","every","k","isMappings","isMixedExports","createBaseErrorMsg","importSpecifier","importer","createErrorMsg","context","reason","internal","ResolveError","InvalidConfigurationError","constructor","InvalidModuleSpecifierError","InvalidPackageTargetError","includesInvalidSegments","pathSegments","slice","t","includes","resolvePackageTarget","target","subpath","pattern","p","resolveId","replace","pkgURL","href","pathToFileURL","location","resolvedTarget","lastError","item","undefined","entries","conditions","resolvePackageImportsExports","matchKey","matchObj","expansionKeys","filter","sort","a","b","expansionKey","prefix","substring","resolvePackageExports","mainExport","resolvedMatch","resolvePackageImports","imports","resolveImportPath","readFile$1","getPackageJson","pkgName","resolveOptions","moduleDirectories","selfPackageJsonResult","name","exportConditions","warn","packageInfoCache","baseDir","info","basedir","includeCoreModules","moduleDirectory","packageFilter","resolveResult","parent","fileURLToPath","pkgDr","resolvedPackageExport","resolveImportSpecifiers","importSpecifierList","lastResolveError","handleDeprecatedOptions","opts","warnings","customResolveOptions","push","forEach","resolveOption","builtins","Set","ES6_BROWSER_EMPTY","deepFreeze","object","freeze","isFrozen","baseConditions","baseConditionsEsm","baseConditionsCjs","defaults","dedupe","resolveOnly","DEFAULTS","nodeResolve","jail","conditionsEsm","conditionsCjs","idToPackageInfo","isPreferBuiltinsSet","preferBuiltins","process","cwd","rollupOptions","importee","map","RegExp","normalized","browserMapCache","buildStart","warning","generateBundle","test","importPath","params","importSuffix","resolvedImportee","browserImportee","parts","shift","isRelativeImport","match","importeeIsBuiltin","args","isRequire","custom","resolvedWithoutBuiltins","prototype","call","normalize","trim","sep","modulesOnly","moduleSideEffects","load","getPackageInfoForId","default"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@rollup/plugin-node-resolve/dist/cjs/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar path = require('path');\nvar builtinList = require('builtin-modules');\nvar deepMerge = require('deepmerge');\nvar isModule = require('is-module');\nvar fs = require('fs');\nvar util = require('util');\nvar url = require('url');\nvar resolve = require('resolve');\nvar pluginutils = require('@rollup/pluginutils');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar builtinList__default = /*#__PURE__*/_interopDefaultLegacy(builtinList);\nvar deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);\nvar isModule__default = /*#__PURE__*/_interopDefaultLegacy(isModule);\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar resolve__default = /*#__PURE__*/_interopDefaultLegacy(resolve);\n\nconst access = util.promisify(fs__default['default'].access);\nconst readFile = util.promisify(fs__default['default'].readFile);\nconst realpath = util.promisify(fs__default['default'].realpath);\nconst stat = util.promisify(fs__default['default'].stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = (error) => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\n\nconst makeCache = (fn) => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(\n        param,\n        fn(param).catch((err) => {\n          cache.delete(param);\n          throw err;\n        })\n      );\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst isFileCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({ mainFields } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let { pkgPath } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = fs.realpathSync(pkgPath);\n  }\n\n  const pkgRoot = path.dirname(pkgPath);\n\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg },\n\n    // path to package.json file\n    packageJsonPath: pkgPath,\n\n    // directory containing the package.json\n    root: pkgRoot,\n\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField:\n      useBrowserOverrides &&\n      typeof pkg.browser === 'object' &&\n      Object.keys(pkg.browser).reduce((browser, key) => {\n        let resolved = pkg.browser[key];\n        if (resolved && resolved[0] === '.') {\n          resolved = path.resolve(pkgRoot, resolved);\n        }\n        /* eslint-disable no-param-reassign */\n        browser[key] = resolved;\n        if (key[0] === '.') {\n          const absoluteKey = path.resolve(pkgRoot, key);\n          browser[absoluteKey] = resolved;\n          if (!path.extname(key)) {\n            extensions.reduce((subBrowser, ext) => {\n              subBrowser[absoluteKey + ext] = subBrowser[key];\n              return subBrowser;\n            }, browser);\n          }\n        }\n        return browser;\n      }, {}),\n    packageInfo\n  };\n\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (\n    useBrowserOverrides &&\n    typeof pkg.browser === 'object' &&\n    // eslint-disable-next-line no-prototype-builtins\n    browserMap.hasOwnProperty(pkg.main)\n  ) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = path.resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = pluginutils.createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = util.promisify(fs__default['default'].exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some((dir) => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const { root } = path__default['default'].parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path__default['default'].join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs__default['default'].readFileSync(pkgJsonPath, 'utf-8');\n      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current, pkgJsonPath };\n    }\n    current = path__default['default'].resolve(current, '..');\n  }\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every((k) => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some((k) => k.startsWith('.')) && keys.some((k) => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const { importSpecifier, importer, pkgJsonPath } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments\n    .split('/')\n    .slice(1)\n    .some((t) => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, { target, subpath, pattern, internal }) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some((p) => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(\n            target.replace(/\\*/g, subpath),\n            context.pkgURL.href\n          );\n          return result ? url.pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? url.pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(\n        context,\n        `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`\n      );\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, { matchKey, matchObj, internal }) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, { target, subpath: '', internal });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj)\n    .filter((k) => k.endsWith('/') || k.endsWith('*'))\n    .sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n\n      const resolved = await resolvePackageTarget(context, { target, subpath, internal });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(\n      context,\n      'All keys must either start with ./, or without one.'\n    );\n  }\n\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, { target: mainExport, subpath: '' });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const { pkgPath, pkgJsonPath, pkgJson } = result;\n  const pkgURL = url.pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n\n  const { imports } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = util.promisify(resolve__default['default']);\nconst readFile$1 = util.promisify(fs__default['default'].readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return { pkgJsonPath, pkgJson };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);\n\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n\n  let location;\n\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = url.fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const { pkgJson, pkgJsonPath } = result;\n      try {\n        const subpath =\n          pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = url.pathToFileURL(pkgDr);\n\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(\n          context,\n          subpath,\n          pkgJson.exports\n        );\n        location = url.fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const { customResolveOptions } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory)\n        ? customResolveOptions.moduleDirectory\n        : [customResolveOptions.moduleDirectory];\n\n      warnings.push(\n        'node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.'\n      );\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error(\n        'node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.'\n      );\n    }\n\n    [\n      'basedir',\n      'package',\n      'extensions',\n      'includeCoreModules',\n      'readFile',\n      'isFile',\n      'isDirectory',\n      'realpath',\n      'packageFilter',\n      'pathFilter',\n      'paths',\n      'packageIterator'\n    ].forEach((resolveOption) => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(\n          `node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`\n        );\n      }\n    });\n  }\n\n  return { warnings };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList__default['default']);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = (object) => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge__default['default']({}, defaults));\n\nfunction nodeResolve(opts = {}) {\n  const { warnings } = handleDeprecatedOptions(opts);\n\n  const options = { ...defaults, ...opts };\n  const { extensions, jail, moduleDirectories, ignoreSideEffectsForRoot } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = path.resolve(options.rootDir || process.cwd());\n  let { dedupe } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = (importee) =>\n      options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map((pattern) => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({ preserveSymlinks } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n\n      const baseDir = !importer || dedupe(importee) ? rootDir : path.dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = path.resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee =\n          browser[importee] ||\n          browser[resolvedImportee] ||\n          browser[`${resolvedImportee}.js`] ||\n          browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = path.resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (\n        !isRelativeImport &&\n        resolveOnly.length &&\n        !resolveOnly.some((pattern) => pattern.test(id))\n      ) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = (...args) => this.warn(...args);\n      const isRequire =\n        opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n\n      const resolved =\n        importeeIsBuiltin && preferBuiltins\n          ? {\n              packageInfo: undefined,\n              hasModuleSideEffects: () => null,\n              hasPackageEntry: true,\n              packageBrowserField: false\n            }\n          : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n\n      const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;\n      let { location } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(\n              `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`\n            );\n          }\n          return false;\n        } else if (jail && location.indexOf(path.normalize(jail.trim(path.sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule__default['default'](code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\n\nexports.DEFAULTS = DEFAULTS;\nexports.default = nodeResolve;\nexports.nodeResolve = nodeResolve;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}