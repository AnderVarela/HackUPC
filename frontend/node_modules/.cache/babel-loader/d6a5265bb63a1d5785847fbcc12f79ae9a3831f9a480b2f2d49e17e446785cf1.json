{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar _cleanupSemantic = require('./cleanupSemantic');\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (op, diffs, changeColor) => diffs.reduce((reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n? changeColor(diff[1]) : ''), ''); // Encapsulate change lines until either a common newline or the end.\n\nclass ChangeBuffer {\n  // incomplete line\n  // complete lines\n  constructor(op, changeColor) {\n    _defineProperty(this, 'op', void 0);\n    _defineProperty(this, 'line', void 0);\n    _defineProperty(this, 'lines', void 0);\n    _defineProperty(this, 'changeColor', void 0);\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(this.line.length !== 1 ? new _cleanupSemantic.Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] // can use instance\n    : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  } // Minor input to buffer.\n\n  pushDiff(diff) {\n    this.line.push(diff);\n  } // Main input to buffer.\n\n  align(diff) {\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  } // Output from buffer.\n\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n} // Encapsulate common and change lines.\n\nclass CommonBuffer {\n  constructor(deleteBuffer, insertBuffer) {\n    _defineProperty(this, 'deleteBuffer', void 0);\n    _defineProperty(this, 'insertBuffer', void 0);\n    _defineProperty(this, 'lines', void 0);\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  } // Input to buffer.\n\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  } // Output from buffer.\n\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n} // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\nvar _default = getAlignedDiffs;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_cleanupSemantic","require","_defineProperty","obj","key","enumerable","configurable","writable","concatenateRelevantDiffs","op","diffs","changeColor","reduce","reduced","diff","DIFF_EQUAL","length","ChangeBuffer","constructor","line","lines","pushSubstring","substring","pushDiff","Diff","pushLine","push","isLineEmpty","align","string","includes","substrings","split","iLast","forEach","i","moveLinesTo","CommonBuffer","deleteBuffer","insertBuffer","pushDiffCommonLine","pushDiffChangeLines","isDiffEmpty","flushChangeLines","subdiff","getLines","getAlignedDiffs","DIFF_DELETE","DIFF_INSERT","commonBuffer","_default"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/globals/node_modules/jest-diff/build/getAlignedDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (op, diffs, changeColor) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n        ? changeColor(diff[1])\n        : ''),\n    ''\n  ); // Encapsulate change lines until either a common newline or the end.\n\nclass ChangeBuffer {\n  // incomplete line\n  // complete lines\n  constructor(op, changeColor) {\n    _defineProperty(this, 'op', void 0);\n\n    _defineProperty(this, 'line', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    _defineProperty(this, 'changeColor', void 0);\n\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(\n      this.line.length !== 1\n        ? new _cleanupSemantic.Diff(\n            this.op,\n            concatenateRelevantDiffs(this.op, this.line, this.changeColor)\n          )\n        : this.line[0][0] === this.op\n        ? this.line[0] // can use instance\n        : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n    this.line.length = 0;\n  }\n\n  isLineEmpty() {\n    return this.line.length === 0;\n  } // Minor input to buffer.\n\n  pushDiff(diff) {\n    this.line.push(diff);\n  } // Main input to buffer.\n\n  align(diff) {\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  } // Output from buffer.\n\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n} // Encapsulate common and change lines.\n\nclass CommonBuffer {\n  constructor(deleteBuffer, insertBuffer) {\n    _defineProperty(this, 'deleteBuffer', void 0);\n\n    _defineProperty(this, 'insertBuffer', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  } // Input to buffer.\n\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  } // Output from buffer.\n\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n} // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_DELETE,\n    changeColor\n  );\n  const insertBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_INSERT,\n    changeColor\n  );\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\n\nvar _default = getAlignedDiffs;\nexports.default = _default;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}