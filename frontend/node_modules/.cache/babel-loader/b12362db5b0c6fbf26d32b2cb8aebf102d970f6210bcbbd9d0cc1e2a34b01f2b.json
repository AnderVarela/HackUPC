{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nclass FunctionSignature {\n  static create(checker, tsNode) {\n    var _a;\n    const signature = checker.getResolvedSignature(tsNode);\n    if (!signature) {\n      return null;\n    }\n    const paramTypes = [];\n    let restType = null;\n    const parameters = signature.getParameters();\n    for (let i = 0; i < parameters.length; i += 1) {\n      const param = parameters[i];\n      const type = checker.getTypeOfSymbolAtLocation(param, tsNode);\n      const decl = (_a = param.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];\n      if (decl && ts.isParameter(decl) && decl.dotDotDotToken) {\n        // is a rest param\n        if (checker.isArrayType(type)) {\n          restType = {\n            type: util.getTypeArguments(type, checker)[0],\n            kind: 0 /* RestTypeKind.Array */,\n            index: i\n          };\n        } else if (checker.isTupleType(type)) {\n          restType = {\n            typeArguments: util.getTypeArguments(type, checker),\n            kind: 1 /* RestTypeKind.Tuple */,\n            index: i\n          };\n        } else {\n          restType = {\n            type,\n            kind: 2 /* RestTypeKind.Other */,\n            index: i\n          };\n        }\n        break;\n      }\n      paramTypes.push(type);\n    }\n    return new this(paramTypes, restType);\n  }\n  constructor(paramTypes, restType) {\n    this.paramTypes = paramTypes;\n    this.restType = restType;\n    this.parameterTypeIndex = 0;\n    this.hasConsumedArguments = false;\n  }\n  getNextParameterType() {\n    const index = this.parameterTypeIndex;\n    this.parameterTypeIndex += 1;\n    if (index >= this.paramTypes.length || this.hasConsumedArguments) {\n      if (this.restType == null) {\n        return null;\n      }\n      switch (this.restType.kind) {\n        case 1 /* RestTypeKind.Tuple */:\n          {\n            const typeArguments = this.restType.typeArguments;\n            if (this.hasConsumedArguments) {\n              // all types consumed by a rest - just assume it's the last type\n              // there is one edge case where this is wrong, but we ignore it because\n              // it's rare and really complicated to handle\n              // eg: function foo(...a: [number, ...string[], number])\n              return typeArguments[typeArguments.length - 1];\n            }\n            const typeIndex = index - this.restType.index;\n            if (typeIndex >= typeArguments.length) {\n              return typeArguments[typeArguments.length - 1];\n            }\n            return typeArguments[typeIndex];\n          }\n        case 0 /* RestTypeKind.Array */:\n        case 2 /* RestTypeKind.Other */:\n          return this.restType.type;\n      }\n    }\n    return this.paramTypes[index];\n  }\n  consumeRemainingArguments() {\n    this.hasConsumedArguments = true;\n  }\n}\nexports.default = util.createRule({\n  name: 'no-unsafe-argument',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow calling a function with a value with type `any`',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unsafeArgument: 'Unsafe argument of type `{{sender}}` assigned to a parameter of type `{{receiver}}`.',\n      unsafeTupleSpread: 'Unsafe spread of a tuple type. The argument is of type `{{sender}}` and is assigned to a parameter of type `{{receiver}}`.',\n      unsafeArraySpread: 'Unsafe spread of an `any` array type.',\n      unsafeSpread: 'Unsafe spread of an `any` type.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    return {\n      'CallExpression, NewExpression'(node) {\n        if (node.arguments.length === 0) {\n          return;\n        }\n        // ignore any-typed calls as these are caught by no-unsafe-call\n        if (util.isTypeAnyType(checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(node.callee)))) {\n          return;\n        }\n        const tsNode = esTreeNodeToTSNodeMap.get(node);\n        const signature = FunctionSignature.create(checker, tsNode);\n        if (!signature) {\n          return;\n        }\n        for (const argument of node.arguments) {\n          switch (argument.type) {\n            // spreads consume\n            case utils_1.AST_NODE_TYPES.SpreadElement:\n              {\n                const spreadArgType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(argument.argument));\n                if (util.isTypeAnyType(spreadArgType)) {\n                  // foo(...any)\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeSpread'\n                  });\n                } else if (util.isTypeAnyArrayType(spreadArgType, checker)) {\n                  // foo(...any[])\n                  // TODO - we could break down the spread and compare the array type against each argument\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeArraySpread'\n                  });\n                } else if (checker.isTupleType(spreadArgType)) {\n                  // foo(...[tuple1, tuple2])\n                  const spreadTypeArguments = util.getTypeArguments(spreadArgType, checker);\n                  for (const tupleType of spreadTypeArguments) {\n                    const parameterType = signature.getNextParameterType();\n                    if (parameterType == null) {\n                      continue;\n                    }\n                    const result = util.isUnsafeAssignment(tupleType, parameterType, checker,\n                    // we can't pass the individual tuple members in here as this will most likely be a spread variable\n                    // not a spread array\n                    null);\n                    if (result) {\n                      context.report({\n                        node: argument,\n                        messageId: 'unsafeTupleSpread',\n                        data: {\n                          sender: checker.typeToString(tupleType),\n                          receiver: checker.typeToString(parameterType)\n                        }\n                      });\n                    }\n                  }\n                  if (spreadArgType.target.hasRestElement) {\n                    // the last element was a rest - so all remaining defined arguments can be considered \"consumed\"\n                    // all remaining arguments should be compared against the rest type (if one exists)\n                    signature.consumeRemainingArguments();\n                  }\n                } else {\n                  // something that's iterable\n                  // handling this will be pretty complex - so we ignore it for now\n                  // TODO - handle generic iterable case\n                }\n                break;\n              }\n            default:\n              {\n                const parameterType = signature.getNextParameterType();\n                if (parameterType == null) {\n                  continue;\n                }\n                const argumentType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(argument));\n                const result = util.isUnsafeAssignment(argumentType, parameterType, checker, argument);\n                if (result) {\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeArgument',\n                    data: {\n                      sender: checker.typeToString(argumentType),\n                      receiver: checker.typeToString(parameterType)\n                    }\n                  });\n                }\n              }\n          }\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","ts","__importStar","util","FunctionSignature","create","checker","tsNode","signature","getResolvedSignature","paramTypes","restType","parameters","getParameters","i","length","param","type","getTypeOfSymbolAtLocation","decl","_a","getDeclarations","isParameter","dotDotDotToken","isArrayType","getTypeArguments","kind","index","isTupleType","typeArguments","push","constructor","parameterTypeIndex","hasConsumedArguments","getNextParameterType","typeIndex","consumeRemainingArguments","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","unsafeArgument","unsafeTupleSpread","unsafeArraySpread","unsafeSpread","schema","defaultOptions","context","program","esTreeNodeToTSNodeMap","getParserServices","getTypeChecker","CallExpression, NewExpression","node","arguments","isTypeAnyType","getTypeAtLocation","get","callee","argument","AST_NODE_TYPES","SpreadElement","spreadArgType","report","messageId","isTypeAnyArrayType","spreadTypeArguments","tupleType","parameterType","result","isUnsafeAssignment","data","sender","typeToString","receiver","target","hasRestElement","argumentType"],"sources":["../../src/rules/no-unsafe-argument.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,EAAA,GAAAC,YAAA,CAAAF,OAAA;AAEA,MAAAG,IAAA,GAAAD,YAAA,CAAAF,OAAA;AA8BA,MAAMI,iBAAiB;EAGd,OAAOC,MAAMA,CAClBC,OAAuB,EACvBC,MAA6B;;IAE7B,MAAMC,SAAS,GAAGF,OAAO,CAACG,oBAAoB,CAACF,MAAM,CAAC;IACtD,IAAI,CAACC,SAAS,EAAE;MACd,OAAO,IAAI;;IAGb,MAAME,UAAU,GAAc,EAAE;IAChC,IAAIC,QAAQ,GAAoB,IAAI;IAEpC,MAAMC,UAAU,GAAGJ,SAAS,CAACK,aAAa,EAAE;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC7C,MAAME,KAAK,GAAGJ,UAAU,CAACE,CAAC,CAAC;MAC3B,MAAMG,IAAI,GAAGX,OAAO,CAACY,yBAAyB,CAACF,KAAK,EAAET,MAAM,CAAC;MAE7D,MAAMY,IAAI,GAAG,CAAAC,EAAA,GAAAJ,KAAK,CAACK,eAAe,EAAE,cAAAD,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC;MACzC,IAAID,IAAI,IAAIlB,EAAE,CAACqB,WAAW,CAACH,IAAI,CAAC,IAAIA,IAAI,CAACI,cAAc,EAAE;QACvD;QACA,IAAIjB,OAAO,CAACkB,WAAW,CAACP,IAAI,CAAC,EAAE;UAC7BN,QAAQ,GAAG;YACTM,IAAI,EAAEd,IAAI,CAACsB,gBAAgB,CAACR,IAAI,EAAEX,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7CoB,IAAI;YACJC,KAAK,EAAEb;WACR;SACF,MAAM,IAAIR,OAAO,CAACsB,WAAW,CAACX,IAAI,CAAC,EAAE;UACpCN,QAAQ,GAAG;YACTkB,aAAa,EAAE1B,IAAI,CAACsB,gBAAgB,CAACR,IAAI,EAAEX,OAAO,CAAC;YACnDoB,IAAI;YACJC,KAAK,EAAEb;WACR;SACF,MAAM;UACLH,QAAQ,GAAG;YACTM,IAAI;YACJS,IAAI;YACJC,KAAK,EAAEb;WACR;;QAEH;;MAGFJ,UAAU,CAACoB,IAAI,CAACb,IAAI,CAAC;;IAGvB,OAAO,IAAI,IAAI,CAACP,UAAU,EAAEC,QAAQ,CAAC;EACvC;EAIAoB,YACUrB,UAAqB,EACrBC,QAAyB;IADzB,KAAAD,UAAU,GAAVA,UAAU;IACV,KAAAC,QAAQ,GAARA,QAAQ;IAtDV,KAAAqB,kBAAkB,GAAG,CAAC;IAkDtB,KAAAC,oBAAoB,GAAG,KAAK;EAKjC;EAEIC,oBAAoBA,CAAA;IACzB,MAAMP,KAAK,GAAG,IAAI,CAACK,kBAAkB;IACrC,IAAI,CAACA,kBAAkB,IAAI,CAAC;IAE5B,IAAIL,KAAK,IAAI,IAAI,CAACjB,UAAU,CAACK,MAAM,IAAI,IAAI,CAACkB,oBAAoB,EAAE;MAChE,IAAI,IAAI,CAACtB,QAAQ,IAAI,IAAI,EAAE;QACzB,OAAO,IAAI;;MAGb,QAAQ,IAAI,CAACA,QAAQ,CAACe,IAAI;QACxB;UAAyB;YACvB,MAAMG,aAAa,GAAG,IAAI,CAAClB,QAAQ,CAACkB,aAAa;YACjD,IAAI,IAAI,CAACI,oBAAoB,EAAE;cAC7B;cACA;cACA;cACA;cACA,OAAOJ,aAAa,CAACA,aAAa,CAACd,MAAM,GAAG,CAAC,CAAC;;YAGhD,MAAMoB,SAAS,GAAGR,KAAK,GAAG,IAAI,CAAChB,QAAQ,CAACgB,KAAK;YAC7C,IAAIQ,SAAS,IAAIN,aAAa,CAACd,MAAM,EAAE;cACrC,OAAOc,aAAa,CAACA,aAAa,CAACd,MAAM,GAAG,CAAC,CAAC;;YAGhD,OAAOc,aAAa,CAACM,SAAS,CAAC;;QAGjC;QACA;UACE,OAAO,IAAI,CAACxB,QAAQ,CAACM,IAAI;;;IAG/B,OAAO,IAAI,CAACP,UAAU,CAACiB,KAAK,CAAC;EAC/B;EAEOS,yBAAyBA,CAAA;IAC9B,IAAI,CAACH,oBAAoB,GAAG,IAAI;EAClC;;AAGFI,OAAA,CAAAC,OAAA,GAAenC,IAAI,CAACoC,UAAU,CAAiB;EAC7CC,IAAI,EAAE,oBAAoB;EAC1BC,IAAI,EAAE;IACJxB,IAAI,EAAE,SAAS;IACfyB,IAAI,EAAE;MACJC,WAAW,EAAE,0DAA0D;MACvEC,WAAW,EAAE,OAAO;MACpBC,oBAAoB,EAAE;KACvB;IACDC,QAAQ,EAAE;MACRC,cAAc,EACZ,sFAAsF;MACxFC,iBAAiB,EACf,4HAA4H;MAC9HC,iBAAiB,EAAE,uCAAuC;MAC1DC,YAAY,EAAE;KACf;IACDC,MAAM,EAAE;GACT;EACDC,cAAc,EAAE,EAAE;EAClB/C,MAAMA,CAACgD,OAAO;IACZ,MAAM;MAAEC,OAAO;MAAEC;IAAqB,CAAE,GAAGpD,IAAI,CAACqD,iBAAiB,CAACH,OAAO,CAAC;IAC1E,MAAM/C,OAAO,GAAGgD,OAAO,CAACG,cAAc,EAAE;IAExC,OAAO;MACL,+BAA+BC,CAC7BC,IAAsD;QAEtD,IAAIA,IAAI,CAACC,SAAS,CAAC7C,MAAM,KAAK,CAAC,EAAE;UAC/B;;QAGF;QACA,IACEZ,IAAI,CAAC0D,aAAa,CAChBvD,OAAO,CAACwD,iBAAiB,CAACP,qBAAqB,CAACQ,GAAG,CAACJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAClE,EACD;UACA;;QAGF,MAAMzD,MAAM,GAAGgD,qBAAqB,CAACQ,GAAG,CAACJ,IAAI,CAAC;QAC9C,MAAMnD,SAAS,GAAGJ,iBAAiB,CAACC,MAAM,CAACC,OAAO,EAAEC,MAAM,CAAC;QAC3D,IAAI,CAACC,SAAS,EAAE;UACd;;QAGF,KAAK,MAAMyD,QAAQ,IAAIN,IAAI,CAACC,SAAS,EAAE;UACrC,QAAQK,QAAQ,CAAChD,IAAI;YACnB;YACA,KAAKlB,OAAA,CAAAmE,cAAc,CAACC,aAAa;cAAE;gBACjC,MAAMC,aAAa,GAAG9D,OAAO,CAACwD,iBAAiB,CAC7CP,qBAAqB,CAACQ,GAAG,CAACE,QAAQ,CAACA,QAAQ,CAAC,CAC7C;gBAED,IAAI9D,IAAI,CAAC0D,aAAa,CAACO,aAAa,CAAC,EAAE;kBACrC;kBACAf,OAAO,CAACgB,MAAM,CAAC;oBACbV,IAAI,EAAEM,QAAQ;oBACdK,SAAS,EAAE;mBACZ,CAAC;iBACH,MAAM,IAAInE,IAAI,CAACoE,kBAAkB,CAACH,aAAa,EAAE9D,OAAO,CAAC,EAAE;kBAC1D;kBAEA;kBACA+C,OAAO,CAACgB,MAAM,CAAC;oBACbV,IAAI,EAAEM,QAAQ;oBACdK,SAAS,EAAE;mBACZ,CAAC;iBACH,MAAM,IAAIhE,OAAO,CAACsB,WAAW,CAACwC,aAAa,CAAC,EAAE;kBAC7C;kBACA,MAAMI,mBAAmB,GAAGrE,IAAI,CAACsB,gBAAgB,CAC/C2C,aAAa,EACb9D,OAAO,CACR;kBACD,KAAK,MAAMmE,SAAS,IAAID,mBAAmB,EAAE;oBAC3C,MAAME,aAAa,GAAGlE,SAAS,CAAC0B,oBAAoB,EAAE;oBACtD,IAAIwC,aAAa,IAAI,IAAI,EAAE;sBACzB;;oBAEF,MAAMC,MAAM,GAAGxE,IAAI,CAACyE,kBAAkB,CACpCH,SAAS,EACTC,aAAa,EACbpE,OAAO;oBACP;oBACA;oBACA,IAAI,CACL;oBACD,IAAIqE,MAAM,EAAE;sBACVtB,OAAO,CAACgB,MAAM,CAAC;wBACbV,IAAI,EAAEM,QAAQ;wBACdK,SAAS,EAAE,mBAAmB;wBAC9BO,IAAI,EAAE;0BACJC,MAAM,EAAExE,OAAO,CAACyE,YAAY,CAACN,SAAS,CAAC;0BACvCO,QAAQ,EAAE1E,OAAO,CAACyE,YAAY,CAACL,aAAa;;uBAE/C,CAAC;;;kBAGN,IAAIN,aAAa,CAACa,MAAM,CAACC,cAAc,EAAE;oBACvC;oBACA;oBACA1E,SAAS,CAAC4B,yBAAyB,EAAE;;iBAExC,MAAM;kBACL;kBACA;kBACA;gBAAA;gBAEF;;YAGF;cAAS;gBACP,MAAMsC,aAAa,GAAGlE,SAAS,CAAC0B,oBAAoB,EAAE;gBACtD,IAAIwC,aAAa,IAAI,IAAI,EAAE;kBACzB;;gBAGF,MAAMS,YAAY,GAAG7E,OAAO,CAACwD,iBAAiB,CAC5CP,qBAAqB,CAACQ,GAAG,CAACE,QAAQ,CAAC,CACpC;gBACD,MAAMU,MAAM,GAAGxE,IAAI,CAACyE,kBAAkB,CACpCO,YAAY,EACZT,aAAa,EACbpE,OAAO,EACP2D,QAAQ,CACT;gBACD,IAAIU,MAAM,EAAE;kBACVtB,OAAO,CAACgB,MAAM,CAAC;oBACbV,IAAI,EAAEM,QAAQ;oBACdK,SAAS,EAAE,gBAAgB;oBAC3BO,IAAI,EAAE;sBACJC,MAAM,EAAExE,OAAO,CAACyE,YAAY,CAACI,YAAY,CAAC;sBAC1CH,QAAQ,EAAE1E,OAAO,CAACyE,YAAY,CAACL,aAAa;;mBAE/C,CAAC;;;;;MAKZ;KACD;EACH;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}