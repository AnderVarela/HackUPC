{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-unnecessary-boolean-literal-compare',\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary equality comparisons against boolean literals',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      direct: 'This expression unnecessarily compares a boolean value to a boolean instead of using it directly.',\n      negated: 'This expression unnecessarily compares a boolean value to a boolean instead of negating it.',\n      comparingNullableToTrueDirect: 'This expression unnecessarily compares a nullable boolean value to true instead of using it directly.',\n      comparingNullableToTrueNegated: 'This expression unnecessarily compares a nullable boolean value to true instead of negating it.',\n      comparingNullableToFalse: 'This expression unnecessarily compares a nullable boolean value to false instead of using the ?? operator to provide a default.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowComparingNullableBooleansToTrue: {\n          description: 'Whether to allow comparisons between nullable boolean variables and `true`.',\n          type: 'boolean'\n        },\n        allowComparingNullableBooleansToFalse: {\n          description: 'Whether to allow comparisons between nullable boolean variables and `false`.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{\n    allowComparingNullableBooleansToTrue: true,\n    allowComparingNullableBooleansToFalse: true\n  }],\n  create(context, [options]) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    function getBooleanComparison(node) {\n      const comparison = deconstructComparison(node);\n      if (!comparison) {\n        return undefined;\n      }\n      const expressionType = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(comparison.expression));\n      if (isBooleanType(expressionType)) {\n        return Object.assign(Object.assign({}, comparison), {\n          expressionIsNullableBoolean: false\n        });\n      }\n      if (isNullableBoolean(expressionType)) {\n        return Object.assign(Object.assign({}, comparison), {\n          expressionIsNullableBoolean: true\n        });\n      }\n      return undefined;\n    }\n    function isBooleanType(expressionType) {\n      return tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);\n    }\n    /**\n     * checks if the expressionType is a union that\n     *   1) contains at least one nullish type (null or undefined)\n     *   2) contains at least once boolean type (true or false or boolean)\n     *   3) does not contain any types besides nullish and boolean types\n     */\n    function isNullableBoolean(expressionType) {\n      if (!expressionType.isUnion()) {\n        return false;\n      }\n      const {\n        types\n      } = expressionType;\n      const nonNullishTypes = types.filter(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Undefined | ts.TypeFlags.Null));\n      const hasNonNullishType = nonNullishTypes.length > 0;\n      if (!hasNonNullishType) {\n        return false;\n      }\n      const hasNullableType = nonNullishTypes.length < types.length;\n      if (!hasNullableType) {\n        return false;\n      }\n      const allNonNullishTypesAreBoolean = nonNullishTypes.every(isBooleanType);\n      if (!allNonNullishTypesAreBoolean) {\n        return false;\n      }\n      return true;\n    }\n    function deconstructComparison(node) {\n      const comparisonType = getEqualsKind(node.operator);\n      if (!comparisonType) {\n        return undefined;\n      }\n      for (const [against, expression] of [[node.right, node.left], [node.left, node.right]]) {\n        if (against.type !== utils_1.AST_NODE_TYPES.Literal || typeof against.value !== 'boolean') {\n          continue;\n        }\n        const {\n          value: literalBooleanInComparison\n        } = against;\n        const negated = !comparisonType.isPositive;\n        return {\n          literalBooleanInComparison,\n          expression,\n          negated\n        };\n      }\n      return undefined;\n    }\n    function nodeIsUnaryNegation(node) {\n      return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.prefix && node.operator === '!';\n    }\n    return {\n      BinaryExpression(node) {\n        const comparison = getBooleanComparison(node);\n        if (comparison === undefined) {\n          return;\n        }\n        if (comparison.expressionIsNullableBoolean) {\n          if (comparison.literalBooleanInComparison && options.allowComparingNullableBooleansToTrue) {\n            return;\n          }\n          if (!comparison.literalBooleanInComparison && options.allowComparingNullableBooleansToFalse) {\n            return;\n          }\n        }\n        context.report({\n          fix: function* (fixer) {\n            // 1. isUnaryNegation - parent negation\n            // 2. literalBooleanInComparison - is compared to literal boolean\n            // 3. negated - is expression negated\n            const isUnaryNegation = node.parent != null && nodeIsUnaryNegation(node.parent);\n            const shouldNegate = comparison.negated !== comparison.literalBooleanInComparison;\n            const mutatedNode = isUnaryNegation ? node.parent : node;\n            yield fixer.replaceText(mutatedNode, sourceCode.getText(comparison.expression));\n            // if `isUnaryNegation === literalBooleanInComparison === !negated` is true - negate the expression\n            if (shouldNegate === isUnaryNegation) {\n              yield fixer.insertTextBefore(mutatedNode, '!');\n              // if the expression `exp` is not a strong precedence node, wrap it in parentheses\n              if (!util.isStrongPrecedenceNode(comparison.expression)) {\n                yield fixer.insertTextBefore(mutatedNode, '(');\n                yield fixer.insertTextAfter(mutatedNode, ')');\n              }\n            }\n            // if the expression `exp` is nullable, and we're not comparing to `true`, insert `?? true`\n            if (comparison.expressionIsNullableBoolean && !comparison.literalBooleanInComparison) {\n              // provide the default `true`\n              yield fixer.insertTextBefore(mutatedNode, '(');\n              yield fixer.insertTextAfter(mutatedNode, ' ?? true)');\n            }\n          },\n          messageId: comparison.expressionIsNullableBoolean ? comparison.literalBooleanInComparison ? comparison.negated ? 'comparingNullableToTrueNegated' : 'comparingNullableToTrueDirect' : 'comparingNullableToFalse' : comparison.negated ? 'negated' : 'direct',\n          node\n        });\n      }\n    };\n  }\n});\nfunction getEqualsKind(operator) {\n  switch (operator) {\n    case '==':\n      return {\n        isPositive: true,\n        isStrict: false\n      };\n    case '===':\n      return {\n        isPositive: true,\n        isStrict: true\n      };\n    case '!=':\n      return {\n        isPositive: false,\n        isStrict: false\n      };\n    case '!==':\n      return {\n        isPositive: false,\n        isStrict: true\n      };\n    default:\n      return undefined;\n  }\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","direct","negated","comparingNullableToTrueDirect","comparingNullableToTrueNegated","comparingNullableToFalse","schema","type","properties","allowComparingNullableBooleansToTrue","allowComparingNullableBooleansToFalse","additionalProperties","defaultOptions","create","context","options","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","getBooleanComparison","node","comparison","deconstructComparison","undefined","expressionType","getTypeAtLocation","esTreeNodeToTSNodeMap","get","expression","isBooleanType","Object","assign","expressionIsNullableBoolean","isNullableBoolean","isTypeFlagSet","TypeFlags","Boolean","BooleanLiteral","isUnion","types","nonNullishTypes","filter","Undefined","Null","hasNonNullishType","length","hasNullableType","allNonNullishTypesAreBoolean","every","comparisonType","getEqualsKind","operator","against","right","left","AST_NODE_TYPES","Literal","value","literalBooleanInComparison","isPositive","nodeIsUnaryNegation","UnaryExpression","prefix","BinaryExpression","report","fix","fixer","isUnaryNegation","parent","shouldNegate","mutatedNode","replaceText","getText","insertTextBefore","isStrongPrecedenceNode","insertTextAfter","messageId","isStrict"],"sources":["../../src/rules/no-unnecessary-boolean-literal-compare.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAC,YAAA,CAAAF,OAAA;AACA,MAAAG,EAAA,GAAAD,YAAA,CAAAF,OAAA;AAEA,MAAAI,IAAA,GAAAF,YAAA,CAAAF,OAAA;AA0BAK,OAAA,CAAAC,OAAA,GAAeF,IAAI,CAACG,UAAU,CAAsB;EAClDC,IAAI,EAAE,wCAAwC;EAC9CC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EACT,oEAAoE;MACtEC,WAAW,EAAE,QAAQ;MACrBC,oBAAoB,EAAE;KACvB;IACDC,OAAO,EAAE,MAAM;IACfC,QAAQ,EAAE;MACRC,MAAM,EACJ,mGAAmG;MACrGC,OAAO,EACL,6FAA6F;MAC/FC,6BAA6B,EAC3B,uGAAuG;MACzGC,8BAA8B,EAC5B,iGAAiG;MACnGC,wBAAwB,EACtB;KACH;IACDC,MAAM,EAAE,CACN;MACEC,IAAI,EAAE,QAAQ;MACdC,UAAU,EAAE;QACVC,oCAAoC,EAAE;UACpCb,WAAW,EACT,6EAA6E;UAC/EW,IAAI,EAAE;SACP;QACDG,qCAAqC,EAAE;UACrCd,WAAW,EACT,8EAA8E;UAChFW,IAAI,EAAE;;OAET;MACDI,oBAAoB,EAAE;KACvB,CACF;IACDJ,IAAI,EAAE;GACP;EACDK,cAAc,EAAE,CACd;IACEH,oCAAoC,EAAE,IAAI;IAC1CC,qCAAqC,EAAE;GACxC,CACF;EACDG,MAAMA,CAACC,OAAO,EAAE,CAACC,OAAO,CAAC;IACvB,MAAMC,cAAc,GAAG3B,IAAI,CAAC4B,iBAAiB,CAACH,OAAO,CAAC;IACtD,MAAMI,OAAO,GAAGF,cAAc,CAACG,OAAO,CAACC,cAAc,EAAE;IACvD,MAAMC,UAAU,GAAGP,OAAO,CAACQ,aAAa,EAAE;IAE1C,SAASC,oBAAoBA,CAC3BC,IAA+B;MAE/B,MAAMC,UAAU,GAAGC,qBAAqB,CAACF,IAAI,CAAC;MAC9C,IAAI,CAACC,UAAU,EAAE;QACf,OAAOE,SAAS;;MAGlB,MAAMC,cAAc,GAAGV,OAAO,CAACW,iBAAiB,CAC9Cb,cAAc,CAACc,qBAAqB,CAACC,GAAG,CAACN,UAAU,CAACO,UAAU,CAAC,CAChE;MAED,IAAIC,aAAa,CAACL,cAAc,CAAC,EAAE;QACjC,OAAAM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKV,UAAU;UACbW,2BAA2B,EAAE;QAAK;;MAItC,IAAIC,iBAAiB,CAACT,cAAc,CAAC,EAAE;QACrC,OAAAM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKV,UAAU;UACbW,2BAA2B,EAAE;QAAI;;MAIrC,OAAOT,SAAS;IAClB;IAEA,SAASM,aAAaA,CAACL,cAAuB;MAC5C,OAAO1C,OAAO,CAACoD,aAAa,CAC1BV,cAAc,EACdxC,EAAE,CAACmD,SAAS,CAACC,OAAO,GAAGpD,EAAE,CAACmD,SAAS,CAACE,cAAc,CACnD;IACH;IAEA;;;;;;IAMA,SAASJ,iBAAiBA,CAACT,cAAuB;MAChD,IAAI,CAACA,cAAc,CAACc,OAAO,EAAE,EAAE;QAC7B,OAAO,KAAK;;MAGd,MAAM;QAAEC;MAAK,CAAE,GAAGf,cAAc;MAEhC,MAAMgB,eAAe,GAAGD,KAAK,CAACE,MAAM,CAClCtC,IAAI,IACF,CAACrB,OAAO,CAACoD,aAAa,CACpB/B,IAAI,EACJnB,EAAE,CAACmD,SAAS,CAACO,SAAS,GAAG1D,EAAE,CAACmD,SAAS,CAACQ,IAAI,CAC3C,CACJ;MAED,MAAMC,iBAAiB,GAAGJ,eAAe,CAACK,MAAM,GAAG,CAAC;MACpD,IAAI,CAACD,iBAAiB,EAAE;QACtB,OAAO,KAAK;;MAGd,MAAME,eAAe,GAAGN,eAAe,CAACK,MAAM,GAAGN,KAAK,CAACM,MAAM;MAC7D,IAAI,CAACC,eAAe,EAAE;QACpB,OAAO,KAAK;;MAGd,MAAMC,4BAA4B,GAAGP,eAAe,CAACQ,KAAK,CAACnB,aAAa,CAAC;MACzE,IAAI,CAACkB,4BAA4B,EAAE;QACjC,OAAO,KAAK;;MAGd,OAAO,IAAI;IACb;IAEA,SAASzB,qBAAqBA,CAC5BF,IAA+B;MAE/B,MAAM6B,cAAc,GAAGC,aAAa,CAAC9B,IAAI,CAAC+B,QAAQ,CAAC;MACnD,IAAI,CAACF,cAAc,EAAE;QACnB,OAAO1B,SAAS;;MAGlB,KAAK,MAAM,CAAC6B,OAAO,EAAExB,UAAU,CAAC,IAAI,CAClC,CAACR,IAAI,CAACiC,KAAK,EAAEjC,IAAI,CAACkC,IAAI,CAAC,EACvB,CAAClC,IAAI,CAACkC,IAAI,EAAElC,IAAI,CAACiC,KAAK,CAAC,CACxB,EAAE;QACD,IACED,OAAO,CAACjD,IAAI,KAAKvB,OAAA,CAAA2E,cAAc,CAACC,OAAO,IACvC,OAAOJ,OAAO,CAACK,KAAK,KAAK,SAAS,EAClC;UACA;;QAGF,MAAM;UAAEA,KAAK,EAAEC;QAA0B,CAAE,GAAGN,OAAO;QACrD,MAAMtD,OAAO,GAAG,CAACmD,cAAc,CAACU,UAAU;QAE1C,OAAO;UACLD,0BAA0B;UAC1B9B,UAAU;UACV9B;SACD;;MAGH,OAAOyB,SAAS;IAClB;IAEA,SAASqC,mBAAmBA,CAACxC,IAAmB;MAC9C,OACEA,IAAI,CAACjB,IAAI,KAAKvB,OAAA,CAAA2E,cAAc,CAACM,eAAe,IAC5CzC,IAAI,CAAC0C,MAAM,IACX1C,IAAI,CAAC+B,QAAQ,KAAK,GAAG;IAEzB;IAEA,OAAO;MACLY,gBAAgBA,CAAC3C,IAAI;QACnB,MAAMC,UAAU,GAAGF,oBAAoB,CAACC,IAAI,CAAC;QAC7C,IAAIC,UAAU,KAAKE,SAAS,EAAE;UAC5B;;QAGF,IAAIF,UAAU,CAACW,2BAA2B,EAAE;UAC1C,IACEX,UAAU,CAACqC,0BAA0B,IACrC/C,OAAO,CAACN,oCAAoC,EAC5C;YACA;;UAEF,IACE,CAACgB,UAAU,CAACqC,0BAA0B,IACtC/C,OAAO,CAACL,qCAAqC,EAC7C;YACA;;;QAIJI,OAAO,CAACsD,MAAM,CAAC;UACbC,GAAG,EAAE,UAAAA,CAAWC,KAAK;YACnB;YACA;YACA;YAEA,MAAMC,eAAe,GACnB/C,IAAI,CAACgD,MAAM,IAAI,IAAI,IAAIR,mBAAmB,CAACxC,IAAI,CAACgD,MAAM,CAAC;YAEzD,MAAMC,YAAY,GAChBhD,UAAU,CAACvB,OAAO,KAAKuB,UAAU,CAACqC,0BAA0B;YAE9D,MAAMY,WAAW,GAAGH,eAAe,GAAG/C,IAAI,CAACgD,MAAO,GAAGhD,IAAI;YAEzD,MAAM8C,KAAK,CAACK,WAAW,CACrBD,WAAW,EACXrD,UAAU,CAACuD,OAAO,CAACnD,UAAU,CAACO,UAAU,CAAC,CAC1C;YAED;YACA,IAAIyC,YAAY,KAAKF,eAAe,EAAE;cACpC,MAAMD,KAAK,CAACO,gBAAgB,CAACH,WAAW,EAAE,GAAG,CAAC;cAE9C;cACA,IAAI,CAACrF,IAAI,CAACyF,sBAAsB,CAACrD,UAAU,CAACO,UAAU,CAAC,EAAE;gBACvD,MAAMsC,KAAK,CAACO,gBAAgB,CAACH,WAAW,EAAE,GAAG,CAAC;gBAC9C,MAAMJ,KAAK,CAACS,eAAe,CAACL,WAAW,EAAE,GAAG,CAAC;;;YAIjD;YACA,IACEjD,UAAU,CAACW,2BAA2B,IACtC,CAACX,UAAU,CAACqC,0BAA0B,EACtC;cACA;cACA,MAAMQ,KAAK,CAACO,gBAAgB,CAACH,WAAW,EAAE,GAAG,CAAC;cAC9C,MAAMJ,KAAK,CAACS,eAAe,CAACL,WAAW,EAAE,WAAW,CAAC;;UAEzD,CAAC;UACDM,SAAS,EAAEvD,UAAU,CAACW,2BAA2B,GAC7CX,UAAU,CAACqC,0BAA0B,GACnCrC,UAAU,CAACvB,OAAO,GAChB,gCAAgC,GAChC,+BAA+B,GACjC,0BAA0B,GAC5BuB,UAAU,CAACvB,OAAO,GAClB,SAAS,GACT,QAAQ;UACZsB;SACD,CAAC;MACJ;KACD;EACH;CACD,CAAC;AAOF,SAAS8B,aAAaA,CAACC,QAAgB;EACrC,QAAQA,QAAQ;IACd,KAAK,IAAI;MACP,OAAO;QACLQ,UAAU,EAAE,IAAI;QAChBkB,QAAQ,EAAE;OACX;IAEH,KAAK,KAAK;MACR,OAAO;QACLlB,UAAU,EAAE,IAAI;QAChBkB,QAAQ,EAAE;OACX;IAEH,KAAK,IAAI;MACP,OAAO;QACLlB,UAAU,EAAE,KAAK;QACjBkB,QAAQ,EAAE;OACX;IAEH,KAAK,KAAK;MACR,OAAO;QACLlB,UAAU,EAAE,KAAK;QACjBkB,QAAQ,EAAE;OACX;IAEH;MACE,OAAOtD,SAAS;;AAEtB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}