{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst allowedFunctionVariableDefTypes = new Set([utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration, utils_1.AST_NODE_TYPES.TSFunctionType, utils_1.AST_NODE_TYPES.TSMethodSignature]);\nexports.default = util.createRule({\n  name: 'no-shadow',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow variable declarations from shadowing variables declared in the outer scope',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        builtinGlobals: {\n          type: 'boolean'\n        },\n        hoist: {\n          enum: ['all', 'functions', 'never']\n        },\n        allow: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        ignoreOnInitialization: {\n          type: 'boolean'\n        },\n        ignoreTypeValueShadow: {\n          type: 'boolean'\n        },\n        ignoreFunctionTypeParameterNameValueShadow: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n      noShadowGlobal: \"'{{name}}' is already a global variable.\"\n    }\n  },\n  defaultOptions: [{\n    allow: [],\n    builtinGlobals: false,\n    hoist: 'functions',\n    ignoreOnInitialization: false,\n    ignoreTypeValueShadow: true,\n    ignoreFunctionTypeParameterNameValueShadow: true\n  }],\n  create(context, [options]) {\n    /**\n     * Check if a scope is a TypeScript module augmenting the global namespace.\n     */\n    function isGlobalAugmentation(scope) {\n      return scope.type === scope_manager_1.ScopeType.tsModule && !!scope.block.global || !!scope.upper && isGlobalAugmentation(scope.upper);\n    }\n    /**\n     * Check if variable is a `this` parameter.\n     */\n    function isThisParam(variable) {\n      return variable.defs[0].type === scope_manager_1.DefinitionType.Parameter && variable.name === 'this';\n    }\n    function isTypeImport(definition) {\n      return (definition === null || definition === void 0 ? void 0 : definition.type) === scope_manager_1.DefinitionType.ImportBinding && (definition.parent.importKind === 'type' || definition.node.type === utils_1.AST_NODE_TYPES.ImportSpecifier && definition.node.importKind === 'type');\n    }\n    function isTypeValueShadow(variable, shadowed) {\n      if (options.ignoreTypeValueShadow !== true) {\n        return false;\n      }\n      if (!('isValueVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n      const [firstDefinition] = shadowed.defs;\n      const isShadowedValue = !('isValueVariable' in shadowed) || !firstDefinition || !isTypeImport(firstDefinition) && shadowed.isValueVariable;\n      return variable.isValueVariable !== isShadowedValue;\n    }\n    function isFunctionTypeParameterNameValueShadow(variable, shadowed) {\n      if (options.ignoreFunctionTypeParameterNameValueShadow !== true) {\n        return false;\n      }\n      if (!('isValueVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n      const isShadowedValue = 'isValueVariable' in shadowed ? shadowed.isValueVariable : true;\n      if (!isShadowedValue) {\n        return false;\n      }\n      return variable.defs.every(def => allowedFunctionVariableDefTypes.has(def.node.type));\n    }\n    function isGenericOfStaticMethod(variable) {\n      if (!('isTypeVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n      if (!variable.isTypeVariable) {\n        return false;\n      }\n      if (variable.identifiers.length === 0) {\n        return false;\n      }\n      const typeParameter = variable.identifiers[0].parent;\n      if ((typeParameter === null || typeParameter === void 0 ? void 0 : typeParameter.type) !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n        return false;\n      }\n      const typeParameterDecl = typeParameter.parent;\n      if ((typeParameterDecl === null || typeParameterDecl === void 0 ? void 0 : typeParameterDecl.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n        return false;\n      }\n      const functionExpr = typeParameterDecl.parent;\n      if (!functionExpr || functionExpr.type !== utils_1.AST_NODE_TYPES.FunctionExpression && functionExpr.type !== utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n        return false;\n      }\n      const methodDefinition = functionExpr.parent;\n      if ((methodDefinition === null || methodDefinition === void 0 ? void 0 : methodDefinition.type) !== utils_1.AST_NODE_TYPES.MethodDefinition) {\n        return false;\n      }\n      return methodDefinition.static;\n    }\n    function isGenericOfClassDecl(variable) {\n      if (!('isTypeVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n      if (!variable.isTypeVariable) {\n        return false;\n      }\n      if (variable.identifiers.length === 0) {\n        return false;\n      }\n      const typeParameter = variable.identifiers[0].parent;\n      if ((typeParameter === null || typeParameter === void 0 ? void 0 : typeParameter.type) !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n        return false;\n      }\n      const typeParameterDecl = typeParameter.parent;\n      if ((typeParameterDecl === null || typeParameterDecl === void 0 ? void 0 : typeParameterDecl.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n        return false;\n      }\n      const classDecl = typeParameterDecl.parent;\n      return (classDecl === null || classDecl === void 0 ? void 0 : classDecl.type) === utils_1.AST_NODE_TYPES.ClassDeclaration;\n    }\n    function isGenericOfAStaticMethodShadow(variable, shadowed) {\n      return isGenericOfStaticMethod(variable) && isGenericOfClassDecl(shadowed);\n    }\n    function isImportDeclaration(definition) {\n      return definition.type === utils_1.AST_NODE_TYPES.ImportDeclaration;\n    }\n    function isExternalModuleDeclarationWithName(scope, name) {\n      return scope.type === scope_manager_1.ScopeType.tsModule && scope.block.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration && scope.block.id.type === utils_1.AST_NODE_TYPES.Literal && scope.block.id.value === name;\n    }\n    function isExternalDeclarationMerging(scope, variable, shadowed) {\n      var _a;\n      const [firstDefinition] = shadowed.defs;\n      const [secondDefinition] = variable.defs;\n      return isTypeImport(firstDefinition) && isImportDeclaration(firstDefinition.parent) && isExternalModuleDeclarationWithName(scope, firstDefinition.parent.source.value) && secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration && ((_a = secondDefinition.node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;\n    }\n    /**\n     * Check if variable name is allowed.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable name is allowed.\n     */\n    function isAllowed(variable) {\n      return options.allow.indexOf(variable.name) !== -1;\n    }\n    /**\n     * Checks if a variable of the class name in the class scope of ClassDeclaration.\n     *\n     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable of the class name in the class scope of ClassDeclaration.\n     */\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === utils_1.AST_NODE_TYPES.ClassDeclaration && block.id === variable.identifiers[0];\n    }\n    /**\n     * Checks if a variable of the class name in the class scope of TSEnumDeclaration.\n     *\n     * TSEnumDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable of the class name in the class scope of TSEnumDeclaration.\n     */\n    function isDuplicatedEnumNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration && block.id === variable.identifiers[0];\n    }\n    /**\n     * Checks whether or not a given location is inside of the range of a given node.\n     * @param node An node to check.\n     * @param location A location to check.\n     * @returns `true` if the location is inside of the range of the node.\n     */\n    function isInRange(node, location) {\n      return node && node.range[0] <= location && location <= node.range[1];\n    }\n    /**\n     * Searches from the current node through its ancestry to find a matching node.\n     * @param node a node to get.\n     * @param match a callback that checks whether or not the node verifies its condition or not.\n     * @returns the matching node.\n     */\n    function findSelfOrAncestor(node, match) {\n      let currentNode = node;\n      while (currentNode && !match(currentNode)) {\n        currentNode = currentNode.parent;\n      }\n      return currentNode;\n    }\n    /**\n     * Finds function's outer scope.\n     * @param scope Function's own scope.\n     * @returns Function's outer scope.\n     */\n    function getOuterScope(scope) {\n      const upper = scope.upper;\n      if ((upper === null || upper === void 0 ? void 0 : upper.type) === 'function-expression-name') {\n        return upper.upper;\n      }\n      return upper;\n    }\n    /**\n     * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n     * @param variable a variable to check.\n     * @param shadowedVariable a shadowedVariable to check.\n     * @returns Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n     */\n    function isInitPatternNode(variable, shadowedVariable) {\n      var _a, _b, _c, _d;\n      const outerDef = shadowedVariable.defs[0];\n      if (!outerDef) {\n        return false;\n      }\n      const {\n        variableScope\n      } = variable.scope;\n      if (!((variableScope.block.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || variableScope.block.type === utils_1.AST_NODE_TYPES.FunctionExpression) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n        return false;\n      }\n      const fun = variableScope.block;\n      const {\n        parent\n      } = fun;\n      const callExpression = findSelfOrAncestor(parent, node => node.type === utils_1.AST_NODE_TYPES.CallExpression);\n      if (!callExpression) {\n        return false;\n      }\n      let node = outerDef.name;\n      const location = callExpression.range[1];\n      while (node) {\n        if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n          if (isInRange(node.init, location)) {\n            return true;\n          }\n          if ((((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ForInStatement || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.type) === utils_1.AST_NODE_TYPES.ForOfStatement) && isInRange(node.parent.parent.right, location)) {\n            return true;\n          }\n          break;\n        } else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n          if (isInRange(node.right, location)) {\n            return true;\n          }\n        } else if ([utils_1.AST_NODE_TYPES.FunctionDeclaration, utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.ClassExpression, utils_1.AST_NODE_TYPES.ArrowFunctionExpression, utils_1.AST_NODE_TYPES.CatchClause, utils_1.AST_NODE_TYPES.ImportDeclaration, utils_1.AST_NODE_TYPES.ExportNamedDeclaration].includes(node.type)) {\n          break;\n        }\n        node = node.parent;\n      }\n      return false;\n    }\n    /**\n     * Checks if a variable is inside the initializer of scopeVar.\n     *\n     * To avoid reporting at declarations such as `var a = function a() {};`.\n     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n     * @param variable The variable to check.\n     * @param scopeVar The scope variable to look for.\n     * @returns Whether or not the variable is inside initializer of scopeVar.\n     */\n    function isOnInitializer(variable, scopeVar) {\n      var _a;\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = (_a = outerDef === null || outerDef === void 0 ? void 0 : outerDef.parent) === null || _a === void 0 ? void 0 : _a.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef === null || innerDef === void 0 ? void 0 : innerDef.name.range;\n      return !!(outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === scope_manager_1.DefinitionType.FunctionName && innerDef.node.type === utils_1.AST_NODE_TYPES.FunctionExpression || innerDef.node.type === utils_1.AST_NODE_TYPES.ClassExpression) && outerScope === innerScope.upper);\n    }\n    /**\n     * Get a range of a variable's identifier node.\n     * @param variable The variable to get.\n     * @returns The range of the variable's identifier node.\n     */\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def === null || def === void 0 ? void 0 : def.name.range;\n    }\n    /**\n     * Checks if a variable is in TDZ of scopeVar.\n     * @param variable The variable to check.\n     * @param scopeVar The variable of TDZ.\n     * @returns Whether or not the variable is in TDZ of scopeVar.\n     */\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return !!(inner && outer && inner[1] < outer[0] && (\n      // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n      options.hoist !== 'functions' || !outerDef || outerDef.node.type !== utils_1.AST_NODE_TYPES.FunctionDeclaration));\n    }\n    /**\n     * Get declared line and column of a variable.\n     * @param  variable The variable to get.\n     * @returns The declared line and column of the variable.\n     */\n    function getDeclaredLocation(variable) {\n      const identifier = variable.identifiers[0];\n      if (identifier) {\n        return {\n          global: false,\n          line: identifier.loc.start.line,\n          column: identifier.loc.start.column + 1\n        };\n      } else {\n        return {\n          global: true\n        };\n      }\n    }\n    /**\n     * Checks the current context for shadowed variables.\n     * @param {Scope} scope Fixme\n     */\n    function checkForShadows(scope) {\n      // ignore global augmentation\n      if (isGlobalAugmentation(scope)) {\n        return;\n      }\n      const variables = scope.variables;\n      for (const variable of variables) {\n        // ignore \"arguments\"\n        if (variable.identifiers.length === 0) {\n          continue;\n        }\n        // this params are pseudo-params that cannot be shadowed\n        if (isThisParam(variable)) {\n          continue;\n        }\n        // ignore variables of a class name in the class scope of ClassDeclaration\n        if (isDuplicatedClassNameVariable(variable)) {\n          continue;\n        }\n        // ignore variables of a class name in the class scope of ClassDeclaration\n        if (isDuplicatedEnumNameVariable(variable)) {\n          continue;\n        }\n        // ignore configured allowed names\n        if (isAllowed(variable)) {\n          continue;\n        }\n        // Gets shadowed variable.\n        const shadowed = scope.upper ? utils_1.ASTUtils.findVariable(scope.upper, variable.name) : null;\n        if (!shadowed) {\n          continue;\n        }\n        // ignore type value variable shadowing if configured\n        if (isTypeValueShadow(variable, shadowed)) {\n          continue;\n        }\n        // ignore function type parameter name shadowing if configured\n        if (isFunctionTypeParameterNameValueShadow(variable, shadowed)) {\n          continue;\n        }\n        // ignore static class method generic shadowing class generic\n        // this is impossible for the scope analyser to understand\n        // so we have to handle this manually in this rule\n        if (isGenericOfAStaticMethodShadow(variable, shadowed)) {\n          continue;\n        }\n        if (isExternalDeclarationMerging(scope, variable, shadowed)) {\n          continue;\n        }\n        const isESLintGlobal = ('writeable' in shadowed);\n        if ((shadowed.identifiers.length > 0 || options.builtinGlobals && isESLintGlobal) && !isOnInitializer(variable, shadowed) && !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(options.hoist !== 'all' && isInTdz(variable, shadowed))) {\n          const location = getDeclaredLocation(shadowed);\n          context.report(Object.assign({\n            node: variable.identifiers[0]\n          }, location.global ? {\n            messageId: 'noShadowGlobal',\n            data: {\n              name: variable.name\n            }\n          } : {\n            messageId: 'noShadow',\n            data: {\n              name: variable.name,\n              shadowedLine: location.line,\n              shadowedColumn: location.column\n            }\n          }));\n        }\n      }\n    }\n    return {\n      'Program:exit'() {\n        const globalScope = context.getScope();\n        const stack = globalScope.childScopes.slice();\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["scope_manager_1","require","utils_1","util","__importStar","allowedFunctionVariableDefTypes","Set","AST_NODE_TYPES","TSCallSignatureDeclaration","TSFunctionType","TSMethodSignature","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","schema","properties","builtinGlobals","hoist","enum","allow","items","ignoreOnInitialization","ignoreTypeValueShadow","ignoreFunctionTypeParameterNameValueShadow","additionalProperties","messages","noShadow","noShadowGlobal","defaultOptions","create","context","options","isGlobalAugmentation","scope","ScopeType","tsModule","block","global","upper","isThisParam","variable","defs","DefinitionType","Parameter","isTypeImport","definition","ImportBinding","parent","importKind","node","ImportSpecifier","isTypeValueShadow","shadowed","firstDefinition","isShadowedValue","isValueVariable","isFunctionTypeParameterNameValueShadow","every","def","has","isGenericOfStaticMethod","isTypeVariable","identifiers","length","typeParameter","TSTypeParameter","typeParameterDecl","TSTypeParameterDeclaration","functionExpr","FunctionExpression","TSEmptyBodyFunctionExpression","methodDefinition","MethodDefinition","static","isGenericOfClassDecl","classDecl","ClassDeclaration","isGenericOfAStaticMethodShadow","isImportDeclaration","ImportDeclaration","isExternalModuleDeclarationWithName","TSModuleDeclaration","id","Literal","value","isExternalDeclarationMerging","secondDefinition","source","TSInterfaceDeclaration","_a","ExportNamedDeclaration","isAllowed","indexOf","isDuplicatedClassNameVariable","isDuplicatedEnumNameVariable","TSEnumDeclaration","isInRange","location","range","findSelfOrAncestor","match","currentNode","getOuterScope","isInitPatternNode","shadowedVariable","outerDef","variableScope","ArrowFunctionExpression","fun","callExpression","CallExpression","VariableDeclarator","init","_b","ForInStatement","_d","_c","ForOfStatement","right","AssignmentPattern","FunctionDeclaration","ClassExpression","CatchClause","includes","isOnInitializer","scopeVar","outerScope","outer","innerScope","innerDef","inner","FunctionName","getNameRange","isInTdz","getDeclaredLocation","identifier","line","loc","start","column","checkForShadows","variables","ASTUtils","findVariable","isESLintGlobal","report","Object","assign","messageId","data","shadowedLine","shadowedColumn","Program:exit","globalScope","getScope","stack","childScopes","slice","pop","push"],"sources":["../../src/rules/no-shadow.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}