{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst util_1 = require(\"../util\");\n/**\n * The following is a list of exceptions to the rule\n * Generated via the following script.\n * This is statically defined to save making purposely invalid calls every lint run\n * ```\nSUPPORTED_GLOBALS.flatMap(namespace => {\n  const object = window[namespace];\n    return Object.getOwnPropertyNames(object)\n      .filter(\n        name =>\n          !name.startsWith('_') &&\n          typeof object[name] === 'function',\n      )\n      .map(name => {\n        try {\n          const x = object[name];\n          x();\n        } catch (e) {\n          if (e.message.includes(\"called on non-object\")) {\n            return `${namespace}.${name}`;\n          }\n        }\n      });\n}).filter(Boolean);\n   * ```\n */\nconst nativelyNotBoundMembers = new Set(['Promise.all', 'Promise.race', 'Promise.resolve', 'Promise.reject', 'Promise.allSettled', 'Object.defineProperties', 'Object.defineProperty', 'Reflect.defineProperty', 'Reflect.deleteProperty', 'Reflect.get', 'Reflect.getOwnPropertyDescriptor', 'Reflect.getPrototypeOf', 'Reflect.has', 'Reflect.isExtensible', 'Reflect.ownKeys', 'Reflect.preventExtensions', 'Reflect.set', 'Reflect.setPrototypeOf']);\nconst SUPPORTED_GLOBALS = ['Number', 'Object', 'String', 'RegExp', 'Symbol', 'Array', 'Proxy', 'Date', 'Infinity', 'Atomics', 'Reflect', 'console', 'Math', 'JSON', 'Intl'];\nconst nativelyBoundMembers = SUPPORTED_GLOBALS.map(namespace => {\n  if (!(namespace in global)) {\n    // node.js might not have namespaces like Intl depending on compilation options\n    // https://nodejs.org/api/intl.html#intl_options_for_building_node_js\n    return [];\n  }\n  const object = global[namespace];\n  return Object.getOwnPropertyNames(object).filter(name => !name.startsWith('_') && typeof object[name] === 'function').map(name => `${namespace}.${name}`);\n}).reduce((arr, names) => arr.concat(names), []).filter(name => !nativelyNotBoundMembers.has(name));\nconst isNotImported = (symbol, currentSourceFile) => {\n  const {\n    valueDeclaration\n  } = symbol;\n  if (!valueDeclaration) {\n    // working around https://github.com/microsoft/TypeScript/issues/31294\n    return false;\n  }\n  return !!currentSourceFile && currentSourceFile !== valueDeclaration.getSourceFile();\n};\nconst getNodeName = node => node.type === utils_1.AST_NODE_TYPES.Identifier ? node.name : null;\nconst getMemberFullName = node => `${getNodeName(node.object)}.${getNodeName(node.property)}`;\nconst BASE_MESSAGE = 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.';\nexports.default = util.createRule({\n  name: 'unbound-method',\n  meta: {\n    docs: {\n      description: 'Enforce unbound methods are called with their expected scope',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unbound: BASE_MESSAGE,\n      unboundWithoutThisAnnotation: BASE_MESSAGE + '\\n' + 'If your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreStatic: {\n          description: 'Whether to skip checking whether `static` methods are correctly bound.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    ignoreStatic: false\n  }],\n  create(context, [{\n    ignoreStatic\n  }]) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const currentSourceFile = parserServices.program.getSourceFile(context.getFilename());\n    function checkMethodAndReport(node, symbol) {\n      if (!symbol) {\n        return;\n      }\n      const {\n        dangerous,\n        firstParamIsThis\n      } = checkMethod(symbol, ignoreStatic);\n      if (dangerous) {\n        context.report({\n          messageId: firstParamIsThis === false ? 'unboundWithoutThisAnnotation' : 'unbound',\n          node\n        });\n      }\n    }\n    return {\n      MemberExpression(node) {\n        if (isSafeUse(node)) {\n          return;\n        }\n        const objectSymbol = checker.getSymbolAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.object));\n        if (objectSymbol && nativelyBoundMembers.includes(getMemberFullName(node)) && isNotImported(objectSymbol, currentSourceFile)) {\n          return;\n        }\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        checkMethodAndReport(node, checker.getSymbolAtLocation(originalNode));\n      },\n      'VariableDeclarator, AssignmentExpression'(node) {\n        const [idNode, initNode] = node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ? [node.id, node.init] : [node.left, node.right];\n        if (initNode && idNode.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(initNode);\n          const rightSymbol = checker.getSymbolAtLocation(tsNode);\n          const initTypes = checker.getTypeAtLocation(tsNode);\n          const notImported = rightSymbol && isNotImported(rightSymbol, currentSourceFile);\n          idNode.properties.forEach(property => {\n            if (property.type === utils_1.AST_NODE_TYPES.Property && property.key.type === utils_1.AST_NODE_TYPES.Identifier) {\n              if (notImported && util.isIdentifier(initNode) && nativelyBoundMembers.includes(`${initNode.name}.${property.key.name}`)) {\n                return;\n              }\n              checkMethodAndReport(property.key, initTypes.getProperty(property.key.name));\n            }\n          });\n        }\n      }\n    };\n  }\n});\nfunction checkMethod(symbol, ignoreStatic) {\n  var _a, _b;\n  const {\n    valueDeclaration\n  } = symbol;\n  if (!valueDeclaration) {\n    // working around https://github.com/microsoft/TypeScript/issues/31294\n    return {\n      dangerous: false\n    };\n  }\n  switch (valueDeclaration.kind) {\n    case ts.SyntaxKind.PropertyDeclaration:\n      return {\n        dangerous: ((_a = valueDeclaration.initializer) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.FunctionExpression\n      };\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.MethodSignature:\n      {\n        const decl = valueDeclaration;\n        const firstParam = decl.parameters[0];\n        const firstParamIsThis = (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.kind) === ts.SyntaxKind.Identifier && (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.escapedText) === 'this';\n        const thisArgIsVoid = firstParamIsThis && ((_b = firstParam === null || firstParam === void 0 ? void 0 : firstParam.type) === null || _b === void 0 ? void 0 : _b.kind) === ts.SyntaxKind.VoidKeyword;\n        return {\n          dangerous: !thisArgIsVoid && !(ignoreStatic && tsutils.hasModifier((0, util_1.getModifiers)(valueDeclaration), ts.SyntaxKind.StaticKeyword)),\n          firstParamIsThis\n        };\n      }\n  }\n  return {\n    dangerous: false\n  };\n}\nfunction isSafeUse(node) {\n  const parent = node.parent;\n  switch (parent === null || parent === void 0 ? void 0 : parent.type) {\n    case utils_1.AST_NODE_TYPES.IfStatement:\n    case utils_1.AST_NODE_TYPES.ForStatement:\n    case utils_1.AST_NODE_TYPES.MemberExpression:\n    case utils_1.AST_NODE_TYPES.SwitchStatement:\n    case utils_1.AST_NODE_TYPES.UpdateExpression:\n    case utils_1.AST_NODE_TYPES.WhileStatement:\n      return true;\n    case utils_1.AST_NODE_TYPES.CallExpression:\n      return parent.callee === node;\n    case utils_1.AST_NODE_TYPES.ConditionalExpression:\n      return parent.test === node;\n    case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n      return parent.tag === node;\n    case utils_1.AST_NODE_TYPES.UnaryExpression:\n      // the first case is safe for obvious\n      // reasons. The second one is also fine\n      // since we're returning something falsy\n      return ['typeof', '!', 'void', 'delete'].includes(parent.operator);\n    case utils_1.AST_NODE_TYPES.BinaryExpression:\n      return ['instanceof', '==', '!=', '===', '!=='].includes(parent.operator);\n    case utils_1.AST_NODE_TYPES.AssignmentExpression:\n      return parent.operator === '=' && (node === parent.left || node.type === utils_1.AST_NODE_TYPES.MemberExpression && node.object.type === utils_1.AST_NODE_TYPES.Super && parent.left.type === utils_1.AST_NODE_TYPES.MemberExpression && parent.left.object.type === utils_1.AST_NODE_TYPES.ThisExpression);\n    case utils_1.AST_NODE_TYPES.ChainExpression:\n    case utils_1.AST_NODE_TYPES.TSNonNullExpression:\n    case utils_1.AST_NODE_TYPES.TSAsExpression:\n    case utils_1.AST_NODE_TYPES.TSTypeAssertion:\n      return isSafeUse(parent);\n    case utils_1.AST_NODE_TYPES.LogicalExpression:\n      if (parent.operator === '&&' && parent.left === node) {\n        // this is safe, as && will return the left if and only if it's falsy\n        return true;\n      }\n      // in all other cases, it's likely the logical expression will return the method ref\n      // so make sure the parent is a safe usage\n      return isSafeUse(parent);\n  }\n  return false;\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","util_1","nativelyNotBoundMembers","Set","SUPPORTED_GLOBALS","nativelyBoundMembers","map","namespace","global","object","Object","getOwnPropertyNames","filter","name","startsWith","reduce","arr","names","concat","has","isNotImported","symbol","currentSourceFile","valueDeclaration","getSourceFile","getNodeName","node","type","AST_NODE_TYPES","Identifier","getMemberFullName","property","BASE_MESSAGE","exports","default","createRule","meta","docs","description","recommended","requiresTypeChecking","messages","unbound","unboundWithoutThisAnnotation","schema","properties","ignoreStatic","additionalProperties","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","getFilename","checkMethodAndReport","dangerous","firstParamIsThis","checkMethod","report","messageId","MemberExpression","isSafeUse","objectSymbol","getSymbolAtLocation","esTreeNodeToTSNodeMap","get","includes","originalNode","VariableDeclarator, AssignmentExpression","idNode","initNode","VariableDeclarator","id","init","left","right","ObjectPattern","tsNode","rightSymbol","initTypes","getTypeAtLocation","notImported","forEach","Property","key","isIdentifier","getProperty","kind","SyntaxKind","PropertyDeclaration","_a","initializer","FunctionExpression","MethodDeclaration","MethodSignature","decl","firstParam","parameters","escapedText","thisArgIsVoid","_b","VoidKeyword","hasModifier","getModifiers","StaticKeyword","parent","IfStatement","ForStatement","SwitchStatement","UpdateExpression","WhileStatement","CallExpression","callee","ConditionalExpression","test","TaggedTemplateExpression","tag","UnaryExpression","operator","BinaryExpression","AssignmentExpression","Super","ThisExpression","ChainExpression","TSNonNullExpression","TSAsExpression","TSTypeAssertion","LogicalExpression"],"sources":["../../src/rules/unbound-method.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}