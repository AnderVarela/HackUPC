{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst util = __importStar(require(\"../util\"));\nconst util_1 = require(\"../util\");\nexports.default = util.createRule({\n  name: 'no-unsafe-assignment',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow assigning a value with type `any` to variables and properties',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      anyAssignment: 'Unsafe assignment of an `any` value.',\n      anyAssignmentThis: ['Unsafe assignment of an `any` value. `this` is typed as `any`.', 'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.'].join('\\n'),\n      unsafeArrayPattern: 'Unsafe array destructuring of an `any` array value.',\n      unsafeArrayPatternFromTuple: 'Unsafe array destructuring of a tuple element with an `any` value.',\n      unsafeAssignment: 'Unsafe assignment of type {{sender}} to a variable of type {{receiver}}.',\n      unsafeArraySpread: 'Unsafe spread of an `any` value in an array.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    const compilerOptions = program.getCompilerOptions();\n    const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n    // returns true if the assignment reported\n    function checkArrayDestructureHelper(receiverNode, senderNode) {\n      if (receiverNode.type !== utils_1.AST_NODE_TYPES.ArrayPattern) {\n        return false;\n      }\n      const senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);\n      const senderType = checker.getTypeAtLocation(senderTsNode);\n      return checkArrayDestructure(receiverNode, senderType, senderTsNode);\n    }\n    // returns true if the assignment reported\n    function checkArrayDestructure(receiverNode, senderType, senderNode) {\n      // any array\n      // const [x] = ([] as any[]);\n      if (util.isTypeAnyArrayType(senderType, checker)) {\n        context.report({\n          node: receiverNode,\n          messageId: 'unsafeArrayPattern'\n        });\n        return false;\n      }\n      if (!checker.isTupleType(senderType)) {\n        return true;\n      }\n      const tupleElements = util.getTypeArguments(senderType, checker);\n      // tuple with any\n      // const [x] = [1 as any];\n      let didReport = false;\n      for (let receiverIndex = 0; receiverIndex < receiverNode.elements.length; receiverIndex += 1) {\n        const receiverElement = receiverNode.elements[receiverIndex];\n        if (!receiverElement) {\n          continue;\n        }\n        if (receiverElement.type === utils_1.AST_NODE_TYPES.RestElement) {\n          // don't handle rests as they're not a 1:1 assignment\n          continue;\n        }\n        const senderType = tupleElements[receiverIndex];\n        if (!senderType) {\n          continue;\n        }\n        // check for the any type first so we can handle [[[x]]] = [any]\n        if (util.isTypeAnyType(senderType)) {\n          context.report({\n            node: receiverElement,\n            messageId: 'unsafeArrayPatternFromTuple'\n          });\n          // we want to report on every invalid element in the tuple\n          didReport = true;\n        } else if (receiverElement.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n          didReport = checkArrayDestructure(receiverElement, senderType, senderNode);\n        } else if (receiverElement.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          didReport = checkObjectDestructure(receiverElement, senderType, senderNode);\n        }\n      }\n      return didReport;\n    }\n    // returns true if the assignment reported\n    function checkObjectDestructureHelper(receiverNode, senderNode) {\n      if (receiverNode.type !== utils_1.AST_NODE_TYPES.ObjectPattern) {\n        return false;\n      }\n      const senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);\n      const senderType = checker.getTypeAtLocation(senderTsNode);\n      return checkObjectDestructure(receiverNode, senderType, senderTsNode);\n    }\n    // returns true if the assignment reported\n    function checkObjectDestructure(receiverNode, senderType, senderNode) {\n      const properties = new Map(senderType.getProperties().map(property => [property.getName(), checker.getTypeOfSymbolAtLocation(property, senderNode)]));\n      let didReport = false;\n      for (const receiverProperty of receiverNode.properties) {\n        if (receiverProperty.type === utils_1.AST_NODE_TYPES.RestElement) {\n          // don't bother checking rest\n          continue;\n        }\n        let key;\n        if (receiverProperty.computed === false) {\n          key = receiverProperty.key.type === utils_1.AST_NODE_TYPES.Identifier ? receiverProperty.key.name : String(receiverProperty.key.value);\n        } else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.Literal) {\n          key = String(receiverProperty.key.value);\n        } else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral && receiverProperty.key.quasis.length === 1) {\n          key = String(receiverProperty.key.quasis[0].value.cooked);\n        } else {\n          // can't figure out the name, so skip it\n          continue;\n        }\n        const senderType = properties.get(key);\n        if (!senderType) {\n          continue;\n        }\n        // check for the any type first so we can handle {x: {y: z}} = {x: any}\n        if (util.isTypeAnyType(senderType)) {\n          context.report({\n            node: receiverProperty.value,\n            messageId: 'unsafeArrayPatternFromTuple'\n          });\n          didReport = true;\n        } else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n          didReport = checkArrayDestructure(receiverProperty.value, senderType, senderNode);\n        } else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          didReport = checkObjectDestructure(receiverProperty.value, senderType, senderNode);\n        }\n      }\n      return didReport;\n    }\n    // returns true if the assignment reported\n    function checkAssignment(receiverNode, senderNode, reportingNode, comparisonType) {\n      var _a;\n      const receiverTsNode = esTreeNodeToTSNodeMap.get(receiverNode);\n      const receiverType = comparisonType === 2 /* ComparisonType.Contextual */ ? (_a = util.getContextualType(checker, receiverTsNode)) !== null && _a !== void 0 ? _a : checker.getTypeAtLocation(receiverTsNode) : checker.getTypeAtLocation(receiverTsNode);\n      const senderType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(senderNode));\n      if (util.isTypeAnyType(senderType)) {\n        // handle cases when we assign any ==> unknown.\n        if (util.isTypeUnknownType(receiverType)) {\n          return false;\n        }\n        let messageId = 'anyAssignment';\n        if (!isNoImplicitThis) {\n          // `var foo = this`\n          const thisExpression = (0, util_1.getThisExpression)(senderNode);\n          if (thisExpression && util.isTypeAnyType(util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(thisExpression)))) {\n            messageId = 'anyAssignmentThis';\n          }\n        }\n        context.report({\n          node: reportingNode,\n          messageId\n        });\n        return true;\n      }\n      if (comparisonType === 0 /* ComparisonType.None */) {\n        return false;\n      }\n      const result = util.isUnsafeAssignment(senderType, receiverType, checker, senderNode);\n      if (!result) {\n        return false;\n      }\n      const {\n        sender,\n        receiver\n      } = result;\n      context.report({\n        node: reportingNode,\n        messageId: 'unsafeAssignment',\n        data: {\n          sender: checker.typeToString(sender),\n          receiver: checker.typeToString(receiver)\n        }\n      });\n      return true;\n    }\n    function getComparisonType(typeAnnotation) {\n      return typeAnnotation ?\n      // if there's a type annotation, we can do a comparison\n      1 /* ComparisonType.Basic */ :\n      // no type annotation means the variable's type will just be inferred, thus equal\n      0 /* ComparisonType.None */;\n    }\n    return {\n      'VariableDeclarator[init != null]'(node) {\n        const init = util.nullThrows(node.init, util.NullThrowsReasons.MissingToken(node.type, 'init'));\n        let didReport = checkAssignment(node.id, init, node, getComparisonType(node.id.typeAnnotation));\n        if (!didReport) {\n          didReport = checkArrayDestructureHelper(node.id, init);\n        }\n        if (!didReport) {\n          checkObjectDestructureHelper(node.id, init);\n        }\n      },\n      'PropertyDefinition[value != null]'(node) {\n        checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));\n      },\n      'AssignmentExpression[operator = \"=\"], AssignmentPattern'(node) {\n        let didReport = checkAssignment(node.left, node.right, node, 1 /* ComparisonType.Basic */);\n        if (!didReport) {\n          didReport = checkArrayDestructureHelper(node.left, node.right);\n        }\n        if (!didReport) {\n          checkObjectDestructureHelper(node.left, node.right);\n        }\n      },\n      // object pattern props are checked via assignments\n      ':not(ObjectPattern) > Property'(node) {\n        if (node.value.type === utils_1.AST_NODE_TYPES.AssignmentPattern || node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n          // handled by other selector\n          return;\n        }\n        checkAssignment(node.key, node.value, node, 2 /* ComparisonType.Contextual */);\n      },\n      'ArrayExpression > SpreadElement'(node) {\n        const resetNode = esTreeNodeToTSNodeMap.get(node.argument);\n        const restType = checker.getTypeAtLocation(resetNode);\n        if (util.isTypeAnyType(restType) || util.isTypeAnyArrayType(restType, checker)) {\n          context.report({\n            node: node,\n            messageId: 'unsafeArraySpread'\n          });\n        }\n      },\n      'JSXAttribute[value != null]'(node) {\n        const value = util.nullThrows(node.value, util.NullThrowsReasons.MissingToken(node.type, 'value'));\n        if (value.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer || value.expression.type === utils_1.AST_NODE_TYPES.JSXEmptyExpression) {\n          return;\n        }\n        checkAssignment(node.name, value.expression, value.expression, 2 /* ComparisonType.Contextual */);\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","util","util_1","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","anyAssignment","anyAssignmentThis","join","unsafeArrayPattern","unsafeArrayPatternFromTuple","unsafeAssignment","unsafeArraySpread","schema","defaultOptions","create","context","program","esTreeNodeToTSNodeMap","getParserServices","checker","getTypeChecker","compilerOptions","getCompilerOptions","isNoImplicitThis","isStrictCompilerOptionEnabled","checkArrayDestructureHelper","receiverNode","senderNode","AST_NODE_TYPES","ArrayPattern","senderTsNode","get","senderType","getTypeAtLocation","checkArrayDestructure","isTypeAnyArrayType","report","node","messageId","isTupleType","tupleElements","getTypeArguments","didReport","receiverIndex","elements","length","receiverElement","RestElement","isTypeAnyType","ObjectPattern","checkObjectDestructure","checkObjectDestructureHelper","properties","Map","getProperties","map","property","getName","getTypeOfSymbolAtLocation","receiverProperty","key","computed","Identifier","String","value","Literal","TemplateLiteral","quasis","cooked","checkAssignment","reportingNode","comparisonType","receiverTsNode","receiverType","_a","getContextualType","isTypeUnknownType","thisExpression","getThisExpression","getConstrainedTypeAtLocation","result","isUnsafeAssignment","sender","receiver","data","typeToString","getComparisonType","typeAnnotation","VariableDeclarator[init != null]","init","nullThrows","NullThrowsReasons","MissingToken","id","PropertyDefinition[value != null]","AssignmentExpression[operator = \"=\"], AssignmentPattern","left","right",":not(ObjectPattern) > Property","AssignmentPattern","TSEmptyBodyFunctionExpression","ArrayExpression > SpreadElement","resetNode","argument","restType","JSXAttribute[value != null]","JSXExpressionContainer","expression","JSXEmptyExpression"],"sources":["../../src/rules/no-unsafe-assignment.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}