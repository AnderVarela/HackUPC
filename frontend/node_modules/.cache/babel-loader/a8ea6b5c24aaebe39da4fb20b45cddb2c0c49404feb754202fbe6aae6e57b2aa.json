{"ast":null,"code":"\"use strict\";\n\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.KeyResolver = exports.ObjectMap = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for('TypeBox.Modifier');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n  const map = new Map();\n  /** Returns the entries in this registry */\n  function Entries() {\n    return new Map(map);\n  }\n  TypeRegistry.Entries = Entries;\n  /** Clears all user defined types */\n  function Clear() {\n    return map.clear();\n  }\n  TypeRegistry.Clear = Clear;\n  /** Returns true if this registry contains this kind */\n  function Has(kind) {\n    return map.has(kind);\n  }\n  TypeRegistry.Has = Has;\n  /** Sets a validation function for a user defined type */\n  function Set(kind, func) {\n    map.set(kind, func);\n  }\n  TypeRegistry.Set = Set;\n  /** Gets a custom validation function for a user defined type */\n  function Get(kind) {\n    return map.get(kind);\n  }\n  TypeRegistry.Get = Get;\n})(TypeRegistry = exports.TypeRegistry || (exports.TypeRegistry = {}));\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n  const map = new Map();\n  /** Returns the entries in this registry */\n  function Entries() {\n    return new Map(map);\n  }\n  FormatRegistry.Entries = Entries;\n  /** Clears all user defined string formats */\n  function Clear() {\n    return map.clear();\n  }\n  FormatRegistry.Clear = Clear;\n  /** Returns true if the user defined string format exists */\n  function Has(format) {\n    return map.has(format);\n  }\n  FormatRegistry.Has = Has;\n  /** Sets a validation function for a user defined string format */\n  function Set(format, func) {\n    map.set(format, func);\n  }\n  FormatRegistry.Set = Set;\n  /** Gets a validation function for a user defined string format */\n  function Get(format) {\n    return map.get(format);\n  }\n  FormatRegistry.Get = Get;\n})(FormatRegistry = exports.FormatRegistry || (exports.FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n  constructor(schema) {\n    super('TypeGuard: Unknown type');\n    this.schema = schema;\n  }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n  function IsObject(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n  }\n  function IsArray(value) {\n    return typeof value === 'object' && value !== null && Array.isArray(value);\n  }\n  function IsPattern(value) {\n    try {\n      new RegExp(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  function IsControlCharacterFree(value) {\n    if (typeof value !== 'string') return false;\n    for (let i = 0; i < value.length; i++) {\n      const code = value.charCodeAt(i);\n      if (code >= 7 && code <= 13 || code === 27 || code === 127) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function IsBigInt(value) {\n    return typeof value === 'bigint';\n  }\n  function IsString(value) {\n    return typeof value === 'string';\n  }\n  function IsNumber(value) {\n    return typeof value === 'number' && globalThis.Number.isFinite(value);\n  }\n  function IsBoolean(value) {\n    return typeof value === 'boolean';\n  }\n  function IsOptionalBigInt(value) {\n    return value === undefined || value !== undefined && IsBigInt(value);\n  }\n  function IsOptionalNumber(value) {\n    return value === undefined || value !== undefined && IsNumber(value);\n  }\n  function IsOptionalBoolean(value) {\n    return value === undefined || value !== undefined && IsBoolean(value);\n  }\n  function IsOptionalString(value) {\n    return value === undefined || value !== undefined && IsString(value);\n  }\n  function IsOptionalPattern(value) {\n    return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);\n  }\n  function IsOptionalFormat(value) {\n    return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value);\n  }\n  function IsOptionalSchema(value) {\n    return value === undefined || TSchema(value);\n  }\n  /** Returns true if the given schema is TAny */\n  function TAny(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Any' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TAny = TAny;\n  /** Returns true if the given schema is TArray */\n  function TArray(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Array' && schema.type === 'array' && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);\n  }\n  TypeGuard.TArray = TArray;\n  /** Returns true if the given schema is TBigInt */\n  function TBigInt(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'BigInt' && schema.type === 'null' && schema.typeOf === 'BigInt' && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);\n  }\n  TypeGuard.TBigInt = TBigInt;\n  /** Returns true if the given schema is TBoolean */\n  function TBoolean(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Boolean' && schema.type === 'boolean' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TBoolean = TBoolean;\n  /** Returns true if the given schema is TConstructor */\n  function TConstructor(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Constructor' && schema.type === 'object' && schema.instanceOf === 'Constructor' && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n      return false;\n    }\n    for (const parameter of schema.parameters) {\n      if (!TSchema(parameter)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TConstructor = TConstructor;\n  /** Returns true if the given schema is TDate */\n  function TDate(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Date' && schema.type === 'object' && schema.instanceOf === 'Date' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);\n  }\n  TypeGuard.TDate = TDate;\n  /** Returns true if the given schema is TFunction */\n  function TFunction(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Function' && schema.type === 'object' && schema.instanceOf === 'Function' && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n      return false;\n    }\n    for (const parameter of schema.parameters) {\n      if (!TSchema(parameter)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TFunction = TFunction;\n  /** Returns true if the given schema is TInteger */\n  function TInteger(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Integer' && schema.type === 'integer' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n  }\n  TypeGuard.TInteger = TInteger;\n  /** Returns true if the given schema is TIntersect */\n  function TIntersect(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Intersect' && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {\n      return false;\n    }\n    if ('type' in schema && schema.type !== 'object') {\n      return false;\n    }\n    for (const inner of schema.allOf) {\n      if (!TSchema(inner)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TIntersect = TIntersect;\n  /** Returns true if the given schema is TKind */\n  function TKind(schema) {\n    return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer\n  }\n  TypeGuard.TKind = TKind;\n  /** Returns true if the given schema is TLiteral */\n  function TLiteral(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && (IsString(schema.const) || IsNumber(schema.const) || IsBoolean(schema.const) || IsBigInt(schema.const));\n  }\n  TypeGuard.TLiteral = TLiteral;\n  /** Returns true if the given schema is TNever */\n  function TNever(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Never' && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n  }\n  TypeGuard.TNever = TNever;\n  /** Returns true if the given schema is TNot */\n  function TNot(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Not' && IsArray(schema.allOf) && schema.allOf.length === 2 && IsObject(schema.allOf[0]) && TSchema(schema.allOf[0].not) && TSchema(schema.allOf[1]);\n  }\n  TypeGuard.TNot = TNot;\n  /** Returns true if the given schema is TNull */\n  function TNull(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Null' && schema.type === 'null' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TNull = TNull;\n  /** Returns true if the given schema is TNumber */\n  function TNumber(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Number' && schema.type === 'number' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n  }\n  TypeGuard.TNumber = TNumber;\n  /** Returns true if the given schema is TObject */\n  function TObject(schema) {\n    if (!(TKind(schema) && schema[exports.Kind] === 'Object' && schema.type === 'object' && IsOptionalString(schema.$id) && IsObject(schema.properties) && (IsOptionalBoolean(schema.additionalProperties) || IsOptionalSchema(schema.additionalProperties)) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {\n      return false;\n    }\n    for (const [key, value] of Object.entries(schema.properties)) {\n      if (!IsControlCharacterFree(key)) return false;\n      if (!TSchema(value)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TObject = TObject;\n  /** Returns true if the given schema is TPromise */\n  function TPromise(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Promise' && schema.type === 'object' && schema.instanceOf === 'Promise' && IsOptionalString(schema.$id) && TSchema(schema.item);\n  }\n  TypeGuard.TPromise = TPromise;\n  /** Returns true if the given schema is TRecord */\n  function TRecord(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Record' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.additionalProperties === false && IsObject(schema.patternProperties))) {\n      return false;\n    }\n    const keys = Object.keys(schema.patternProperties);\n    if (keys.length !== 1) {\n      return false;\n    }\n    if (!IsPattern(keys[0])) {\n      return false;\n    }\n    if (!TSchema(schema.patternProperties[keys[0]])) {\n      return false;\n    }\n    return true;\n  }\n  TypeGuard.TRecord = TRecord;\n  /** Returns true if the given schema is TRef */\n  function TRef(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Ref' && IsOptionalString(schema.$id) && IsString(schema.$ref);\n  }\n  TypeGuard.TRef = TRef;\n  /** Returns true if the given schema is TString */\n  function TString(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'String' && schema.type === 'string' && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);\n  }\n  TypeGuard.TString = TString;\n  /** Returns true if the given schema is TSymbol */\n  function TSymbol(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Symbol' && schema.type === 'null' && schema.typeOf === 'Symbol' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TSymbol = TSymbol;\n  /** Returns true if the given schema is TTemplateLiteral */\n  function TTemplateLiteral(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'TemplateLiteral' && schema.type === 'string' && IsString(schema.pattern) && schema.pattern[0] === '^' && schema.pattern[schema.pattern.length - 1] === '$';\n  }\n  TypeGuard.TTemplateLiteral = TTemplateLiteral;\n  /** Returns true if the given schema is TThis */\n  function TThis(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'This' && IsOptionalString(schema.$id) && IsString(schema.$ref);\n  }\n  TypeGuard.TThis = TThis;\n  /** Returns true if the given schema is TTuple */\n  function TTuple(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Tuple' && schema.type === 'array' && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {\n      return false;\n    }\n    if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n      return true;\n    }\n    if (!IsArray(schema.items)) {\n      return false;\n    }\n    for (const inner of schema.items) {\n      if (!TSchema(inner)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TTuple = TTuple;\n  /** Returns true if the given schema is TUndefined */\n  function TUndefined(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Undefined' && schema.type === 'null' && schema.typeOf === 'Undefined' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TUndefined = TUndefined;\n  /** Returns true if the given schema is TUnion */\n  function TUnion(schema) {\n    // prettier-ignore\n    if (!(TKind(schema) && schema[exports.Kind] === 'Union' && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {\n      return false;\n    }\n    for (const inner of schema.anyOf) {\n      if (!TSchema(inner)) return false;\n    }\n    return true;\n  }\n  TypeGuard.TUnion = TUnion;\n  /** Returns true if the given schema is TUnion<Literal<string>[]> */\n  function TUnionLiteral(schema) {\n    return TUnion(schema) && schema.anyOf.every(schema => TLiteral(schema) && typeof schema.const === 'string');\n  }\n  TypeGuard.TUnionLiteral = TUnionLiteral;\n  /** Returns true if the given schema is TUint8Array */\n  function TUint8Array(schema) {\n    return TKind(schema) && schema[exports.Kind] === 'Uint8Array' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.instanceOf === 'Uint8Array' && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n  }\n  TypeGuard.TUint8Array = TUint8Array;\n  /** Returns true if the given schema is TUnknown */\n  function TUnknown(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Unknown' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TUnknown = TUnknown;\n  /** Returns true if the given schema is a raw TUnsafe */\n  function TUnsafe(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Unsafe';\n  }\n  TypeGuard.TUnsafe = TUnsafe;\n  /** Returns true if the given schema is TVoid */\n  function TVoid(schema) {\n    // prettier-ignore\n    return TKind(schema) && schema[exports.Kind] === 'Void' && schema.type === 'null' && schema.typeOf === 'Void' && IsOptionalString(schema.$id);\n  }\n  TypeGuard.TVoid = TVoid;\n  /** Returns true if this schema has the ReadonlyOptional modifier */\n  function TReadonlyOptional(schema) {\n    return IsObject(schema) && schema[exports.Modifier] === 'ReadonlyOptional';\n  }\n  TypeGuard.TReadonlyOptional = TReadonlyOptional;\n  /** Returns true if this schema has the Readonly modifier */\n  function TReadonly(schema) {\n    return IsObject(schema) && schema[exports.Modifier] === 'Readonly';\n  }\n  TypeGuard.TReadonly = TReadonly;\n  /** Returns true if this schema has the Optional modifier */\n  function TOptional(schema) {\n    return IsObject(schema) && schema[exports.Modifier] === 'Optional';\n  }\n  TypeGuard.TOptional = TOptional;\n  /** Returns true if the given schema is TSchema */\n  function TSchema(schema) {\n    return typeof schema === 'object' && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));\n  }\n  TypeGuard.TSchema = TSchema;\n})(TypeGuard = exports.TypeGuard || (exports.TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n  function Check(schema) {\n    if (schema[exports.Kind] === 'Undefined') return true;\n    if (schema[exports.Kind] === 'Union') {\n      const union = schema;\n      return union.anyOf.some(schema => Check(schema));\n    }\n    return false;\n  }\n  ExtendsUndefined.Check = Check;\n})(ExtendsUndefined = exports.ExtendsUndefined || (exports.ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n  TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n  TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n  TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult = exports.TypeExtendsResult || (exports.TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n  // --------------------------------------------------------------------------\n  // IntoBooleanResult\n  // --------------------------------------------------------------------------\n  function IntoBooleanResult(result) {\n    return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Any\n  // --------------------------------------------------------------------------\n  function AnyRight(left, right) {\n    return TypeExtendsResult.True;\n  }\n  function Any(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right) && right.anyOf.some(schema => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema))) return TypeExtendsResult.True;\n    if (TypeGuard.TUnion(right)) return TypeExtendsResult.Union;\n    if (TypeGuard.TUnknown(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TAny(right)) return TypeExtendsResult.True;\n    return TypeExtendsResult.Union;\n  }\n  // --------------------------------------------------------------------------\n  // Array\n  // --------------------------------------------------------------------------\n  function ArrayRight(left, right) {\n    if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n    if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n    if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n    return TypeExtendsResult.False;\n  }\n  function Array(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n    if (!TypeGuard.TArray(right)) return TypeExtendsResult.False;\n    return IntoBooleanResult(Visit(left.items, right.items));\n  }\n  // --------------------------------------------------------------------------\n  // BigInt\n  // --------------------------------------------------------------------------\n  function BigInt(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Boolean\n  // --------------------------------------------------------------------------\n  function BooleanRight(left, right) {\n    if (TypeGuard.TLiteral(left) && typeof left.const === 'boolean') return TypeExtendsResult.True;\n    return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Boolean(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Constructor\n  // --------------------------------------------------------------------------\n  function Constructor(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (!TypeGuard.TConstructor(right)) return TypeExtendsResult.False;\n    if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n    if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n      return TypeExtendsResult.False;\n    }\n    return IntoBooleanResult(Visit(left.returns, right.returns));\n  }\n  // --------------------------------------------------------------------------\n  // Date\n  // --------------------------------------------------------------------------\n  function Date(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Function\n  // --------------------------------------------------------------------------\n  function Function(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (!TypeGuard.TFunction(right)) return TypeExtendsResult.False;\n    if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n    if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n      return TypeExtendsResult.False;\n    }\n    return IntoBooleanResult(Visit(left.returns, right.returns));\n  }\n  // --------------------------------------------------------------------------\n  // Integer\n  // --------------------------------------------------------------------------\n  function IntegerRight(left, right) {\n    if (TypeGuard.TLiteral(left) && typeof left.const === 'number') return TypeExtendsResult.True;\n    return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Integer(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Intersect\n  // --------------------------------------------------------------------------\n  function IntersectRight(left, right) {\n    return right.allOf.every(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Intersect(left, right) {\n    return left.allOf.some(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Literal\n  // --------------------------------------------------------------------------\n  function IsLiteralString(schema) {\n    return typeof schema.const === 'string';\n  }\n  function IsLiteralNumber(schema) {\n    return typeof schema.const === 'number';\n  }\n  function IsLiteralBoolean(schema) {\n    return typeof schema.const === 'boolean';\n  }\n  function Literal(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    if (TypeGuard.TString(right)) return StringRight(left, right);\n    if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n    if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n    if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n    return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Never\n  // --------------------------------------------------------------------------\n  function NeverRight(left, right) {\n    return TypeExtendsResult.False;\n  }\n  function Never(left, right) {\n    return TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Null\n  // --------------------------------------------------------------------------\n  function Null(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Number\n  // --------------------------------------------------------------------------\n  function NumberRight(left, right) {\n    if (TypeGuard.TLiteral(left) && IsLiteralNumber(left)) return TypeExtendsResult.True;\n    return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Number(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Object\n  // --------------------------------------------------------------------------\n  function IsObjectPropertyCount(schema, count) {\n    return globalThis.Object.keys(schema.properties).length === count;\n  }\n  function IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n  }\n  function IsObjectSymbolLike(schema) {\n    // prettier-ignore\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));\n  }\n  function IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n  }\n  function IsObjectFunctionLike(schema) {\n    const length = exports.Type.Number();\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True;\n  }\n  function IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n  }\n  function IsObjectArrayLike(schema) {\n    const length = exports.Type.Number();\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True;\n  }\n  function IsObjectPromiseLike(schema) {\n    const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Property\n  // --------------------------------------------------------------------------\n  function Property(left, right) {\n    if (Visit(left, right) === TypeExtendsResult.False) return TypeExtendsResult.False;\n    if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right)) return TypeExtendsResult.False;\n    return TypeExtendsResult.True;\n  }\n  function ObjectRight(left, right) {\n    if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n    if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n    if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n    if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TDate(left) && IsObjectDateLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n      // When expressing a Record with literal key values, the Record is converted into a Object with\n      // the Hint assigned as `Record`. This is used to invert the extends logic.\n      return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n      return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    return TypeExtendsResult.False;\n  }\n  function Object(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    if (!TypeGuard.TObject(right)) return TypeExtendsResult.False;\n    for (const key of globalThis.Object.keys(right.properties)) {\n      if (!(key in left.properties)) return TypeExtendsResult.False;\n      if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n        return TypeExtendsResult.False;\n      }\n    }\n    return TypeExtendsResult.True;\n  }\n  // --------------------------------------------------------------------------\n  // Promise\n  // --------------------------------------------------------------------------\n  function Promise(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right) && IsObjectPromiseLike(right)) return TypeExtendsResult.True;\n    if (!TypeGuard.TPromise(right)) return TypeExtendsResult.False;\n    return IntoBooleanResult(Visit(left.item, right.item));\n  }\n  // --------------------------------------------------------------------------\n  // Record\n  // --------------------------------------------------------------------------\n  function RecordKey(schema) {\n    if (exports.PatternNumberExact in schema.patternProperties) return exports.Type.Number();\n    if (exports.PatternStringExact in schema.patternProperties) return exports.Type.String();\n    throw Error('TypeExtends: Cannot get record key');\n  }\n  function RecordValue(schema) {\n    if (exports.PatternNumberExact in schema.patternProperties) return schema.patternProperties[exports.PatternNumberExact];\n    if (exports.PatternStringExact in schema.patternProperties) return schema.patternProperties[exports.PatternStringExact];\n    throw Error('TypeExtends: Cannot get record value');\n  }\n  function RecordRight(left, right) {\n    const Key = RecordKey(right);\n    const Value = RecordValue(right);\n    if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) return TypeExtendsResult.True;\n    if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n    if (TypeGuard.TString(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n    if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n    if (TypeGuard.TObject(left)) {\n      for (const key of globalThis.Object.keys(left.properties)) {\n        if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n          return TypeExtendsResult.False;\n        }\n      }\n      return TypeExtendsResult.True;\n    }\n    return TypeExtendsResult.False;\n  }\n  function Record(left, right) {\n    const Value = RecordValue(left);\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (!TypeGuard.TRecord(right)) return TypeExtendsResult.False;\n    return Visit(Value, RecordValue(right));\n  }\n  // --------------------------------------------------------------------------\n  // String\n  // --------------------------------------------------------------------------\n  function StringRight(left, right) {\n    if (TypeGuard.TLiteral(left) && typeof left.const === 'string') return TypeExtendsResult.True;\n    return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function String(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Symbol\n  // --------------------------------------------------------------------------\n  function Symbol(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Tuple\n  // --------------------------------------------------------------------------\n  function TupleRight(left, right) {\n    if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n    if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n    if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n    return TypeExtendsResult.False;\n  }\n  function IsArrayOfTuple(left, right) {\n    return TypeGuard.TArray(right) && left.items !== undefined && left.items.every(schema => Visit(schema, right.items) === TypeExtendsResult.True);\n  }\n  function Tuple(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n    if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right)) return TypeExtendsResult.True;\n    if (!TypeGuard.TTuple(right)) return TypeExtendsResult.False;\n    if (left.items === undefined && right.items !== undefined || left.items !== undefined && right.items === undefined) return TypeExtendsResult.False;\n    if (left.items === undefined && right.items === undefined) return TypeExtendsResult.True;\n    return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Uint8Array\n  // --------------------------------------------------------------------------\n  function Uint8Array(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Undefined\n  // --------------------------------------------------------------------------\n  function Undefined(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TNever(right)) return NeverRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n    if (TypeGuard.TVoid(right)) return VoidRight(left, right);\n    return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Union\n  // --------------------------------------------------------------------------\n  function UnionRight(left, right) {\n    return right.anyOf.some(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Union(left, right) {\n    return left.anyOf.every(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Unknown\n  // --------------------------------------------------------------------------\n  function UnknownRight(left, right) {\n    return TypeExtendsResult.True;\n  }\n  function Unknown(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TString(right)) return StringRight(left, right);\n    if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n    if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n    if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n    if (TypeGuard.TArray(right)) return ArrayRight(left, right);\n    if (TypeGuard.TTuple(right)) return TupleRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  // --------------------------------------------------------------------------\n  // Void\n  // --------------------------------------------------------------------------\n  function VoidRight(left, right) {\n    if (TypeGuard.TUndefined(left)) return TypeExtendsResult.True;\n    return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Void(left, right) {\n    if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n    if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n    if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n    if (TypeGuard.TAny(right)) return AnyRight(left, right);\n    if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n    return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n  }\n  function Visit(left, right) {\n    // template union remap\n    if (TypeGuard.TTemplateLiteral(left)) return Visit(TemplateLiteralResolver.Resolve(left), right);\n    if (TypeGuard.TTemplateLiteral(right)) return Visit(left, TemplateLiteralResolver.Resolve(right));\n    // standard extends\n    if (TypeGuard.TAny(left)) return Any(left, right);\n    if (TypeGuard.TArray(left)) return Array(left, right);\n    if (TypeGuard.TBigInt(left)) return BigInt(left, right);\n    if (TypeGuard.TBoolean(left)) return Boolean(left, right);\n    if (TypeGuard.TConstructor(left)) return Constructor(left, right);\n    if (TypeGuard.TDate(left)) return Date(left, right);\n    if (TypeGuard.TFunction(left)) return Function(left, right);\n    if (TypeGuard.TInteger(left)) return Integer(left, right);\n    if (TypeGuard.TIntersect(left)) return Intersect(left, right);\n    if (TypeGuard.TLiteral(left)) return Literal(left, right);\n    if (TypeGuard.TNever(left)) return Never(left, right);\n    if (TypeGuard.TNull(left)) return Null(left, right);\n    if (TypeGuard.TNumber(left)) return Number(left, right);\n    if (TypeGuard.TObject(left)) return Object(left, right);\n    if (TypeGuard.TRecord(left)) return Record(left, right);\n    if (TypeGuard.TString(left)) return String(left, right);\n    if (TypeGuard.TSymbol(left)) return Symbol(left, right);\n    if (TypeGuard.TTuple(left)) return Tuple(left, right);\n    if (TypeGuard.TPromise(left)) return Promise(left, right);\n    if (TypeGuard.TUint8Array(left)) return Uint8Array(left, right);\n    if (TypeGuard.TUndefined(left)) return Undefined(left, right);\n    if (TypeGuard.TUnion(left)) return Union(left, right);\n    if (TypeGuard.TUnknown(left)) return Unknown(left, right);\n    if (TypeGuard.TVoid(left)) return Void(left, right);\n    throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n  }\n  function Extends(left, right) {\n    return Visit(left, right);\n  }\n  TypeExtends.Extends = Extends;\n})(TypeExtends = exports.TypeExtends || (exports.TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n  function IsObject(value) {\n    return typeof value === 'object' && value !== null;\n  }\n  function IsArray(value) {\n    return globalThis.Array.isArray(value);\n  }\n  function Array(value) {\n    return value.map(value => Visit(value));\n  }\n  function Object(value) {\n    const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {\n      return {\n        ...acc,\n        [key]: Visit(value[key])\n      };\n    }, {});\n    const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {\n      return {\n        ...acc,\n        [key]: Visit(value[key])\n      };\n    }, {});\n    return {\n      ...clonedProperties,\n      ...clonedSymbols\n    };\n  }\n  function Visit(value) {\n    if (IsArray(value)) return Array(value);\n    if (IsObject(value)) return Object(value);\n    return value;\n  }\n  /** Clones a type. */\n  function Clone(schema, options) {\n    return {\n      ...Visit(schema),\n      ...options\n    };\n  }\n  TypeClone.Clone = Clone;\n})(TypeClone = exports.TypeClone || (exports.TypeClone = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n  function Intersect(schema, callback) {\n    // prettier-ignore\n    return exports.Type.Intersect(schema.allOf.map(inner => Visit(inner, callback)), {\n      ...schema\n    });\n  }\n  function Union(schema, callback) {\n    // prettier-ignore\n    return exports.Type.Union(schema.anyOf.map(inner => Visit(inner, callback)), {\n      ...schema\n    });\n  }\n  function Object(schema, callback) {\n    return callback(schema);\n  }\n  function Visit(schema, callback) {\n    // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n    // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n    // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n    // used for composition, we use explicit checks instead.\n    if (schema[exports.Kind] === 'Intersect') return Intersect(schema, callback);\n    if (schema[exports.Kind] === 'Union') return Union(schema, callback);\n    if (schema[exports.Kind] === 'Object') return Object(schema, callback);\n    return schema;\n  }\n  function Map(schema, callback, options) {\n    return {\n      ...Visit(TypeClone.Clone(schema, {}), callback),\n      ...options\n    };\n  }\n  ObjectMap.Map = Map;\n})(ObjectMap = exports.ObjectMap || (exports.ObjectMap = {}));\n// --------------------------------------------------------------------------\n// KeyResolver\n// --------------------------------------------------------------------------\nvar KeyResolver;\n(function (KeyResolver) {\n  function IsKeyable(schema) {\n    return TypeGuard.TIntersect(schema) || TypeGuard.TUnion(schema) || TypeGuard.TObject(schema) && globalThis.Object.getOwnPropertyNames(schema.properties).length > 0;\n  }\n  function Intersect(schema) {\n    return [...schema.allOf.filter(schema => IsKeyable(schema)).reduce((set, schema) => Visit(schema).map(key => set.add(key))[0], new Set())];\n  }\n  function Union(schema) {\n    const sets = schema.anyOf.filter(schema => IsKeyable(schema)).map(inner => Visit(inner));\n    return [...sets.reduce((set, outer) => outer.map(key => sets.every(inner => inner.includes(key)) ? set.add(key) : set)[0], new Set())];\n  }\n  function Object(schema) {\n    return globalThis.Object.keys(schema.properties);\n  }\n  function Visit(schema) {\n    if (TypeGuard.TIntersect(schema)) return Intersect(schema);\n    if (TypeGuard.TUnion(schema)) return Union(schema);\n    if (TypeGuard.TObject(schema)) return Object(schema);\n    return [];\n  }\n  function Resolve(schema) {\n    return Visit(schema);\n  }\n  KeyResolver.Resolve = Resolve;\n})(KeyResolver = exports.KeyResolver || (exports.KeyResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n  function Escape(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }\n  function Visit(schema, acc) {\n    if (TypeGuard.TTemplateLiteral(schema)) {\n      const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n      return pattern;\n    } else if (TypeGuard.TUnion(schema)) {\n      const tokens = schema.anyOf.map(schema => Visit(schema, acc)).join('|');\n      return `(${tokens})`;\n    } else if (TypeGuard.TNumber(schema)) {\n      return `${acc}${exports.PatternNumber}`;\n    } else if (TypeGuard.TInteger(schema)) {\n      return `${acc}${exports.PatternNumber}`;\n    } else if (TypeGuard.TBigInt(schema)) {\n      return `${acc}${exports.PatternNumber}`;\n    } else if (TypeGuard.TString(schema)) {\n      return `${acc}${exports.PatternString}`;\n    } else if (TypeGuard.TLiteral(schema)) {\n      return `${acc}${Escape(schema.const.toString())}`;\n    } else if (TypeGuard.TBoolean(schema)) {\n      return `${acc}${exports.PatternBoolean}`;\n    } else if (TypeGuard.TNever(schema)) {\n      throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');\n    } else {\n      throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n    }\n  }\n  function Create(kinds) {\n    return `^${kinds.map(schema => Visit(schema, '')).join('')}\\$`;\n  }\n  TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern = exports.TemplateLiteralPattern || (exports.TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n  function Resolve(template) {\n    const expression = TemplateLiteralParser.ParseExact(template.pattern);\n    if (!TemplateLiteralFinite.Check(expression)) return exports.Type.String();\n    const literals = [...TemplateLiteralGenerator.Generate(expression)].map(value => exports.Type.Literal(value));\n    return exports.Type.Union(literals);\n  }\n  TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver = exports.TemplateLiteralResolver || (exports.TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n  function IsNonEscaped(pattern, index, char) {\n    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n  }\n  function IsOpenParen(pattern, index) {\n    return IsNonEscaped(pattern, index, '(');\n  }\n  function IsCloseParen(pattern, index) {\n    return IsNonEscaped(pattern, index, ')');\n  }\n  function IsSeparator(pattern, index) {\n    return IsNonEscaped(pattern, index, '|');\n  }\n  function IsGroup(pattern) {\n    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (count === 0 && index !== pattern.length - 1) return false;\n    }\n    return true;\n  }\n  function InGroup(pattern) {\n    return pattern.slice(1, pattern.length - 1);\n  }\n  function IsPrecedenceOr(pattern) {\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (IsSeparator(pattern, index) && count === 0) return true;\n    }\n    return false;\n  }\n  function IsPrecedenceAnd(pattern) {\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) return true;\n    }\n    return false;\n  }\n  function Or(pattern) {\n    let [count, start] = [0, 0];\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) count += 1;\n      if (IsCloseParen(pattern, index)) count -= 1;\n      if (IsSeparator(pattern, index) && count === 0) {\n        const range = pattern.slice(start, index);\n        if (range.length > 0) expressions.push(Parse(range));\n        start = index + 1;\n      }\n    }\n    const range = pattern.slice(start);\n    if (range.length > 0) expressions.push(Parse(range));\n    if (expressions.length === 0) return {\n      type: 'const',\n      const: ''\n    };\n    if (expressions.length === 1) return expressions[0];\n    return {\n      type: 'or',\n      expr: expressions\n    };\n  }\n  function And(pattern) {\n    function Group(value, index) {\n      if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n      let count = 0;\n      for (let scan = index; scan < value.length; scan++) {\n        if (IsOpenParen(value, scan)) count += 1;\n        if (IsCloseParen(value, scan)) count -= 1;\n        if (count === 0) return [index, scan];\n      }\n      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n    }\n    function Range(pattern, index) {\n      for (let scan = index; scan < pattern.length; scan++) {\n        if (IsOpenParen(pattern, scan)) return [index, scan];\n      }\n      return [index, pattern.length];\n    }\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n      if (IsOpenParen(pattern, index)) {\n        const [start, end] = Group(pattern, index);\n        const range = pattern.slice(start, end + 1);\n        expressions.push(Parse(range));\n        index = end;\n      } else {\n        const [start, end] = Range(pattern, index);\n        const range = pattern.slice(start, end);\n        if (range.length > 0) expressions.push(Parse(range));\n        index = end - 1;\n      }\n    }\n    if (expressions.length === 0) return {\n      type: 'const',\n      const: ''\n    };\n    if (expressions.length === 1) return expressions[0];\n    return {\n      type: 'and',\n      expr: expressions\n    };\n  }\n  /** Parses a pattern and returns an expression tree */\n  function Parse(pattern) {\n    if (IsGroup(pattern)) return Parse(InGroup(pattern));\n    if (IsPrecedenceOr(pattern)) return Or(pattern);\n    if (IsPrecedenceAnd(pattern)) return And(pattern);\n    return {\n      type: 'const',\n      const: pattern\n    };\n  }\n  TemplateLiteralParser.Parse = Parse;\n  /** Parses a pattern and strips forward and trailing ^ and $ */\n  function ParseExact(pattern) {\n    return Parse(pattern.slice(1, pattern.length - 1));\n  }\n  TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser = exports.TemplateLiteralParser || (exports.TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n  function IsNumber(expression) {\n    // prettier-ignore\n    return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === '0' && expression.expr[1].type === 'const' && expression.expr[1].const === '[1-9][0-9]*';\n  }\n  function IsBoolean(expression) {\n    // prettier-ignore\n    return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === 'true' && expression.expr[1].type === 'const' && expression.expr[1].const === 'false';\n  }\n  function IsString(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n  }\n  function Check(expression) {\n    if (IsBoolean(expression)) return true;\n    if (IsNumber(expression) || IsString(expression)) return false;\n    if (expression.type === 'and') return expression.expr.every(expr => Check(expr));\n    if (expression.type === 'or') return expression.expr.every(expr => Check(expr));\n    if (expression.type === 'const') return true;\n    throw Error(`TemplateLiteralFinite: Unknown expression type`);\n  }\n  TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite = exports.TemplateLiteralFinite || (exports.TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n  function* Reduce(buffer) {\n    if (buffer.length === 1) return yield* buffer[0];\n    for (const left of buffer[0]) {\n      for (const right of Reduce(buffer.slice(1))) {\n        yield `${left}${right}`;\n      }\n    }\n  }\n  function* And(expression) {\n    return yield* Reduce(expression.expr.map(expr => [...Generate(expr)]));\n  }\n  function* Or(expression) {\n    for (const expr of expression.expr) yield* Generate(expr);\n  }\n  function* Const(expression) {\n    return yield expression.const;\n  }\n  function* Generate(expression) {\n    if (expression.type === 'and') return yield* And(expression);\n    if (expression.type === 'or') return yield* Or(expression);\n    if (expression.type === 'const') return yield* Const(expression);\n    throw Error('TemplateLiteralGenerator: Unknown expression');\n  }\n  TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator = exports.TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n  /** `[Utility]` Creates a schema without `static` and `params` types */\n  Create(schema) {\n    return schema;\n  }\n  /** `[Standard]` Omits compositing symbols from this schema */\n  Strict(schema) {\n    return JSON.parse(JSON.stringify(schema));\n  }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n  // ------------------------------------------------------------------------\n  // Modifiers\n  // ------------------------------------------------------------------------\n  /** `[Modifier]` Creates a Optional property */\n  Optional(schema) {\n    return {\n      [exports.Modifier]: 'Optional',\n      ...TypeClone.Clone(schema, {})\n    };\n  }\n  /** `[Modifier]` Creates a ReadonlyOptional property */\n  ReadonlyOptional(schema) {\n    return {\n      [exports.Modifier]: 'ReadonlyOptional',\n      ...TypeClone.Clone(schema, {})\n    };\n  }\n  /** `[Modifier]` Creates a Readonly object or property */\n  Readonly(schema) {\n    return {\n      [exports.Modifier]: 'Readonly',\n      ...schema\n    };\n  }\n  // ------------------------------------------------------------------------\n  // Types\n  // ------------------------------------------------------------------------\n  /** `[Standard]` Creates an Any type */\n  Any(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Any'\n    });\n  }\n  /** `[Standard]` Creates an Array type */\n  Array(items, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Array',\n      type: 'array',\n      items: TypeClone.Clone(items, {})\n    });\n  }\n  /** `[Standard]` Creates a Boolean type */\n  Boolean(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Boolean',\n      type: 'boolean'\n    });\n  }\n  /** `[Standard]` Creates a Composite object type. */\n  Composite(objects, options) {\n    const isOptionalAll = (objects, key) => objects.every(object => !(key in object.properties) || IsOptional(object.properties[key]));\n    const IsOptional = schema => TypeGuard.TOptional(schema) || TypeGuard.TReadonlyOptional(schema);\n    const [required, optional] = [new Set(), new Set()];\n    for (const object of objects) {\n      for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {\n        if (isOptionalAll(objects, key)) optional.add(key);\n      }\n    }\n    for (const object of objects) {\n      for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {\n        if (!optional.has(key)) required.add(key);\n      }\n    }\n    const properties = {};\n    for (const object of objects) {\n      for (const [key, schema] of Object.entries(object.properties)) {\n        const property = TypeClone.Clone(schema, {});\n        if (!optional.has(key)) delete property[exports.Modifier];\n        if (key in properties) {\n          const left = TypeExtends.Extends(properties[key], property) !== TypeExtendsResult.False;\n          const right = TypeExtends.Extends(property, properties[key]) !== TypeExtendsResult.False;\n          if (!left && !right) properties[key] = exports.Type.Never();\n          if (!left && right) properties[key] = property;\n        } else {\n          properties[key] = property;\n        }\n      }\n    }\n    if (required.size > 0) {\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Object',\n        [exports.Hint]: 'Composite',\n        type: 'object',\n        properties,\n        required: [...required]\n      });\n    } else {\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Object',\n        [exports.Hint]: 'Composite',\n        type: 'object',\n        properties\n      });\n    }\n  }\n  /** `[Standard]` Creates a Enum type */\n  Enum(item, options = {}) {\n    // prettier-ignore\n    const values = globalThis.Object.keys(item).filter(key => isNaN(key)).map(key => item[key]);\n    const anyOf = values.map(value => typeof value === 'string' ? {\n      [exports.Kind]: 'Literal',\n      type: 'string',\n      const: value\n    } : {\n      [exports.Kind]: 'Literal',\n      type: 'number',\n      const: value\n    });\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Union',\n      anyOf\n    });\n  }\n  /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */\n  Extends(left, right, trueType, falseType, options = {}) {\n    switch (TypeExtends.Extends(left, right)) {\n      case TypeExtendsResult.Union:\n        return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);\n      case TypeExtendsResult.True:\n        return TypeClone.Clone(trueType, options);\n      case TypeExtendsResult.False:\n        return TypeClone.Clone(falseType, options);\n    }\n  }\n  /** `[Standard]` Excludes from the left type any type that is not assignable to the right */\n  Exclude(left, right, options = {}) {\n    if (TypeGuard.TTemplateLiteral(left)) return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n    if (TypeGuard.TTemplateLiteral(right)) return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n    if (TypeGuard.TUnion(left)) {\n      const narrowed = left.anyOf.filter(inner => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n      return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n    } else {\n      return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);\n    }\n  }\n  /** `[Standard]` Extracts from the left type any type that is assignable to the right */\n  Extract(left, right, options = {}) {\n    if (TypeGuard.TTemplateLiteral(left)) return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n    if (TypeGuard.TTemplateLiteral(right)) return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n    if (TypeGuard.TUnion(left)) {\n      const narrowed = left.anyOf.filter(inner => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n      return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n    } else {\n      return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);\n    }\n  }\n  /** `[Standard]` Creates an Integer type */\n  Integer(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Integer',\n      type: 'integer'\n    });\n  }\n  Intersect(allOf, options = {}) {\n    if (allOf.length === 0) return exports.Type.Never();\n    if (allOf.length === 1) return TypeClone.Clone(allOf[0], options);\n    const objects = allOf.every(schema => TypeGuard.TObject(schema));\n    const cloned = allOf.map(schema => TypeClone.Clone(schema, {}));\n    const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? {\n      unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {})\n    } : {};\n    if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n      return this.Create({\n        ...options,\n        ...clonedUnevaluatedProperties,\n        [exports.Kind]: 'Intersect',\n        type: 'object',\n        allOf: cloned\n      });\n    } else {\n      return this.Create({\n        ...options,\n        ...clonedUnevaluatedProperties,\n        [exports.Kind]: 'Intersect',\n        allOf: cloned\n      });\n    }\n  }\n  /** `[Standard]` Creates a KeyOf type */\n  KeyOf(schema, options = {}) {\n    if (TypeGuard.TRecord(schema)) {\n      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n      if (pattern === exports.PatternNumberExact) return this.Number(options);\n      if (pattern === exports.PatternStringExact) return this.String(options);\n      throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');\n    } else {\n      const resolved = KeyResolver.Resolve(schema);\n      if (resolved.length === 0) return this.Never(options);\n      const literals = resolved.map(key => this.Literal(key));\n      return this.Union(literals, options);\n    }\n  }\n  /** `[Standard]` Creates a Literal type */\n  Literal(value, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Literal',\n      const: value,\n      type: typeof value\n    });\n  }\n  /** `[Standard]` Creates a Never type */\n  Never(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Never',\n      not: {}\n    });\n  }\n  /** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */\n  Not(not, schema, options) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Not',\n      allOf: [{\n        not: TypeClone.Clone(not, {})\n      }, TypeClone.Clone(schema, {})]\n    });\n  }\n  /** `[Standard]` Creates a Null type */\n  Null(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Null',\n      type: 'null'\n    });\n  }\n  /** `[Standard]` Creates a Number type */\n  Number(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Number',\n      type: 'number'\n    });\n  }\n  /** `[Standard]` Creates an Object type */\n  Object(properties, options = {}) {\n    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n    const optionalKeys = propertyKeys.filter(key => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n    const requiredKeys = propertyKeys.filter(name => !optionalKeys.includes(name));\n    const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? {\n      additionalProperties: TypeClone.Clone(options.additionalProperties, {})\n    } : {};\n    const clonedProperties = propertyKeys.reduce((acc, key) => ({\n      ...acc,\n      [key]: TypeClone.Clone(properties[key], {})\n    }), {});\n    if (requiredKeys.length > 0) {\n      return this.Create({\n        ...options,\n        ...clonedAdditionalProperties,\n        [exports.Kind]: 'Object',\n        type: 'object',\n        properties: clonedProperties,\n        required: requiredKeys\n      });\n    } else {\n      return this.Create({\n        ...options,\n        ...clonedAdditionalProperties,\n        [exports.Kind]: 'Object',\n        type: 'object',\n        properties: clonedProperties\n      });\n    }\n  }\n  Omit(schema, unresolved, options = {}) {\n    // prettier-ignore\n    const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map(schema => schema.const) : TypeGuard.TLiteral(unresolved) ? [unresolved.const] : TypeGuard.TNever(unresolved) ? [] : unresolved;\n    // prettier-ignore\n    return ObjectMap.Map(TypeClone.Clone(schema, {}), schema => {\n      if (schema.required) {\n        schema.required = schema.required.filter(key => !keys.includes(key));\n        if (schema.required.length === 0) delete schema.required;\n      }\n      for (const key of globalThis.Object.keys(schema.properties)) {\n        if (keys.includes(key)) delete schema.properties[key];\n      }\n      return this.Create(schema);\n    }, options);\n  }\n  /** `[Standard]` Creates a mapped type where all properties are Optional */\n  Partial(schema, options = {}) {\n    function Apply(schema) {\n      // prettier-ignore\n      switch (schema[exports.Modifier]) {\n        case 'ReadonlyOptional':\n          schema[exports.Modifier] = 'ReadonlyOptional';\n          break;\n        case 'Readonly':\n          schema[exports.Modifier] = 'ReadonlyOptional';\n          break;\n        case 'Optional':\n          schema[exports.Modifier] = 'Optional';\n          break;\n        default:\n          schema[exports.Modifier] = 'Optional';\n          break;\n      }\n    }\n    // prettier-ignore\n    return ObjectMap.Map(TypeClone.Clone(schema, {}), schema => {\n      delete schema.required;\n      globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n      return schema;\n    }, options);\n  }\n  Pick(schema, unresolved, options = {}) {\n    // prettier-ignore\n    const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map(schema => schema.const) : TypeGuard.TLiteral(unresolved) ? [unresolved.const] : TypeGuard.TNever(unresolved) ? [] : unresolved;\n    // prettier-ignore\n    return ObjectMap.Map(TypeClone.Clone(schema, {}), schema => {\n      if (schema.required) {\n        schema.required = schema.required.filter(key => keys.includes(key));\n        if (schema.required.length === 0) delete schema.required;\n      }\n      for (const key of globalThis.Object.keys(schema.properties)) {\n        if (!keys.includes(key)) delete schema.properties[key];\n      }\n      return this.Create(schema);\n    }, options);\n  }\n  /** `[Standard]` Creates a Record type */\n  Record(key, schema, options = {}) {\n    if (TypeGuard.TTemplateLiteral(key)) {\n      const expression = TemplateLiteralParser.ParseExact(key.pattern);\n      // prettier-ignore\n      return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({\n        ...acc,\n        [key]: TypeClone.Clone(schema, {})\n      }), {}), options) : this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [key.pattern]: TypeClone.Clone(schema, {})\n        },\n        additionalProperties: false\n      });\n    } else if (TypeGuard.TUnionLiteral(key)) {\n      if (key.anyOf.every(schema => TypeGuard.TLiteral(schema) && (typeof schema.const === 'string' || typeof schema.const === 'number'))) {\n        const properties = key.anyOf.reduce((acc, literal) => ({\n          ...acc,\n          [literal.const]: TypeClone.Clone(schema, {})\n        }), {});\n        return this.Object(properties, {\n          ...options,\n          [exports.Hint]: 'Record'\n        });\n      } else throw Error('TypeBuilder: Record key can only be derived from union literal of number or string');\n    } else if (TypeGuard.TLiteral(key)) {\n      if (typeof key.const === 'string' || typeof key.const === 'number') {\n        return this.Object({\n          [key.const]: TypeClone.Clone(schema, {})\n        }, options);\n      } else throw Error('TypeBuilder: Record key can only be derived from literals of number or string');\n    } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n      const pattern = exports.PatternNumberExact;\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [pattern]: TypeClone.Clone(schema, {})\n        },\n        additionalProperties: false\n      });\n    } else if (TypeGuard.TString(key)) {\n      const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Record',\n        type: 'object',\n        patternProperties: {\n          [pattern]: TypeClone.Clone(schema, {})\n        },\n        additionalProperties: false\n      });\n    } else {\n      throw Error(`StandardTypeBuilder: Invalid Record Key`);\n    }\n  }\n  /** `[Standard]` Creates a Recursive type */\n  Recursive(callback, options = {}) {\n    if (options.$id === undefined) options.$id = `T${TypeOrdinal++}`;\n    const thisType = callback({\n      [exports.Kind]: 'This',\n      $ref: `${options.$id}`\n    });\n    thisType.$id = options.$id;\n    return this.Create({\n      ...options,\n      [exports.Hint]: 'Recursive',\n      ...thisType\n    });\n  }\n  /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */\n  Ref(schema, options = {}) {\n    if (schema.$id === undefined) throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Ref',\n      $ref: schema.$id\n    });\n  }\n  /** `[Standard]` Creates a mapped type where all properties are Required */\n  Required(schema, options = {}) {\n    function Apply(schema) {\n      // prettier-ignore\n      switch (schema[exports.Modifier]) {\n        case 'ReadonlyOptional':\n          schema[exports.Modifier] = 'Readonly';\n          break;\n        case 'Readonly':\n          schema[exports.Modifier] = 'Readonly';\n          break;\n        case 'Optional':\n          delete schema[exports.Modifier];\n          break;\n        default:\n          delete schema[exports.Modifier];\n          break;\n      }\n    }\n    // prettier-ignore\n    return ObjectMap.Map(TypeClone.Clone(schema, {}), schema => {\n      schema.required = globalThis.Object.keys(schema.properties);\n      globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n      return schema;\n    }, options);\n  }\n  /** `[Standard]` Creates a String type */\n  String(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'String',\n      type: 'string'\n    });\n  }\n  /** `[Standard]` Creates a template literal type */\n  TemplateLiteral(kinds, options = {}) {\n    const pattern = TemplateLiteralPattern.Create(kinds);\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'TemplateLiteral',\n      type: 'string',\n      pattern\n    });\n  }\n  /** `[Standard]` Creates a Tuple type */\n  Tuple(items, options = {}) {\n    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n    const clonedItems = items.map(item => TypeClone.Clone(item, {}));\n    // prettier-ignore\n    const schema = items.length > 0 ? {\n      ...options,\n      [exports.Kind]: 'Tuple',\n      type: 'array',\n      items: clonedItems,\n      additionalItems,\n      minItems,\n      maxItems\n    } : {\n      ...options,\n      [exports.Kind]: 'Tuple',\n      type: 'array',\n      minItems,\n      maxItems\n    };\n    return this.Create(schema);\n  }\n  Union(union, options = {}) {\n    if (TypeGuard.TTemplateLiteral(union)) {\n      return TemplateLiteralResolver.Resolve(union);\n    } else {\n      const anyOf = union;\n      if (anyOf.length === 0) return this.Never(options);\n      if (anyOf.length === 1) return this.Create(TypeClone.Clone(anyOf[0], options));\n      const clonedAnyOf = anyOf.map(schema => TypeClone.Clone(schema, {}));\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Union',\n        anyOf: clonedAnyOf\n      });\n    }\n  }\n  /** `[Standard]` Creates an Unknown type */\n  Unknown(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Unknown'\n    });\n  }\n  /** `[Standard]` Creates a Unsafe type that infers for the generic argument */\n  Unsafe(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: options[exports.Kind] || 'Unsafe'\n    });\n  }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n  /** `[Extended]` Creates a BigInt type */\n  BigInt(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'BigInt',\n      type: 'null',\n      typeOf: 'BigInt'\n    });\n  }\n  /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */\n  ConstructorParameters(schema, options = {}) {\n    return this.Tuple([...schema.parameters], {\n      ...options\n    });\n  }\n  Constructor(parameters, returns, options = {}) {\n    const clonedReturns = TypeClone.Clone(returns, {});\n    if (TypeGuard.TTuple(parameters)) {\n      const clonedParameters = parameters.items === undefined ? [] : parameters.items.map(parameter => TypeClone.Clone(parameter, {}));\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Constructor',\n        type: 'object',\n        instanceOf: 'Constructor',\n        parameters: clonedParameters,\n        returns: clonedReturns\n      });\n    } else if (globalThis.Array.isArray(parameters)) {\n      const clonedParameters = parameters.map(parameter => TypeClone.Clone(parameter, {}));\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Constructor',\n        type: 'object',\n        instanceOf: 'Constructor',\n        parameters: clonedParameters,\n        returns: clonedReturns\n      });\n    } else {\n      throw new Error('ExtendedTypeBuilder.Constructor: Invalid parameters');\n    }\n  }\n  /** `[Extended]` Creates a Date type */\n  Date(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Date',\n      type: 'object',\n      instanceOf: 'Date'\n    });\n  }\n  Function(parameters, returns, options = {}) {\n    const clonedReturns = TypeClone.Clone(returns, {});\n    if (TypeGuard.TTuple(parameters)) {\n      const clonedParameters = parameters.items === undefined ? [] : parameters.items.map(parameter => TypeClone.Clone(parameter, {}));\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Function',\n        type: 'object',\n        instanceOf: 'Function',\n        parameters: clonedParameters,\n        returns: clonedReturns\n      });\n    } else if (globalThis.Array.isArray(parameters)) {\n      const clonedParameters = parameters.map(parameter => TypeClone.Clone(parameter, {}));\n      return this.Create({\n        ...options,\n        [exports.Kind]: 'Function',\n        type: 'object',\n        instanceOf: 'Function',\n        parameters: clonedParameters,\n        returns: clonedReturns\n      });\n    } else {\n      throw new Error('ExtendedTypeBuilder.Function: Invalid parameters');\n    }\n  }\n  /** `[Extended]` Extracts the InstanceType from the given Constructor */\n  InstanceType(schema, options = {}) {\n    return TypeClone.Clone(schema.returns, options);\n  }\n  /** `[Extended]` Extracts the Parameters from the given Function type */\n  Parameters(schema, options = {}) {\n    return this.Tuple(schema.parameters, {\n      ...options\n    });\n  }\n  /** `[Extended]` Creates a Promise type */\n  Promise(item, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Promise',\n      type: 'object',\n      instanceOf: 'Promise',\n      item: TypeClone.Clone(item, {})\n    });\n  }\n  /** `[Extended]` Creates a regular expression type */\n  RegEx(regex, options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'String',\n      type: 'string',\n      pattern: regex.source\n    });\n  }\n  /** `[Extended]` Extracts the ReturnType from the given Function */\n  ReturnType(schema, options = {}) {\n    return TypeClone.Clone(schema.returns, options);\n  }\n  /** `[Extended]` Creates a Symbol type */\n  Symbol(options) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Symbol',\n      type: 'null',\n      typeOf: 'Symbol'\n    });\n  }\n  /** `[Extended]` Creates a Undefined type */\n  Undefined(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Undefined',\n      type: 'null',\n      typeOf: 'Undefined'\n    });\n  }\n  /** `[Extended]` Creates a Uint8Array type */\n  Uint8Array(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Uint8Array',\n      type: 'object',\n      instanceOf: 'Uint8Array'\n    });\n  }\n  /** `[Extended]` Creates a Void type */\n  Void(options = {}) {\n    return this.Create({\n      ...options,\n      [exports.Kind]: 'Void',\n      type: 'null',\n      typeOf: 'Void'\n    });\n  }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.Type = new ExtendedTypeBuilder();","map":{"version":3,"names":["Object","defineProperty","exports","value","Type","StandardType","ExtendedTypeBuilder","StandardTypeBuilder","TypeBuilder","TemplateLiteralGenerator","TemplateLiteralFinite","TemplateLiteralParser","TemplateLiteralParserError","TemplateLiteralResolver","TemplateLiteralPattern","KeyResolver","ObjectMap","TypeClone","TypeExtends","TypeExtendsResult","ExtendsUndefined","TypeGuard","TypeGuardUnknownTypeError","FormatRegistry","TypeRegistry","PatternStringExact","PatternNumberExact","PatternBooleanExact","PatternString","PatternNumber","PatternBoolean","Kind","Hint","Modifier","Symbol","for","map","Map","Entries","Clear","clear","Has","kind","has","Set","func","set","Get","get","format","Error","constructor","schema","IsObject","Array","isArray","IsArray","IsPattern","RegExp","IsControlCharacterFree","i","length","code","charCodeAt","IsBigInt","IsString","IsNumber","globalThis","Number","isFinite","IsBoolean","IsOptionalBigInt","undefined","IsOptionalNumber","IsOptionalBoolean","IsOptionalString","IsOptionalPattern","IsOptionalFormat","IsOptionalSchema","TSchema","TAny","TKind","$id","TArray","type","items","minItems","maxItems","uniqueItems","TBigInt","typeOf","multipleOf","minimum","maximum","exclusiveMinimum","exclusiveMaximum","TBoolean","TConstructor","instanceOf","parameters","returns","parameter","TDate","minimumTimestamp","maximumTimestamp","exclusiveMinimumTimestamp","exclusiveMaximumTimestamp","TFunction","TInteger","TIntersect","allOf","unevaluatedProperties","inner","TLiteral","const","TNever","not","getOwnPropertyNames","TNot","TNull","TNumber","TObject","properties","additionalProperties","minProperties","maxProperties","key","entries","TPromise","item","TRecord","patternProperties","keys","TRef","$ref","TString","minLength","maxLength","pattern","TSymbol","TTemplateLiteral","TThis","TTuple","additionalItems","TUndefined","TUnion","anyOf","TUnionLiteral","every","TUint8Array","minByteLength","maxByteLength","TUnknown","TUnsafe","TVoid","TReadonlyOptional","TReadonly","TOptional","Check","union","some","IntoBooleanResult","result","False","True","AnyRight","left","right","Any","IntersectRight","Union","ArrayRight","UnionRight","UnknownRight","IsObjectArrayLike","Visit","BigInt","NeverRight","ObjectRight","RecordRight","BooleanRight","Boolean","Constructor","index","Date","Function","IntegerRight","Integer","Intersect","IsLiteralString","IsLiteralNumber","IsLiteralBoolean","Literal","StringRight","NumberRight","Never","Null","IsObjectPropertyCount","count","IsObjectStringLike","IsObjectSymbolLike","description","IsObjectNumberLike","IsObjectBooleanLike","IsObjectBigIntLike","IsObjectDateLike","IsObjectUint8ArrayLike","IsObjectFunctionLike","IsObjectConstructorLike","IsObjectPromiseLike","then","Property","RecordKey","Promise","String","RecordValue","Key","Value","Record","TupleRight","IsArrayOfTuple","Tuple","Uint8Array","Undefined","VoidRight","Unknown","Void","Resolve","Extends","clonedProperties","reduce","acc","clonedSymbols","getOwnPropertySymbols","Clone","options","callback","IsKeyable","filter","add","sets","outer","includes","Escape","replace","slice","tokens","join","toString","Create","kinds","template","expression","ParseExact","literals","Generate","message","IsNonEscaped","char","IsOpenParen","IsCloseParen","IsSeparator","IsGroup","InGroup","IsPrecedenceOr","IsPrecedenceAnd","Or","start","expressions","range","push","Parse","expr","And","Group","scan","Range","end","Reduce","buffer","Const","TypeOrdinal","Strict","JSON","parse","stringify","Optional","ReadonlyOptional","Readonly","Composite","objects","isOptionalAll","object","IsOptional","required","optional","property","size","Enum","values","isNaN","trueType","falseType","Exclude","narrowed","Extract","cloned","clonedUnevaluatedProperties","KeyOf","resolved","Not","propertyKeys","optionalKeys","requiredKeys","name","clonedAdditionalProperties","Omit","unresolved","Partial","Apply","forEach","Pick","literal","Recursive","thisType","Ref","Required","TemplateLiteral","clonedItems","clonedAnyOf","Unsafe","ConstructorParameters","clonedReturns","clonedParameters","InstanceType","Parameters","RegEx","regex","source","ReturnType"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@sinclair/typebox/typebox.js"],"sourcesContent":["\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.KeyResolver = exports.ObjectMap = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for('TypeBox.Modifier');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry = exports.TypeRegistry || (exports.TypeRegistry = {}));\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry = exports.FormatRegistry || (exports.FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema) {\n        super('TypeGuard: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n    }\n    function IsArray(value) {\n        return typeof value === 'object' && value !== null && Array.isArray(value);\n    }\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (typeof value !== 'string')\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    function IsNumber(value) {\n        return typeof value === 'number' && globalThis.Number.isFinite(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    function IsOptionalBigInt(value) {\n        return value === undefined || (value !== undefined && IsBigInt(value));\n    }\n    function IsOptionalNumber(value) {\n        return value === undefined || (value !== undefined && IsNumber(value));\n    }\n    function IsOptionalBoolean(value) {\n        return value === undefined || (value !== undefined && IsBoolean(value));\n    }\n    function IsOptionalString(value) {\n        return value === undefined || (value !== undefined && IsString(value));\n    }\n    function IsOptionalPattern(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return value === undefined || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */\n    function TAny(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Any' && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */\n    function TArray(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Array' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'BigInt' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'BigInt' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.multipleOf) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.exclusiveMaximum));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Boolean' &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Constructor' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Constructor' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */\n    function TDate(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Date' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Function' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Function' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */\n    function TInteger(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Integer' &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Intersect' &&\n            IsArray(schema.allOf) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if ('type' in schema && schema.type !== 'object') {\n            return false;\n        }\n        for (const inner of schema.allOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TKind */\n    function TKind(schema) {\n        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral */\n    function TLiteral(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Literal' &&\n            IsOptionalString(schema.$id) &&\n            (IsString(schema.const) ||\n                IsNumber(schema.const) ||\n                IsBoolean(schema.const) ||\n                IsBigInt(schema.const)));\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */\n    function TNever(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Never' && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Not' &&\n            IsArray(schema.allOf) &&\n            schema.allOf.length === 2 &&\n            IsObject(schema.allOf[0]) &&\n            TSchema(schema.allOf[0].not) &&\n            TSchema(schema.allOf[1]));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Null' &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */\n    function TNumber(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Number' &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */\n    function TObject(schema) {\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Object' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsObject(schema.properties) &&\n            (IsOptionalBoolean(schema.additionalProperties) || IsOptionalSchema(schema.additionalProperties)) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)) {\n            if (!IsControlCharacterFree(key))\n                return false;\n            if (!TSchema(value))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Promise' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Record' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            schema.additionalProperties === false &&\n            IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.keys(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Ref' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */\n    function TString(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'String' &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Symbol' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'TemplateLiteral' &&\n            schema.type === 'string' &&\n            IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'This' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Tuple' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            IsNumber(schema.minItems) &&\n            IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n            return true;\n        }\n        if (!IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Undefined' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Union' &&\n            IsArray(schema.anyOf) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUnion<Literal<string>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteral(schema) && typeof schema.const === 'string');\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUint8Array */\n    function TUint8Array(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Uint8Array' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.instanceOf === 'Uint8Array' && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unknown' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */\n    function TUnsafe(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Void' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the ReadonlyOptional modifier */\n    function TReadonlyOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'ReadonlyOptional';\n    }\n    TypeGuard.TReadonlyOptional = TReadonlyOptional;\n    /** Returns true if this schema has the Readonly modifier */\n    function TReadonly(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */\n    function TOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */\n    function TSchema(schema) {\n        return (typeof schema === 'object' &&\n            (TAny(schema) ||\n                TArray(schema) ||\n                TBoolean(schema) ||\n                TBigInt(schema) ||\n                TConstructor(schema) ||\n                TDate(schema) ||\n                TFunction(schema) ||\n                TInteger(schema) ||\n                TIntersect(schema) ||\n                TLiteral(schema) ||\n                TNever(schema) ||\n                TNot(schema) ||\n                TNull(schema) ||\n                TNumber(schema) ||\n                TObject(schema) ||\n                TPromise(schema) ||\n                TRecord(schema) ||\n                TRef(schema) ||\n                TString(schema) ||\n                TSymbol(schema) ||\n                TTemplateLiteral(schema) ||\n                TThis(schema) ||\n                TTuple(schema) ||\n                TUndefined(schema) ||\n                TUnion(schema) ||\n                TUint8Array(schema) ||\n                TUnknown(schema) ||\n                TUnsafe(schema) ||\n                TVoid(schema) ||\n                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard = exports.TypeGuard || (exports.TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === 'Undefined')\n            return true;\n        if (schema[exports.Kind] === 'Union') {\n            const union = schema;\n            return union.anyOf.some((schema) => Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined = exports.ExtendsUndefined || (exports.ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult = exports.TypeExtendsResult || (exports.TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function AnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Any(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function ArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function BigInt(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function BooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'boolean')\n            return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Boolean(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function Constructor(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function Date(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function Function(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TFunction(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function IntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'number')\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Integer(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function IntersectRight(left, right) {\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Intersect(left, right) {\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function IsLiteralString(schema) {\n        return typeof schema.const === 'string';\n    }\n    function IsLiteralNumber(schema) {\n        return typeof schema.const === 'number';\n    }\n    function IsLiteralBoolean(schema) {\n        return typeof schema.const === 'boolean';\n    }\n    function Literal(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function NeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function Never(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function Null(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function NumberRight(left, right) {\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Number(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return globalThis.Object.keys(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False)\n            return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))\n            return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function ObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Object(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (!TypeGuard.TObject(right))\n            return TypeExtendsResult.False;\n        for (const key of globalThis.Object.keys(right.properties)) {\n            if (!(key in left.properties))\n                return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function Promise(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties)\n            return exports.Type.String();\n        throw Error('TypeExtends: Cannot get record key');\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternStringExact];\n        throw Error('TypeExtends: Cannot get record value');\n    }\n    function RecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of globalThis.Object.keys(left.properties)) {\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Record(left, right) {\n        const Value = RecordValue(left);\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TRecord(right))\n            return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function StringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'string')\n            return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function String(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function Symbol(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function TupleRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function IsArrayOfTuple(left, right) {\n        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);\n    }\n    function Tuple(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right))\n            return TypeExtendsResult.False;\n        if ((left.items === undefined && right.items !== undefined) || (left.items !== undefined && right.items === undefined))\n            return TypeExtendsResult.False;\n        if (left.items === undefined && right.items === undefined)\n            return TypeExtendsResult.True;\n        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function Uint8Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function Undefined(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TVoid(right))\n            return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function UnionRight(left, right) {\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Union(left, right) {\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function UnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Unknown(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        if (TypeGuard.TArray(right))\n            return ArrayRight(left, right);\n        if (TypeGuard.TTuple(right))\n            return TupleRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Void(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // template union remap\n        if (TypeGuard.TTemplateLiteral(left))\n            return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right))\n            return Visit(left, TemplateLiteralResolver.Resolve(right));\n        // standard extends\n        if (TypeGuard.TAny(left))\n            return Any(left, right);\n        if (TypeGuard.TArray(left))\n            return Array(left, right);\n        if (TypeGuard.TBigInt(left))\n            return BigInt(left, right);\n        if (TypeGuard.TBoolean(left))\n            return Boolean(left, right);\n        if (TypeGuard.TConstructor(left))\n            return Constructor(left, right);\n        if (TypeGuard.TDate(left))\n            return Date(left, right);\n        if (TypeGuard.TFunction(left))\n            return Function(left, right);\n        if (TypeGuard.TInteger(left))\n            return Integer(left, right);\n        if (TypeGuard.TIntersect(left))\n            return Intersect(left, right);\n        if (TypeGuard.TLiteral(left))\n            return Literal(left, right);\n        if (TypeGuard.TNever(left))\n            return Never(left, right);\n        if (TypeGuard.TNull(left))\n            return Null(left, right);\n        if (TypeGuard.TNumber(left))\n            return Number(left, right);\n        if (TypeGuard.TObject(left))\n            return Object(left, right);\n        if (TypeGuard.TRecord(left))\n            return Record(left, right);\n        if (TypeGuard.TString(left))\n            return String(left, right);\n        if (TypeGuard.TSymbol(left))\n            return Symbol(left, right);\n        if (TypeGuard.TTuple(left))\n            return Tuple(left, right);\n        if (TypeGuard.TPromise(left))\n            return Promise(left, right);\n        if (TypeGuard.TUint8Array(left))\n            return Uint8Array(left, right);\n        if (TypeGuard.TUndefined(left))\n            return Undefined(left, right);\n        if (TypeGuard.TUnion(left))\n            return Union(left, right);\n        if (TypeGuard.TUnknown(left))\n            return Unknown(left, right);\n        if (TypeGuard.TVoid(left))\n            return Void(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends = exports.TypeExtends || (exports.TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function Array(value) {\n        return value.map((value) => Visit(value));\n    }\n    function Object(value) {\n        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function Visit(value) {\n        if (IsArray(value))\n            return Array(value);\n        if (IsObject(value))\n            return Object(value);\n        return value;\n    }\n    /** Clones a type. */\n    function Clone(schema, options) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone = exports.TypeClone || (exports.TypeClone = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function Intersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Union(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Object(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === 'Intersect')\n            return Intersect(schema, callback);\n        if (schema[exports.Kind] === 'Union')\n            return Union(schema, callback);\n        if (schema[exports.Kind] === 'Object')\n            return Object(schema, callback);\n        return schema;\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap = exports.ObjectMap || (exports.ObjectMap = {}));\n// --------------------------------------------------------------------------\n// KeyResolver\n// --------------------------------------------------------------------------\nvar KeyResolver;\n(function (KeyResolver) {\n    function IsKeyable(schema) {\n        return TypeGuard.TIntersect(schema) || TypeGuard.TUnion(schema) || (TypeGuard.TObject(schema) && globalThis.Object.getOwnPropertyNames(schema.properties).length > 0);\n    }\n    function Intersect(schema) {\n        return [...schema.allOf.filter((schema) => IsKeyable(schema)).reduce((set, schema) => Visit(schema).map((key) => set.add(key))[0], new Set())];\n    }\n    function Union(schema) {\n        const sets = schema.anyOf.filter((schema) => IsKeyable(schema)).map((inner) => Visit(inner));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function Object(schema) {\n        return globalThis.Object.keys(schema.properties);\n    }\n    function Visit(schema) {\n        if (TypeGuard.TIntersect(schema))\n            return Intersect(schema);\n        if (TypeGuard.TUnion(schema))\n            return Union(schema);\n        if (TypeGuard.TObject(schema))\n            return Object(schema);\n        return [];\n    }\n    function Resolve(schema) {\n        return Visit(schema);\n    }\n    KeyResolver.Resolve = Resolve;\n})(KeyResolver = exports.KeyResolver || (exports.KeyResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n            return pattern;\n        }\n        else if (TypeGuard.TUnion(schema)) {\n            const tokens = schema.anyOf.map((schema) => Visit(schema, acc)).join('|');\n            return `(${tokens})`;\n        }\n        else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        }\n        else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        }\n        else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        }\n        else if (TypeGuard.TNever(schema)) {\n            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');\n        }\n        else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern = exports.TemplateLiteralPattern || (exports.TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver = exports.TemplateLiteralResolver || (exports.TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        if (IsGroup(pattern))\n            return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern))\n            return Or(pattern);\n        if (IsPrecedenceAnd(pattern))\n            return And(pattern);\n        return { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser = exports.TemplateLiteralParser || (exports.TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        if (IsBoolean(expression))\n            return true;\n        if (IsNumber(expression) || IsString(expression))\n            return false;\n        if (expression.type === 'and')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'or')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'const')\n            return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite = exports.TemplateLiteralFinite || (exports.TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === 'and')\n            return yield* And(expression);\n        if (expression.type === 'or')\n            return yield* Or(expression);\n        if (expression.type === 'const')\n            return yield* Const(expression);\n        throw Error('TemplateLiteralGenerator: Unknown expression');\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator = exports.TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Modifier]` Creates a Optional property */\n    Optional(schema) {\n        return { [exports.Modifier]: 'Optional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a ReadonlyOptional property */\n    ReadonlyOptional(schema) {\n        return { [exports.Modifier]: 'ReadonlyOptional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a Readonly object or property */\n    Readonly(schema) {\n        return { [exports.Modifier]: 'Readonly', ...schema };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Standard]` Creates an Array type */\n    Array(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(items, {}) });\n    }\n    /** `[Standard]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Standard]` Creates a Composite object type. */\n    Composite(objects, options) {\n        const isOptionalAll = (objects, key) => objects.every((object) => !(key in object.properties) || IsOptional(object.properties[key]));\n        const IsOptional = (schema) => TypeGuard.TOptional(schema) || TypeGuard.TReadonlyOptional(schema);\n        const [required, optional] = [new Set(), new Set()];\n        for (const object of objects) {\n            for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {\n                if (isOptionalAll(objects, key))\n                    optional.add(key);\n            }\n        }\n        for (const object of objects) {\n            for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {\n                if (!optional.has(key))\n                    required.add(key);\n            }\n        }\n        const properties = {};\n        for (const object of objects) {\n            for (const [key, schema] of Object.entries(object.properties)) {\n                const property = TypeClone.Clone(schema, {});\n                if (!optional.has(key))\n                    delete property[exports.Modifier];\n                if (key in properties) {\n                    const left = TypeExtends.Extends(properties[key], property) !== TypeExtendsResult.False;\n                    const right = TypeExtends.Extends(property, properties[key]) !== TypeExtendsResult.False;\n                    if (!left && !right)\n                        properties[key] = exports.Type.Never();\n                    if (!left && right)\n                        properties[key] = property;\n                }\n                else {\n                    properties[key] = property;\n                }\n            }\n        }\n        if (required.size > 0) {\n            return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties, required: [...required] });\n        }\n        else {\n            return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties });\n        }\n    }\n    /** `[Standard]` Creates a Enum type */\n    Enum(item, options = {}) {\n        // prettier-ignore\n        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const anyOf = values.map((value) => (typeof value === 'string' ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));\n        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });\n    }\n    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */\n    Exclude(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options));\n        }\n    }\n    /** `[Standard]` Extracts from the left type any type that is assignable to the right */\n    Extract(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options));\n        }\n    }\n    /** `[Standard]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });\n        }\n        else {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact)\n                return this.Number(options);\n            if (pattern === exports.PatternStringExact)\n                return this.String(options);\n            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');\n        }\n        else {\n            const resolved = KeyResolver.Resolve(schema);\n            if (resolved.length === 0)\n                return this.Never(options);\n            const literals = resolved.map((key) => this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Standard]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */\n    Not(not, schema, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', allOf: [{ not: TypeClone.Clone(not, {}) }, TypeClone.Clone(schema, {})] });\n    }\n    /** `[Standard]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Standard]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Standard]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });\n        }\n        else {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n        }\n    }\n    Omit(schema, unresolved, options = {}) {\n        // prettier-ignore\n        const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) => schema.const) :\n            TypeGuard.TLiteral(unresolved) ? [unresolved.const] :\n                TypeGuard.TNever(unresolved) ? [] :\n                    unresolved;\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => !keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Optional */\n    Partial(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Optional':\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n                default:\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            delete schema.required;\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    Pick(schema, unresolved, options = {}) {\n        // prettier-ignore\n        const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) => schema.const) :\n            TypeGuard.TLiteral(unresolved) ? [unresolved.const] :\n                TypeGuard.TNever(unresolved) ? [] :\n                    unresolved;\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (!keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });\n        }\n        else if (TypeGuard.TUnionLiteral(key)) {\n            if (key.anyOf.every((schema) => TypeGuard.TLiteral(schema) && (typeof schema.const === 'string' || typeof schema.const === 'number'))) {\n                const properties = key.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});\n                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n            }\n            else\n                throw Error('TypeBuilder: Record key can only be derived from union literal of number or string');\n        }\n        else if (TypeGuard.TLiteral(key)) {\n            if (typeof key.const === 'string' || typeof key.const === 'number') {\n                return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);\n            }\n            else\n                throw Error('TypeBuilder: Record key can only be derived from literals of number or string');\n        }\n        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            const pattern = exports.PatternNumberExact;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });\n        }\n        else if (TypeGuard.TString(key)) {\n            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });\n        }\n        else {\n            throw Error(`StandardTypeBuilder: Invalid Record Key`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (options.$id === undefined)\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */\n    Ref(schema, options = {}) {\n        if (schema.$id === undefined)\n            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: schema.$id });\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Required */\n    Required(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Optional':\n                    delete schema[exports.Modifier];\n                    break;\n                default:\n                    delete schema[exports.Modifier];\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            schema.required = globalThis.Object.keys(schema.properties);\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    /** `[Standard]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Standard]` Creates a template literal type */\n    TemplateLiteral(kinds, options = {}) {\n        const pattern = TemplateLiteralPattern.Create(kinds);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Standard]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        }\n        else {\n            const anyOf = union;\n            if (anyOf.length === 0)\n                return this.Never(options);\n            if (anyOf.length === 1)\n                return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'null', typeOf: 'BigInt' });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    Constructor(parameters, returns, options = {}) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        if (TypeGuard.TTuple(parameters)) {\n            const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) => TypeClone.Clone(parameter, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n        }\n        else if (globalThis.Array.isArray(parameters)) {\n            const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n        }\n        else {\n            throw new Error('ExtendedTypeBuilder.Constructor: Invalid parameters');\n        }\n    }\n    /** `[Extended]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'object', instanceOf: 'Date' });\n    }\n    Function(parameters, returns, options = {}) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        if (TypeGuard.TTuple(parameters)) {\n            const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) => TypeClone.Clone(parameter, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });\n        }\n        else if (globalThis.Array.isArray(parameters)) {\n            const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });\n        }\n        else {\n            throw new Error('ExtendedTypeBuilder.Function: Invalid parameters');\n        }\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[Extended]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'object', instanceOf: 'Promise', item: TypeClone.Clone(item, {}) });\n    }\n    /** `[Extended]` Creates a regular expression type */\n    RegEx(regex, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern: regex.source });\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'null', typeOf: 'Symbol' });\n    }\n    /** `[Extended]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'null', typeOf: 'Undefined' });\n    }\n    /** `[Extended]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'object', instanceOf: 'Uint8Array' });\n    }\n    /** `[Extended]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'null', typeOf: 'Void' });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.Type = new ExtendedTypeBuilder();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}