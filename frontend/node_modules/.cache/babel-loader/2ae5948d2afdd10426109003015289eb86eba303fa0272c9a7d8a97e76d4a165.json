{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nvar AllowedType;\n(function (AllowedType) {\n  AllowedType[AllowedType[\"Number\"] = 0] = \"Number\";\n  AllowedType[AllowedType[\"String\"] = 1] = \"String\";\n  AllowedType[AllowedType[\"Unknown\"] = 2] = \"Unknown\";\n})(AllowedType || (AllowedType = {}));\nexports.default = util.createRule({\n  name: 'no-mixed-enums',\n  meta: {\n    docs: {\n      description: 'Disallow enums from having both number and string members',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      mixed: `Mixing number and string enums can be confusing.`\n    },\n    schema: [],\n    type: 'problem'\n  },\n  defaultOptions: [],\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    function collectNodeDefinitions(node) {\n      var _a, _b, _c, _d, _e;\n      const {\n        name\n      } = node.id;\n      const found = {\n        imports: [],\n        previousSibling: undefined\n      };\n      let scope = context.getScope();\n      for (const definition of (_c = (_b = (_a = scope.upper) === null || _a === void 0 ? void 0 : _a.set.get(name)) === null || _b === void 0 ? void 0 : _b.defs) !== null && _c !== void 0 ? _c : []) {\n        if (definition.node.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration && definition.node.range[0] < node.range[0] && definition.node.members.length > 0) {\n          found.previousSibling = definition.node;\n          break;\n        }\n      }\n      while (scope) {\n        (_e = (_d = scope.set.get(name)) === null || _d === void 0 ? void 0 : _d.defs) === null || _e === void 0 ? void 0 : _e.forEach(definition => {\n          if (definition.type === scope_manager_1.DefinitionType.ImportBinding) {\n            found.imports.push(definition.node);\n          }\n        });\n        scope = scope.upper;\n      }\n      return found;\n    }\n    function getAllowedTypeForNode(node) {\n      return tsutils.isTypeFlagSet(typeChecker.getTypeAtLocation(node), ts.TypeFlags.StringLike) ? AllowedType.String : AllowedType.Number;\n    }\n    function getTypeFromImported(imported) {\n      var _a;\n      const type = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(imported));\n      const valueDeclaration = (_a = type.getSymbol()) === null || _a === void 0 ? void 0 : _a.valueDeclaration;\n      if (!valueDeclaration || !ts.isEnumDeclaration(valueDeclaration) || valueDeclaration.members.length === 0) {\n        return undefined;\n      }\n      return getAllowedTypeForNode(valueDeclaration.members[0]);\n    }\n    function getMemberType(member) {\n      if (!member.initializer) {\n        return AllowedType.Number;\n      }\n      switch (member.initializer.type) {\n        case utils_1.AST_NODE_TYPES.Literal:\n          switch (typeof member.initializer.value) {\n            case 'number':\n              return AllowedType.Number;\n            case 'string':\n              return AllowedType.String;\n            default:\n              return AllowedType.Unknown;\n          }\n        case utils_1.AST_NODE_TYPES.TemplateLiteral:\n          return AllowedType.String;\n        default:\n          return getAllowedTypeForNode(parserServices.esTreeNodeToTSNodeMap.get(member.initializer));\n      }\n    }\n    function getDesiredTypeForDefinition(node) {\n      const {\n        imports,\n        previousSibling\n      } = collectNodeDefinitions(node);\n      // Case: Merged ambiently via module augmentation\n      // import { MyEnum } from 'other-module';\n      // declare module 'other-module' {\n      //   enum MyEnum { A }\n      // }\n      for (const imported of imports) {\n        const typeFromImported = getTypeFromImported(imported);\n        if (typeFromImported !== undefined) {\n          return typeFromImported;\n        }\n      }\n      // Case: Multiple enum declarations in the same file\n      // enum MyEnum { A }\n      // enum MyEnum { B }\n      if (previousSibling) {\n        return getMemberType(previousSibling.members[0]);\n      }\n      // Case: Namespace declaration merging\n      // namespace MyNamespace {\n      //   export enum MyEnum { A }\n      // }\n      // namespace MyNamespace {\n      //   export enum MyEnum { B }\n      // }\n      if (node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration && node.parent.parent.type === utils_1.AST_NODE_TYPES.TSModuleBlock) {\n        // TODO: We don't need to dip into the TypeScript type checker here!\n        // Merged namespaces must all exist in the same file.\n        // We could instead compare this file's nodes to find the merges.\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node.id);\n        const declarations = typeChecker.getSymbolAtLocation(tsNode).getDeclarations();\n        for (const declaration of declarations) {\n          for (const member of declaration.members) {\n            return member.initializer ? tsutils.isTypeFlagSet(typeChecker.getTypeAtLocation(member.initializer), ts.TypeFlags.StringLike) ? AllowedType.String : AllowedType.Number : AllowedType.Number;\n          }\n        }\n      }\n      // Finally, we default to the type of the first enum member\n      return getMemberType(node.members[0]);\n    }\n    return {\n      TSEnumDeclaration(node) {\n        var _a;\n        if (!node.members.length) {\n          return;\n        }\n        let desiredType = getDesiredTypeForDefinition(node);\n        if (desiredType === ts.TypeFlags.Unknown) {\n          return;\n        }\n        for (const member of node.members) {\n          const currentType = getMemberType(member);\n          if (currentType === AllowedType.Unknown) {\n            return;\n          }\n          if (currentType === AllowedType.Number) {\n            desiredType !== null && desiredType !== void 0 ? desiredType : desiredType = currentType;\n          }\n          if (currentType !== desiredType && (currentType !== undefined || desiredType === AllowedType.String)) {\n            context.report({\n              messageId: 'mixed',\n              node: (_a = member.initializer) !== null && _a !== void 0 ? _a : member\n            });\n            return;\n          }\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["scope_manager_1","require","utils_1","tsutils","__importStar","ts","util","AllowedType","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","mixed","schema","type","defaultOptions","create","context","parserServices","getParserServices","typeChecker","program","getTypeChecker","collectNodeDefinitions","node","id","found","imports","previousSibling","undefined","scope","getScope","definition","_c","_b","_a","upper","set","get","defs","AST_NODE_TYPES","TSEnumDeclaration","range","members","length","_e","_d","forEach","DefinitionType","ImportBinding","push","getAllowedTypeForNode","isTypeFlagSet","getTypeAtLocation","TypeFlags","StringLike","String","Number","getTypeFromImported","imported","esTreeNodeToTSNodeMap","valueDeclaration","getSymbol","isEnumDeclaration","getMemberType","member","initializer","Literal","value","Unknown","TemplateLiteral","getDesiredTypeForDefinition","typeFromImported","parent","ExportNamedDeclaration","TSModuleBlock","tsNode","declarations","getSymbolAtLocation","getDeclarations","declaration","desiredType","currentType","report","messageId"],"sources":["../../src/rules/no-mixed-enums.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,eAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAC,YAAA,CAAAH,OAAA;AACA,MAAAI,EAAA,GAAAD,YAAA,CAAAH,OAAA;AAEA,MAAAK,IAAA,GAAAF,YAAA,CAAAH,OAAA;AAEA,IAAKM,WAIJ;AAJD,WAAKA,WAAW;EACdA,WAAA,CAAAA,WAAA,0BAAM;EACNA,WAAA,CAAAA,WAAA,0BAAM;EACNA,WAAA,CAAAA,WAAA,4BAAO;AACT,CAAC,EAJIA,WAAW,KAAXA,WAAW;AAMhBC,OAAA,CAAAC,OAAA,GAAeH,IAAI,CAACI,UAAU,CAAC;EAC7BC,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EAAE,2DAA2D;MACxEC,WAAW,EAAE,QAAQ;MACrBC,oBAAoB,EAAE;KACvB;IACDC,QAAQ,EAAE;MACRC,KAAK,EAAE;KACR;IACDC,MAAM,EAAE,EAAE;IACVC,IAAI,EAAE;GACP;EACDC,cAAc,EAAE,EAAE;EAClBC,MAAMA,CAACC,OAAO;IACZ,MAAMC,cAAc,GAAGlB,IAAI,CAACmB,iBAAiB,CAACF,OAAO,CAAC;IACtD,MAAMG,WAAW,GAAGF,cAAc,CAACG,OAAO,CAACC,cAAc,EAAE;IAO3D,SAASC,sBAAsBA,CAC7BC,IAAgC;;MAEhC,MAAM;QAAEnB;MAAI,CAAE,GAAGmB,IAAI,CAACC,EAAE;MACxB,MAAMC,KAAK,GAAyB;QAClCC,OAAO,EAAE,EAAE;QACXC,eAAe,EAAEC;OAClB;MACD,IAAIC,KAAK,GAAiBb,OAAO,CAACc,QAAQ,EAAE;MAE5C,KAAK,MAAMC,UAAU,IAAI,CAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,GAAAL,KAAK,CAACM,KAAK,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,GAAG,CAACC,GAAG,CAACjC,IAAI,CAAC,cAAA6B,EAAA,uBAAAA,EAAA,CAAEK,IAAI,cAAAN,EAAA,cAAAA,EAAA,GAAI,EAAE,EAAE;QAC/D,IACED,UAAU,CAACR,IAAI,CAACV,IAAI,KAAKlB,OAAA,CAAA4C,cAAc,CAACC,iBAAiB,IACzDT,UAAU,CAACR,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,GAAGlB,IAAI,CAACkB,KAAK,CAAC,CAAC,CAAC,IACxCV,UAAU,CAACR,IAAI,CAACmB,OAAO,CAACC,MAAM,GAAG,CAAC,EAClC;UACAlB,KAAK,CAACE,eAAe,GAAGI,UAAU,CAACR,IAAI;UACvC;;;MAIJ,OAAOM,KAAK,EAAE;QACZ,CAAAe,EAAA,IAAAC,EAAA,GAAAhB,KAAK,CAACO,GAAG,CAACC,GAAG,CAACjC,IAAI,CAAC,cAAAyC,EAAA,uBAAAA,EAAA,CAAEP,IAAI,cAAAM,EAAA,uBAAAA,EAAA,CAAEE,OAAO,CAACf,UAAU,IAAG;UAC9C,IAAIA,UAAU,CAAClB,IAAI,KAAKpB,eAAA,CAAAsD,cAAc,CAACC,aAAa,EAAE;YACpDvB,KAAK,CAACC,OAAO,CAACuB,IAAI,CAAClB,UAAU,CAACR,IAAI,CAAC;;QAEvC,CAAC,CAAC;QAEFM,KAAK,GAAGA,KAAK,CAACM,KAAK;;MAGrB,OAAOV,KAAK;IACd;IAEA,SAASyB,qBAAqBA,CAAC3B,IAAa;MAC1C,OAAO3B,OAAO,CAACuD,aAAa,CAC1BhC,WAAW,CAACiC,iBAAiB,CAAC7B,IAAI,CAAC,EACnCzB,EAAE,CAACuD,SAAS,CAACC,UAAU,CACxB,GACGtD,WAAW,CAACuD,MAAM,GAClBvD,WAAW,CAACwD,MAAM;IACxB;IAEA,SAASC,mBAAmBA,CAC1BC,QAAuB;;MAEvB,MAAM7C,IAAI,GAAGM,WAAW,CAACiC,iBAAiB,CACxCnC,cAAc,CAAC0C,qBAAqB,CAACtB,GAAG,CAACqB,QAAQ,CAAC,CACnD;MAED,MAAME,gBAAgB,GAAG,CAAA1B,EAAA,GAAArB,IAAI,CAACgD,SAAS,EAAE,cAAA3B,EAAA,uBAAAA,EAAA,CAAE0B,gBAAgB;MAC3D,IACE,CAACA,gBAAgB,IACjB,CAAC9D,EAAE,CAACgE,iBAAiB,CAACF,gBAAgB,CAAC,IACvCA,gBAAgB,CAAClB,OAAO,CAACC,MAAM,KAAK,CAAC,EACrC;QACA,OAAOf,SAAS;;MAGlB,OAAOsB,qBAAqB,CAACU,gBAAgB,CAAClB,OAAO,CAAC,CAAC,CAAC,CAAC;IAC3D;IAEA,SAASqB,aAAaA,CAACC,MAA6B;MAClD,IAAI,CAACA,MAAM,CAACC,WAAW,EAAE;QACvB,OAAOjE,WAAW,CAACwD,MAAM;;MAG3B,QAAQQ,MAAM,CAACC,WAAW,CAACpD,IAAI;QAC7B,KAAKlB,OAAA,CAAA4C,cAAc,CAAC2B,OAAO;UACzB,QAAQ,OAAOF,MAAM,CAACC,WAAW,CAACE,KAAK;YACrC,KAAK,QAAQ;cACX,OAAOnE,WAAW,CAACwD,MAAM;YAC3B,KAAK,QAAQ;cACX,OAAOxD,WAAW,CAACuD,MAAM;YAC3B;cACE,OAAOvD,WAAW,CAACoE,OAAO;;QAGhC,KAAKzE,OAAA,CAAA4C,cAAc,CAAC8B,eAAe;UACjC,OAAOrE,WAAW,CAACuD,MAAM;QAE3B;UACE,OAAOL,qBAAqB,CAC1BjC,cAAc,CAAC0C,qBAAqB,CAACtB,GAAG,CAAC2B,MAAM,CAACC,WAAW,CAAC,CAC7D;;IAEP;IAEA,SAASK,2BAA2BA,CAClC/C,IAAgC;MAEhC,MAAM;QAAEG,OAAO;QAAEC;MAAe,CAAE,GAAGL,sBAAsB,CAACC,IAAI,CAAC;MAEjE;MACA;MACA;MACA;MACA;MACA,KAAK,MAAMmC,QAAQ,IAAIhC,OAAO,EAAE;QAC9B,MAAM6C,gBAAgB,GAAGd,mBAAmB,CAACC,QAAQ,CAAC;QACtD,IAAIa,gBAAgB,KAAK3C,SAAS,EAAE;UAClC,OAAO2C,gBAAgB;;;MAI3B;MACA;MACA;MACA,IAAI5C,eAAe,EAAE;QACnB,OAAOoC,aAAa,CAACpC,eAAe,CAACe,OAAO,CAAC,CAAC,CAAC,CAAC;;MAGlD;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IACEnB,IAAI,CAACiD,MAAO,CAAC3D,IAAI,KAAKlB,OAAA,CAAA4C,cAAc,CAACkC,sBAAsB,IAC3DlD,IAAI,CAACiD,MAAO,CAACA,MAAO,CAAC3D,IAAI,KAAKlB,OAAA,CAAA4C,cAAc,CAACmC,aAAa,EAC1D;QACA;QACA;QACA;QACA,MAAMC,MAAM,GAAG1D,cAAc,CAAC0C,qBAAqB,CAACtB,GAAG,CAACd,IAAI,CAACC,EAAE,CAAC;QAChE,MAAMoD,YAAY,GAAGzD,WAAW,CAC7B0D,mBAAmB,CAACF,MAAM,CAAE,CAC5BG,eAAe,EAAG;QAErB,KAAK,MAAMC,WAAW,IAAIH,YAAY,EAAE;UACtC,KAAK,MAAMZ,MAAM,IAAKe,WAAkC,CAACrC,OAAO,EAAE;YAChE,OAAOsB,MAAM,CAACC,WAAW,GACrBrE,OAAO,CAACuD,aAAa,CACnBhC,WAAW,CAACiC,iBAAiB,CAACY,MAAM,CAACC,WAAW,CAAC,EACjDnE,EAAE,CAACuD,SAAS,CAACC,UAAU,CACxB,GACCtD,WAAW,CAACuD,MAAM,GAClBvD,WAAW,CAACwD,MAAM,GACpBxD,WAAW,CAACwD,MAAM;;;;MAK5B;MACA,OAAOO,aAAa,CAACxC,IAAI,CAACmB,OAAO,CAAC,CAAC,CAAC,CAAC;IACvC;IAEA,OAAO;MACLF,iBAAiBA,CAACjB,IAAI;;QACpB,IAAI,CAACA,IAAI,CAACmB,OAAO,CAACC,MAAM,EAAE;UACxB;;QAGF,IAAIqC,WAAW,GAAGV,2BAA2B,CAAC/C,IAAI,CAAC;QACnD,IAAIyD,WAAW,KAAKlF,EAAE,CAACuD,SAAS,CAACe,OAAO,EAAE;UACxC;;QAGF,KAAK,MAAMJ,MAAM,IAAIzC,IAAI,CAACmB,OAAO,EAAE;UACjC,MAAMuC,WAAW,GAAGlB,aAAa,CAACC,MAAM,CAAC;UACzC,IAAIiB,WAAW,KAAKjF,WAAW,CAACoE,OAAO,EAAE;YACvC;;UAGF,IAAIa,WAAW,KAAKjF,WAAW,CAACwD,MAAM,EAAE;YACtCwB,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAXA,WAAW,GAAKC,WAAW;;UAG7B,IACEA,WAAW,KAAKD,WAAW,KAC1BC,WAAW,KAAKrD,SAAS,IAAIoD,WAAW,KAAKhF,WAAW,CAACuD,MAAM,CAAC,EACjE;YACAvC,OAAO,CAACkE,MAAM,CAAC;cACbC,SAAS,EAAE,OAAO;cAClB5D,IAAI,EAAE,CAAAW,EAAA,GAAA8B,MAAM,CAACC,WAAW,cAAA/B,EAAA,cAAAA,EAAA,GAAI8B;aAC7B,CAAC;YACF;;;MAGN;KACD;EACH;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}