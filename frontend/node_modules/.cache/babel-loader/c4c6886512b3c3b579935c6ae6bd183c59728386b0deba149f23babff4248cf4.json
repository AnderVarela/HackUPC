{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTypeReadonly = exports.readonlynessOptionsDefaults = exports.readonlynessOptionsSchema = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst getTypeArguments_1 = require(\"./getTypeArguments\");\nconst propertyTypes_1 = require(\"./propertyTypes\");\nexports.readonlynessOptionsSchema = {\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    treatMethodsAsReadonly: {\n      type: 'boolean'\n    }\n  }\n};\nexports.readonlynessOptionsDefaults = {\n  treatMethodsAsReadonly: false\n};\nfunction hasSymbol(node) {\n  return Object.prototype.hasOwnProperty.call(node, 'symbol');\n}\nfunction isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes) {\n  function checkTypeArguments(arrayType) {\n    const typeArguments =\n    // getTypeArguments was only added in TS3.7\n    (0, getTypeArguments_1.getTypeArguments)(arrayType, checker);\n    // this shouldn't happen in reality as:\n    // - tuples require at least 1 type argument\n    // - ReadonlyArray requires at least 1 type argument\n    /* istanbul ignore if */\n    if (typeArguments.length === 0) {\n      return 3 /* Readonlyness.Readonly */;\n    }\n    // validate the element types are also readonly\n    if (typeArguments.some(typeArg => isTypeReadonlyRecurser(checker, typeArg, options, seenTypes) === 2 /* Readonlyness.Mutable */)) {\n      return 2 /* Readonlyness.Mutable */;\n    }\n    return 3 /* Readonlyness.Readonly */;\n  }\n  if (checker.isArrayType(type)) {\n    const symbol = utils_1.ESLintUtils.nullThrows(type.getSymbol(), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('symbol', 'array type'));\n    const escapedName = symbol.getEscapedName();\n    if (escapedName === 'Array') {\n      return 2 /* Readonlyness.Mutable */;\n    }\n    return checkTypeArguments(type);\n  }\n  if (checker.isTupleType(type)) {\n    if (!type.target.readonly) {\n      return 2 /* Readonlyness.Mutable */;\n    }\n    return checkTypeArguments(type);\n  }\n  return 1 /* Readonlyness.UnknownType */;\n}\nfunction isTypeReadonlyObject(checker, type, options, seenTypes) {\n  function checkIndexSignature(kind) {\n    const indexInfo = checker.getIndexInfoOfType(type, kind);\n    if (indexInfo) {\n      if (!indexInfo.isReadonly) {\n        return 2 /* Readonlyness.Mutable */;\n      }\n      if (indexInfo.type === type || seenTypes.has(indexInfo.type)) {\n        return 3 /* Readonlyness.Readonly */;\n      }\n      return isTypeReadonlyRecurser(checker, indexInfo.type, options, seenTypes);\n    }\n    return 1 /* Readonlyness.UnknownType */;\n  }\n  const properties = type.getProperties();\n  if (properties.length) {\n    // ensure the properties are marked as readonly\n    for (const property of properties) {\n      if (options.treatMethodsAsReadonly) {\n        if (property.valueDeclaration !== undefined && hasSymbol(property.valueDeclaration) && (0, tsutils_1.isSymbolFlagSet)(property.valueDeclaration.symbol, ts.SymbolFlags.Method)) {\n          continue;\n        }\n        const declarations = property.getDeclarations();\n        const lastDeclaration = declarations !== undefined && declarations.length > 0 ? declarations[declarations.length - 1] : undefined;\n        if (lastDeclaration !== undefined && hasSymbol(lastDeclaration) && (0, tsutils_1.isSymbolFlagSet)(lastDeclaration.symbol, ts.SymbolFlags.Method)) {\n          continue;\n        }\n      }\n      if ((0, tsutils_1.isPropertyReadonlyInType)(type, property.getEscapedName(), checker)) {\n        continue;\n      }\n      const name = ts.getNameOfDeclaration(property.valueDeclaration);\n      if (name && ts.isPrivateIdentifier(name)) {\n        continue;\n      }\n      return 2 /* Readonlyness.Mutable */;\n    }\n    // all properties were readonly\n    // now ensure that all of the values are readonly also.\n    // do this after checking property readonly-ness as a perf optimization,\n    // as we might be able to bail out early due to a mutable property before\n    // doing this deep, potentially expensive check.\n    for (const property of properties) {\n      const propertyType = utils_1.ESLintUtils.nullThrows((0, propertyTypes_1.getTypeOfPropertyOfType)(checker, type, property), utils_1.ESLintUtils.NullThrowsReasons.MissingToken(`property \"${property.name}\"`, 'type'));\n      // handle recursive types.\n      // we only need this simple check, because a mutable recursive type will break via the above prop readonly check\n      if (seenTypes.has(propertyType)) {\n        continue;\n      }\n      if (isTypeReadonlyRecurser(checker, propertyType, options, seenTypes) === 2 /* Readonlyness.Mutable */) {\n        return 2 /* Readonlyness.Mutable */;\n      }\n    }\n  }\n  const isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);\n  if (isStringIndexSigReadonly === 2 /* Readonlyness.Mutable */) {\n    return isStringIndexSigReadonly;\n  }\n  const isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);\n  if (isNumberIndexSigReadonly === 2 /* Readonlyness.Mutable */) {\n    return isNumberIndexSigReadonly;\n  }\n  return 3 /* Readonlyness.Readonly */;\n}\n// a helper function to ensure the seenTypes map is always passed down, except by the external caller\nfunction isTypeReadonlyRecurser(checker, type, options, seenTypes) {\n  seenTypes.add(type);\n  if ((0, tsutils_1.isUnionType)(type)) {\n    // all types in the union must be readonly\n    const result = (0, tsutils_1.unionTypeParts)(type).every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3 /* Readonlyness.Readonly */);\n    const readonlyness = result ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;\n    return readonlyness;\n  }\n  if ((0, tsutils_1.isIntersectionType)(type)) {\n    // Special case for handling arrays/tuples (as readonly arrays/tuples always have mutable methods).\n    if (type.types.some(t => checker.isArrayType(t) || checker.isTupleType(t))) {\n      const allReadonlyParts = type.types.every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3 /* Readonlyness.Readonly */);\n      return allReadonlyParts ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;\n    }\n    // Normal case.\n    const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);\n    if (isReadonlyObject !== 1 /* Readonlyness.UnknownType */) {\n      return isReadonlyObject;\n    }\n  }\n  if ((0, tsutils_1.isConditionalType)(type)) {\n    const result = [type.root.node.trueType, type.root.node.falseType].map(checker.getTypeFromTypeNode).every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3 /* Readonlyness.Readonly */);\n    const readonlyness = result ? 3 /* Readonlyness.Readonly */ : 2 /* Readonlyness.Mutable */;\n    return readonlyness;\n  }\n  // all non-object, non-intersection types are readonly.\n  // this should only be primitive types\n  if (!(0, tsutils_1.isObjectType)(type)) {\n    return 3 /* Readonlyness.Readonly */;\n  }\n  // pure function types are readonly\n  if (type.getCallSignatures().length > 0 && type.getProperties().length === 0) {\n    return 3 /* Readonlyness.Readonly */;\n  }\n  const isReadonlyArray = isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes);\n  if (isReadonlyArray !== 1 /* Readonlyness.UnknownType */) {\n    return isReadonlyArray;\n  }\n  const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);\n  /* istanbul ignore else */\n  if (isReadonlyObject !== 1 /* Readonlyness.UnknownType */) {\n    return isReadonlyObject;\n  }\n  throw new Error('Unhandled type');\n}\n/**\n * Checks if the given type is readonly\n */\nfunction isTypeReadonly(checker, type, options = exports.readonlynessOptionsDefaults) {\n  return isTypeReadonlyRecurser(checker, type, options, new Set()) === 3 /* Readonlyness.Readonly */;\n}\nexports.isTypeReadonly = isTypeReadonly;","map":{"version":3,"names":["utils_1","require","tsutils_1","ts","__importStar","getTypeArguments_1","propertyTypes_1","exports","readonlynessOptionsSchema","type","additionalProperties","properties","treatMethodsAsReadonly","readonlynessOptionsDefaults","hasSymbol","node","Object","prototype","hasOwnProperty","call","isTypeReadonlyArrayOrTuple","checker","options","seenTypes","checkTypeArguments","arrayType","typeArguments","getTypeArguments","length","some","typeArg","isTypeReadonlyRecurser","isArrayType","symbol","ESLintUtils","nullThrows","getSymbol","NullThrowsReasons","MissingToken","escapedName","getEscapedName","isTupleType","target","readonly","isTypeReadonlyObject","checkIndexSignature","kind","indexInfo","getIndexInfoOfType","isReadonly","has","getProperties","property","valueDeclaration","undefined","isSymbolFlagSet","SymbolFlags","Method","declarations","getDeclarations","lastDeclaration","isPropertyReadonlyInType","name","getNameOfDeclaration","isPrivateIdentifier","propertyType","getTypeOfPropertyOfType","isStringIndexSigReadonly","IndexKind","String","isNumberIndexSigReadonly","Number","add","isUnionType","result","unionTypeParts","every","t","readonlyness","isIntersectionType","types","allReadonlyParts","isReadonlyObject","isConditionalType","root","trueType","falseType","map","getTypeFromTypeNode","isObjectType","getCallSignatures","isReadonlyArray","Error","isTypeReadonly","Set"],"sources":["../src/isTypeReadonly.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AASA,MAAAE,EAAA,GAAAC,YAAA,CAAAH,OAAA;AAEA,MAAAI,kBAAA,GAAAJ,OAAA;AACA,MAAAK,eAAA,GAAAL,OAAA;AAeaM,OAAA,CAAAC,yBAAyB,GAAG;EACvCC,IAAI,EAAE,QAAQ;EACdC,oBAAoB,EAAE,KAAK;EAC3BC,UAAU,EAAE;IACVC,sBAAsB,EAAE;MACtBH,IAAI,EAAE;;;CAGX;AAEYF,OAAA,CAAAM,2BAA2B,GAAwB;EAC9DD,sBAAsB,EAAE;CACzB;AAED,SAASE,SAASA,CAACC,IAAa;EAC9B,OAAOC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,IAAI,EAAE,QAAQ,CAAC;AAC7D;AAEA,SAASK,0BAA0BA,CACjCC,OAAuB,EACvBZ,IAAa,EACba,OAA4B,EAC5BC,SAAuB;EAEvB,SAASC,kBAAkBA,CAACC,SAA2B;IACrD,MAAMC,aAAa;IACjB;IACA,IAAArB,kBAAA,CAAAsB,gBAAgB,EAACF,SAAS,EAAEJ,OAAO,CAAC;IAEtC;IACA;IACA;IACA;IAAyB,IAAIK,aAAa,CAACE,MAAM,KAAK,CAAC,EAAE;MACvD;;IAGF;IACA,IACEF,aAAa,CAACG,IAAI,CAChBC,OAAO,IACLC,sBAAsB,CAACV,OAAO,EAAES,OAAO,EAAER,OAAO,EAAEC,SAAS,CAAC,K,4BACxC,CACvB,EACD;MACA;;IAEF;EACF;EAEA,IAAIF,OAAO,CAACW,WAAW,CAACvB,IAAI,CAAC,EAAE;IAC7B,MAAMwB,MAAM,GAAGjC,OAAA,CAAAkC,WAAW,CAACC,UAAU,CACnC1B,IAAI,CAAC2B,SAAS,EAAE,EAChBpC,OAAA,CAAAkC,WAAW,CAACG,iBAAiB,CAACC,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,CACnE;IACD,MAAMC,WAAW,GAAGN,MAAM,CAACO,cAAc,EAAE;IAC3C,IAAID,WAAW,KAAK,OAAO,EAAE;MAC3B;;IAGF,OAAOf,kBAAkB,CAACf,IAAI,CAAC;;EAGjC,IAAIY,OAAO,CAACoB,WAAW,CAAChC,IAAI,CAAC,EAAE;IAC7B,IAAI,CAACA,IAAI,CAACiC,MAAM,CAACC,QAAQ,EAAE;MACzB;;IAGF,OAAOnB,kBAAkB,CAACf,IAAI,CAAC;;EAGjC;AACF;AAEA,SAASmC,oBAAoBA,CAC3BvB,OAAuB,EACvBZ,IAAa,EACba,OAA4B,EAC5BC,SAAuB;EAEvB,SAASsB,mBAAmBA,CAACC,IAAkB;IAC7C,MAAMC,SAAS,GAAG1B,OAAO,CAAC2B,kBAAkB,CAACvC,IAAI,EAAEqC,IAAI,CAAC;IACxD,IAAIC,SAAS,EAAE;MACb,IAAI,CAACA,SAAS,CAACE,UAAU,EAAE;QACzB;;MAGF,IAAIF,SAAS,CAACtC,IAAI,KAAKA,IAAI,IAAIc,SAAS,CAAC2B,GAAG,CAACH,SAAS,CAACtC,IAAI,CAAC,EAAE;QAC5D;;MAGF,OAAOsB,sBAAsB,CAC3BV,OAAO,EACP0B,SAAS,CAACtC,IAAI,EACda,OAAO,EACPC,SAAS,CACV;;IAGH;EACF;EAEA,MAAMZ,UAAU,GAAGF,IAAI,CAAC0C,aAAa,EAAE;EACvC,IAAIxC,UAAU,CAACiB,MAAM,EAAE;IACrB;IACA,KAAK,MAAMwB,QAAQ,IAAIzC,UAAU,EAAE;MACjC,IAAIW,OAAO,CAACV,sBAAsB,EAAE;QAClC,IACEwC,QAAQ,CAACC,gBAAgB,KAAKC,SAAS,IACvCxC,SAAS,CAACsC,QAAQ,CAACC,gBAAgB,CAAC,IACpC,IAAAnD,SAAA,CAAAqD,eAAe,EACbH,QAAQ,CAACC,gBAAgB,CAACpB,MAAM,EAChC9B,EAAE,CAACqD,WAAW,CAACC,MAAM,CACtB,EACD;UACA;;QAGF,MAAMC,YAAY,GAAGN,QAAQ,CAACO,eAAe,EAAE;QAC/C,MAAMC,eAAe,GACnBF,YAAY,KAAKJ,SAAS,IAAII,YAAY,CAAC9B,MAAM,GAAG,CAAC,GACjD8B,YAAY,CAACA,YAAY,CAAC9B,MAAM,GAAG,CAAC,CAAC,GACrC0B,SAAS;QACf,IACEM,eAAe,KAAKN,SAAS,IAC7BxC,SAAS,CAAC8C,eAAe,CAAC,IAC1B,IAAA1D,SAAA,CAAAqD,eAAe,EAACK,eAAe,CAAC3B,MAAM,EAAE9B,EAAE,CAACqD,WAAW,CAACC,MAAM,CAAC,EAC9D;UACA;;;MAIJ,IAAI,IAAAvD,SAAA,CAAA2D,wBAAwB,EAACpD,IAAI,EAAE2C,QAAQ,CAACZ,cAAc,EAAE,EAAEnB,OAAO,CAAC,EAAE;QACtE;;MAGF,MAAMyC,IAAI,GAAG3D,EAAE,CAAC4D,oBAAoB,CAACX,QAAQ,CAACC,gBAAgB,CAAC;MAC/D,IAAIS,IAAI,IAAI3D,EAAE,CAAC6D,mBAAmB,CAACF,IAAI,CAAC,EAAE;QACxC;;MAGF;;IAGF;IACA;IAEA;IACA;IACA;IACA,KAAK,MAAMV,QAAQ,IAAIzC,UAAU,EAAE;MACjC,MAAMsD,YAAY,GAAGjE,OAAA,CAAAkC,WAAW,CAACC,UAAU,CACzC,IAAA7B,eAAA,CAAA4D,uBAAuB,EAAC7C,OAAO,EAAEZ,IAAI,EAAE2C,QAAQ,CAAC,EAChDpD,OAAA,CAAAkC,WAAW,CAACG,iBAAiB,CAACC,YAAY,CACxC,aAAac,QAAQ,CAACU,IAAI,GAAG,EAC7B,MAAM,CACP,CACF;MAED;MACA;MACA,IAAIvC,SAAS,CAAC2B,GAAG,CAACe,YAAY,CAAC,EAAE;QAC/B;;MAGF,IACElC,sBAAsB,CAACV,OAAO,EAAE4C,YAAY,EAAE3C,OAAO,EAAEC,SAAS,CAAC,K,8BAEjE;QACA;;;;EAKN,MAAM4C,wBAAwB,GAAGtB,mBAAmB,CAAC1C,EAAE,CAACiE,SAAS,CAACC,MAAM,CAAC;EACzE,IAAIF,wBAAwB,mCAA2B;IACrD,OAAOA,wBAAwB;;EAGjC,MAAMG,wBAAwB,GAAGzB,mBAAmB,CAAC1C,EAAE,CAACiE,SAAS,CAACG,MAAM,CAAC;EACzE,IAAID,wBAAwB,mCAA2B;IACrD,OAAOA,wBAAwB;;EAGjC;AACF;AAEA;AACA,SAASvC,sBAAsBA,CAC7BV,OAAuB,EACvBZ,IAAa,EACba,OAA4B,EAC5BC,SAAuB;EAEvBA,SAAS,CAACiD,GAAG,CAAC/D,IAAI,CAAC;EAEnB,IAAI,IAAAP,SAAA,CAAAuE,WAAW,EAAChE,IAAI,CAAC,EAAE;IACrB;IACA,MAAMiE,MAAM,GAAG,IAAAxE,SAAA,CAAAyE,cAAc,EAAClE,IAAI,CAAC,CAACmE,KAAK,CACvCC,CAAC,IACCtD,SAAS,CAAC2B,GAAG,CAAC2B,CAAC,CAAC,IAChB9C,sBAAsB,CAACV,OAAO,EAAEwD,CAAC,EAAEvD,OAAO,EAAEC,SAAS,CAAC,K,6BAC/B,CAC1B;IACD,MAAMuD,YAAY,GAAGJ,MAAM,GAAE,gCAAwB;IACrD,OAAOI,YAAY;;EAGrB,IAAI,IAAA5E,SAAA,CAAA6E,kBAAkB,EAACtE,IAAI,CAAC,EAAE;IAC5B;IACA,IACEA,IAAI,CAACuE,KAAK,CAACnD,IAAI,CAACgD,CAAC,IAAIxD,OAAO,CAACW,WAAW,CAAC6C,CAAC,CAAC,IAAIxD,OAAO,CAACoB,WAAW,CAACoC,CAAC,CAAC,CAAC,EACtE;MACA,MAAMI,gBAAgB,GAAGxE,IAAI,CAACuE,KAAK,CAACJ,KAAK,CACvCC,CAAC,IACCtD,SAAS,CAAC2B,GAAG,CAAC2B,CAAC,CAAC,IAChB9C,sBAAsB,CAACV,OAAO,EAAEwD,CAAC,EAAEvD,OAAO,EAAEC,SAAS,CAAC,K,6BAC/B,CAC1B;MACD,OAAO0D,gBAAgB,GAAE,gCAAwB;;IAGnD;IACA,MAAMC,gBAAgB,GAAGtC,oBAAoB,CAC3CvB,OAAO,EACPZ,IAAI,EACJa,OAAO,EACPC,SAAS,CACV;IACD,IAAI2D,gBAAgB,uCAA+B;MACjD,OAAOA,gBAAgB;;;EAI3B,IAAI,IAAAhF,SAAA,CAAAiF,iBAAiB,EAAC1E,IAAI,CAAC,EAAE;IAC3B,MAAMiE,MAAM,GAAG,CAACjE,IAAI,CAAC2E,IAAI,CAACrE,IAAI,CAACsE,QAAQ,EAAE5E,IAAI,CAAC2E,IAAI,CAACrE,IAAI,CAACuE,SAAS,CAAC,CAC/DC,GAAG,CAAClE,OAAO,CAACmE,mBAAmB,CAAC,CAChCZ,KAAK,CACJC,CAAC,IACCtD,SAAS,CAAC2B,GAAG,CAAC2B,CAAC,CAAC,IAChB9C,sBAAsB,CAACV,OAAO,EAAEwD,CAAC,EAAEvD,OAAO,EAAEC,SAAS,CAAC,K,6BAC/B,CAC1B;IAEH,MAAMuD,YAAY,GAAGJ,MAAM,GAAE,gCAAwB;IACrD,OAAOI,YAAY;;EAGrB;EACA;EACA,IAAI,CAAC,IAAA5E,SAAA,CAAAuF,YAAY,EAAChF,IAAI,CAAC,EAAE;IACvB;;EAGF;EACA,IACEA,IAAI,CAACiF,iBAAiB,EAAE,CAAC9D,MAAM,GAAG,CAAC,IACnCnB,IAAI,CAAC0C,aAAa,EAAE,CAACvB,MAAM,KAAK,CAAC,EACjC;IACA;;EAGF,MAAM+D,eAAe,GAAGvE,0BAA0B,CAChDC,OAAO,EACPZ,IAAI,EACJa,OAAO,EACPC,SAAS,CACV;EACD,IAAIoE,eAAe,uCAA+B;IAChD,OAAOA,eAAe;;EAGxB,MAAMT,gBAAgB,GAAGtC,oBAAoB,CAC3CvB,OAAO,EACPZ,IAAI,EACJa,OAAO,EACPC,SAAS,CACV;EACD;EAA2B,IACzB2D,gBAAgB,uCAChB;IACA,OAAOA,gBAAgB;;EAGzB,MAAM,IAAIU,KAAK,CAAC,gBAAgB,CAAC;AACnC;AAEA;;;AAGA,SAASC,cAAcA,CACrBxE,OAAuB,EACvBZ,IAAa,EACba,OAAA,GAA+Bf,OAAA,CAAAM,2BAA2B;EAE1D,OACEkB,sBAAsB,CAACV,OAAO,EAAEZ,IAAI,EAAEa,OAAO,EAAE,IAAIwE,GAAG,EAAE,CAAC,K;AAG7D;AAESvF,OAAA,CAAAsF,cAAA,GAAAA,cAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}