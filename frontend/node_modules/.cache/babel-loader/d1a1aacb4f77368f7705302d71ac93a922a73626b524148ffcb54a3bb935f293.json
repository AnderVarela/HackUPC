{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _importBuilder = require(\"./import-builder.js\");\nvar _isModule = require(\"./is-module.js\");\nconst {\n  identifier,\n  importSpecifier,\n  numericLiteral,\n  sequenceExpression,\n  isImportDeclaration\n} = _t;\nclass ImportInjector {\n  constructor(path, importedSource, opts) {\n    this._defaultOpts = {\n      importedSource: null,\n      importedType: \"commonjs\",\n      importedInterop: \"babel\",\n      importingInterop: \"babel\",\n      ensureLiveReference: false,\n      ensureNoContext: false,\n      importPosition: \"before\"\n    };\n    const programPath = path.find(p => p.isProgram());\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub;\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n  addDefault(importedSourceIn, opts) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n  addNamed(importName, importedSourceIn, opts) {\n    _assert(typeof importName === \"string\");\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);\n  }\n  addNamespace(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);\n  }\n  addSideEffect(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);\n  }\n  _applyDefaults(importedSource, opts, isInit = false) {\n    let newOpts;\n    if (typeof importedSource === \"string\") {\n      newOpts = Object.assign({}, this._defaultOpts, {\n        importedSource\n      }, opts);\n    } else {\n      _assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = Object.assign({}, this._defaultOpts, importedSource);\n    }\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n  _generateImport(opts, importName) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n      blockHoist\n    } = opts;\n    let name = nameHint || importName;\n    const isMod = (0, _isModule.default)(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n    const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n        builder.import();\n        if (isNamespace) {\n          builder.default(es6Default).var(name || importedSource).wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder.default(es6Default).var(name || importedSource).defaultInterop().read(\"default\");\n          } else {\n            builder.default(es6Default).var(name).defaultInterop().prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n    const {\n      statements,\n      resultName\n    } = builder.done();\n    this._insertStatements(statements, importPosition, blockHoist);\n    if ((isDefault || isNamed) && ensureNoContext && resultName.type !== \"Identifier\") {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n  _insertStatements(statements, importPosition = \"before\", blockHoist = 3) {\n    if (importPosition === \"after\") {\n      if (this._insertStatementsAfter(statements)) return;\n    } else {\n      if (this._insertStatementsBefore(statements, blockHoist)) return;\n    }\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n  _insertStatementsBefore(statements, blockHoist) {\n    if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {\n      const firstImportDecl = this._programPath.get(\"body\").find(p => {\n        return p.isImportDeclaration() && isValueImport(p.node);\n      });\n      if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {\n        return true;\n      }\n    }\n    statements.forEach(node => {\n      node._blockHoist = blockHoist;\n    });\n    const targetPath = this._programPath.get(\"body\").find(p => {\n      const val = p.node._blockHoist;\n      return Number.isFinite(val) && val < 4;\n    });\n    if (targetPath) {\n      targetPath.insertBefore(statements);\n      return true;\n    }\n    return false;\n  }\n  _insertStatementsAfter(statements) {\n    const statementsSet = new Set(statements);\n    const importDeclarations = new Map();\n    for (const statement of statements) {\n      if (isImportDeclaration(statement) && isValueImport(statement)) {\n        const source = statement.source.value;\n        if (!importDeclarations.has(source)) importDeclarations.set(source, []);\n        importDeclarations.get(source).push(statement);\n      }\n    }\n    let lastImportPath = null;\n    for (const bodyStmt of this._programPath.get(\"body\")) {\n      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {\n        lastImportPath = bodyStmt;\n        const source = bodyStmt.node.source.value;\n        const newImports = importDeclarations.get(source);\n        if (!newImports) continue;\n        for (const decl of newImports) {\n          if (!statementsSet.has(decl)) continue;\n          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {\n            statementsSet.delete(decl);\n          }\n        }\n      }\n    }\n    if (statementsSet.size === 0) return true;\n    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));\n    return !!lastImportPath;\n  }\n}\nexports.default = ImportInjector;\nfunction isValueImport(node) {\n  return node.importKind !== \"type\" && node.importKind !== \"typeof\";\n}\nfunction hasNamespaceImport(node) {\n  return node.specifiers.length === 1 && node.specifiers[0].type === \"ImportNamespaceSpecifier\" || node.specifiers.length === 2 && node.specifiers[1].type === \"ImportNamespaceSpecifier\";\n}\nfunction hasDefaultImport(node) {\n  return node.specifiers.length > 0 && node.specifiers[0].type === \"ImportDefaultSpecifier\";\n}\nfunction maybeAppendImportSpecifiers(target, source) {\n  if (!target.specifiers.length) {\n    target.specifiers = source.specifiers;\n    return true;\n  }\n  if (!source.specifiers.length) return true;\n  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;\n  if (hasDefaultImport(source)) {\n    if (hasDefaultImport(target)) {\n      source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier(\"default\"));\n    } else {\n      target.specifiers.unshift(source.specifiers.shift());\n    }\n  }\n  target.specifiers.push(...source.specifiers);\n  return true;\n}","map":{"version":3,"names":["_assert","require","_t","_importBuilder","_isModule","identifier","importSpecifier","numericLiteral","sequenceExpression","isImportDeclaration","ImportInjector","constructor","path","importedSource","opts","_defaultOpts","importedType","importedInterop","importingInterop","ensureLiveReference","ensureNoContext","importPosition","programPath","find","p","isProgram","_programPath","_programScope","scope","_hub","hub","_applyDefaults","addDefault","importedSourceIn","addNamed","importName","_generateImport","addNamespace","addSideEffect","isInit","newOpts","Object","assign","nameHint","undefined","blockHoist","isDefault","isNamed","isNamespace","name","isMod","default","isModuleForNode","isModuleForBabel","Error","builder","import","namespace","named","es6Default","var","wildcardInterop","defaultInterop","read","prop","statements","resultName","done","_insertStatements","type","_insertStatementsAfter","_insertStatementsBefore","unshiftContainer","length","isValueImport","firstImportDecl","get","node","source","value","maybeAppendImportSpecifiers","forEach","_blockHoist","targetPath","val","Number","isFinite","insertBefore","statementsSet","Set","importDeclarations","Map","statement","has","set","push","lastImportPath","bodyStmt","newImports","decl","delete","size","insertAfter","Array","from","exports","importKind","hasNamespaceImport","specifiers","hasDefaultImport","target","local","unshift","shift"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\helper-module-imports\\src\\import-injector.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  identifier,\n  importSpecifier,\n  numericLiteral,\n  sequenceExpression,\n  isImportDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport type { File } from \"@babel/core\";\n\nimport ImportBuilder from \"./import-builder.ts\";\nimport isModule from \"./is-module.ts\";\n\nexport type ImportOptions = {\n  /**\n   * The module being referenced.\n   */\n  importedSource: string | null;\n  /**\n   * The type of module being imported:\n   *\n   *  * 'es6'      - An ES6 module.\n   *  * 'commonjs' - A CommonJS module. (Default)\n   */\n  importedType: \"es6\" | \"commonjs\";\n  /**\n   * The type of interop behavior for namespace/default/named when loading\n   * CommonJS modules.\n   *\n   * ## 'babel' (Default)\n   *\n   * Load using Babel's interop.\n   *\n   * If '.__esModule' is true, treat as 'compiled', else:\n   *\n   * * Namespace: A copy of the module.exports with .default\n   *     populated by the module.exports object.\n   * * Default: The module.exports value.\n   * * Named: The .named property of module.exports.\n   *\n   * The 'ensureLiveReference' has no effect on the liveness of these.\n   *\n   * ## 'compiled'\n   *\n   * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting\n   * interop logic if you are confident that the module is a certain format.\n   *\n   * * Namespace: The root module.exports object.\n   * * Default: The .default property of the namespace.\n   * * Named: The .named property of the namespace.\n   *\n   * Will return erroneous results if the imported module is _not_ compiled\n   * from ES6 with Babel.\n   *\n   * ## 'uncompiled'\n   *\n   * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified\n   * access pattern that doesn't require additional function calls.\n   *\n   * Will return erroneous results if the imported module _is_ compiled\n   * from ES6 with Babel.\n   *\n   * * Namespace: The module.exports object.\n   * * Default: The module.exports object.\n   * * Named: The .named property of module.exports.\n   */\n  importedInterop: \"babel\" | \"node\" | \"compiled\" | \"uncompiled\";\n  /**\n   * The type of CommonJS interop included in the environment that will be\n   * loading the output code.\n   *\n   *  * 'babel' - CommonJS modules load with Babel's interop. (Default)\n   *  * 'node'  - CommonJS modules load with Node's interop.\n   *\n   * See descriptions in 'importedInterop' for more details.\n   */\n  importingInterop: \"babel\" | \"node\";\n  /**\n   * Define whether we explicitly care that the import be a live reference.\n   * Only applies when importing default and named imports, not the namespace.\n   *\n   *  * true  - Force imported values to be live references.\n   *  * false - No particular requirements. Keeps the code simplest. (Default)\n   */\n  ensureLiveReference: boolean;\n  /**\n   * Define if we explicitly care that the result not be a property reference.\n   *\n   *  * true  - Force calls to exclude context. Useful if the value is going to\n   *            be used as function callee.\n   *  * false - No particular requirements for context of the access. (Default)\n   */\n  ensureNoContext: boolean;\n  /**\n   * Define whether the import should be loaded before or after the existing imports.\n   * \"after\" is only allowed inside ECMAScript modules, since it's not possible to\n   * reliably pick the location _after_ require() calls but _before_ other code in CJS.\n   */\n  importPosition: \"before\" | \"after\";\n\n  nameHint?: string;\n  blockHoist?: number;\n};\n\n/**\n * A general helper classes add imports via transforms. See README for usage.\n */\nexport default class ImportInjector {\n  /**\n   * The path used for manipulation.\n   */\n  declare _programPath: NodePath<t.Program>;\n\n  /**\n   * The scope used to generate unique variable names.\n   */\n  declare _programScope: Scope;\n\n  /**\n   * The file used to inject helpers and resolve paths.\n   */\n  declare _hub: File[\"hub\"];\n\n  /**\n   * The default options to use with this instance when imports are added.\n   */\n  _defaultOpts: ImportOptions = {\n    importedSource: null,\n    importedType: \"commonjs\",\n    importedInterop: \"babel\",\n    importingInterop: \"babel\",\n    ensureLiveReference: false,\n    ensureNoContext: false,\n    importPosition: \"before\",\n  };\n\n  constructor(\n    path: NodePath,\n    importedSource?: string,\n    opts?: Partial<ImportOptions>,\n  ) {\n    const programPath = path.find(p => p.isProgram()) as NodePath<t.Program>;\n\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub as File[\"hub\"];\n\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n\n  addDefault(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n\n  addNamed(\n    importName: string,\n    importedSourceIn: string,\n    opts: Partial<ImportOptions>,\n  ) {\n    assert(typeof importName === \"string\");\n\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      importName,\n    );\n  }\n\n  addNamespace(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      null,\n    );\n  }\n\n  addSideEffect(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      void 0,\n    );\n  }\n\n  _applyDefaults(\n    importedSource: string | Partial<ImportOptions>,\n    opts: Partial<ImportOptions> | undefined,\n    isInit = false,\n  ) {\n    let newOpts: ImportOptions;\n    if (typeof importedSource === \"string\") {\n      newOpts = { ...this._defaultOpts, importedSource, ...opts };\n    } else {\n      assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = { ...this._defaultOpts, ...importedSource };\n    }\n\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n\n  _generateImport(\n    opts: Partial<ImportOptions>,\n    importName: string | null | undefined,\n  ) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n\n      // Not meant for public usage. Allows code that absolutely must control\n      // ordering to set a specific hoist value on the import nodes.\n      // This is ignored when \"importPosition\" is \"after\".\n      blockHoist,\n    } = opts;\n\n    // Provide a hint for generateUidIdentifier for the local variable name\n    // to use for the import, if the code will generate a simple assignment\n    // to a variable.\n    let name = nameHint || importName;\n\n    const isMod = isModule(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n\n    const builder = new ImportBuilder(\n      importedSource,\n      this._programScope,\n      this._hub,\n    );\n\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n\n      // import * as namespace from ''; namespace\n      // import def from ''; def\n      // import { named } from ''; named\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        // import _tmp from ''; var namespace = interopRequireWildcard(_tmp); namespace\n        // import _tmp from ''; var def = interopRequireDefault(_tmp).default; def\n        // import _tmp from ''; _tmp.named\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n\n        builder.import();\n        if (isNamespace) {\n          builder\n            .default(es6Default)\n            .var(name || importedSource)\n            .wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder\n              .default(es6Default)\n              .var(name || importedSource)\n              .defaultInterop()\n              .read(\"default\");\n          } else {\n            builder\n              .default(es6Default)\n              .var(name)\n              .defaultInterop()\n              .prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = interopRequireWildcard(require(''));\n        // var def = interopRequireDefault(require('')).default; def\n        // var named = require('').named; named\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import namespace from ''; namespace.default\n        // import namespace from ''; namespace.named\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        // Note: These lookups will break if the module has no __esModule set,\n        // hence the warning that 'compiled' will not work on standard CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var namespace = require(''); namespace.default\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import def from ''; def;\n        // import namespace from ''; namespace.named\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import namespace from '';\n        // import def from '';\n        // import { named } from ''; named;\n        // Note: These lookups will break if the module has __esModule set,\n        // hence the warning that 'uncompiled' will not work on ES6 transpiled\n        // to CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var def = require(''); def\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n\n    const { statements, resultName } = builder.done();\n\n    this._insertStatements(statements, importPosition, blockHoist);\n\n    if (\n      (isDefault || isNamed) &&\n      ensureNoContext &&\n      resultName.type !== \"Identifier\"\n    ) {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n\n  _insertStatements(\n    statements: t.Statement[],\n    importPosition = \"before\",\n    blockHoist = 3,\n  ) {\n    if (importPosition === \"after\") {\n      if (this._insertStatementsAfter(statements)) return;\n    } else {\n      if (this._insertStatementsBefore(statements, blockHoist)) return;\n    }\n\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n\n  _insertStatementsBefore(statements: t.Statement[], blockHoist: number) {\n    if (\n      statements.length === 1 &&\n      isImportDeclaration(statements[0]) &&\n      isValueImport(statements[0])\n    ) {\n      const firstImportDecl = this._programPath\n        .get(\"body\")\n        .find((p): p is NodePath<t.ImportDeclaration> => {\n          return p.isImportDeclaration() && isValueImport(p.node);\n        });\n\n      if (\n        firstImportDecl?.node.source.value === statements[0].source.value &&\n        maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])\n      ) {\n        return true;\n      }\n    }\n\n    statements.forEach(node => {\n      // @ts-expect-error handle _blockHoist\n      node._blockHoist = blockHoist;\n    });\n\n    const targetPath = this._programPath.get(\"body\").find(p => {\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      const val = p.node._blockHoist;\n      return Number.isFinite(val) && val < 4;\n    });\n\n    if (targetPath) {\n      targetPath.insertBefore(statements);\n      return true;\n    }\n\n    return false;\n  }\n\n  _insertStatementsAfter(statements: t.Statement[]): boolean {\n    const statementsSet = new Set(statements);\n    const importDeclarations: Map<string, t.ImportDeclaration[]> = new Map();\n\n    for (const statement of statements) {\n      if (isImportDeclaration(statement) && isValueImport(statement)) {\n        const source = statement.source.value;\n        if (!importDeclarations.has(source)) importDeclarations.set(source, []);\n        importDeclarations.get(source).push(statement);\n      }\n    }\n\n    let lastImportPath = null;\n    for (const bodyStmt of this._programPath.get(\"body\")) {\n      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {\n        lastImportPath = bodyStmt;\n\n        const source = bodyStmt.node.source.value;\n        const newImports = importDeclarations.get(source);\n        if (!newImports) continue;\n\n        for (const decl of newImports) {\n          if (!statementsSet.has(decl)) continue;\n          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {\n            statementsSet.delete(decl);\n          }\n        }\n      }\n    }\n\n    if (statementsSet.size === 0) return true;\n\n    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));\n\n    return !!lastImportPath;\n  }\n}\n\nfunction isValueImport(node: t.ImportDeclaration) {\n  return node.importKind !== \"type\" && node.importKind !== \"typeof\";\n}\n\nfunction hasNamespaceImport(node: t.ImportDeclaration) {\n  return (\n    (node.specifiers.length === 1 &&\n      node.specifiers[0].type === \"ImportNamespaceSpecifier\") ||\n    (node.specifiers.length === 2 &&\n      node.specifiers[1].type === \"ImportNamespaceSpecifier\")\n  );\n}\n\nfunction hasDefaultImport(node: t.ImportDeclaration) {\n  return (\n    node.specifiers.length > 0 &&\n    node.specifiers[0].type === \"ImportDefaultSpecifier\"\n  );\n}\n\nfunction maybeAppendImportSpecifiers(\n  target: t.ImportDeclaration,\n  source: t.ImportDeclaration,\n): boolean {\n  if (!target.specifiers.length) {\n    target.specifiers = source.specifiers;\n    return true;\n  }\n  if (!source.specifiers.length) return true;\n\n  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;\n\n  if (hasDefaultImport(source)) {\n    if (hasDefaultImport(target)) {\n      source.specifiers[0] = importSpecifier(\n        source.specifiers[0].local,\n        identifier(\"default\"),\n      );\n    } else {\n      target.specifiers.unshift(source.specifiers.shift());\n    }\n  }\n\n  target.specifiers.push(...source.specifiers);\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}