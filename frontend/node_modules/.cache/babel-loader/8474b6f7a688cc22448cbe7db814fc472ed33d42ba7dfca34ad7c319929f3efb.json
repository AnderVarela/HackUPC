{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}();\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n  var length = s.length;\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {\n    return false;\n  }\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"names":["getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","isAbsolute","parts","split","part","up","i","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","indexOf","index","lastIndexOf","slice","Array","substr","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","charCodeAt","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","strcmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","aStr1","aStr2","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/reporters/node_modules/source-map/lib/util.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}