{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-loop-func');\nexports.default = util.createRule({\n  name: 'no-loop-func',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow function declarations that contain unsafe references inside loop statements',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: [],\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: [],\n  create(context) {\n    /**\n     * Reports functions which match the following condition:\n     * - has a loop node in ancestors.\n     * - has any references which refers to an unsafe variable.\n     *\n     * @param node The AST node to check.\n     * @returns Whether or not the node is within a loop.\n     */\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n      if (!loopNode) {\n        return;\n      }\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: 'unsafeRefs',\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n});\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param node An AST node to get.\n * @returns The containing loop node of the specified node, or `null`.\n */\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n    switch (parent.type) {\n      case utils_1.AST_NODE_TYPES.WhileStatement:\n      case utils_1.AST_NODE_TYPES.DoWhileStatement:\n        return parent;\n      case utils_1.AST_NODE_TYPES.ForStatement:\n        // `init` is outside of the loop.\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n        break;\n      case utils_1.AST_NODE_TYPES.ForInStatement:\n      case utils_1.AST_NODE_TYPES.ForOfStatement:\n        // `right` is outside of the loop.\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n        break;\n      case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        // We don't need to check nested functions.\n        return null;\n      default:\n        break;\n    }\n  }\n  return null;\n}\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param node A node to get. This is a loop node.\n * @param excludedNode A node that the result node should not include.\n * @returns The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n  return retv;\n}\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param loopNode A containing loop node.\n * @param reference A reference to check.\n * @returns `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n  var _a;\n  const variable = reference.resolved;\n  const definition = variable === null || variable === void 0 ? void 0 : variable.defs[0];\n  const declaration = definition === null || definition === void 0 ? void 0 : definition.parent;\n  const kind = (declaration === null || declaration === void 0 ? void 0 : declaration.type) === utils_1.AST_NODE_TYPES.VariableDeclaration ? declaration.kind : '';\n  // type references are all safe\n  // this only really matters for global types that haven't been configured\n  if (reference.isTypeReference) {\n    return true;\n  }\n  // Variables which are declared by `const` is safe.\n  if (kind === 'const') {\n    return true;\n  }\n  /*\n   * Variables which are declared by `let` in the loop is safe.\n   * It's a different instance from the next loop step's.\n   */\n  if (kind === 'let' && declaration && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n  /*\n   * WriteReferences which exist after this border are unsafe because those\n   * can modify the variable.\n   */\n  const border = getTopLoopNode(loopNode, kind === 'let' ? declaration : null).range[0];\n  /**\n   * Checks whether a given reference is safe or not.\n   * The reference is every reference of the upper scope's variable we are\n   * looking now.\n   *\n   * It's safe if the reference matches one of the following condition.\n   * - is readonly.\n   * - doesn't exist inside a local function and after the border.\n   *\n   * @param upperRef A reference to check.\n   * @returns `true` if the reference is safe.\n   */\n  function isSafeReference(upperRef) {\n    var _a;\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || ((_a = variable === null || variable === void 0 ? void 0 : variable.scope) === null || _a === void 0 ? void 0 : _a.variableScope) === upperRef.from.variableScope && id.range[0] < border;\n  }\n  return (_a = variable === null || variable === void 0 ? void 0 : variable.references.every(isSafeReference)) !== null && _a !== void 0 ? _a : false;\n}","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","exports","default","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","hasSuggestions","schema","messages","defaultOptions","create","context","checkForLoops","node","loopNode","getContainingLoopNode","references","getScope","through","unsafeRefs","filter","r","isSafe","map","identifier","length","report","messageId","data","varNames","join","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","currentNode","parent","AST_NODE_TYPES","WhileStatement","DoWhileStatement","ForStatement","init","ForInStatement","ForOfStatement","right","getTopLoopNode","excludedNode","border","range","retv","containingLoopNode","reference","variable","resolved","definition","defs","declaration","kind","VariableDeclaration","isTypeReference","isSafeReference","upperRef","id","isWrite","_a","scope","variableScope","from","every"],"sources":["../../src/rules/no-loop-func.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}