{"ast":null,"code":"/* eslint-disable global-require, import/no-dynamic-require */\n\n// import generate from 'babel-generator';\n// console.log(generate(node).code);\nimport isAnnotatedForRemoval from './isAnnotatedForRemoval';\nimport isStatelessComponent from './isStatelessComponent';\nimport remove from './remove';\nfunction isPathReactClass(path, globalOptions) {\n  const node = path.node;\n  const matchers = globalOptions.classNameMatchers;\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n  return false;\n}\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n  let answer = false;\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    const className = superClass.node.name;\n    const binding = scope.getBinding(className);\n    if (!binding) {\n      answer = false;\n    } else {\n      const bindingSuperClass = binding.path.get('superClass');\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n  return answer;\n}\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n  if (set1.size !== set2.size) {\n    return false;\n  }\n  return !Array.from(set1).some(item => !set2.has(item));\n}\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  const parent = path.findParent(p => !p.isMemberExpression());\n  const {\n    type\n  } = parent.node;\n  let memberExpression;\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  }\n\n  // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n  return memberExpression.get('object');\n}\nexport default function (api) {\n  const {\n    template,\n    types,\n    traverse\n  } = api;\n  const nestedIdentifiers = new Set();\n  const removedPaths = new WeakSet();\n  const collectNestedIdentifiers = {\n    Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n\n        const root = memberExpressionRootIdentifier(path);\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n        return;\n      }\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program(programPath, state) {\n        let ignoreFilenames;\n        let classNameMatchers;\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n        const globalOptions = {\n          visitedKey: `transform-react-remove-prop-types${Date.now()}`,\n          unsafeWrapTemplate: template(`\n              if (process.env.NODE_ENV !== \"production\") {\n                NODE;\n              }\n            `, {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: ({\n            LEFT,\n            RIGHT\n          }, options = {}) => {\n            const {\n              as = 'assignmentExpression'\n            } = options;\n            const right = template.expression(`\n                process.env.NODE_ENV !== \"production\" ? RIGHT : {}\n              `, {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT\n            });\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n              default:\n                throw new Error(`unrecognized template type ${as}`);\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames,\n          types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n        if (state.opts.plugins) {\n          const pluginsState = state;\n          const pluginsVisitors = state.opts.plugins.map(pluginOpts => {\n            const pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = {\n                ...pluginsState.opts,\n                ...pluginOpts[1]\n              };\n            }\n            let plugin = require(pluginName);\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        }\n\n        // On program start, do an explicit traversal up front for this plugin.\n        programPath.traverse({\n          ObjectProperty: {\n            exit(path) {\n              const node = path.node;\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n              const parent = path.findParent(currentNode => {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty(path) {\n            const {\n              node,\n              scope\n            } = path;\n            if (node.key.name === 'propTypes') {\n              const pathClassDeclaration = scope.path;\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression(path) {\n            const {\n              node,\n              scope\n            } = path;\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n            const forceRemoval = isAnnotatedForRemoval(path.node.left);\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              remove(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n            const className = node.left.object.name;\n            const binding = scope.getBinding(className);\n            if (!binding) {\n              return;\n            }\n            if (binding.path.isClassDeclaration()) {\n              const superClass = binding.path.get('superClass');\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if (isStatelessComponent(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              remove(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        let skippedIdentifiers = 0;\n        const removeNewlyUnusedIdentifiers = {\n          VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n            const {\n              name\n            } = path.node.id;\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n            const {\n              referencePaths\n            } = path.scope.getBinding(name);\n\n            // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n            const hasRemainingReferencePaths = referencePaths.some(referencePath => {\n              const found = referencePath.find(path2 => removedPaths.has(path2));\n              return !found;\n            });\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            remove(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        let lastNestedIdentifiers = new Set();\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration(path) {\n                const {\n                  source,\n                  specifiers\n                } = path.node;\n                const found = globalOptions.libraries.some(library => {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n                  return source.value === library;\n                });\n                if (!found) {\n                  return;\n                }\n                const haveUsedSpecifiers = specifiers.some(specifier => {\n                  const importedIdentifierName = specifier.local.name;\n                  const {\n                    referencePaths\n                  } = path.scope.getBinding(importedIdentifierName);\n                  return referencePaths.length > 0;\n                });\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["isAnnotatedForRemoval","isStatelessComponent","remove","isPathReactClass","path","globalOptions","node","matchers","classNameMatchers","matchesPattern","name","test","isReactClass","superClass","scope","answer","className","binding","getBinding","bindingSuperClass","get","areSetsEqual","set1","set2","size","Array","from","some","item","has","memberExpressionRootIdentifier","parent","findParent","p","isMemberExpression","type","memberExpression","object","api","template","types","traverse","nestedIdentifiers","Set","removedPaths","WeakSet","collectNestedIdentifiers","Identifier","root","add","key","shorthand","visitor","Program","programPath","state","ignoreFilenames","opts","RegExp","join","undefined","visitedKey","Date","now","unsafeWrapTemplate","placeholderPattern","wrapTemplate","LEFT","RIGHT","options","as","right","expression","variableDeclarator","assignmentExpression","Error","mode","removeImport","libraries","additionalLibraries","concat","createReactClassName","plugins","pluginsState","pluginsVisitors","map","pluginOpts","pluginName","plugin","require","default","visitors","merge","parentPath","ObjectProperty","exit","computed","currentNode","property","ClassProperty","pathClassDeclaration","AssignmentExpression","left","forceRemoval","isClassDeclaration","skippedIdentifiers","removeNewlyUnusedIdentifiers","VariableDeclarator","block","includes","id","referencePaths","hasRemainingReferencePaths","referencePath","found","find","path2","delete","lastNestedIdentifiers","crawl","ImportDeclaration","source","specifiers","library","value","haveUsedSpecifiers","specifier","importedIdentifierName","local","length"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/src/index.js"],"sourcesContent":["/* eslint-disable global-require, import/no-dynamic-require */\n\n// import generate from 'babel-generator';\n// console.log(generate(node).code);\nimport isAnnotatedForRemoval from './isAnnotatedForRemoval'\nimport isStatelessComponent from './isStatelessComponent'\nimport remove from './remove'\n\nfunction isPathReactClass(path, globalOptions) {\n  const node = path.node\n  const matchers = globalOptions.classNameMatchers\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true\n  }\n\n  return false\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false\n  }\n\n  let answer = false\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    const className = superClass.node.name\n    const binding = scope.getBinding(className)\n    if (!binding) {\n      answer = false\n    } else {\n      const bindingSuperClass = binding.path.get('superClass')\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true\n      }\n    }\n  }\n\n  return answer\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true\n  }\n\n  if (set1.size !== set2.size) {\n    return false\n  }\n\n  return !Array.from(set1).some(item => !set2.has(item))\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  const parent = path.findParent(p => !p.isMemberExpression())\n  const { type } = parent.node\n\n  let memberExpression\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value')\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null\n  }\n\n  // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object')\n  }\n\n  return memberExpression.get('object')\n}\n\nexport default function(api) {\n  const { template, types, traverse } = api\n\n  const nestedIdentifiers = new Set()\n  const removedPaths = new WeakSet()\n  const collectNestedIdentifiers = {\n    Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n\n        const root = memberExpressionRootIdentifier(path)\n        if (root) {\n          nestedIdentifiers.add(root.node.name)\n        }\n\n        return\n      }\n\n      if (\n        path.parent.type === 'ObjectProperty' &&\n        (path.parent.key === path.node || path.parent.shorthand)\n      ) {\n        // { foo: 'bar' }\n        // { foo }\n        return\n      }\n\n      nestedIdentifiers.add(path.node.name)\n    },\n  }\n\n  return {\n    visitor: {\n      Program(programPath, state) {\n        let ignoreFilenames\n        let classNameMatchers\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i')\n        } else {\n          ignoreFilenames = undefined\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'))\n        } else {\n          classNameMatchers = undefined\n        }\n\n        const globalOptions = {\n          visitedKey: `transform-react-remove-prop-types${Date.now()}`,\n          unsafeWrapTemplate: template(\n            `\n              if (process.env.NODE_ENV !== \"production\") {\n                NODE;\n              }\n            `,\n            { placeholderPattern: /^NODE$/ }\n          ),\n          wrapTemplate: ({ LEFT, RIGHT }, options = {}) => {\n            const { as = 'assignmentExpression' } = options\n            const right = template.expression(\n              `\n                process.env.NODE_ENV !== \"production\" ? RIGHT : {}\n              `,\n              { placeholderPattern: /^(LEFT|RIGHT)$/ }\n            )({ RIGHT })\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right)\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right)\n              default:\n                throw new Error(`unrecognized template type ${as}`)\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames,\n          types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass',\n        }\n\n        if (state.opts.plugins) {\n          const pluginsState = state\n          const pluginsVisitors = state.opts.plugins.map(pluginOpts => {\n            const pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0]\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = {\n                ...pluginsState.opts,\n                ...pluginOpts[1],\n              }\n            }\n\n            let plugin = require(pluginName)\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default\n            }\n\n            return plugin(api).visitor\n          })\n\n          traverse(\n            programPath.parent,\n            traverse.visitors.merge(pluginsVisitors),\n            programPath.scope,\n            pluginsState,\n            programPath.parentPath\n          )\n        }\n\n        // On program start, do an explicit traversal up front for this plugin.\n        programPath.traverse({\n          ObjectProperty: {\n            exit(path) {\n              const node = path.node\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return\n              }\n\n              const parent = path.findParent(currentNode => {\n                if (currentNode.type !== 'CallExpression') {\n                  return false\n                }\n\n                return (\n                  currentNode.get('callee').node.name === globalOptions.createReactClassName ||\n                  (currentNode.get('callee').node.property &&\n                    currentNode.get('callee').node.property.name === 'createClass')\n                )\n              })\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, {\n                  type: 'createClass',\n                })\n              }\n            },\n          },\n\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty(path) {\n            const { node, scope } = path\n\n            if (node.key.name === 'propTypes') {\n              const pathClassDeclaration = scope.path\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration,\n                })\n              }\n            }\n          },\n\n          AssignmentExpression(path) {\n            const { node, scope } = path\n\n            if (\n              node.left.computed ||\n              !node.left.property ||\n              node.left.property.name !== 'propTypes'\n            ) {\n              return\n            }\n\n            const forceRemoval = isAnnotatedForRemoval(path.node.left)\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers)\n              removedPaths.add(path)\n              remove(path, globalOptions, { type: 'assign' })\n              return\n            }\n\n            const className = node.left.object.name\n            const binding = scope.getBinding(className)\n\n            if (!binding) {\n              return\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              const superClass = binding.path.get('superClass')\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, { type: 'assign' })\n              }\n            } else if (isStatelessComponent(binding.path)) {\n              path.traverse(collectNestedIdentifiers)\n              removedPaths.add(path)\n              remove(path, globalOptions, { type: 'assign' })\n            }\n          },\n        })\n\n        let skippedIdentifiers = 0\n        const removeNewlyUnusedIdentifiers = {\n          VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return\n            }\n            const { name } = path.node.id\n\n            if (!nestedIdentifiers.has(name)) {\n              return\n            }\n\n            const { referencePaths } = path.scope.getBinding(name)\n\n            // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n            const hasRemainingReferencePaths = referencePaths.some(referencePath => {\n              const found = referencePath.find(path2 => removedPaths.has(path2))\n              return !found\n            })\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1\n              return\n            }\n\n            removedPaths.add(path)\n            nestedIdentifiers.delete(name)\n            path.get('init').traverse(collectNestedIdentifiers)\n            remove(path, globalOptions, { type: 'declarator' })\n          },\n        }\n\n        let lastNestedIdentifiers = new Set()\n        while (\n          !areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) &&\n          nestedIdentifiers.size > 0 &&\n          skippedIdentifiers < nestedIdentifiers.size\n        ) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers)\n          skippedIdentifiers = 0\n          programPath.scope.crawl()\n          programPath.traverse(removeNewlyUnusedIdentifiers)\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl()\n\n            programPath.traverse({\n              ImportDeclaration(path) {\n                const { source, specifiers } = path.node\n\n                const found = globalOptions.libraries.some(library => {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value)\n                  }\n\n                  return source.value === library\n                })\n\n                if (!found) {\n                  return\n                }\n\n                const haveUsedSpecifiers = specifiers.some(specifier => {\n                  const importedIdentifierName = specifier.local.name\n                  const { referencePaths } = path.scope.getBinding(importedIdentifierName)\n                  return referencePaths.length > 0\n                })\n\n                if (!haveUsedSpecifiers) {\n                  path.remove()\n                }\n              },\n            })\n          } else {\n            throw new Error(\n              'transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.'\n            )\n          }\n        }\n      },\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}