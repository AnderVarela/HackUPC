{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('key-spacing');\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nconst baseSchema = Array.isArray(baseRule.meta.schema) ? baseRule.meta.schema[0] : baseRule.meta.schema;\n/**\n * TODO: replace with native .at() once Node 14 stops being supported\n */\nfunction at(arr, position) {\n  if (position < 0) {\n    return arr[arr.length + position];\n  }\n  return arr[position];\n}\nexports.default = util.createRule({\n  name: 'key-spacing',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Enforce consistent spacing between property names and type annotations in types and interfaces',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'whitespace',\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: [baseSchema],\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: [{}],\n  create(context, [options]) {\n    const sourceCode = context.getSourceCode();\n    const baseRules = baseRule.create(context);\n    /**\n     * @returns the column of the position after converting all unicode characters in the line to 1 char length\n     */\n    function adjustedColumn(position) {\n      const line = position.line - 1; // position.line is 1-indexed\n      return util.getStringLength(at(sourceCode.lines, line).slice(0, position.column));\n    }\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     */\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, util.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n    function isKeyTypeNode(node) {\n      return (node.type === utils_1.AST_NODE_TYPES.TSPropertySignature || node.type === utils_1.AST_NODE_TYPES.TSIndexSignature || node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) && !!node.typeAnnotation;\n    }\n    function isApplicable(node) {\n      return isKeyTypeNode(node) && node.typeAnnotation.loc.start.line === node.loc.end.line;\n    }\n    /**\n     * To handle index signatures, to get the whole text for the parameters\n     */\n    function getKeyText(node) {\n      if (node.type !== utils_1.AST_NODE_TYPES.TSIndexSignature) {\n        return sourceCode.getText(node.key);\n      }\n      const code = sourceCode.getText(node);\n      return code.slice(0, sourceCode.getTokenAfter(at(node.parameters, -1), util.isClosingBracketToken).range[1] - node.range[0]);\n    }\n    /**\n     * To handle index signatures, be able to get the end position of the parameters\n     */\n    function getKeyLocEnd(node) {\n      return getLastTokenBeforeColon(node.type !== utils_1.AST_NODE_TYPES.TSIndexSignature ? node.key : at(node.parameters, -1)).loc.end;\n    }\n    function checkBeforeColon(node, expectedWhitespaceBeforeColon, mode) {\n      const {\n        typeAnnotation\n      } = node;\n      const colon = typeAnnotation.loc.start.column;\n      const keyEnd = getKeyLocEnd(node);\n      const difference = colon - keyEnd.column - expectedWhitespaceBeforeColon;\n      if (mode === 'strict' ? difference : difference < 0) {\n        context.report({\n          node,\n          messageId: difference > 0 ? 'extraKey' : 'missingKey',\n          fix: fixer => {\n            if (difference > 0) {\n              return fixer.removeRange([typeAnnotation.range[0] - difference, typeAnnotation.range[0]]);\n            } else {\n              return fixer.insertTextBefore(typeAnnotation, ' '.repeat(-difference));\n            }\n          },\n          data: {\n            computed: '',\n            key: getKeyText(node)\n          }\n        });\n      }\n    }\n    function checkAfterColon(node, expectedWhitespaceAfterColon, mode) {\n      const {\n        typeAnnotation\n      } = node;\n      const colon = typeAnnotation.loc.start.column;\n      const typeStart = typeAnnotation.typeAnnotation.loc.start.column;\n      const difference = typeStart - colon - 1 - expectedWhitespaceAfterColon;\n      if (mode === 'strict' ? difference : difference < 0) {\n        context.report({\n          node,\n          messageId: difference > 0 ? 'extraValue' : 'missingValue',\n          fix: fixer => {\n            if (difference > 0) {\n              return fixer.removeRange([typeAnnotation.typeAnnotation.range[0] - difference, typeAnnotation.typeAnnotation.range[0]]);\n            } else {\n              return fixer.insertTextBefore(typeAnnotation.typeAnnotation, ' '.repeat(-difference));\n            }\n          },\n          data: {\n            computed: '',\n            key: getKeyText(node)\n          }\n        });\n      }\n    }\n    // adapted from  https://github.com/eslint/eslint/blob/ba74253e8bd63e9e163bbee0540031be77e39253/lib/rules/key-spacing.js#L356\n    function continuesAlignGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line;\n      const candidateValueStartLine = (isKeyTypeNode(candidate) ? candidate.typeAnnotation : candidate).loc.start.line;\n      if (candidateValueStartLine === groupEndLine) {\n        return false;\n      }\n      if (candidateValueStartLine - groupEndLine === 1) {\n        return true;\n      }\n      /*\n       * Check that the first comment is adjacent to the end of the group, the\n       * last comment is adjacent to the candidate property, and that successive\n       * comments are adjacent to each other.\n       */\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - at(leadingComments, -1).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n    function checkAlignGroup(group) {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      let alignColumn = 0;\n      const align = (_d = typeof options.align === 'object' ? options.align.on : typeof ((_a = options.multiLine) === null || _a === void 0 ? void 0 : _a.align) === 'object' ? options.multiLine.align.on : (_c = (_b = options.multiLine) === null || _b === void 0 ? void 0 : _b.align) !== null && _c !== void 0 ? _c : options.align) !== null && _d !== void 0 ? _d : 'colon';\n      const beforeColon = (_e = typeof options.align === 'object' ? options.align.beforeColon : options.multiLine ? typeof options.multiLine.align === 'object' ? options.multiLine.align.beforeColon : options.multiLine.beforeColon : options.beforeColon) !== null && _e !== void 0 ? _e : false;\n      const expectedWhitespaceBeforeColon = beforeColon ? 1 : 0;\n      const afterColon = (_f = typeof options.align === 'object' ? options.align.afterColon : options.multiLine ? typeof options.multiLine.align === 'object' ? options.multiLine.align.afterColon : options.multiLine.afterColon : options.afterColon) !== null && _f !== void 0 ? _f : true;\n      const expectedWhitespaceAfterColon = afterColon ? 1 : 0;\n      const mode = (_h = typeof options.align === 'object' ? options.align.mode : options.multiLine ? typeof options.multiLine.align === 'object' ?\n      // same behavior as in original rule\n      (_g = options.multiLine.align.mode) !== null && _g !== void 0 ? _g : options.multiLine.mode : options.multiLine.mode : options.mode) !== null && _h !== void 0 ? _h : 'strict';\n      for (const node of group) {\n        if (isKeyTypeNode(node)) {\n          const keyEnd = adjustedColumn(getKeyLocEnd(node));\n          alignColumn = Math.max(alignColumn, align === 'colon' ? keyEnd + expectedWhitespaceBeforeColon : keyEnd + ':'.length + expectedWhitespaceAfterColon + expectedWhitespaceBeforeColon);\n        }\n      }\n      for (const node of group) {\n        if (!isApplicable(node)) {\n          continue;\n        }\n        const {\n          typeAnnotation\n        } = node;\n        const toCheck = align === 'colon' ? typeAnnotation : typeAnnotation.typeAnnotation;\n        const difference = adjustedColumn(toCheck.loc.start) - alignColumn;\n        if (difference) {\n          context.report({\n            node,\n            messageId: difference > 0 ? align === 'colon' ? 'extraKey' : 'extraValue' : align === 'colon' ? 'missingKey' : 'missingValue',\n            fix: fixer => {\n              if (difference > 0) {\n                return fixer.removeRange([toCheck.range[0] - difference, toCheck.range[0]]);\n              } else {\n                return fixer.insertTextBefore(toCheck, ' '.repeat(-difference));\n              }\n            },\n            data: {\n              computed: '',\n              key: getKeyText(node)\n            }\n          });\n        }\n        if (align === 'colon') {\n          checkAfterColon(node, expectedWhitespaceAfterColon, mode);\n        } else {\n          checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);\n        }\n      }\n    }\n    function checkIndividualNode(node, {\n      singleLine\n    }) {\n      var _a, _b, _c;\n      const beforeColon = (_a = singleLine ? options.singleLine ? options.singleLine.beforeColon : options.beforeColon : options.multiLine ? options.multiLine.beforeColon : options.beforeColon) !== null && _a !== void 0 ? _a : false;\n      const expectedWhitespaceBeforeColon = beforeColon ? 1 : 0;\n      const afterColon = (_b = singleLine ? options.singleLine ? options.singleLine.afterColon : options.afterColon : options.multiLine ? options.multiLine.afterColon : options.afterColon) !== null && _b !== void 0 ? _b : true;\n      const expectedWhitespaceAfterColon = afterColon ? 1 : 0;\n      const mode = (_c = singleLine ? options.singleLine ? options.singleLine.mode : options.mode : options.multiLine ? options.multiLine.mode : options.mode) !== null && _c !== void 0 ? _c : 'strict';\n      if (isApplicable(node)) {\n        checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);\n        checkAfterColon(node, expectedWhitespaceAfterColon, mode);\n      }\n    }\n    function validateBody(body) {\n      var _a;\n      const isSingleLine = body.loc.start.line === body.loc.end.line;\n      const members = body.type === utils_1.AST_NODE_TYPES.TSTypeLiteral ? body.members : body.body;\n      let alignGroups = [];\n      let unalignedElements = [];\n      if (options.align || ((_a = options.multiLine) === null || _a === void 0 ? void 0 : _a.align)) {\n        let currentAlignGroup = [];\n        alignGroups.push(currentAlignGroup);\n        let prevNode = undefined;\n        for (const node of members) {\n          let prevAlignedNode = at(currentAlignGroup, -1);\n          if (prevAlignedNode !== prevNode) {\n            prevAlignedNode = undefined;\n          }\n          if (prevAlignedNode && continuesAlignGroup(prevAlignedNode, node)) {\n            currentAlignGroup.push(node);\n          } else if ((prevNode === null || prevNode === void 0 ? void 0 : prevNode.loc.start.line) === node.loc.start.line) {\n            if (prevAlignedNode) {\n              // Here, prevNode === prevAlignedNode === currentAlignGroup.at(-1)\n              unalignedElements.push(prevAlignedNode);\n              currentAlignGroup.pop();\n            }\n            unalignedElements.push(node);\n          } else {\n            currentAlignGroup = [node];\n            alignGroups.push(currentAlignGroup);\n          }\n          prevNode = node;\n        }\n        unalignedElements = unalignedElements.concat(...alignGroups.filter(group => group.length === 1));\n        alignGroups = alignGroups.filter(group => group.length >= 2);\n      } else {\n        unalignedElements = members;\n      }\n      for (const group of alignGroups) {\n        checkAlignGroup(group);\n      }\n      for (const node of unalignedElements) {\n        checkIndividualNode(node, {\n          singleLine: isSingleLine\n        });\n      }\n    }\n    return Object.assign(Object.assign({}, baseRules), {\n      TSTypeLiteral: validateBody,\n      TSInterfaceBody: validateBody,\n      ClassBody: validateBody\n    });\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","getESLintCoreRule_1","baseRule","getESLintCoreRule","baseSchema","Array","isArray","meta","schema","at","arr","position","length","exports","default","createRule","name","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","messages","defaultOptions","create","context","options","sourceCode","getSourceCode","baseRules","adjustedColumn","line","getStringLength","lines","slice","column","getLastTokenBeforeColon","node","colonToken","getTokenAfter","isColonToken","getTokenBefore","isKeyTypeNode","AST_NODE_TYPES","TSPropertySignature","TSIndexSignature","PropertyDefinition","typeAnnotation","isApplicable","loc","start","end","getKeyText","getText","key","code","parameters","isClosingBracketToken","range","getKeyLocEnd","checkBeforeColon","expectedWhitespaceBeforeColon","mode","colon","keyEnd","difference","report","messageId","fix","fixer","removeRange","insertTextBefore","repeat","data","computed","checkAfterColon","expectedWhitespaceAfterColon","typeStart","continuesAlignGroup","lastMember","candidate","groupEndLine","candidateValueStartLine","leadingComments","getCommentsBefore","i","checkAlignGroup","group","alignColumn","align","_d","on","_a","multiLine","_c","_b","beforeColon","_e","afterColon","_f","_h","_g","Math","max","toCheck","checkIndividualNode","singleLine","validateBody","body","isSingleLine","members","TSTypeLiteral","alignGroups","unalignedElements","currentAlignGroup","push","prevNode","undefined","prevAlignedNode","pop","concat","filter","Object","assign","TSInterfaceBody","ClassBody"],"sources":["../../src/rules/key-spacing.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}