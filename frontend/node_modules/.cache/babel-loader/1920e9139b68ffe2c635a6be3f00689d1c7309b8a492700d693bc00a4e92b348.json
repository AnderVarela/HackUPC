{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nvar tslib_1 = require(\"tslib\");\nvar error_1 = require(\"./error\");\nvar types_1 = require(\"./types\");\nvar regex_generated_1 = require(\"./regex.generated\");\nvar icu_skeleton_parser_1 = require(\"@formatjs/icu-skeleton-parser\");\nvar date_time_pattern_generator_1 = require(\"./date-time-pattern-generator\");\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, \"*$\"));\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith && '_a'.startsWith('a', 1);\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n};\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\n   * legacy Edge or Xbox One browser\n   * Unicode flag support: supported\n   * Pattern_Syntax support: not supported\n   * See https://github.com/formatjs/formatjs/issues/2822\n   */\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith ?\n// Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} :\n// For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint :\n// IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n  return elements;\n};\nvar fromEntries =\n// native\nhasNativeFromEntries ? Object.fromEntries :\n// Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n      k = _a[0],\n      v = _a[1];\n    obj[k] = v;\n  }\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ?\n// Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} :\n// IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ?\n// Native\nfunction trimStart(s) {\n  return s.trimStart();\n} :\n// Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ?\n// Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} :\n// Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n};\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n    while (true) {\n      var c = codePointAt(s, index);\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n    return fromCodePoint.apply(void 0, match);\n  };\n}\nvar Parser = /** @class */function () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.locale = options.locale;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n    return this.parseMessage(0, '', false);\n  };\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n    while (!this.isEOF()) {\n      var char = this.char();\n      if (char === 123 /* `{` */) {\n        var result = this.parseArgument(nestingLevel, expectingCloseTag);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      } else if (char === 125 /* `}` */ && nestingLevel > 0) {\n        break;\n      } else if (char === 35 /* `#` */ && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: types_1.TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60 /* `<` */ && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n        if (expectingCloseTag) {\n          break;\n        } else {\n          return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n      } else if (char === 60 /* `<` */ && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n        if (result.err) {\n          return result;\n        }\n        elements.push(result.val);\n      }\n    }\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n   * are accepted:\n   *\n   * ```\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n   * tagName ::= [a-z] (PENChar)*\n   * PENChar ::=\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n   * ```\n   *\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n   * since other tag-based engines like React allow it\n   */\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: types_1.TYPE.literal,\n          value: \"<\".concat(tagName, \"/>\"),\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n      var children = childrenResult.val;\n      // Expecting a close tag\n      var endTagStartPosition = this.clonePosition();\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n        if (tagName !== closingTagName) {\n          return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (!this.bumpIf('>')) {\n          return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n        return {\n          val: {\n            type: types_1.TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(error_1.ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\n   * This method assumes that the caller has peeked ahead for the first tag character.\n   */\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n    return this.message.slice(startOffset, this.offset());\n  };\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n      break;\n    }\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: types_1.TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60 /* `<` */ && (this.ignoreTag ||\n    // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n      return '<';\n    }\n    return null;\n  };\n  /**\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n   */\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39 /* `'` */) {\n      return null;\n    }\n    // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n    switch (this.peek()) {\n      case 39 /* `'` */:\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n        return null;\n      default:\n        return null;\n    }\n    this.bump(); // apostrophe\n    var codePoints = [this.char()]; // escaped char\n    this.bump();\n    // read chars until the optional closing apostrophe is found\n    while (!this.isEOF()) {\n      var ch = this.char();\n      if (ch === 39 /* `'` */) {\n        if (this.peek() === 39 /* `'` */) {\n          codePoints.push(39);\n          // Bump one more time because we need to skip 2 characters.\n          this.bump();\n        } else {\n          // Optional closing apostrophe.\n          this.bump();\n          break;\n        }\n      } else {\n        codePoints.push(ch);\n      }\n      this.bump();\n    }\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n    var ch = this.char();\n    if (ch === 60 /* `<` */ || ch === 123 /* `{` */ || ch === 35 /* `#` */ && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125 /* `}` */ && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n    this.bumpSpace();\n    if (this.isEOF()) {\n      return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    if (this.char() === 125 /* `}` */) {\n      this.bump();\n      return this.error(error_1.ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    // argument name\n    var value = this.parseIdentifierIfPossible().value;\n    if (!value) {\n      return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    this.bumpSpace();\n    if (this.isEOF()) {\n      return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125 /* `}` */:\n        {\n          this.bump(); // `}`\n          return {\n            val: {\n              type: types_1.TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n      case 44 /* `,` */:\n        {\n          this.bump(); // `,`\n          this.bumpSpace();\n          if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n      default:\n        return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\n   * Advance the parser until the end of the identifier, if it is currently on\n   * an identifier character. Return an empty string otherwise.\n   */\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a;\n    // Parse this range:\n    // {name, type, style}\n    //        ^---^\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n            if (result.err) {\n              return result;\n            }\n            var style = trimEnd(result.val);\n            if (style.length === 0) {\n              return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n          var location_1 = createLocation(openingBracePosition, this.clonePosition());\n          // Extract style or skeleton\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n              if (result.err) {\n                return result;\n              }\n              return {\n                val: {\n                  type: types_1.TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(error_1.ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n              var dateTimePattern = skeleton;\n              // Get \"best match\" pattern only if locale is passed, if not, let it\n              // pass as-is where `parseDateTimeSkeleton()` will throw an error\n              // for unsupported patterns.\n              if (this.locale) {\n                dateTimePattern = (0, date_time_pattern_generator_1.getBestPattern)(skeleton, this.locale);\n              }\n              var style = {\n                type: types_1.SKELETON_TYPE.dateTime,\n                pattern: dateTimePattern,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? (0, icu_skeleton_parser_1.parseDateTimeSkeleton)(dateTimePattern) : {}\n              };\n              var type = argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          }\n          // Regular style or no style.\n          return {\n            val: {\n              type: argType === 'number' ? types_1.TYPE.number : argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n          if (!this.bumpIf(',')) {\n            return this.error(error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, tslib_1.__assign({}, typeEndPosition_1)));\n          }\n          this.bumpSpace();\n          // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n            if (result.err) {\n              return result;\n            }\n            // Parse another identifier for option parsing\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n          if (argType === 'select') {\n            return {\n              val: {\n                type: types_1.TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: types_1.TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n      default:\n        return this.error(error_1.ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125 /* `}` */) {\n      return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n    this.bump(); // `}`\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n   */\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n    while (!this.isEOF()) {\n      var ch = this.char();\n      switch (ch) {\n        case 39 /* `'` */:\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(error_1.ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n            this.bump();\n            break;\n          }\n        case 123 /* `{` */:\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n        case 125 /* `}` */:\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n            break;\n          }\n        default:\n          this.bump();\n          break;\n      }\n    }\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n    try {\n      tokens = (0, icu_skeleton_parser_1.parseNumberSkeletonFromString)(skeleton);\n    } catch (e) {\n      return this.error(error_1.ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n    return {\n      val: {\n        type: types_1.SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? (0, icu_skeleton_parser_1.parseNumberSkeleton)(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\n   * @param nesting_level The current nesting level of messages.\n   *     This can be positive when parsing message fragment in select or plural argument options.\n   * @param parent_arg_type The parent argument's type.\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n   *     the argument. It is a by-product of a previous parsing attempt.\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\n   *     the closing tag boundary.\n   */\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n      selectorLocation = parsedFirstIdentifier.location;\n    // Parse:\n    // one {one apple}\n    // ^--^\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n          if (result.err) {\n            return result;\n          }\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      }\n      // Duplicate selector clauses\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? error_1.ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : error_1.ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n      if (selector === 'other') {\n        hasOtherClause = true;\n      }\n      // Parse:\n      // one {one apple}\n      //     ^----------^\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]);\n      // Keep track of the existing selectors\n      parsedSelectors.add(selector);\n      // Prep next selector clause.\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(error_1.ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n    return {\n      val: options,\n      err: null\n    };\n  };\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n    var hasDigits = false;\n    var decimal = 0;\n    while (!this.isEOF()) {\n      var ch = this.char();\n      if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n        hasDigits = true;\n        decimal = decimal * 10 + (ch - 48);\n        this.bump();\n      } else {\n        break;\n      }\n    }\n    var location = createLocation(startingPosition, this.clonePosition());\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n    decimal *= sign;\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\n   * Return the code point at the current position of the parser.\n   * Throws if the index is out of bound.\n   */\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n    var code = codePointAt(this.message, offset);\n    if (code === undefined) {\n      throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n    }\n    return code;\n  };\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n    var code = this.char();\n    if (code === 10 /* '\\n' */) {\n      this.position.line += 1;\n      this.position.column = 1;\n      this.position.offset += 1;\n    } else {\n      this.position.column += 1;\n      // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\n   * If the substring starting at the current position of the parser has\n   * the given prefix, then bump the parser to the character immediately\n   * following the prefix and return true. Otherwise, don't bump the parser\n   * and return false.\n   */\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Bump the parser until the pattern character is found and return `true`.\n   * Otherwise bump to the end of the file and return `false`.\n   */\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\n   * Bump the parser to the target offset.\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\n   */\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n    }\n    targetOffset = Math.min(targetOffset, this.message.length);\n    while (true) {\n      var offset = this.offset();\n      if (offset === targetOffset) {\n        break;\n      }\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n      }\n      this.bump();\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n   * If the input has been exhausted, then this returns null.\n   */\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n  return Parser;\n}();\nexports.Parser = Parser;\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n  return c === 45 /* '-' */ || c === 46 /* '.' */ || c >= 48 && c <= 57 /* 0..9 */ || c === 95 /* '_' */ || c >= 97 && c <= 122 /** a..z */ || c >= 65 && c <= 90 /* A..Z */ || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","Parser","tslib_1","require","error_1","types_1","regex_generated_1","icu_skeleton_parser_1","date_time_pattern_generator_1","SPACE_SEPARATOR_START_REGEX","RegExp","concat","SPACE_SEPARATOR_REGEX","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","re","RE","exec","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","undefined","first","charCodeAt","second","replace","flag","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","_isWhiteSpace","_isPatternSyntax","push","apply","message","options","offset","line","column","ignoreTag","locale","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","TYPE","pound","location","peek","error","ErrorKind","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","parseNumberSkeletonFromString","number","EXPECT_DATE_TIME_SKELETON","dateTimePattern","getBestPattern","SKELETON_TYPE","dateTime","pattern","parsedOptions","parseDateTimeSkeleton","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","__assign","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","parseNumberSkeleton","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@formatjs/icu-messageformat-parser/parser.js"],"sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nvar tslib_1 = require(\"tslib\");\nvar error_1 = require(\"./error\");\nvar types_1 = require(\"./types\");\nvar regex_generated_1 = require(\"./regex.generated\");\nvar icu_skeleton_parser_1 = require(\"@formatjs/icu-skeleton-parser\");\nvar date_time_pattern_generator_1 = require(\"./date-time-pattern-generator\");\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, \"*$\"));\nfunction createLocation(start, end) {\n    return { start: start, end: end };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith && '_a'.startsWith('a', 1);\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger\n    ? Number.isSafeInteger\n    : function (n) {\n        return (typeof n === 'number' &&\n            isFinite(n) &&\n            Math.floor(n) === n &&\n            Math.abs(n) <= 0x1fffffffffffff);\n    };\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    /**\n     * legacy Edge or Xbox One browser\n     * Unicode flag support: supported\n     * Pattern_Syntax support: not supported\n     * See https://github.com/formatjs/formatjs/issues/2822\n     */\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n}\ncatch (_) {\n    REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith\n    ? // Native\n        function startsWith(s, search, position) {\n            return s.startsWith(search, position);\n        }\n    : // For IE11\n        function startsWith(s, search, position) {\n            return s.slice(position, position + search.length) === search;\n        };\nvar fromCodePoint = hasNativeFromCodePoint\n    ? String.fromCodePoint\n    : // IE11\n        function fromCodePoint() {\n            var codePoints = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                codePoints[_i] = arguments[_i];\n            }\n            var elements = '';\n            var length = codePoints.length;\n            var i = 0;\n            var code;\n            while (length > i) {\n                code = codePoints[i++];\n                if (code > 0x10ffff)\n                    throw RangeError(code + ' is not a valid code point');\n                elements +=\n                    code < 0x10000\n                        ? String.fromCharCode(code)\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\n            }\n            return elements;\n        };\nvar fromEntries = \n// native\nhasNativeFromEntries\n    ? Object.fromEntries\n    : // Ponyfill\n        function fromEntries(entries) {\n            var obj = {};\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                obj[k] = v;\n            }\n            return obj;\n        };\nvar codePointAt = hasNativeCodePointAt\n    ? // Native\n        function codePointAt(s, index) {\n            return s.codePointAt(index);\n        }\n    : // IE 11\n        function codePointAt(s, index) {\n            var size = s.length;\n            if (index < 0 || index >= size) {\n                return undefined;\n            }\n            var first = s.charCodeAt(index);\n            var second;\n            return first < 0xd800 ||\n                first > 0xdbff ||\n                index + 1 === size ||\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\n                second > 0xdfff\n                ? first\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\n        };\nvar trimStart = hasTrimStart\n    ? // Native\n        function trimStart(s) {\n            return s.trimStart();\n        }\n    : // Ponyfill\n        function trimStart(s) {\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n        };\nvar trimEnd = hasTrimEnd\n    ? // Native\n        function trimEnd(s) {\n            return s.trimEnd();\n        }\n    : // Ponyfill\n        function trimEnd(s) {\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n        };\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n    return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n    // Native\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var _a;\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n    };\n}\nelse {\n    // IE11\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var match = [];\n        while (true) {\n            var c = codePointAt(s, index);\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n                break;\n            }\n            match.push(c);\n            index += c >= 0x10000 ? 2 : 1;\n        }\n        return fromCodePoint.apply(void 0, match);\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(message, options) {\n        if (options === void 0) { options = {}; }\n        this.message = message;\n        this.position = { offset: 0, line: 1, column: 1 };\n        this.ignoreTag = !!options.ignoreTag;\n        this.locale = options.locale;\n        this.requiresOtherClause = !!options.requiresOtherClause;\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n    }\n    Parser.prototype.parse = function () {\n        if (this.offset() !== 0) {\n            throw Error('parser can only be used once');\n        }\n        return this.parseMessage(0, '', false);\n    };\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n        var elements = [];\n        while (!this.isEOF()) {\n            var char = this.char();\n            if (char === 123 /* `{` */) {\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\n                break;\n            }\n            else if (char === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n                var position = this.clonePosition();\n                this.bump();\n                elements.push({\n                    type: types_1.TYPE.pound,\n                    location: createLocation(position, this.clonePosition()),\n                });\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                this.peek() === 47 // char code for '/'\n            ) {\n                if (expectingCloseTag) {\n                    break;\n                }\n                else {\n                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n                }\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                _isAlpha(this.peek() || 0)) {\n                var result = this.parseTag(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else {\n                var result = this.parseLiteral(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n        }\n        return { val: elements, err: null };\n    };\n    /**\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n     * are accepted:\n     *\n     * ```\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n     * tagName ::= [a-z] (PENChar)*\n     * PENChar ::=\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n     * ```\n     *\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n     * since other tag-based engines like React allow it\n     */\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n        var startPosition = this.clonePosition();\n        this.bump(); // `<`\n        var tagName = this.parseTagName();\n        this.bumpSpace();\n        if (this.bumpIf('/>')) {\n            // Self closing tag\n            return {\n                val: {\n                    type: types_1.TYPE.literal,\n                    value: \"<\".concat(tagName, \"/>\"),\n                    location: createLocation(startPosition, this.clonePosition()),\n                },\n                err: null,\n            };\n        }\n        else if (this.bumpIf('>')) {\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n            if (childrenResult.err) {\n                return childrenResult;\n            }\n            var children = childrenResult.val;\n            // Expecting a close tag\n            var endTagStartPosition = this.clonePosition();\n            if (this.bumpIf('</')) {\n                if (this.isEOF() || !_isAlpha(this.char())) {\n                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                var closingTagNameStartPosition = this.clonePosition();\n                var closingTagName = this.parseTagName();\n                if (tagName !== closingTagName) {\n                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n                }\n                this.bumpSpace();\n                if (!this.bumpIf('>')) {\n                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                return {\n                    val: {\n                        type: types_1.TYPE.tag,\n                        value: tagName,\n                        children: children,\n                        location: createLocation(startPosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            else {\n                return this.error(error_1.ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n            }\n        }\n        else {\n            return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n        }\n    };\n    /**\n     * This method assumes that the caller has peeked ahead for the first tag character.\n     */\n    Parser.prototype.parseTagName = function () {\n        var startOffset = this.offset();\n        this.bump(); // the first tag name character\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n            this.bump();\n        }\n        return this.message.slice(startOffset, this.offset());\n    };\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n        var start = this.clonePosition();\n        var value = '';\n        while (true) {\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\n            if (parseQuoteResult) {\n                value += parseQuoteResult;\n                continue;\n            }\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n            if (parseUnquotedResult) {\n                value += parseUnquotedResult;\n                continue;\n            }\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n            if (parseLeftAngleResult) {\n                value += parseLeftAngleResult;\n                continue;\n            }\n            break;\n        }\n        var location = createLocation(start, this.clonePosition());\n        return {\n            val: { type: types_1.TYPE.literal, value: value, location: location },\n            err: null,\n        };\n    };\n    Parser.prototype.tryParseLeftAngleBracket = function () {\n        if (!this.isEOF() &&\n            this.char() === 60 /* `<` */ &&\n            (this.ignoreTag ||\n                // If at the opening tag or closing tag position, bail.\n                !_isAlphaOrSlash(this.peek() || 0))) {\n            this.bump(); // `<`\n            return '<';\n        }\n        return null;\n    };\n    /**\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n     */\n    Parser.prototype.tryParseQuote = function (parentArgType) {\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\n            return null;\n        }\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n        // Check if is valid escaped character\n        switch (this.peek()) {\n            case 39 /* `'` */:\n                // double quote, should return as a single quote.\n                this.bump();\n                this.bump();\n                return \"'\";\n            // '{', '<', '>', '}'\n            case 123:\n            case 60:\n            case 62:\n            case 125:\n                break;\n            case 35: // '#'\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n                    break;\n                }\n                return null;\n            default:\n                return null;\n        }\n        this.bump(); // apostrophe\n        var codePoints = [this.char()]; // escaped char\n        this.bump();\n        // read chars until the optional closing apostrophe is found\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch === 39 /* `'` */) {\n                if (this.peek() === 39 /* `'` */) {\n                    codePoints.push(39);\n                    // Bump one more time because we need to skip 2 characters.\n                    this.bump();\n                }\n                else {\n                    // Optional closing apostrophe.\n                    this.bump();\n                    break;\n                }\n            }\n            else {\n                codePoints.push(ch);\n            }\n            this.bump();\n        }\n        return fromCodePoint.apply(void 0, codePoints);\n    };\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n        if (this.isEOF()) {\n            return null;\n        }\n        var ch = this.char();\n        if (ch === 60 /* `<` */ ||\n            ch === 123 /* `{` */ ||\n            (ch === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\n            return null;\n        }\n        else {\n            this.bump();\n            return fromCodePoint(ch);\n        }\n    };\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n        var openingBracePosition = this.clonePosition();\n        this.bump(); // `{`\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        if (this.char() === 125 /* `}` */) {\n            this.bump();\n            return this.error(error_1.ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        // argument name\n        var value = this.parseIdentifierIfPossible().value;\n        if (!value) {\n            return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        switch (this.char()) {\n            // Simple argument: `{name}`\n            case 125 /* `}` */: {\n                this.bump(); // `}`\n                return {\n                    val: {\n                        type: types_1.TYPE.argument,\n                        // value does not include the opening and closing braces.\n                        value: value,\n                        location: createLocation(openingBracePosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            // Argument with options: `{name, format, ...}`\n            case 44 /* `,` */: {\n                this.bump(); // `,`\n                this.bumpSpace();\n                if (this.isEOF()) {\n                    return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n                }\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n            }\n            default:\n                return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n    };\n    /**\n     * Advance the parser until the end of the identifier, if it is currently on\n     * an identifier character. Return an empty string otherwise.\n     */\n    Parser.prototype.parseIdentifierIfPossible = function () {\n        var startingPosition = this.clonePosition();\n        var startOffset = this.offset();\n        var value = matchIdentifierAtIndex(this.message, startOffset);\n        var endOffset = startOffset + value.length;\n        this.bumpTo(endOffset);\n        var endPosition = this.clonePosition();\n        var location = createLocation(startingPosition, endPosition);\n        return { value: value, location: location };\n    };\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n        var _a;\n        // Parse this range:\n        // {name, type, style}\n        //        ^---^\n        var typeStartPosition = this.clonePosition();\n        var argType = this.parseIdentifierIfPossible().value;\n        var typeEndPosition = this.clonePosition();\n        switch (argType) {\n            case '':\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\n                return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n            case 'number':\n            case 'date':\n            case 'time': {\n                // Parse this range:\n                // {name, number, style}\n                //              ^-------^\n                this.bumpSpace();\n                var styleAndLocation = null;\n                if (this.bumpIf(',')) {\n                    this.bumpSpace();\n                    var styleStartPosition = this.clonePosition();\n                    var result = this.parseSimpleArgStyleIfPossible();\n                    if (result.err) {\n                        return result;\n                    }\n                    var style = trimEnd(result.val);\n                    if (style.length === 0) {\n                        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\n                // Extract style or skeleton\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n                    // Skeleton starts with `::`.\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\n                    if (argType === 'number') {\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n                        if (result.err) {\n                            return result;\n                        }\n                        return {\n                            val: { type: types_1.TYPE.number, value: value, location: location_1, style: result.val },\n                            err: null,\n                        };\n                    }\n                    else {\n                        if (skeleton.length === 0) {\n                            return this.error(error_1.ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n                        }\n                        var dateTimePattern = skeleton;\n                        // Get \"best match\" pattern only if locale is passed, if not, let it\n                        // pass as-is where `parseDateTimeSkeleton()` will throw an error\n                        // for unsupported patterns.\n                        if (this.locale) {\n                            dateTimePattern = (0, date_time_pattern_generator_1.getBestPattern)(skeleton, this.locale);\n                        }\n                        var style = {\n                            type: types_1.SKELETON_TYPE.dateTime,\n                            pattern: dateTimePattern,\n                            location: styleAndLocation.styleLocation,\n                            parsedOptions: this.shouldParseSkeletons\n                                ? (0, icu_skeleton_parser_1.parseDateTimeSkeleton)(dateTimePattern)\n                                : {},\n                        };\n                        var type = argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time;\n                        return {\n                            val: { type: type, value: value, location: location_1, style: style },\n                            err: null,\n                        };\n                    }\n                }\n                // Regular style or no style.\n                return {\n                    val: {\n                        type: argType === 'number'\n                            ? types_1.TYPE.number\n                            : argType === 'date'\n                                ? types_1.TYPE.date\n                                : types_1.TYPE.time,\n                        value: value,\n                        location: location_1,\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\n                    },\n                    err: null,\n                };\n            }\n            case 'plural':\n            case 'selectordinal':\n            case 'select': {\n                // Parse this range:\n                // {name, plural, options}\n                //              ^---------^\n                var typeEndPosition_1 = this.clonePosition();\n                this.bumpSpace();\n                if (!this.bumpIf(',')) {\n                    return this.error(error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, tslib_1.__assign({}, typeEndPosition_1)));\n                }\n                this.bumpSpace();\n                // Parse offset:\n                // {name, plural, offset:1, options}\n                //                ^-----^\n                //\n                // or the first option:\n                //\n                // {name, plural, one {...} other {...}}\n                //                ^--^\n                var identifierAndLocation = this.parseIdentifierIfPossible();\n                var pluralOffset = 0;\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n                    if (!this.bumpIf(':')) {\n                        return this.error(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    this.bumpSpace();\n                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n                    if (result.err) {\n                        return result;\n                    }\n                    // Parse another identifier for option parsing\n                    this.bumpSpace();\n                    identifierAndLocation = this.parseIdentifierIfPossible();\n                    pluralOffset = result.val;\n                }\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n                if (optionsResult.err) {\n                    return optionsResult;\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\n                if (argType === 'select') {\n                    return {\n                        val: {\n                            type: types_1.TYPE.select,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n                else {\n                    return {\n                        val: {\n                            type: types_1.TYPE.plural,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            offset: pluralOffset,\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n            }\n            default:\n                return this.error(error_1.ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n        }\n    };\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n        // Parse: {value, number, ::currency/GBP }\n        //\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\n            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bump(); // `}`\n        return { val: true, err: null };\n    };\n    /**\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n     */\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n        var nestedBraces = 0;\n        var startPosition = this.clonePosition();\n        while (!this.isEOF()) {\n            var ch = this.char();\n            switch (ch) {\n                case 39 /* `'` */: {\n                    // Treat apostrophe as quoting but include it in the style part.\n                    // Find the end of the quoted literal text.\n                    this.bump();\n                    var apostrophePosition = this.clonePosition();\n                    if (!this.bumpUntil(\"'\")) {\n                        return this.error(error_1.ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n                    }\n                    this.bump();\n                    break;\n                }\n                case 123 /* `{` */: {\n                    nestedBraces += 1;\n                    this.bump();\n                    break;\n                }\n                case 125 /* `}` */: {\n                    if (nestedBraces > 0) {\n                        nestedBraces -= 1;\n                    }\n                    else {\n                        return {\n                            val: this.message.slice(startPosition.offset, this.offset()),\n                            err: null,\n                        };\n                    }\n                    break;\n                }\n                default:\n                    this.bump();\n                    break;\n            }\n        }\n        return {\n            val: this.message.slice(startPosition.offset, this.offset()),\n            err: null,\n        };\n    };\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n        var tokens = [];\n        try {\n            tokens = (0, icu_skeleton_parser_1.parseNumberSkeletonFromString)(skeleton);\n        }\n        catch (e) {\n            return this.error(error_1.ErrorKind.INVALID_NUMBER_SKELETON, location);\n        }\n        return {\n            val: {\n                type: types_1.SKELETON_TYPE.number,\n                tokens: tokens,\n                location: location,\n                parsedOptions: this.shouldParseSkeletons\n                    ? (0, icu_skeleton_parser_1.parseNumberSkeleton)(tokens)\n                    : {},\n            },\n            err: null,\n        };\n    };\n    /**\n     * @param nesting_level The current nesting level of messages.\n     *     This can be positive when parsing message fragment in select or plural argument options.\n     * @param parent_arg_type The parent argument's type.\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n     *     the argument. It is a by-product of a previous parsing attempt.\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\n     *     the closing tag boundary.\n     */\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n        var _a;\n        var hasOtherClause = false;\n        var options = [];\n        var parsedSelectors = new Set();\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\n        // Parse:\n        // one {one apple}\n        // ^--^\n        while (true) {\n            if (selector.length === 0) {\n                var startPosition = this.clonePosition();\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\n                    // Try parse `={number}` selector\n                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n                    if (result.err) {\n                        return result;\n                    }\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\n                    selector = this.message.slice(startPosition.offset, this.offset());\n                }\n                else {\n                    break;\n                }\n            }\n            // Duplicate selector clauses\n            if (parsedSelectors.has(selector)) {\n                return this.error(parentArgType === 'select'\n                    ? error_1.ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\n                    : error_1.ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n            }\n            if (selector === 'other') {\n                hasOtherClause = true;\n            }\n            // Parse:\n            // one {one apple}\n            //     ^----------^\n            this.bumpSpace();\n            var openingBracePosition = this.clonePosition();\n            if (!this.bumpIf('{')) {\n                return this.error(parentArgType === 'select'\n                    ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\n                    : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n            if (fragmentResult.err) {\n                return fragmentResult;\n            }\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n            if (argCloseResult.err) {\n                return argCloseResult;\n            }\n            options.push([\n                selector,\n                {\n                    value: fragmentResult.val,\n                    location: createLocation(openingBracePosition, this.clonePosition()),\n                },\n            ]);\n            // Keep track of the existing selectors\n            parsedSelectors.add(selector);\n            // Prep next selector clause.\n            this.bumpSpace();\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\n        }\n        if (options.length === 0) {\n            return this.error(parentArgType === 'select'\n                ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\n                : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        if (this.requiresOtherClause && !hasOtherClause) {\n            return this.error(error_1.ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        return { val: options, err: null };\n    };\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n        var sign = 1;\n        var startingPosition = this.clonePosition();\n        if (this.bumpIf('+')) {\n        }\n        else if (this.bumpIf('-')) {\n            sign = -1;\n        }\n        var hasDigits = false;\n        var decimal = 0;\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n                hasDigits = true;\n                decimal = decimal * 10 + (ch - 48);\n                this.bump();\n            }\n            else {\n                break;\n            }\n        }\n        var location = createLocation(startingPosition, this.clonePosition());\n        if (!hasDigits) {\n            return this.error(expectNumberError, location);\n        }\n        decimal *= sign;\n        if (!isSafeInteger(decimal)) {\n            return this.error(invalidNumberError, location);\n        }\n        return { val: decimal, err: null };\n    };\n    Parser.prototype.offset = function () {\n        return this.position.offset;\n    };\n    Parser.prototype.isEOF = function () {\n        return this.offset() === this.message.length;\n    };\n    Parser.prototype.clonePosition = function () {\n        // This is much faster than `Object.assign` or spread.\n        return {\n            offset: this.position.offset,\n            line: this.position.line,\n            column: this.position.column,\n        };\n    };\n    /**\n     * Return the code point at the current position of the parser.\n     * Throws if the index is out of bound.\n     */\n    Parser.prototype.char = function () {\n        var offset = this.position.offset;\n        if (offset >= this.message.length) {\n            throw Error('out of bound');\n        }\n        var code = codePointAt(this.message, offset);\n        if (code === undefined) {\n            throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n        }\n        return code;\n    };\n    Parser.prototype.error = function (kind, location) {\n        return {\n            val: null,\n            err: {\n                kind: kind,\n                message: this.message,\n                location: location,\n            },\n        };\n    };\n    /** Bump the parser to the next UTF-16 code unit. */\n    Parser.prototype.bump = function () {\n        if (this.isEOF()) {\n            return;\n        }\n        var code = this.char();\n        if (code === 10 /* '\\n' */) {\n            this.position.line += 1;\n            this.position.column = 1;\n            this.position.offset += 1;\n        }\n        else {\n            this.position.column += 1;\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n            this.position.offset += code < 0x10000 ? 1 : 2;\n        }\n    };\n    /**\n     * If the substring starting at the current position of the parser has\n     * the given prefix, then bump the parser to the character immediately\n     * following the prefix and return true. Otherwise, don't bump the parser\n     * and return false.\n     */\n    Parser.prototype.bumpIf = function (prefix) {\n        if (startsWith(this.message, prefix, this.offset())) {\n            for (var i = 0; i < prefix.length; i++) {\n                this.bump();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Bump the parser until the pattern character is found and return `true`.\n     * Otherwise bump to the end of the file and return `false`.\n     */\n    Parser.prototype.bumpUntil = function (pattern) {\n        var currentOffset = this.offset();\n        var index = this.message.indexOf(pattern, currentOffset);\n        if (index >= 0) {\n            this.bumpTo(index);\n            return true;\n        }\n        else {\n            this.bumpTo(this.message.length);\n            return false;\n        }\n    };\n    /**\n     * Bump the parser to the target offset.\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\n     */\n    Parser.prototype.bumpTo = function (targetOffset) {\n        if (this.offset() > targetOffset) {\n            throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n        }\n        targetOffset = Math.min(targetOffset, this.message.length);\n        while (true) {\n            var offset = this.offset();\n            if (offset === targetOffset) {\n                break;\n            }\n            if (offset > targetOffset) {\n                throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n            }\n            this.bump();\n            if (this.isEOF()) {\n                break;\n            }\n        }\n    };\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\n    Parser.prototype.bumpSpace = function () {\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\n            this.bump();\n        }\n    };\n    /**\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n     * If the input has been exhausted, then this returns null.\n     */\n    Parser.prototype.peek = function () {\n        if (this.isEOF()) {\n            return null;\n        }\n        var code = this.char();\n        var offset = this.offset();\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\nfunction _isAlpha(codepoint) {\n    return ((codepoint >= 97 && codepoint <= 122) ||\n        (codepoint >= 65 && codepoint <= 90));\n}\nfunction _isAlphaOrSlash(codepoint) {\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n    return (c === 45 /* '-' */ ||\n        c === 46 /* '.' */ ||\n        (c >= 48 && c <= 57) /* 0..9 */ ||\n        c === 95 /* '_' */ ||\n        (c >= 97 && c <= 122) /** a..z */ ||\n        (c >= 65 && c <= 90) /* A..Z */ ||\n        c == 0xb7 ||\n        (c >= 0xc0 && c <= 0xd6) ||\n        (c >= 0xd8 && c <= 0xf6) ||\n        (c >= 0xf8 && c <= 0x37d) ||\n        (c >= 0x37f && c <= 0x1fff) ||\n        (c >= 0x200c && c <= 0x200d) ||\n        (c >= 0x203f && c <= 0x2040) ||\n        (c >= 0x2070 && c <= 0x218f) ||\n        (c >= 0x2c00 && c <= 0x2fef) ||\n        (c >= 0x3001 && c <= 0xd7ff) ||\n        (c >= 0xf900 && c <= 0xfdcf) ||\n        (c >= 0xfdf0 && c <= 0xfffd) ||\n        (c >= 0x10000 && c <= 0xeffff));\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isWhiteSpace(c) {\n    return ((c >= 0x0009 && c <= 0x000d) ||\n        c === 0x0020 ||\n        c === 0x0085 ||\n        (c >= 0x200e && c <= 0x200f) ||\n        c === 0x2028 ||\n        c === 0x2029);\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isPatternSyntax(c) {\n    return ((c >= 0x0021 && c <= 0x0023) ||\n        c === 0x0024 ||\n        (c >= 0x0025 && c <= 0x0027) ||\n        c === 0x0028 ||\n        c === 0x0029 ||\n        c === 0x002a ||\n        c === 0x002b ||\n        c === 0x002c ||\n        c === 0x002d ||\n        (c >= 0x002e && c <= 0x002f) ||\n        (c >= 0x003a && c <= 0x003b) ||\n        (c >= 0x003c && c <= 0x003e) ||\n        (c >= 0x003f && c <= 0x0040) ||\n        c === 0x005b ||\n        c === 0x005c ||\n        c === 0x005d ||\n        c === 0x005e ||\n        c === 0x0060 ||\n        c === 0x007b ||\n        c === 0x007c ||\n        c === 0x007d ||\n        c === 0x007e ||\n        c === 0x00a1 ||\n        (c >= 0x00a2 && c <= 0x00a5) ||\n        c === 0x00a6 ||\n        c === 0x00a7 ||\n        c === 0x00a9 ||\n        c === 0x00ab ||\n        c === 0x00ac ||\n        c === 0x00ae ||\n        c === 0x00b0 ||\n        c === 0x00b1 ||\n        c === 0x00b6 ||\n        c === 0x00bb ||\n        c === 0x00bf ||\n        c === 0x00d7 ||\n        c === 0x00f7 ||\n        (c >= 0x2010 && c <= 0x2015) ||\n        (c >= 0x2016 && c <= 0x2017) ||\n        c === 0x2018 ||\n        c === 0x2019 ||\n        c === 0x201a ||\n        (c >= 0x201b && c <= 0x201c) ||\n        c === 0x201d ||\n        c === 0x201e ||\n        c === 0x201f ||\n        (c >= 0x2020 && c <= 0x2027) ||\n        (c >= 0x2030 && c <= 0x2038) ||\n        c === 0x2039 ||\n        c === 0x203a ||\n        (c >= 0x203b && c <= 0x203e) ||\n        (c >= 0x2041 && c <= 0x2043) ||\n        c === 0x2044 ||\n        c === 0x2045 ||\n        c === 0x2046 ||\n        (c >= 0x2047 && c <= 0x2051) ||\n        c === 0x2052 ||\n        c === 0x2053 ||\n        (c >= 0x2055 && c <= 0x205e) ||\n        (c >= 0x2190 && c <= 0x2194) ||\n        (c >= 0x2195 && c <= 0x2199) ||\n        (c >= 0x219a && c <= 0x219b) ||\n        (c >= 0x219c && c <= 0x219f) ||\n        c === 0x21a0 ||\n        (c >= 0x21a1 && c <= 0x21a2) ||\n        c === 0x21a3 ||\n        (c >= 0x21a4 && c <= 0x21a5) ||\n        c === 0x21a6 ||\n        (c >= 0x21a7 && c <= 0x21ad) ||\n        c === 0x21ae ||\n        (c >= 0x21af && c <= 0x21cd) ||\n        (c >= 0x21ce && c <= 0x21cf) ||\n        (c >= 0x21d0 && c <= 0x21d1) ||\n        c === 0x21d2 ||\n        c === 0x21d3 ||\n        c === 0x21d4 ||\n        (c >= 0x21d5 && c <= 0x21f3) ||\n        (c >= 0x21f4 && c <= 0x22ff) ||\n        (c >= 0x2300 && c <= 0x2307) ||\n        c === 0x2308 ||\n        c === 0x2309 ||\n        c === 0x230a ||\n        c === 0x230b ||\n        (c >= 0x230c && c <= 0x231f) ||\n        (c >= 0x2320 && c <= 0x2321) ||\n        (c >= 0x2322 && c <= 0x2328) ||\n        c === 0x2329 ||\n        c === 0x232a ||\n        (c >= 0x232b && c <= 0x237b) ||\n        c === 0x237c ||\n        (c >= 0x237d && c <= 0x239a) ||\n        (c >= 0x239b && c <= 0x23b3) ||\n        (c >= 0x23b4 && c <= 0x23db) ||\n        (c >= 0x23dc && c <= 0x23e1) ||\n        (c >= 0x23e2 && c <= 0x2426) ||\n        (c >= 0x2427 && c <= 0x243f) ||\n        (c >= 0x2440 && c <= 0x244a) ||\n        (c >= 0x244b && c <= 0x245f) ||\n        (c >= 0x2500 && c <= 0x25b6) ||\n        c === 0x25b7 ||\n        (c >= 0x25b8 && c <= 0x25c0) ||\n        c === 0x25c1 ||\n        (c >= 0x25c2 && c <= 0x25f7) ||\n        (c >= 0x25f8 && c <= 0x25ff) ||\n        (c >= 0x2600 && c <= 0x266e) ||\n        c === 0x266f ||\n        (c >= 0x2670 && c <= 0x2767) ||\n        c === 0x2768 ||\n        c === 0x2769 ||\n        c === 0x276a ||\n        c === 0x276b ||\n        c === 0x276c ||\n        c === 0x276d ||\n        c === 0x276e ||\n        c === 0x276f ||\n        c === 0x2770 ||\n        c === 0x2771 ||\n        c === 0x2772 ||\n        c === 0x2773 ||\n        c === 0x2774 ||\n        c === 0x2775 ||\n        (c >= 0x2794 && c <= 0x27bf) ||\n        (c >= 0x27c0 && c <= 0x27c4) ||\n        c === 0x27c5 ||\n        c === 0x27c6 ||\n        (c >= 0x27c7 && c <= 0x27e5) ||\n        c === 0x27e6 ||\n        c === 0x27e7 ||\n        c === 0x27e8 ||\n        c === 0x27e9 ||\n        c === 0x27ea ||\n        c === 0x27eb ||\n        c === 0x27ec ||\n        c === 0x27ed ||\n        c === 0x27ee ||\n        c === 0x27ef ||\n        (c >= 0x27f0 && c <= 0x27ff) ||\n        (c >= 0x2800 && c <= 0x28ff) ||\n        (c >= 0x2900 && c <= 0x2982) ||\n        c === 0x2983 ||\n        c === 0x2984 ||\n        c === 0x2985 ||\n        c === 0x2986 ||\n        c === 0x2987 ||\n        c === 0x2988 ||\n        c === 0x2989 ||\n        c === 0x298a ||\n        c === 0x298b ||\n        c === 0x298c ||\n        c === 0x298d ||\n        c === 0x298e ||\n        c === 0x298f ||\n        c === 0x2990 ||\n        c === 0x2991 ||\n        c === 0x2992 ||\n        c === 0x2993 ||\n        c === 0x2994 ||\n        c === 0x2995 ||\n        c === 0x2996 ||\n        c === 0x2997 ||\n        c === 0x2998 ||\n        (c >= 0x2999 && c <= 0x29d7) ||\n        c === 0x29d8 ||\n        c === 0x29d9 ||\n        c === 0x29da ||\n        c === 0x29db ||\n        (c >= 0x29dc && c <= 0x29fb) ||\n        c === 0x29fc ||\n        c === 0x29fd ||\n        (c >= 0x29fe && c <= 0x2aff) ||\n        (c >= 0x2b00 && c <= 0x2b2f) ||\n        (c >= 0x2b30 && c <= 0x2b44) ||\n        (c >= 0x2b45 && c <= 0x2b46) ||\n        (c >= 0x2b47 && c <= 0x2b4c) ||\n        (c >= 0x2b4d && c <= 0x2b73) ||\n        (c >= 0x2b74 && c <= 0x2b75) ||\n        (c >= 0x2b76 && c <= 0x2b95) ||\n        c === 0x2b96 ||\n        (c >= 0x2b97 && c <= 0x2bff) ||\n        (c >= 0x2e00 && c <= 0x2e01) ||\n        c === 0x2e02 ||\n        c === 0x2e03 ||\n        c === 0x2e04 ||\n        c === 0x2e05 ||\n        (c >= 0x2e06 && c <= 0x2e08) ||\n        c === 0x2e09 ||\n        c === 0x2e0a ||\n        c === 0x2e0b ||\n        c === 0x2e0c ||\n        c === 0x2e0d ||\n        (c >= 0x2e0e && c <= 0x2e16) ||\n        c === 0x2e17 ||\n        (c >= 0x2e18 && c <= 0x2e19) ||\n        c === 0x2e1a ||\n        c === 0x2e1b ||\n        c === 0x2e1c ||\n        c === 0x2e1d ||\n        (c >= 0x2e1e && c <= 0x2e1f) ||\n        c === 0x2e20 ||\n        c === 0x2e21 ||\n        c === 0x2e22 ||\n        c === 0x2e23 ||\n        c === 0x2e24 ||\n        c === 0x2e25 ||\n        c === 0x2e26 ||\n        c === 0x2e27 ||\n        c === 0x2e28 ||\n        c === 0x2e29 ||\n        (c >= 0x2e2a && c <= 0x2e2e) ||\n        c === 0x2e2f ||\n        (c >= 0x2e30 && c <= 0x2e39) ||\n        (c >= 0x2e3a && c <= 0x2e3b) ||\n        (c >= 0x2e3c && c <= 0x2e3f) ||\n        c === 0x2e40 ||\n        c === 0x2e41 ||\n        c === 0x2e42 ||\n        (c >= 0x2e43 && c <= 0x2e4f) ||\n        (c >= 0x2e50 && c <= 0x2e51) ||\n        c === 0x2e52 ||\n        (c >= 0x2e53 && c <= 0x2e7f) ||\n        (c >= 0x3001 && c <= 0x3003) ||\n        c === 0x3008 ||\n        c === 0x3009 ||\n        c === 0x300a ||\n        c === 0x300b ||\n        c === 0x300c ||\n        c === 0x300d ||\n        c === 0x300e ||\n        c === 0x300f ||\n        c === 0x3010 ||\n        c === 0x3011 ||\n        (c >= 0x3012 && c <= 0x3013) ||\n        c === 0x3014 ||\n        c === 0x3015 ||\n        c === 0x3016 ||\n        c === 0x3017 ||\n        c === 0x3018 ||\n        c === 0x3019 ||\n        c === 0x301a ||\n        c === 0x301b ||\n        c === 0x301c ||\n        c === 0x301d ||\n        (c >= 0x301e && c <= 0x301f) ||\n        c === 0x3020 ||\n        c === 0x3030 ||\n        c === 0xfd3e ||\n        c === 0xfd3f ||\n        (c >= 0xfe45 && c <= 0xfe46));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}