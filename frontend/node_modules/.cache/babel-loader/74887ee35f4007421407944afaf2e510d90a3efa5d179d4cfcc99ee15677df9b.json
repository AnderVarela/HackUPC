{"ast":null,"code":"import { deepNormalizeScriptCov, normalizeFunctionCov, normalizeProcessCov, normalizeRangeTree, normalizeScriptCov } from \"./normalize\";\nimport { RangeTree } from \"./range-tree\";\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\nexport function mergeProcessCovs(processCovs) {\n  if (processCovs.length === 0) {\n    return {\n      result: []\n    };\n  }\n  const urlToScripts = new Map();\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs = urlToScripts.get(scriptCov.url);\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n      scriptCovs.push(scriptCov);\n    }\n  }\n  const result = [];\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts));\n  }\n  const merged = {\n    result\n  };\n  normalizeProcessCov(merged);\n  return merged;\n}\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\nexport function mergeScriptCovs(scriptCovs) {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged = scriptCovs[0];\n    deepNormalizeScriptCov(merged);\n    return merged;\n  }\n  const first = scriptCovs[0];\n  const scriptId = first.scriptId;\n  const url = first.url;\n  const rangeToFuncs = new Map();\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange = stringifyFunctionRootRange(funcCov);\n      let funcCovs = rangeToFuncs.get(rootRange);\n      if (funcCovs === undefined ||\n      // if the entry in rangeToFuncs is function-level granularity and\n      // the new coverage is block-level, prefer block-level.\n      !funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n      funcCovs.push(funcCov);\n    }\n  }\n  const functions = [];\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs));\n  }\n  const merged = {\n    scriptId,\n    url,\n    functions\n  };\n  normalizeScriptCov(merged);\n  return merged;\n}\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\nfunction stringifyFunctionRootRange(funcCov) {\n  const rootRange = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\nexport function mergeFunctionCovs(funcCovs) {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged = funcCovs[0];\n    normalizeFunctionCov(merged);\n    return merged;\n  }\n  const functionName = funcCovs[0].functionName;\n  const trees = [];\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(RangeTree.fromSortedRanges(funcCov.ranges));\n  }\n  // assert: `trees.length > 0`\n  const mergedTree = mergeRangeTrees(trees);\n  normalizeRangeTree(mergedTree);\n  const ranges = mergedTree.toRanges();\n  const isBlockCoverage = !(ranges.length === 1 && ranges[0].count === 0);\n  const merged = {\n    functionName,\n    ranges,\n    isBlockCoverage\n  };\n  // assert: `merged` is normalized\n  return merged;\n}\n/**\n * @precondition Same `start` and `end` for all the trees\n */\nfunction mergeRangeTrees(trees) {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n  const first = trees[0];\n  let delta = 0;\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n  const children = mergeRangeTreeChildren(trees);\n  return new RangeTree(first.start, first.end, delta, children);\n}\nclass RangeTreeWithParent {\n  constructor(parentIndex, tree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n}\nclass StartEvent {\n  constructor(offset, trees) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n  static compare(a, b) {\n    return a.offset - b.offset;\n  }\n}\nclass StartEventQueue {\n  constructor(queue) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n  static fromParentTrees(parentTrees) {\n    const startToTrees = new Map();\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees = startToTrees.get(child.start);\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n    const queue = [];\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n  setPendingOffset(offset) {\n    this.pendingOffset = offset;\n  }\n  pushPendingTree(tree) {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n    this.pendingTrees.push(tree);\n  }\n  next() {\n    const pendingTrees = this.pendingTrees;\n    const nextEvent = this.queue[this.nextIndex];\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n}\nfunction mergeRangeTreeChildren(parentTrees) {\n  const result = [];\n  const startEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested = new Map();\n  let openRange;\n  while (true) {\n    const event = startEventQueue.next();\n    if (event === undefined) {\n      break;\n    }\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n    if (openRange === undefined) {\n      let openRangeEnd = event.offset + 1;\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {\n        start: event.offset,\n        end: openRangeEnd\n      };\n    } else {\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        if (tree.end > openRange.end) {\n          const right = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n  return result;\n}\nfunction insertChild(parentToNested, parentIndex, tree) {\n  let nested = parentToNested.get(parentIndex);\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n  nested.push(tree);\n}\nfunction nextChild(openRange, parentToNested) {\n  const matchingTrees = [];\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new RangeTree(openRange.start, openRange.end, 0, nested));\n    }\n  }\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees);\n}","map":{"version":3,"names":["deepNormalizeScriptCov","normalizeFunctionCov","normalizeProcessCov","normalizeRangeTree","normalizeScriptCov","RangeTree","mergeProcessCovs","processCovs","length","result","urlToScripts","Map","processCov","scriptCov","scriptCovs","get","url","undefined","set","push","scripts","values","mergeScriptCovs","merged","first","scriptId","rangeToFuncs","funcCov","functions","rootRange","stringifyFunctionRootRange","funcCovs","isBlockCoverage","mergeFunctionCovs","ranges","startOffset","toString","endOffset","functionName","trees","fromSortedRanges","mergedTree","mergeRangeTrees","toRanges","count","delta","tree","children","mergeRangeTreeChildren","start","end","RangeTreeWithParent","constructor","parentIndex","StartEvent","offset","compare","a","b","StartEventQueue","queue","nextIndex","pendingOffset","pendingTrees","fromParentTrees","parentTrees","startToTrees","parentTree","entries","child","sort","setPendingOffset","pushPendingTree","next","nextEvent","startEventQueue","parentToNested","openRange","event","nextChild","openRangeEnd","Math","max","insertChild","right","split","nested","matchingTrees","clear"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\merge.ts"],"sourcesContent":["import {\n  deepNormalizeScriptCov,\n  normalizeFunctionCov,\n  normalizeProcessCov,\n  normalizeRangeTree,\n  normalizeScriptCov,\n} from \"./normalize\";\nimport { RangeTree } from \"./range-tree\";\nimport { FunctionCov, ProcessCov, Range, RangeCov, ScriptCov } from \"./types\";\n\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\nexport function mergeProcessCovs(processCovs: ReadonlyArray<ProcessCov>): ProcessCov {\n  if (processCovs.length === 0) {\n    return {result: []};\n  }\n\n  const urlToScripts: Map<string, ScriptCov[]> = new Map();\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs: ScriptCov[] | undefined = urlToScripts.get(scriptCov.url);\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n      scriptCovs.push(scriptCov);\n    }\n  }\n\n  const result: ScriptCov[] = [];\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts)!);\n  }\n  const merged: ProcessCov = {result};\n\n  normalizeProcessCov(merged);\n  return merged;\n}\n\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\nexport function mergeScriptCovs(scriptCovs: ReadonlyArray<ScriptCov>): ScriptCov | undefined {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged: ScriptCov = scriptCovs[0];\n    deepNormalizeScriptCov(merged);\n    return merged;\n  }\n\n  const first: ScriptCov = scriptCovs[0];\n  const scriptId: string = first.scriptId;\n  const url: string = first.url;\n\n  const rangeToFuncs: Map<string, FunctionCov[]> = new Map();\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange: string = stringifyFunctionRootRange(funcCov);\n      let funcCovs: FunctionCov[] | undefined = rangeToFuncs.get(rootRange);\n\n      if (funcCovs === undefined ||\n        // if the entry in rangeToFuncs is function-level granularity and\n        // the new coverage is block-level, prefer block-level.\n        (!funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage)) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n      funcCovs.push(funcCov);\n    }\n  }\n\n  const functions: FunctionCov[] = [];\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs)!);\n  }\n\n  const merged: ScriptCov = {scriptId, url, functions};\n  normalizeScriptCov(merged);\n  return merged;\n}\n\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\nfunction stringifyFunctionRootRange(funcCov: Readonly<FunctionCov>): string {\n  const rootRange: RangeCov = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\nexport function mergeFunctionCovs(funcCovs: ReadonlyArray<FunctionCov>): FunctionCov | undefined {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged: FunctionCov = funcCovs[0];\n    normalizeFunctionCov(merged);\n    return merged;\n  }\n\n  const functionName: string = funcCovs[0].functionName;\n\n  const trees: RangeTree[] = [];\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(RangeTree.fromSortedRanges(funcCov.ranges)!);\n  }\n\n  // assert: `trees.length > 0`\n  const mergedTree: RangeTree = mergeRangeTrees(trees)!;\n  normalizeRangeTree(mergedTree);\n  const ranges: RangeCov[] = mergedTree.toRanges();\n  const isBlockCoverage: boolean = !(ranges.length === 1 && ranges[0].count === 0);\n\n  const merged: FunctionCov = {functionName, ranges, isBlockCoverage};\n  // assert: `merged` is normalized\n  return merged;\n}\n\n/**\n * @precondition Same `start` and `end` for all the trees\n */\nfunction mergeRangeTrees(trees: ReadonlyArray<RangeTree>): RangeTree | undefined {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n  const first: RangeTree = trees[0];\n  let delta: number = 0;\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n  const children: RangeTree[] = mergeRangeTreeChildren(trees);\n  return new RangeTree(first.start, first.end, delta, children);\n}\n\nclass RangeTreeWithParent {\n  readonly parentIndex: number;\n  readonly tree: RangeTree;\n\n  constructor(parentIndex: number, tree: RangeTree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n}\n\nclass StartEvent {\n  readonly offset: number;\n  readonly trees: RangeTreeWithParent[];\n\n  constructor(offset: number, trees: RangeTreeWithParent[]) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n\n  static compare(a: StartEvent, b: StartEvent): number {\n    return a.offset - b.offset;\n  }\n}\n\nclass StartEventQueue {\n  private readonly queue: StartEvent[];\n  private nextIndex: number;\n  private pendingOffset: number;\n  private pendingTrees: RangeTreeWithParent[] | undefined;\n\n  private constructor(queue: StartEvent[]) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n\n  static fromParentTrees(parentTrees: ReadonlyArray<RangeTree>): StartEventQueue {\n    const startToTrees: Map<number, RangeTreeWithParent[]> = new Map();\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees: RangeTreeWithParent[] | undefined = startToTrees.get(child.start);\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n    const queue: StartEvent[] = [];\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n\n  setPendingOffset(offset: number): void {\n    this.pendingOffset = offset;\n  }\n\n  pushPendingTree(tree: RangeTreeWithParent): void {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n    this.pendingTrees.push(tree);\n  }\n\n  next(): StartEvent | undefined {\n    const pendingTrees: RangeTreeWithParent[] | undefined = this.pendingTrees;\n    const nextEvent: StartEvent | undefined = this.queue[this.nextIndex];\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n}\n\nfunction mergeRangeTreeChildren(parentTrees: ReadonlyArray<RangeTree>): RangeTree[] {\n  const result: RangeTree[] = [];\n  const startEventQueue: StartEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested: Map<number, RangeTree[]> = new Map();\n  let openRange: Range | undefined;\n\n  while (true) {\n    const event: StartEvent | undefined = startEventQueue.next();\n    if (event === undefined) {\n      break;\n    }\n\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n\n    if (openRange === undefined) {\n      let openRangeEnd: number = event.offset + 1;\n      for (const {parentIndex, tree} of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {start: event.offset, end: openRangeEnd};\n    } else {\n      for (const {parentIndex, tree} of event.trees) {\n        if (tree.end > openRange.end) {\n          const right: RangeTree = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n\n  return result;\n}\n\nfunction insertChild(parentToNested: Map<number, RangeTree[]>, parentIndex: number, tree: RangeTree): void {\n  let nested: RangeTree[] | undefined = parentToNested.get(parentIndex);\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n  nested.push(tree);\n}\n\nfunction nextChild(openRange: Range, parentToNested: Map<number, RangeTree[]>): RangeTree {\n  const matchingTrees: RangeTree[] = [];\n\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new RangeTree(\n        openRange.start,\n        openRange.end,\n        0,\n        nested,\n      ));\n    }\n  }\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees)!;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}