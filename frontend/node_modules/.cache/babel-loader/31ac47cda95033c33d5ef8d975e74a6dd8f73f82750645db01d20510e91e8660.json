{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ancestorHasReturnType = exports.isValidFunctionExpressionReturnType = exports.isTypedFunctionExpression = exports.doesImmediatelyReturnFunctionExpression = exports.checkFunctionReturnType = exports.checkFunctionExpressionReturnType = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst astUtils_1 = require(\"./astUtils\");\nconst getFunctionHeadLoc_1 = require(\"./getFunctionHeadLoc\");\n/**\n * Checks if a node is a variable declarator with a type annotation.\n * ```\n * const x: Foo = ...\n * ```\n */\nfunction isVariableDeclaratorWithTypeAnnotation(node) {\n  return node.type === utils_1.AST_NODE_TYPES.VariableDeclarator && !!node.id.typeAnnotation;\n}\n/**\n * Checks if a node is a class property with a type annotation.\n * ```\n * public x: Foo = ...\n * ```\n */\nfunction isPropertyDefinitionWithTypeAnnotation(node) {\n  return node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && !!node.typeAnnotation;\n}\n/**\n * Checks if a node belongs to:\n * ```\n * new Foo(() => {})\n *         ^^^^^^^^\n * ```\n */\nfunction isConstructorArgument(node) {\n  return node.type === utils_1.AST_NODE_TYPES.NewExpression;\n}\n/**\n * Checks if a node is a property or a nested property of a typed object:\n * ```\n * const x: Foo = { prop: () => {} }\n * const x = { prop: () => {} } as Foo\n * const x = <Foo>{ prop: () => {} }\n * const x: Foo = { bar: { prop: () => {} } }\n * ```\n */\nfunction isPropertyOfObjectWithType(property) {\n  if (!property || property.type !== utils_1.AST_NODE_TYPES.Property) {\n    return false;\n  }\n  const objectExpr = property.parent; // this shouldn't happen, checking just in case\n  /* istanbul ignore if */\n  if (!objectExpr || objectExpr.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {\n    return false;\n  }\n  const parent = objectExpr.parent; // this shouldn't happen, checking just in case\n  /* istanbul ignore if */\n  if (!parent) {\n    return false;\n  }\n  return (0, astUtils_1.isTypeAssertion)(parent) || isPropertyDefinitionWithTypeAnnotation(parent) || isVariableDeclaratorWithTypeAnnotation(parent) || isFunctionArgument(parent) || isPropertyOfObjectWithType(parent);\n}\n/**\n * Checks if a function belongs to:\n * ```\n * () => () => ...\n * () => function () { ... }\n * () => { return () => ... }\n * () => { return function () { ... } }\n * function fn() { return () => ... }\n * function fn() { return function() { ... } }\n * ```\n */\nfunction doesImmediatelyReturnFunctionExpression({\n  body\n}) {\n  // Should always have a body; really checking just in case\n  /* istanbul ignore if */\n  if (!body) {\n    return false;\n  }\n  // Check if body is a block with a single statement\n  if (body.type === utils_1.AST_NODE_TYPES.BlockStatement && body.body.length === 1) {\n    const [statement] = body.body;\n    // Check if that statement is a return statement with an argument\n    if (statement.type === utils_1.AST_NODE_TYPES.ReturnStatement && !!statement.argument) {\n      // If so, check that returned argument as body\n      body = statement.argument;\n    }\n  }\n  // Check if the body being returned is a function expression\n  return body.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || body.type === utils_1.AST_NODE_TYPES.FunctionExpression;\n}\nexports.doesImmediatelyReturnFunctionExpression = doesImmediatelyReturnFunctionExpression;\n/**\n * Checks if a node belongs to:\n * ```\n * foo(() => 1)\n * ```\n */\nfunction isFunctionArgument(parent, callee) {\n  return parent.type === utils_1.AST_NODE_TYPES.CallExpression &&\n  // make sure this isn't an IIFE\n  parent.callee !== callee;\n}\n/**\n * Checks if a function belongs to:\n * ```\n * () => ({ action: 'xxx' } as const)\n * ```\n */\nfunction returnsConstAssertionDirectly(node) {\n  const {\n    body\n  } = node;\n  if ((0, astUtils_1.isTypeAssertion)(body)) {\n    const {\n      typeAnnotation\n    } = body;\n    if (typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n      const {\n        typeName\n      } = typeAnnotation;\n      if (typeName.type === utils_1.AST_NODE_TYPES.Identifier && typeName.name === 'const') {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n/**\n * True when the provided function expression is typed.\n */\nfunction isTypedFunctionExpression(node, options) {\n  const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n  if (!options.allowTypedFunctionExpressions) {\n    return false;\n  }\n  return (0, astUtils_1.isTypeAssertion)(parent) || isVariableDeclaratorWithTypeAnnotation(parent) || isPropertyDefinitionWithTypeAnnotation(parent) || isPropertyOfObjectWithType(parent) || isFunctionArgument(parent, node) || isConstructorArgument(parent);\n}\nexports.isTypedFunctionExpression = isTypedFunctionExpression;\n/**\n * Check whether the function expression return type is either typed or valid\n * with the provided options.\n */\nfunction isValidFunctionExpressionReturnType(node, options) {\n  if (isTypedFunctionExpression(node, options)) {\n    return true;\n  }\n  const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n  if (options.allowExpressions && parent.type !== utils_1.AST_NODE_TYPES.VariableDeclarator && parent.type !== utils_1.AST_NODE_TYPES.MethodDefinition && parent.type !== utils_1.AST_NODE_TYPES.ExportDefaultDeclaration && parent.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {\n    return true;\n  }\n  // https://github.com/typescript-eslint/typescript-eslint/issues/653\n  return options.allowDirectConstAssertionInArrowFunctions === true && node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression && returnsConstAssertionDirectly(node);\n}\nexports.isValidFunctionExpressionReturnType = isValidFunctionExpressionReturnType;\n/**\n * Check that the function expression or declaration is valid.\n */\nfunction isValidFunctionReturnType(node, options) {\n  if (options.allowHigherOrderFunctions && doesImmediatelyReturnFunctionExpression(node)) {\n    return true;\n  }\n  return node.returnType != null || (0, astUtils_1.isConstructor)(node.parent) || (0, astUtils_1.isSetter)(node.parent);\n}\n/**\n * Checks if a function declaration/expression has a return type.\n */\nfunction checkFunctionReturnType(node, options, sourceCode, report) {\n  if (isValidFunctionReturnType(node, options)) {\n    return;\n  }\n  report((0, getFunctionHeadLoc_1.getFunctionHeadLoc)(node, sourceCode));\n}\nexports.checkFunctionReturnType = checkFunctionReturnType;\n/**\n * Checks if a function declaration/expression has a return type.\n */\nfunction checkFunctionExpressionReturnType(node, options, sourceCode, report) {\n  if (isValidFunctionExpressionReturnType(node, options)) {\n    return;\n  }\n  checkFunctionReturnType(node, options, sourceCode, report);\n}\nexports.checkFunctionExpressionReturnType = checkFunctionExpressionReturnType;\n/**\n * Check whether any ancestor of the provided function has a valid return type.\n */\nfunction ancestorHasReturnType(node) {\n  let ancestor = node.parent;\n  if ((ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.Property) {\n    ancestor = ancestor.value;\n  }\n  // if the ancestor is not a return, then this function was not returned at all, so we can exit early\n  const isReturnStatement = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.ReturnStatement;\n  const isBodylessArrow = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression && ancestor.body.type !== utils_1.AST_NODE_TYPES.BlockStatement;\n  if (!isReturnStatement && !isBodylessArrow) {\n    return false;\n  }\n  while (ancestor) {\n    switch (ancestor.type) {\n      case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        if (ancestor.returnType) {\n          return true;\n        }\n        break;\n      // const x: Foo = () => {};\n      // Assume that a typed variable types the function expression\n      case utils_1.AST_NODE_TYPES.VariableDeclarator:\n        if (ancestor.id.typeAnnotation) {\n          return true;\n        }\n        break;\n    }\n    ancestor = ancestor.parent;\n  }\n  return false;\n}\nexports.ancestorHasReturnType = ancestorHasReturnType;","map":{"version":3,"names":["utils_1","require","astUtils_1","getFunctionHeadLoc_1","isVariableDeclaratorWithTypeAnnotation","node","type","AST_NODE_TYPES","VariableDeclarator","id","typeAnnotation","isPropertyDefinitionWithTypeAnnotation","PropertyDefinition","isConstructorArgument","NewExpression","isPropertyOfObjectWithType","property","Property","objectExpr","parent","ObjectExpression","isTypeAssertion","isFunctionArgument","doesImmediatelyReturnFunctionExpression","body","BlockStatement","length","statement","ReturnStatement","argument","ArrowFunctionExpression","FunctionExpression","exports","callee","CallExpression","returnsConstAssertionDirectly","TSTypeReference","typeName","Identifier","name","isTypedFunctionExpression","options","ESLintUtils","nullThrows","NullThrowsReasons","MissingParent","allowTypedFunctionExpressions","isValidFunctionExpressionReturnType","allowExpressions","MethodDefinition","ExportDefaultDeclaration","allowDirectConstAssertionInArrowFunctions","isValidFunctionReturnType","allowHigherOrderFunctions","returnType","isConstructor","isSetter","checkFunctionReturnType","sourceCode","report","getFunctionHeadLoc","checkFunctionExpressionReturnType","ancestorHasReturnType","ancestor","value","isReturnStatement","isBodylessArrow","FunctionDeclaration"],"sources":["../../src/util/explicitReturnTypeUtils.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}