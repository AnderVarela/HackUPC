{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.setArray = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /**\n   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n   * index of the `key` in the backing array.\n   *\n   * This is designed to allow synchronizing a second array with the contents of the backing array,\n   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n   * and there are never duplicates.\n   */\n  class SetArray {\n    constructor() {\n      this._indexes = {\n        __proto__: null\n      };\n      this.array = [];\n    }\n  }\n  /**\n   * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n   * with public access modifiers.\n   */\n  function cast(set) {\n    return set;\n  }\n  /**\n   * Gets the index associated with `key` in the backing array, if it is already present.\n   */\n  function get(setarr, key) {\n    return cast(setarr)._indexes[key];\n  }\n  /**\n   * Puts `key` into the backing array, if it is not already present. Returns\n   * the index of the `key` in the backing array.\n   */\n  function put(setarr, key) {\n    // The key may or may not be present. If it is present, it's a number.\n    const index = get(setarr, key);\n    if (index !== undefined) return index;\n    const {\n      array,\n      _indexes: indexes\n    } = cast(setarr);\n    const length = array.push(key);\n    return indexes[key] = length - 1;\n  }\n  /**\n   * Pops the last added item out of the SetArray.\n   */\n  function pop(setarr) {\n    const {\n      array,\n      _indexes: indexes\n    } = cast(setarr);\n    if (array.length === 0) return;\n    const last = array.pop();\n    indexes[last] = undefined;\n  }\n  /**\n   * Removes the key, if it exists in the set.\n   */\n  function remove(setarr, key) {\n    const index = get(setarr, key);\n    if (index === undefined) return;\n    const {\n      array,\n      _indexes: indexes\n    } = cast(setarr);\n    for (let i = index + 1; i < array.length; i++) {\n      const k = array[i];\n      array[i - 1] = k;\n      indexes[k]--;\n    }\n    indexes[key] = undefined;\n    array.pop();\n  }\n  exports.SetArray = SetArray;\n  exports.get = get;\n  exports.pop = pop;\n  exports.put = put;\n  exports.remove = remove;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["SetArray","constructor","_indexes","__proto__","array","cast","set","get","setarr","key","put","index","undefined","indexes","length","push","pop","last","remove","i","k"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\set-array\\src\\set-array.ts"],"sourcesContent":["type Key = string | number | symbol;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray<T extends Key = Key> {\n  private declare _indexes: Record<T, number | undefined>;\n  declare array: readonly T[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n}\n\ninterface PublicSet<T extends Key> {\n  array: T[];\n  _indexes: SetArray<T>['_indexes'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\n  return set as any;\n}\n\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\n  return cast(setarr)._indexes[key];\n}\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n\n  const { array, _indexes: indexes } = cast(setarr);\n\n  const length = array.push(key);\n  return (indexes[key] = length - 1);\n}\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\n  const { array, _indexes: indexes } = cast(setarr);\n  if (array.length === 0) return;\n\n  const last = array.pop()!;\n  indexes[last] = undefined;\n}\n\n/**\n * Removes the key, if it exists in the set.\n */\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]!--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\n"],"mappings":";;;;;EAEA;;;;;;;;QAQaA,QAAQ;IAInBC,YAAA;MACE,IAAI,CAACC,QAAQ,GAAG;QAAEC,SAAS,EAAE;MAAI,CAAS;MAC1C,IAAI,CAACC,KAAK,GAAG,EAAE;;;EASnB;;;;EAIA,SAASC,IAAIA,CAAgBC,GAAgB;IAC3C,OAAOA,GAAU;EACnB;EAEA;;;WAGgBC,GAAGA,CAAgBC,MAAmB,EAAEC,GAAM;IAC5D,OAAOJ,IAAI,CAACG,MAAM,CAAC,CAACN,QAAQ,CAACO,GAAG,CAAC;EACnC;EAEA;;;;WAIgBC,GAAGA,CAAgBF,MAAmB,EAAEC,GAAM;;IAE5D,MAAME,KAAK,GAAGJ,GAAG,CAACC,MAAM,EAAEC,GAAG,CAAC;IAC9B,IAAIE,KAAK,KAAKC,SAAS,EAAE,OAAOD,KAAK;IAErC,MAAM;MAAEP,KAAK;MAAEF,QAAQ,EAAEW;IAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;IAEjD,MAAMM,MAAM,GAAGV,KAAK,CAACW,IAAI,CAACN,GAAG,CAAC;IAC9B,OAAQI,OAAO,CAACJ,GAAG,CAAC,GAAGK,MAAM,GAAG,CAAC;EACnC;EAEA;;;WAGgBE,GAAGA,CAAgBR,MAAmB;IACpD,MAAM;MAAEJ,KAAK;MAAEF,QAAQ,EAAEW;IAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;IACjD,IAAIJ,KAAK,CAACU,MAAM,KAAK,CAAC,EAAE;IAExB,MAAMG,IAAI,GAAGb,KAAK,CAACY,GAAG,EAAG;IACzBH,OAAO,CAACI,IAAI,CAAC,GAAGL,SAAS;EAC3B;EAEA;;;WAGgBM,MAAMA,CAAgBV,MAAmB,EAAEC,GAAM;IAC/D,MAAME,KAAK,GAAGJ,GAAG,CAACC,MAAM,EAAEC,GAAG,CAAC;IAC9B,IAAIE,KAAK,KAAKC,SAAS,EAAE;IAEzB,MAAM;MAAER,KAAK;MAAEF,QAAQ,EAAEW;IAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;IACjD,KAAK,IAAIW,CAAC,GAAGR,KAAK,GAAG,CAAC,EAAEQ,CAAC,GAAGf,KAAK,CAACU,MAAM,EAAEK,CAAC,EAAE,EAAE;MAC7C,MAAMC,CAAC,GAAGhB,KAAK,CAACe,CAAC,CAAC;MAClBf,KAAK,CAACe,CAAC,GAAG,CAAC,CAAC,GAAGC,CAAC;MAChBP,OAAO,CAACO,CAAC,CAAE,EAAE;;IAEfP,OAAO,CAACJ,GAAG,CAAC,GAAGG,SAAS;IACxBR,KAAK,CAACY,GAAG,EAAE;EACb","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}