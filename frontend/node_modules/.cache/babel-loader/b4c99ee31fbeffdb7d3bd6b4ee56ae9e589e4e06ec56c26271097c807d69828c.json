{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@babel/core');\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar helperEnvironmentVisitor = require('@babel/helper-environment-visitor');\nfunction isNameOrLength(key) {\n  if (core.types.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (core.types.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\nfunction isStaticFieldWithValue(node) {\n  return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;\n}\nconst hasReferenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, {\n    name\n  }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  }\n};\nfunction isReferenceOrThis(node, name) {\n  return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {\n    name\n  });\n}\nconst hasReferenceOrThisVisitor = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      helperEnvironmentVisitor.requeueComputedKeyAndDecorators(path);\n    }\n  }\n};\nfunction getPotentiallyBuggyFieldsIndexes(path) {\n  var _path$node$id;\n  const buggyPublicStaticFieldsIndexes = [];\n  let classReferenced = false;\n  const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;\n  const hasReferenceState = {\n    name: className,\n    ref: () => classReferenced = true\n  };\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if (el.node.computed) {\n        el.get(\"key\").traverse(hasReferenceVisitor, hasReferenceState);\n        if (classReferenced) break;\n      }\n    }\n  }\n  let nextPotentiallyBuggy = false;\n  const {\n    body\n  } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (!nextPotentiallyBuggy) {\n      if (core.types.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            path.get(`body.body.${i}.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n    if (core.types.isClassProperty(node, {\n      static: true\n    }) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n  return buggyPublicStaticFieldsIndexes;\n}\nfunction getNameOrLengthStaticFieldsIndexes(path) {\n  const indexes = [];\n  const {\n    body\n  } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (core.types.isClassProperty(node, {\n      static: true,\n      computed: false\n    }) && isNameOrLength(node.key)) {\n      indexes.push(i);\n    }\n  }\n  return indexes;\n}\nfunction toRanges(nums) {\n  const ranges = [];\n  if (nums.length === 0) return ranges;\n  let start = nums[0];\n  let end = start + 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      throw new Error(\"Internal Babel error: nums must be in ascending order\");\n    }\n    if (nums[i] === end) {\n      end++;\n    } else {\n      ranges.push([start, end]);\n      start = nums[i];\n      end = start + 1;\n    }\n  }\n  ranges.push([start, end]);\n  return ranges;\n}\nfunction buildFieldsReplacement(fields, scope, file) {\n  return core.types.staticBlock(fields.map(field => {\n    const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);\n    return core.types.expressionStatement(core.types.callExpression(file.addHelper(\"defineProperty\"), [core.types.thisExpression(), key, field.value || scope.buildUndefinedNode()]));\n  }));\n}\nvar index = helperPluginUtils.declare(api => {\n  api.assertVersion(7);\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  return {\n    name: \"bugfix-v8-static-class-fields-redefine-readonly\",\n    visitor: {\n      Class(path) {\n        const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));\n        for (let i = ranges.length - 1; i >= 0; i--) {\n          const [start, end] = ranges[i];\n          const startPath = path.get(\"body.body\")[start];\n          startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));\n          for (let j = end - 1; j > start; j--) {\n            path.get(\"body.body\")[j].remove();\n          }\n        }\n      }\n    }\n  };\n});\nexports.default = index;","map":{"version":3,"names":["isNameOrLength","key","core","types","isIdentifier","name","isStringLiteral","value","isStaticFieldWithValue","node","isClassProperty","isClassPrivateProperty","static","hasReferenceVisitor","ReferencedIdentifier","path","state","ref","stop","Scope","scope","hasOwnBinding","skip","isReferenceOrThis","isThisExpression","hasReferenceOrThisVisitor","ThisExpression|ReferencedIdentifier","FunctionParent","isArrowFunctionExpression","traverse","isMethod","helperEnvironmentVisitor","requeueComputedKeyAndDecorators","getPotentiallyBuggyFieldsIndexes","_path$node$id","buggyPublicStaticFieldsIndexes","classReferenced","className","id","hasReferenceState","el","get","computed","nextPotentiallyBuggy","body","i","length","isStaticBlock","isPure","push","getNameOrLengthStaticFieldsIndexes","indexes","toRanges","nums","ranges","start","end","Error","buildFieldsReplacement","fields","file","staticBlock","map","field","stringLiteral","expressionStatement","callExpression","addHelper","thisExpression","buildUndefinedNode","index","helperPluginUtils","declare","api","assertVersion","setPublicClassFields","assumption","visitor","Class","startPath","replaceWith","slice","j","remove"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-bugfix-v8-static-class-fields-redefine-readonly\\src\\util.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-bugfix-v8-static-class-fields-redefine-readonly\\src\\index.ts"],"sourcesContent":["import type { NodePath, Visitor } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\nimport { requeueComputedKeyAndDecorators } from \"@babel/helper-environment-visitor\";\n\nfunction isNameOrLength(key: t.Node): boolean {\n  if (t.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (t.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\nfunction isStaticFieldWithValue(\n  node: t.Node,\n): node is t.ClassProperty | t.ClassPrivateProperty {\n  return (\n    (t.isClassProperty(node) || t.isClassPrivateProperty(node)) &&\n    node.static &&\n    !!node.value\n  );\n}\n\nconst hasReferenceVisitor: Visitor<{ name: string; ref: () => void }> = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, { name }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  },\n};\n\nfunction isReferenceOrThis(node: t.Node, name?: string) {\n  return t.isThisExpression(node) || (name && t.isIdentifier(node, { name }));\n}\n\nconst hasReferenceOrThisVisitor: Visitor<{ name?: string; ref: () => void }> = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      requeueComputedKeyAndDecorators(path);\n    }\n  },\n};\n\ntype ClassElementWithComputedKeySupport = Extract<\n  t.ClassBody[\"body\"][number],\n  { computed?: boolean }\n>;\n\n/**\n * This function returns an array containing the indexes of class elements\n * that might be affected by https://crbug.com/v8/12421 bug.\n *\n * This bug affects public static class fields that have the same name as an\n * existing non-writable property with the same name. This usually happens when\n * the static field is named 'length' or 'name', since it clashes with the\n * predefined fn.length and fn.name properties. We must also compile static\n * fields with computed key, because they might end up being named 'length' or\n * 'name'.\n *\n * However, this bug can potentially affect public static fields with any name.\n * Consider this example:\n *\n *     class A {\n *       static {\n *         Object.defineProperty(A, \"readonly\", {\n *           value: 1,\n *           writable: false,\n *           configurable: true\n *         })\n *       }\n *\n *       static readonly = 2;\n *     }\n *\n * When initializing the 'static readonly' field, the class already has a\n * non-writable property named 'readonly' and thus V8 9.7 incorrectly throws.\n *\n * To avoid unconditionally compiling every public static field, we track how\n * the class is referenced during definition & static evaluation: any side\n * effect after a reference to the class can potentially define a non-writable\n * conficting property, so subsequent public static fields must be compiled.\n * The class could be referenced using the class name in computed keys, which\n * run before static fields, or using either the class name or 'this' in static\n * fields (both public and private) and static blocks.\n *\n * We don't need to check if computed keys referencing the class have any side\n * effect, because during the computed keys evaluation the internal class\n * binding is in TDZ. However, the first side effect in a static field/block\n * could have access to a function defined in a computed key that modifies the\n * class.\n *\n * This logic is already quite complex, so we assume that static blocks always\n * have side effects and reference the class (the reason to use them is to\n * perform additional initialization logic on the class anyway), so that we do\n * not have to check their contents.\n */\nexport function getPotentiallyBuggyFieldsIndexes(path: NodePath<t.Class>) {\n  const buggyPublicStaticFieldsIndexes: number[] = [];\n\n  let classReferenced = false;\n  const className = path.node.id?.name;\n\n  const hasReferenceState = {\n    name: className,\n    ref: () => (classReferenced = true),\n  };\n\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if ((el.node as ClassElementWithComputedKeySupport).computed) {\n        // Since .traverse skips the top-level node, it doesn't detect\n        // a reference happening immediately:\n        //     class A { [A]() {} }\n        // However, it's a TDZ error so it's ok not to consider this case.\n        (el as NodePath<ClassElementWithComputedKeySupport>)\n          .get(\"key\")\n          .traverse(hasReferenceVisitor, hasReferenceState);\n\n        if (classReferenced) break;\n      }\n    }\n  }\n\n  let nextPotentiallyBuggy = false;\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n\n    if (!nextPotentiallyBuggy) {\n      if (t.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            (\n              path.get(`body.body.${i}.value`) as NodePath<t.Expression>\n            ).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n\n    if (\n      t.isClassProperty(node, { static: true }) &&\n      (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))\n    ) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n\n  return buggyPublicStaticFieldsIndexes;\n}\n\nexport function getNameOrLengthStaticFieldsIndexes(path: NodePath<t.Class>) {\n  const indexes: number[] = [];\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (\n      t.isClassProperty(node, { static: true, computed: false }) &&\n      isNameOrLength(node.key)\n    ) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}\n\ntype Range = [start: number, end: number];\n\n/**\n * Converts a sorted list of numbers into a list of (inclusive-exclusive)\n * ranges representing the same numbers.\n *\n * @example toRanges([1, 3, 4, 5, 8, 9]) -> [[1, 2], [3, 6], [8, 10]]\n */\nexport function toRanges(nums: number[]): Range[] {\n  const ranges: Range[] = [];\n\n  if (nums.length === 0) return ranges;\n\n  let start = nums[0];\n  let end = start + 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      throw new Error(\"Internal Babel error: nums must be in ascending order\");\n    }\n    if (nums[i] === end) {\n      end++;\n    } else {\n      ranges.push([start, end]);\n      start = nums[i];\n      end = start + 1;\n    }\n  }\n  ranges.push([start, end]);\n\n  return ranges;\n}\n","import type { NodePath, Scope } from \"@babel/traverse\";\nimport { types as t, type PluginPass, type File } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nimport {\n  getPotentiallyBuggyFieldsIndexes,\n  getNameOrLengthStaticFieldsIndexes,\n  toRanges,\n} from \"./util.ts\";\n\nfunction buildFieldsReplacement(\n  fields: t.ClassProperty[],\n  scope: Scope,\n  file: File,\n) {\n  return t.staticBlock(\n    fields.map(field => {\n      const key =\n        field.computed || !t.isIdentifier(field.key)\n          ? field.key\n          : t.stringLiteral(field.key.name);\n\n      return t.expressionStatement(\n        t.callExpression(file.addHelper(\"defineProperty\"), [\n          t.thisExpression(),\n          key,\n          field.value || scope.buildUndefinedNode(),\n        ]),\n      );\n    }),\n  );\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n\n  return {\n    name: \"bugfix-v8-static-class-fields-redefine-readonly\",\n\n    visitor: {\n      Class(this: PluginPass, path: NodePath<t.Class>) {\n        const ranges = toRanges(\n          setPublicClassFields\n            ? getNameOrLengthStaticFieldsIndexes(path)\n            : getPotentiallyBuggyFieldsIndexes(path),\n        );\n\n        for (let i = ranges.length - 1; i >= 0; i--) {\n          const [start, end] = ranges[i];\n\n          const startPath = path.get(\"body.body\")[start];\n\n          startPath.replaceWith(\n            buildFieldsReplacement(\n              path.node.body.body.slice(start, end) as t.ClassProperty[],\n              path.scope,\n              this.file,\n            ),\n          );\n\n          for (let j = end - 1; j > start; j--) {\n            path.get(\"body.body\")[j].remove();\n          }\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}