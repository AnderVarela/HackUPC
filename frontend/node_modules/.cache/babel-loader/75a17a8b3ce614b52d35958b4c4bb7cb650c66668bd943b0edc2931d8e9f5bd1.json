{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst enumValues = ['always', 'never', 'in-unions', 'in-intersections', 'in-unions-and-intersections'];\nexports.default = util.createRule({\n  name: 'no-type-alias',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow type aliases',\n      // too opinionated to be recommended\n      recommended: false\n    },\n    messages: {\n      noTypeAlias: 'Type {{alias}} are not allowed.',\n      noCompositionAlias: '{{typeName}} in {{compositionType}} types are not allowed.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowAliases: {\n          description: 'Whether to allow direct one-to-one type aliases.',\n          enum: enumValues\n        },\n        allowCallbacks: {\n          description: 'Whether to allow type aliases for callbacks.',\n          enum: ['always', 'never']\n        },\n        allowConditionalTypes: {\n          description: 'Whether to allow type aliases for conditional types.',\n          enum: ['always', 'never']\n        },\n        allowConstructors: {\n          description: 'Whether to allow type aliases with constructors.',\n          enum: ['always', 'never']\n        },\n        allowLiterals: {\n          description: 'Whether to allow type aliases with object literal types.',\n          enum: enumValues\n        },\n        allowMappedTypes: {\n          description: 'Whether to allow type aliases with mapped types.',\n          enum: enumValues\n        },\n        allowTupleTypes: {\n          description: 'Whether to allow type aliases with tuple types.',\n          enum: enumValues\n        },\n        allowGenerics: {\n          description: 'Whether to allow type aliases with generic types.',\n          enum: ['always', 'never']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowAliases: 'never',\n    allowCallbacks: 'never',\n    allowConditionalTypes: 'never',\n    allowConstructors: 'never',\n    allowLiterals: 'never',\n    allowMappedTypes: 'never',\n    allowTupleTypes: 'never',\n    allowGenerics: 'never'\n  }],\n  create(context, [{\n    allowAliases,\n    allowCallbacks,\n    allowConditionalTypes,\n    allowConstructors,\n    allowLiterals,\n    allowMappedTypes,\n    allowTupleTypes,\n    allowGenerics\n  }]) {\n    const unions = ['always', 'in-unions', 'in-unions-and-intersections'];\n    const intersections = ['always', 'in-intersections', 'in-unions-and-intersections'];\n    const compositions = ['in-unions', 'in-intersections', 'in-unions-and-intersections'];\n    const aliasTypes = new Set([utils_1.AST_NODE_TYPES.TSArrayType, utils_1.AST_NODE_TYPES.TSImportType, utils_1.AST_NODE_TYPES.TSTypeReference, utils_1.AST_NODE_TYPES.TSLiteralType, utils_1.AST_NODE_TYPES.TSTypeQuery, utils_1.AST_NODE_TYPES.TSIndexedAccessType, utils_1.AST_NODE_TYPES.TSTemplateLiteralType]);\n    /**\n     * Determines if the composition type is supported by the allowed flags.\n     * @param isTopLevel a flag indicating this is the top level node.\n     * @param compositionType the composition type (either TSUnionType or TSIntersectionType)\n     * @param allowed the currently allowed flags.\n     */\n    function isSupportedComposition(isTopLevel, compositionType, allowed) {\n      return !compositions.includes(allowed) || !isTopLevel && (compositionType === utils_1.AST_NODE_TYPES.TSUnionType && unions.includes(allowed) || compositionType === utils_1.AST_NODE_TYPES.TSIntersectionType && intersections.includes(allowed));\n    }\n    /**\n     * Gets the message to be displayed based on the node type and whether the node is a top level declaration.\n     * @param node the location\n     * @param compositionType the type of composition this alias is part of (undefined if not\n     *                                  part of a composition)\n     * @param isRoot a flag indicating we are dealing with the top level declaration.\n     * @param type the kind of type alias being validated.\n     */\n    function reportError(node, compositionType, isRoot, type) {\n      if (isRoot) {\n        return context.report({\n          node,\n          messageId: 'noTypeAlias',\n          data: {\n            alias: type.toLowerCase()\n          }\n        });\n      }\n      return context.report({\n        node,\n        messageId: 'noCompositionAlias',\n        data: {\n          compositionType: compositionType === utils_1.AST_NODE_TYPES.TSUnionType ? 'union' : 'intersection',\n          typeName: type\n        }\n      });\n    }\n    const isValidTupleType = type => {\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n        return true;\n      }\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator) {\n        if (['keyof', 'readonly'].includes(type.node.operator) && type.node.typeAnnotation && type.node.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const isValidGeneric = type => {\n      return type.node.type === utils_1.AST_NODE_TYPES.TSTypeReference && type.node.typeParameters !== undefined;\n    };\n    const checkAndReport = (optionValue, isTopLevel, type, label) => {\n      if (optionValue === 'never' || !isSupportedComposition(isTopLevel, type.compositionType, optionValue)) {\n        reportError(type.node, type.compositionType, isTopLevel, label);\n      }\n    };\n    /**\n     * Validates the node looking for aliases, callbacks and literals.\n     * @param type the type of composition this alias is part of (null if not\n     *                                  part of a composition)\n     * @param isTopLevel a flag indicating this is the top level node.\n     */\n    function validateTypeAliases(type, isTopLevel = false) {\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSFunctionType) {\n        // callback\n        if (allowCallbacks === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Callbacks');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSConditionalType) {\n        // conditional type\n        if (allowConditionalTypes === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Conditional types');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSConstructorType) {\n        if (allowConstructors === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Constructors');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeLiteral) {\n        // literal object type\n        checkAndReport(allowLiterals, isTopLevel, type, 'Literals');\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSMappedType) {\n        // mapped type\n        checkAndReport(allowMappedTypes, isTopLevel, type, 'Mapped types');\n      } else if (isValidTupleType(type)) {\n        // tuple types\n        checkAndReport(allowTupleTypes, isTopLevel, type, 'Tuple Types');\n      } else if (isValidGeneric(type)) {\n        if (allowGenerics === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Generics');\n        }\n      } else if (type.node.type.endsWith(utils_1.AST_TOKEN_TYPES.Keyword) || aliasTypes.has(type.node.type) || type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator && (type.node.operator === 'keyof' || type.node.operator === 'readonly' && type.node.typeAnnotation && aliasTypes.has(type.node.typeAnnotation.type))) {\n        // alias / keyword\n        checkAndReport(allowAliases, isTopLevel, type, 'Aliases');\n      } else {\n        // unhandled type - shouldn't happen\n        reportError(type.node, type.compositionType, isTopLevel, 'Unhandled');\n      }\n    }\n    /**\n     * Flatten the given type into an array of its dependencies\n     */\n    function getTypes(node, compositionType = null) {\n      if (node.type === utils_1.AST_NODE_TYPES.TSUnionType || node.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n        return node.types.reduce((acc, type) => {\n          acc.push(...getTypes(type, node.type));\n          return acc;\n        }, []);\n      }\n      return [{\n        node,\n        compositionType\n      }];\n    }\n    return {\n      TSTypeAliasDeclaration(node) {\n        const types = getTypes(node.typeAnnotation);\n        if (types.length === 1) {\n          // is a top level type annotation\n          validateTypeAliases(types[0], true);\n        } else {\n          // is a composition type\n          types.forEach(type => {\n            validateTypeAliases(type);\n          });\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","enumValues","exports","default","createRule","name","meta","type","docs","description","recommended","messages","noTypeAlias","noCompositionAlias","schema","properties","allowAliases","enum","allowCallbacks","allowConditionalTypes","allowConstructors","allowLiterals","allowMappedTypes","allowTupleTypes","allowGenerics","additionalProperties","defaultOptions","create","context","unions","intersections","compositions","aliasTypes","Set","AST_NODE_TYPES","TSArrayType","TSImportType","TSTypeReference","TSLiteralType","TSTypeQuery","TSIndexedAccessType","TSTemplateLiteralType","isSupportedComposition","isTopLevel","compositionType","allowed","includes","TSUnionType","TSIntersectionType","reportError","node","isRoot","report","messageId","data","alias","toLowerCase","typeName","isValidTupleType","TSTupleType","TSTypeOperator","operator","typeAnnotation","isValidGeneric","typeParameters","undefined","checkAndReport","optionValue","label","validateTypeAliases","TSFunctionType","TSConditionalType","TSConstructorType","TSTypeLiteral","TSMappedType","endsWith","AST_TOKEN_TYPES","Keyword","has","getTypes","types","reduce","acc","push","TSTypeAliasDeclaration","length","forEach"],"sources":["../../src/rules/no-type-alias.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}