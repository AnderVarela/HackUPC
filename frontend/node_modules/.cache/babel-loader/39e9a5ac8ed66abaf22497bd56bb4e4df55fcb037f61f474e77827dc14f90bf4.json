{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nvar Usefulness;\n(function (Usefulness) {\n  Usefulness[Usefulness[\"Always\"] = 0] = \"Always\";\n  Usefulness[\"Never\"] = \"will\";\n  Usefulness[\"Sometimes\"] = \"may\";\n})(Usefulness || (Usefulness = {}));\nexports.default = util.createRule({\n  name: 'no-base-to-string',\n  meta: {\n    docs: {\n      description: 'Require `.toString()` to only be called on objects which provide useful information when stringified',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      baseToString: \"'{{name}}' {{certainty}} evaluate to '[object Object]' when stringified.\"\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoredTypeNames: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{\n    ignoredTypeNames: ['Error', 'RegExp', 'URL', 'URLSearchParams']\n  }],\n  create(context, [option]) {\n    var _a;\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const ignoredTypeNames = (_a = option.ignoredTypeNames) !== null && _a !== void 0 ? _a : [];\n    function checkExpression(node, type) {\n      if (node.type === utils_1.AST_NODE_TYPES.Literal) {\n        return;\n      }\n      const certainty = collectToStringCertainty(type !== null && type !== void 0 ? type : typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node)));\n      if (certainty === Usefulness.Always) {\n        return;\n      }\n      context.report({\n        data: {\n          certainty,\n          name: context.getSourceCode().getText(node)\n        },\n        messageId: 'baseToString',\n        node\n      });\n    }\n    function collectToStringCertainty(type) {\n      const toString = typeChecker.getPropertyOfType(type, 'toString');\n      const declarations = toString === null || toString === void 0 ? void 0 : toString.getDeclarations();\n      if (!toString || !declarations || declarations.length === 0) {\n        return Usefulness.Always;\n      }\n      // Patch for old version TypeScript, the Boolean type definition missing toString()\n      if (type.flags & ts.TypeFlags.Boolean || type.flags & ts.TypeFlags.BooleanLiteral) {\n        return Usefulness.Always;\n      }\n      if (ignoredTypeNames.includes(util.getTypeName(typeChecker, type))) {\n        return Usefulness.Always;\n      }\n      if (declarations.every(({\n        parent\n      }) => !ts.isInterfaceDeclaration(parent) || parent.name.text !== 'Object')) {\n        return Usefulness.Always;\n      }\n      if (type.isIntersection()) {\n        for (const subType of type.types) {\n          const subtypeUsefulness = collectToStringCertainty(subType);\n          if (subtypeUsefulness === Usefulness.Always) {\n            return Usefulness.Always;\n          }\n        }\n        return Usefulness.Never;\n      }\n      if (!type.isUnion()) {\n        return Usefulness.Never;\n      }\n      let allSubtypesUseful = true;\n      let someSubtypeUseful = false;\n      for (const subType of type.types) {\n        const subtypeUsefulness = collectToStringCertainty(subType);\n        if (subtypeUsefulness !== Usefulness.Always && allSubtypesUseful) {\n          allSubtypesUseful = false;\n        }\n        if (subtypeUsefulness !== Usefulness.Never && !someSubtypeUseful) {\n          someSubtypeUseful = true;\n        }\n      }\n      if (allSubtypesUseful && someSubtypeUseful) {\n        return Usefulness.Always;\n      }\n      if (someSubtypeUseful) {\n        return Usefulness.Sometimes;\n      }\n      return Usefulness.Never;\n    }\n    return {\n      'AssignmentExpression[operator = \"+=\"], BinaryExpression[operator = \"+\"]'(node) {\n        const leftType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.left));\n        const rightType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.right));\n        if (util.getTypeName(typeChecker, leftType) === 'string') {\n          checkExpression(node.right, rightType);\n        } else if (util.getTypeName(typeChecker, rightType) === 'string' && node.left.type !== utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n          checkExpression(node.left, leftType);\n        }\n      },\n      'CallExpression > MemberExpression.callee > Identifier[name = \"toString\"].property'(node) {\n        const memberExpr = node.parent;\n        checkExpression(memberExpr.object);\n      },\n      TemplateLiteral(node) {\n        if (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {\n          return;\n        }\n        for (const expression of node.expressions) {\n          checkExpression(expression);\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","ts","__importStar","util","Usefulness","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","baseToString","schema","type","properties","ignoredTypeNames","items","additionalProperties","defaultOptions","create","context","option","parserServices","getParserServices","typeChecker","program","getTypeChecker","_a","checkExpression","node","AST_NODE_TYPES","Literal","certainty","collectToStringCertainty","getTypeAtLocation","esTreeNodeToTSNodeMap","get","Always","report","data","getSourceCode","getText","messageId","toString","getPropertyOfType","declarations","getDeclarations","length","flags","TypeFlags","Boolean","BooleanLiteral","includes","getTypeName","every","parent","isInterfaceDeclaration","text","isIntersection","subType","types","subtypeUsefulness","Never","isUnion","allSubtypesUseful","someSubtypeUseful","Sometimes","AssignmentExpression[operator = \"+=\"], BinaryExpression[operator = \"+\"]","leftType","left","rightType","right","PrivateIdentifier","CallExpression > MemberExpression.callee > Identifier[name = \"toString\"].property","memberExpr","object","TemplateLiteral","TaggedTemplateExpression","expression","expressions"],"sources":["../../src/rules/no-base-to-string.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}