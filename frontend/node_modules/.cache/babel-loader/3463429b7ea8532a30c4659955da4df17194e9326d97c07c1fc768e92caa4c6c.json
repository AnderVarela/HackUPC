{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeConfigAPI = makeConfigAPI;\nexports.makePluginAPI = makePluginAPI;\nexports.makePresetAPI = makePresetAPI;\nfunction _semver() {\n  const data = require(\"semver\");\n  _semver = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"../../index.js\");\nvar _caching = require(\"../caching.js\");\nfunction makeConfigAPI(cache) {\n  const env = value => cache.using(data => {\n    if (typeof value === \"undefined\") return data.envName;\n    if (typeof value === \"function\") {\n      return (0, _caching.assertSimpleType)(value(data.envName));\n    }\n    return (Array.isArray(value) ? value : [value]).some(entry => {\n      if (typeof entry !== \"string\") {\n        throw new Error(\"Unexpected non-string value\");\n      }\n      return entry === data.envName;\n    });\n  });\n  const caller = cb => cache.using(data => (0, _caching.assertSimpleType)(cb(data.caller)));\n  return {\n    version: _index.version,\n    cache: cache.simple(),\n    env,\n    async: () => false,\n    caller,\n    assertVersion\n  };\n}\nfunction makePresetAPI(cache, externalDependencies) {\n  const targets = () => JSON.parse(cache.using(data => JSON.stringify(data.targets)));\n  const addExternalDependency = ref => {\n    externalDependencies.push(ref);\n  };\n  return Object.assign({}, makeConfigAPI(cache), {\n    targets,\n    addExternalDependency\n  });\n}\nfunction makePluginAPI(cache, externalDependencies) {\n  const assumption = name => cache.using(data => data.assumptions[name]);\n  return Object.assign({}, makePresetAPI(cache, externalDependencies), {\n    assumption\n  });\n}\nfunction assertVersion(range) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n  if (range === \"*\" || _semver().satisfies(_index.version, range)) return;\n  const limit = Error.stackTraceLimit;\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n  const err = new Error(`Requires Babel \"${range}\", but was loaded with \"${_index.version}\". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` + `to see what is calling Babel.`);\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: _index.version,\n    range\n  });\n}\n0 && 0;","map":{"version":3,"names":["_semver","data","require","_index","_caching","makeConfigAPI","cache","env","value","using","envName","assertSimpleType","Array","isArray","some","entry","Error","caller","cb","version","simple","async","assertVersion","makePresetAPI","externalDependencies","targets","JSON","parse","stringify","addExternalDependency","ref","push","Object","assign","makePluginAPI","assumption","name","assumptions","range","Number","isInteger","satisfies","limit","stackTraceLimit","err","code"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\core\\src\\config\\helpers\\config-api.ts"],"sourcesContent":["import semver from \"semver\";\nimport type { Targets } from \"@babel/helper-compilation-targets\";\n\nimport { version as coreVersion } from \"../../index.ts\";\nimport { assertSimpleType } from \"../caching.ts\";\nimport type {\n  CacheConfigurator,\n  SimpleCacheConfigurator,\n  SimpleType,\n} from \"../caching.ts\";\n\nimport type { AssumptionName, CallerMetadata } from \"../validation/options.ts\";\n\nimport type * as Context from \"../cache-contexts\";\n\ntype EnvFunction = {\n  (): string;\n  <T>(extractor: (babelEnv: string) => T): T;\n  (envVar: string): boolean;\n  (envVars: Array<string>): boolean;\n};\n\ntype CallerFactory = {\n  <T extends SimpleType>(\n    extractor: (callerMetadata: CallerMetadata | undefined) => T,\n  ): T;\n  (\n    extractor: (callerMetadata: CallerMetadata | undefined) => unknown,\n  ): SimpleType;\n};\ntype TargetsFunction = () => Targets;\ntype AssumptionFunction = (name: AssumptionName) => boolean | undefined;\n\nexport type ConfigAPI = {\n  version: string;\n  cache: SimpleCacheConfigurator;\n  env: EnvFunction;\n  async: () => boolean;\n  assertVersion: typeof assertVersion;\n  caller?: CallerFactory;\n};\n\nexport type PresetAPI = {\n  targets: TargetsFunction;\n  addExternalDependency: (ref: string) => void;\n} & ConfigAPI;\n\nexport type PluginAPI = {\n  assumption: AssumptionFunction;\n} & PresetAPI;\n\nexport function makeConfigAPI<SideChannel extends Context.SimpleConfig>(\n  cache: CacheConfigurator<SideChannel>,\n): ConfigAPI {\n  // TODO(@nicolo-ribaudo): If we remove the explicit type from `value`\n  // and the `as any` type cast, TypeScript crashes in an infinite\n  // recursion. After upgrading to TS4.7 and finishing the noImplicitAny\n  // PR, we should check if it still crashes and report it to the TS team.\n  const env: EnvFunction = ((\n    value: string | string[] | (<T>(babelEnv: string) => T),\n  ) =>\n    cache.using(data => {\n      if (typeof value === \"undefined\") return data.envName;\n      if (typeof value === \"function\") {\n        return assertSimpleType(value(data.envName));\n      }\n      return (Array.isArray(value) ? value : [value]).some(entry => {\n        if (typeof entry !== \"string\") {\n          throw new Error(\"Unexpected non-string value\");\n        }\n        return entry === data.envName;\n      });\n    })) as any;\n\n  const caller = (cb: {\n    (CallerMetadata: CallerMetadata | undefined): SimpleType;\n  }) => cache.using(data => assertSimpleType(cb(data.caller)));\n\n  return {\n    version: coreVersion,\n    cache: cache.simple(),\n    // Expose \".env()\" so people can easily get the same env that we expose using the \"env\" key.\n    env,\n    async: () => false,\n    caller,\n    assertVersion,\n  };\n}\n\nexport function makePresetAPI<SideChannel extends Context.SimplePreset>(\n  cache: CacheConfigurator<SideChannel>,\n  externalDependencies: Array<string>,\n): PresetAPI {\n  const targets = () =>\n    // We are using JSON.parse/JSON.stringify because it's only possible to cache\n    // primitive values. We can safely stringify the targets object because it\n    // only contains strings as its properties.\n    // Please make the Record and Tuple proposal happen!\n    JSON.parse(cache.using(data => JSON.stringify(data.targets)));\n\n  const addExternalDependency = (ref: string) => {\n    externalDependencies.push(ref);\n  };\n\n  return { ...makeConfigAPI(cache), targets, addExternalDependency };\n}\n\nexport function makePluginAPI<SideChannel extends Context.SimplePlugin>(\n  cache: CacheConfigurator<SideChannel>,\n  externalDependencies: Array<string>,\n): PluginAPI {\n  const assumption = (name: string) =>\n    cache.using(data => data.assumptions[name]);\n\n  return { ...makePresetAPI(cache, externalDependencies), assumption };\n}\n\nfunction assertVersion(range: string | number): void {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  // We want \"*\" to also allow any pre-release, but we do not pass\n  // the includePrerelease option to semver.satisfies because we\n  // do not want ^7.0.0 to match 8.0.0-alpha.1.\n  if (range === \"*\" || semver.satisfies(coreVersion, range)) return;\n\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    // Bump up the limit if needed so that users are more likely\n    // to be able to see what is calling Babel.\n    Error.stackTraceLimit = 25;\n  }\n\n  const err = new Error(\n    `Requires Babel \"${range}\", but was loaded with \"${coreVersion}\". ` +\n      `If you are sure you have a compatible version of @babel/core, ` +\n      `it is likely that something in your build process is loading the ` +\n      `wrong version. Inspect the stack trace of this error to look for ` +\n      `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` +\n      `to see what is calling Babel.`,\n  );\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: coreVersion,\n    range,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}