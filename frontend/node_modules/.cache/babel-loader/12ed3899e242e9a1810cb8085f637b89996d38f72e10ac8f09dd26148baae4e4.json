{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst util_1 = require(\"../util\");\nexports.default = util.createRule({\n  name: 'no-floating-promises',\n  meta: {\n    docs: {\n      description: 'Require Promise-like statements to be handled appropriately',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    messages: {\n      floating: 'Promises must be awaited, end with a call to .catch, or end with a call to .then with a rejection handler.',\n      floatingFixAwait: 'Add await operator.',\n      floatingVoid: 'Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler' + ' or be explicitly marked as ignored with the `void` operator.',\n      floatingFixVoid: 'Add void operator to ignore.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreVoid: {\n          description: 'Whether to ignore `void` expressions.',\n          type: 'boolean'\n        },\n        ignoreIIFE: {\n          description: 'Whether to ignore async IIFEs (Immediately Invocated Function Expressions).',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    ignoreVoid: true,\n    ignoreIIFE: false\n  }],\n  create(context, [options]) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    return {\n      ExpressionStatement(node) {\n        if (options.ignoreIIFE && isAsyncIife(node)) {\n          return;\n        }\n        let expression = node.expression;\n        if (expression.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n          expression = expression.expression;\n        }\n        if (isUnhandledPromise(checker, expression)) {\n          if (options.ignoreVoid) {\n            context.report({\n              node,\n              messageId: 'floatingVoid',\n              suggest: [{\n                messageId: 'floatingFixVoid',\n                fix(fixer) {\n                  const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node.expression);\n                  if (isHigherPrecedenceThanUnary(tsNode)) {\n                    return fixer.insertTextBefore(node, 'void ');\n                  } else {\n                    return [fixer.insertTextBefore(node, 'void ('), fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')')];\n                  }\n                }\n              }]\n            });\n          } else {\n            context.report({\n              node,\n              messageId: 'floating',\n              suggest: [{\n                messageId: 'floatingFixAwait',\n                fix(fixer) {\n                  if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression && expression.operator === 'void') {\n                    return fixer.replaceTextRange([expression.range[0], expression.range[0] + 4], 'await');\n                  }\n                  const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node.expression);\n                  if (isHigherPrecedenceThanUnary(tsNode)) {\n                    return fixer.insertTextBefore(node, 'await ');\n                  } else {\n                    return [fixer.insertTextBefore(node, 'await ('), fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')')];\n                  }\n                }\n              }]\n            });\n          }\n        }\n      }\n    };\n    function isHigherPrecedenceThanUnary(node) {\n      const operator = tsutils.isBinaryExpression(node) ? node.operatorToken.kind : ts.SyntaxKind.Unknown;\n      const nodePrecedence = util.getOperatorPrecedence(node.kind, operator);\n      return nodePrecedence > util_1.OperatorPrecedence.Unary;\n    }\n    function isAsyncIife(node) {\n      if (node.expression.type !== utils_1.AST_NODE_TYPES.CallExpression) {\n        return false;\n      }\n      return node.expression.type === utils_1.AST_NODE_TYPES.CallExpression && (node.expression.callee.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || node.expression.callee.type === utils_1.AST_NODE_TYPES.FunctionExpression);\n    }\n    function isUnhandledPromise(checker, node) {\n      // First, check expressions whose resulting types may not be promise-like\n      if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n        // Any child in a comma expression could return a potentially unhandled\n        // promise, so we check them all regardless of whether the final returned\n        // value is promise-like.\n        return node.expressions.some(item => isUnhandledPromise(checker, item));\n      }\n      if (!options.ignoreVoid && node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === 'void') {\n        // Similarly, a `void` expression always returns undefined, so we need to\n        // see what's inside it without checking the type of the overall expression.\n        return isUnhandledPromise(checker, node.argument);\n      }\n      // Check the type. At this point it can't be unhandled if it isn't a promise\n      if (!isPromiseLike(checker, parserServices.esTreeNodeToTSNodeMap.get(node))) {\n        return false;\n      }\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        // If the outer expression is a call, it must be either a `.then()` or\n        // `.catch()` that handles the promise.\n        return !isPromiseCatchCallWithHandler(node) && !isPromiseThenCallWithRejectionHandler(node) && !isPromiseFinallyCallWithHandler(node);\n      } else if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        // We must be getting the promise-like value from one of the branches of the\n        // ternary. Check them directly.\n        return isUnhandledPromise(checker, node.alternate) || isUnhandledPromise(checker, node.consequent);\n      } else if (node.type === utils_1.AST_NODE_TYPES.MemberExpression || node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.NewExpression) {\n        // If it is just a property access chain or a `new` call (e.g. `foo.bar` or\n        // `new Promise()`), the promise is not handled because it doesn't have the\n        // necessary then/catch call at the end of the chain.\n        return true;\n      } else if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n        return isUnhandledPromise(checker, node.left) || isUnhandledPromise(checker, node.right);\n      }\n      // We conservatively return false for all other types of expressions because\n      // we don't want to accidentally fail if the promise is handled internally but\n      // we just can't tell.\n      return false;\n    }\n  }\n});\n// Modified from tsutils.isThenable() to only consider thenables which can be\n// rejected/caught via a second parameter. Original source (MIT licensed):\n//\n//   https://github.com/ajafff/tsutils/blob/49d0d31050b44b81e918eae4fbaf1dfe7b7286af/util/type.ts#L95-L125\nfunction isPromiseLike(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n  for (const ty of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    const then = ty.getProperty('then');\n    if (then === undefined) {\n      continue;\n    }\n    const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n    if (hasMatchingSignature(thenType, signature => signature.parameters.length >= 2 && isFunctionParam(checker, signature.parameters[0], node) && isFunctionParam(checker, signature.parameters[1], node))) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction hasMatchingSignature(type, matcher) {\n  for (const t of tsutils.unionTypeParts(type)) {\n    if (t.getCallSignatures().some(matcher)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isFunctionParam(checker, param, node) {\n  const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n  for (const t of tsutils.unionTypeParts(type)) {\n    if (t.getCallSignatures().length !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isPromiseCatchCallWithHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'catch' && expression.arguments.length >= 1;\n}\nfunction isPromiseThenCallWithRejectionHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'then' && expression.arguments.length >= 2;\n}\nfunction isPromiseFinallyCallWithHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'finally' && expression.arguments.length >= 1;\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","util_1","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","hasSuggestions","messages","floating","floatingFixAwait","floatingVoid","floatingFixVoid","schema","type","properties","ignoreVoid","ignoreIIFE","additionalProperties","defaultOptions","create","context","options","parserServices","getParserServices","checker","program","getTypeChecker","ExpressionStatement","node","isAsyncIife","expression","AST_NODE_TYPES","ChainExpression","isUnhandledPromise","report","messageId","suggest","fix","fixer","tsNode","esTreeNodeToTSNodeMap","get","isHigherPrecedenceThanUnary","insertTextBefore","insertTextAfterRange","range","UnaryExpression","operator","replaceTextRange","isBinaryExpression","operatorToken","kind","SyntaxKind","Unknown","nodePrecedence","getOperatorPrecedence","OperatorPrecedence","Unary","CallExpression","callee","ArrowFunctionExpression","FunctionExpression","SequenceExpression","expressions","some","item","argument","isPromiseLike","isPromiseCatchCallWithHandler","isPromiseThenCallWithRejectionHandler","isPromiseFinallyCallWithHandler","ConditionalExpression","alternate","consequent","MemberExpression","Identifier","NewExpression","LogicalExpression","left","right","getTypeAtLocation","ty","unionTypeParts","getApparentType","then","getProperty","undefined","thenType","getTypeOfSymbolAtLocation","hasMatchingSignature","signature","parameters","length","isFunctionParam","matcher","t","getCallSignatures","param","property","arguments"],"sources":["../../src/rules/no-floating-promises.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAC,YAAA,CAAAF,OAAA;AACA,MAAAG,EAAA,GAAAD,YAAA,CAAAF,OAAA;AAEA,MAAAI,IAAA,GAAAF,YAAA,CAAAF,OAAA;AACA,MAAAK,MAAA,GAAAL,OAAA;AAeAM,OAAA,CAAAC,OAAA,GAAeH,IAAI,CAACI,UAAU,CAAqB;EACjDC,IAAI,EAAE,sBAAsB;EAC5BC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EACT,6DAA6D;MAC/DC,WAAW,EAAE,OAAO;MACpBC,oBAAoB,EAAE;KACvB;IACDC,cAAc,EAAE,IAAI;IACpBC,QAAQ,EAAE;MACRC,QAAQ,EACN,4GAA4G;MAC9GC,gBAAgB,EAAE,qBAAqB;MACvCC,YAAY,EACV,wGAAwG,GACxG,+DAA+D;MACjEC,eAAe,EAAE;KAClB;IACDC,MAAM,EAAE,CACN;MACEC,IAAI,EAAE,QAAQ;MACdC,UAAU,EAAE;QACVC,UAAU,EAAE;UACVZ,WAAW,EAAE,uCAAuC;UACpDU,IAAI,EAAE;SACP;QACDG,UAAU,EAAE;UACVb,WAAW,EACT,6EAA6E;UAC/EU,IAAI,EAAE;;OAET;MACDI,oBAAoB,EAAE;KACvB,CACF;IACDJ,IAAI,EAAE;GACP;EACDK,cAAc,EAAE,CACd;IACEH,UAAU,EAAE,IAAI;IAChBC,UAAU,EAAE;GACb,CACF;EAEDG,MAAMA,CAACC,OAAO,EAAE,CAACC,OAAO,CAAC;IACvB,MAAMC,cAAc,GAAG3B,IAAI,CAAC4B,iBAAiB,CAACH,OAAO,CAAC;IACtD,MAAMI,OAAO,GAAGF,cAAc,CAACG,OAAO,CAACC,cAAc,EAAE;IAEvD,OAAO;MACLC,mBAAmBA,CAACC,IAAI;QACtB,IAAIP,OAAO,CAACL,UAAU,IAAIa,WAAW,CAACD,IAAI,CAAC,EAAE;UAC3C;;QAGF,IAAIE,UAAU,GAAGF,IAAI,CAACE,UAAU;QAEhC,IAAIA,UAAU,CAACjB,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAACC,eAAe,EAAE;UACtDF,UAAU,GAAGA,UAAU,CAACA,UAAU;;QAGpC,IAAIG,kBAAkB,CAACT,OAAO,EAAEM,UAAU,CAAC,EAAE;UAC3C,IAAIT,OAAO,CAACN,UAAU,EAAE;YACtBK,OAAO,CAACc,MAAM,CAAC;cACbN,IAAI;cACJO,SAAS,EAAE,cAAc;cACzBC,OAAO,EAAE,CACP;gBACED,SAAS,EAAE,iBAAiB;gBAC5BE,GAAGA,CAACC,KAAK;kBACP,MAAMC,MAAM,GAAGjB,cAAc,CAACkB,qBAAqB,CAACC,GAAG,CACrDb,IAAI,CAACE,UAAU,CAChB;kBACD,IAAIY,2BAA2B,CAACH,MAAM,CAAC,EAAE;oBACvC,OAAOD,KAAK,CAACK,gBAAgB,CAACf,IAAI,EAAE,OAAO,CAAC;mBAC7C,MAAM;oBACL,OAAO,CACLU,KAAK,CAACK,gBAAgB,CAACf,IAAI,EAAE,QAAQ,CAAC,EACtCU,KAAK,CAACM,oBAAoB,CACxB,CAACd,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,EAAEf,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC,EAC1C,GAAG,CACJ,CACF;;gBAEL;eACD;aAEJ,CAAC;WACH,MAAM;YACLzB,OAAO,CAACc,MAAM,CAAC;cACbN,IAAI;cACJO,SAAS,EAAE,UAAU;cACrBC,OAAO,EAAE,CACP;gBACED,SAAS,EAAE,kBAAkB;gBAC7BE,GAAGA,CAACC,KAAK;kBACP,IACER,UAAU,CAACjB,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAACe,eAAe,IAClDhB,UAAU,CAACiB,QAAQ,KAAK,MAAM,EAC9B;oBACA,OAAOT,KAAK,CAACU,gBAAgB,CAC3B,CAAClB,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,EAAEf,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAC9C,OAAO,CACR;;kBAEH,MAAMN,MAAM,GAAGjB,cAAc,CAACkB,qBAAqB,CAACC,GAAG,CACrDb,IAAI,CAACE,UAAU,CAChB;kBACD,IAAIY,2BAA2B,CAACH,MAAM,CAAC,EAAE;oBACvC,OAAOD,KAAK,CAACK,gBAAgB,CAACf,IAAI,EAAE,QAAQ,CAAC;mBAC9C,MAAM;oBACL,OAAO,CACLU,KAAK,CAACK,gBAAgB,CAACf,IAAI,EAAE,SAAS,CAAC,EACvCU,KAAK,CAACM,oBAAoB,CACxB,CAACd,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,EAAEf,UAAU,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC,EAC1C,GAAG,CACJ,CACF;;gBAEL;eACD;aAEJ,CAAC;;;MAGR;KACD;IAED,SAASH,2BAA2BA,CAACd,IAAa;MAChD,MAAMmB,QAAQ,GAAGvD,OAAO,CAACyD,kBAAkB,CAACrB,IAAI,CAAC,GAC7CA,IAAI,CAACsB,aAAa,CAACC,IAAI,GACvBzD,EAAE,CAAC0D,UAAU,CAACC,OAAO;MACzB,MAAMC,cAAc,GAAG3D,IAAI,CAAC4D,qBAAqB,CAAC3B,IAAI,CAACuB,IAAI,EAAEJ,QAAQ,CAAC;MACtE,OAAOO,cAAc,GAAG1D,MAAA,CAAA4D,kBAAkB,CAACC,KAAK;IAClD;IAEA,SAAS5B,WAAWA,CAACD,IAAkC;MACrD,IAAIA,IAAI,CAACE,UAAU,CAACjB,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2B,cAAc,EAAE;QAC1D,OAAO,KAAK;;MAGd,OACE9B,IAAI,CAACE,UAAU,CAACjB,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2B,cAAc,KACrD9B,IAAI,CAACE,UAAU,CAAC6B,MAAM,CAAC9C,IAAI,KAC1BvB,OAAA,CAAAyC,cAAc,CAAC6B,uBAAuB,IACtChC,IAAI,CAACE,UAAU,CAAC6B,MAAM,CAAC9C,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC8B,kBAAkB,CAAC;IAExE;IAEA,SAAS5B,kBAAkBA,CACzBT,OAAuB,EACvBI,IAAmB;MAEnB;MACA,IAAIA,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC+B,kBAAkB,EAAE;QACnD;QACA;QACA;QACA,OAAOlC,IAAI,CAACmC,WAAW,CAACC,IAAI,CAACC,IAAI,IAAIhC,kBAAkB,CAACT,OAAO,EAAEyC,IAAI,CAAC,CAAC;;MAGzE,IACE,CAAC5C,OAAO,CAACN,UAAU,IACnBa,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAACe,eAAe,IAC5ClB,IAAI,CAACmB,QAAQ,KAAK,MAAM,EACxB;QACA;QACA;QACA,OAAOd,kBAAkB,CAACT,OAAO,EAAEI,IAAI,CAACsC,QAAQ,CAAC;;MAGnD;MACA,IACE,CAACC,aAAa,CAAC3C,OAAO,EAAEF,cAAc,CAACkB,qBAAqB,CAACC,GAAG,CAACb,IAAI,CAAC,CAAC,EACvE;QACA,OAAO,KAAK;;MAGd,IAAIA,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2B,cAAc,EAAE;QAC/C;QACA;QACA,OACE,CAACU,6BAA6B,CAACxC,IAAI,CAAC,IACpC,CAACyC,qCAAqC,CAACzC,IAAI,CAAC,IAC5C,CAAC0C,+BAA+B,CAAC1C,IAAI,CAAC;OAEzC,MAAM,IAAIA,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAACwC,qBAAqB,EAAE;QAC7D;QACA;QACA,OACEtC,kBAAkB,CAACT,OAAO,EAAEI,IAAI,CAAC4C,SAAS,CAAC,IAC3CvC,kBAAkB,CAACT,OAAO,EAAEI,IAAI,CAAC6C,UAAU,CAAC;OAE/C,MAAM,IACL7C,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2C,gBAAgB,IAC7C9C,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC4C,UAAU,IACvC/C,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC6C,aAAa,EAC1C;QACA;QACA;QACA;QACA,OAAO,IAAI;OACZ,MAAM,IAAIhD,IAAI,CAACf,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC8C,iBAAiB,EAAE;QACzD,OACE5C,kBAAkB,CAACT,OAAO,EAAEI,IAAI,CAACkD,IAAI,CAAC,IACtC7C,kBAAkB,CAACT,OAAO,EAAEI,IAAI,CAACmD,KAAK,CAAC;;MAI3C;MACA;MACA;MACA,OAAO,KAAK;IACd;EACF;CACD,CAAC;AAEF;AACA;AACA;AACA;AACA,SAASZ,aAAaA,CAAC3C,OAAuB,EAAEI,IAAa;EAC3D,MAAMf,IAAI,GAAGW,OAAO,CAACwD,iBAAiB,CAACpD,IAAI,CAAC;EAC5C,KAAK,MAAMqD,EAAE,IAAIzF,OAAO,CAAC0F,cAAc,CAAC1D,OAAO,CAAC2D,eAAe,CAACtE,IAAI,CAAC,CAAC,EAAE;IACtE,MAAMuE,IAAI,GAAGH,EAAE,CAACI,WAAW,CAAC,MAAM,CAAC;IACnC,IAAID,IAAI,KAAKE,SAAS,EAAE;MACtB;;IAGF,MAAMC,QAAQ,GAAG/D,OAAO,CAACgE,yBAAyB,CAACJ,IAAI,EAAExD,IAAI,CAAC;IAC9D,IACE6D,oBAAoB,CAClBF,QAAQ,EACRG,SAAS,IACPA,SAAS,CAACC,UAAU,CAACC,MAAM,IAAI,CAAC,IAChCC,eAAe,CAACrE,OAAO,EAAEkE,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE/D,IAAI,CAAC,IACvDiE,eAAe,CAACrE,OAAO,EAAEkE,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE/D,IAAI,CAAC,CAC1D,EACD;MACA,OAAO,IAAI;;;EAGf,OAAO,KAAK;AACd;AAEA,SAAS6D,oBAAoBA,CAC3B5E,IAAa,EACbiF,OAA6C;EAE7C,KAAK,MAAMC,CAAC,IAAIvG,OAAO,CAAC0F,cAAc,CAACrE,IAAI,CAAC,EAAE;IAC5C,IAAIkF,CAAC,CAACC,iBAAiB,EAAE,CAAChC,IAAI,CAAC8B,OAAO,CAAC,EAAE;MACvC,OAAO,IAAI;;;EAIf,OAAO,KAAK;AACd;AAEA,SAASD,eAAeA,CACtBrE,OAAuB,EACvByE,KAAgB,EAChBrE,IAAa;EAEb,MAAMf,IAAI,GAAwBW,OAAO,CAAC2D,eAAe,CACvD3D,OAAO,CAACgE,yBAAyB,CAACS,KAAK,EAAErE,IAAI,CAAC,CAC/C;EACD,KAAK,MAAMmE,CAAC,IAAIvG,OAAO,CAAC0F,cAAc,CAACrE,IAAI,CAAC,EAAE;IAC5C,IAAIkF,CAAC,CAACC,iBAAiB,EAAE,CAACJ,MAAM,KAAK,CAAC,EAAE;MACtC,OAAO,IAAI;;;EAGf,OAAO,KAAK;AACd;AAEA,SAASxB,6BAA6BA,CACpCtC,UAAmC;EAEnC,OACEA,UAAU,CAAC6B,MAAM,CAAC9C,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2C,gBAAgB,IAC1D5C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAACrF,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC4C,UAAU,IAC7D7C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAAClG,IAAI,KAAK,OAAO,IAC3C8B,UAAU,CAACqE,SAAS,CAACP,MAAM,IAAI,CAAC;AAEpC;AAEA,SAASvB,qCAAqCA,CAC5CvC,UAAmC;EAEnC,OACEA,UAAU,CAAC6B,MAAM,CAAC9C,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2C,gBAAgB,IAC1D5C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAACrF,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC4C,UAAU,IAC7D7C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAAClG,IAAI,KAAK,MAAM,IAC1C8B,UAAU,CAACqE,SAAS,CAACP,MAAM,IAAI,CAAC;AAEpC;AAEA,SAAStB,+BAA+BA,CACtCxC,UAAmC;EAEnC,OACEA,UAAU,CAAC6B,MAAM,CAAC9C,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC2C,gBAAgB,IAC1D5C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAACrF,IAAI,KAAKvB,OAAA,CAAAyC,cAAc,CAAC4C,UAAU,IAC7D7C,UAAU,CAAC6B,MAAM,CAACuC,QAAQ,CAAClG,IAAI,KAAK,SAAS,IAC7C8B,UAAU,CAACqE,SAAS,CAACP,MAAM,IAAI,CAAC;AAEpC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}