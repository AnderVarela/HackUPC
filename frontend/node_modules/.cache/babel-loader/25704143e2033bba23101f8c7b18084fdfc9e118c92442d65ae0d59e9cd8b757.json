{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isThisInTypeQuery = exports.isThisIdentifier = exports.identifierIsThisKeyword = exports.firstDefined = exports.nodeHasTokens = exports.createError = exports.TSError = exports.convertTokens = exports.convertToken = exports.getTokenType = exports.isChildUnwrappableOptionalChain = exports.isChainExpression = exports.isOptional = exports.isComputedProperty = exports.unescapeStringLiteralText = exports.hasJSXAncestor = exports.findFirstMatchingAncestor = exports.findNextToken = exports.getTSNodeAccessibility = exports.getDeclarationKind = exports.isJSXToken = exports.isToken = exports.getRange = exports.canContainDirective = exports.getLocFor = exports.getLineAndCharacterFor = exports.getBinaryExpressionType = exports.isJSDocComment = exports.isComment = exports.isComma = exports.getLastModifier = exports.hasModifier = exports.isESTreeClassMember = exports.getTextForTokenKind = exports.isLogicalOperator = exports.isAssignmentOperator = void 0;\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst xhtml_entities_1 = require(\"./jsx/xhtml-entities\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst version_check_1 = require(\"./version-check\");\nconst isAtLeast50 = version_check_1.typescriptVersionIsAtLeast['5.0'];\nconst SyntaxKind = ts.SyntaxKind;\nconst LOGICAL_OPERATORS = [SyntaxKind.BarBarToken, SyntaxKind.AmpersandAmpersandToken, SyntaxKind.QuestionQuestionToken];\n/**\n * Returns true if the given ts.Token is the assignment operator\n * @param operator the operator token\n * @returns is assignment\n */\nfunction isAssignmentOperator(operator) {\n  return operator.kind >= SyntaxKind.FirstAssignment && operator.kind <= SyntaxKind.LastAssignment;\n}\nexports.isAssignmentOperator = isAssignmentOperator;\n/**\n * Returns true if the given ts.Token is a logical operator\n * @param operator the operator token\n * @returns is a logical operator\n */\nfunction isLogicalOperator(operator) {\n  return LOGICAL_OPERATORS.includes(operator.kind);\n}\nexports.isLogicalOperator = isLogicalOperator;\n/**\n * Returns the string form of the given TSToken SyntaxKind\n * @param kind the token's SyntaxKind\n * @returns the token applicable token as a string\n */\nfunction getTextForTokenKind(kind) {\n  return ts.tokenToString(kind);\n}\nexports.getTextForTokenKind = getTextForTokenKind;\n/**\n * Returns true if the given ts.Node is a valid ESTree class member\n * @param node TypeScript AST node\n * @returns is valid ESTree class member\n */\nfunction isESTreeClassMember(node) {\n  return node.kind !== SyntaxKind.SemicolonClassElement;\n}\nexports.isESTreeClassMember = isESTreeClassMember;\n/**\n * Checks if a ts.Node has a modifier\n * @param modifierKind TypeScript SyntaxKind modifier\n * @param node TypeScript AST node\n * @returns has the modifier specified\n */\nfunction hasModifier(modifierKind, node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  return (modifiers === null || modifiers === void 0 ? void 0 : modifiers.some(modifier => modifier.kind === modifierKind)) === true;\n}\nexports.hasModifier = hasModifier;\n/**\n * Get last last modifier in ast\n * @param node TypeScript AST node\n * @returns returns last modifier if present or null\n */\nfunction getLastModifier(node) {\n  var _a;\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  if (modifiers == null) {\n    return null;\n  }\n  return (_a = modifiers[modifiers.length - 1]) !== null && _a !== void 0 ? _a : null;\n}\nexports.getLastModifier = getLastModifier;\n/**\n * Returns true if the given ts.Token is a comma\n * @param token the TypeScript token\n * @returns is comma\n */\nfunction isComma(token) {\n  return token.kind === SyntaxKind.CommaToken;\n}\nexports.isComma = isComma;\n/**\n * Returns true if the given ts.Node is a comment\n * @param node the TypeScript node\n * @returns is comment\n */\nfunction isComment(node) {\n  return node.kind === SyntaxKind.SingleLineCommentTrivia || node.kind === SyntaxKind.MultiLineCommentTrivia;\n}\nexports.isComment = isComment;\n/**\n * Returns true if the given ts.Node is a JSDoc comment\n * @param node the TypeScript node\n * @returns is JSDoc comment\n */\nfunction isJSDocComment(node) {\n  return node.kind === SyntaxKind.JSDocComment;\n}\nexports.isJSDocComment = isJSDocComment;\n/**\n * Returns the binary expression type of the given ts.Token\n * @param operator the operator token\n * @returns the binary expression type\n */\nfunction getBinaryExpressionType(operator) {\n  if (isAssignmentOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.AssignmentExpression;\n  } else if (isLogicalOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.LogicalExpression;\n  }\n  return ts_estree_1.AST_NODE_TYPES.BinaryExpression;\n}\nexports.getBinaryExpressionType = getBinaryExpressionType;\n/**\n * Returns line and column data for the given positions,\n * @param pos position to check\n * @param ast the AST object\n * @returns line and column\n */\nfunction getLineAndCharacterFor(pos, ast) {\n  const loc = ast.getLineAndCharacterOfPosition(pos);\n  return {\n    line: loc.line + 1,\n    column: loc.character\n  };\n}\nexports.getLineAndCharacterFor = getLineAndCharacterFor;\n/**\n * Returns line and column data for the given start and end positions,\n * for the given AST\n * @param start start data\n * @param end   end data\n * @param ast   the AST object\n * @returns the loc data\n */\nfunction getLocFor(start, end, ast) {\n  return {\n    start: getLineAndCharacterFor(start, ast),\n    end: getLineAndCharacterFor(end, ast)\n  };\n}\nexports.getLocFor = getLocFor;\n/**\n * Check whatever node can contain directive\n * @param node\n * @returns returns true if node can contain directive\n */\nfunction canContainDirective(node) {\n  if (node.kind === ts.SyntaxKind.Block) {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.Constructor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n        return true;\n      default:\n        return false;\n    }\n  }\n  return true;\n}\nexports.canContainDirective = canContainDirective;\n/**\n * Returns range for the given ts.Node\n * @param node the ts.Node or ts.Token\n * @param ast the AST object\n * @returns the range data\n */\nfunction getRange(node, ast) {\n  return [node.getStart(ast), node.getEnd()];\n}\nexports.getRange = getRange;\n/**\n * Returns true if a given ts.Node is a token\n * @param node the ts.Node\n * @returns is a token\n */\nfunction isToken(node) {\n  return node.kind >= SyntaxKind.FirstToken && node.kind <= SyntaxKind.LastToken;\n}\nexports.isToken = isToken;\n/**\n * Returns true if a given ts.Node is a JSX token\n * @param node ts.Node to be checked\n * @returns is a JSX token\n */\nfunction isJSXToken(node) {\n  return node.kind >= SyntaxKind.JsxElement && node.kind <= SyntaxKind.JsxAttribute;\n}\nexports.isJSXToken = isJSXToken;\n/**\n * Returns the declaration kind of the given ts.Node\n * @param node TypeScript AST node\n * @returns declaration kind\n */\nfunction getDeclarationKind(node) {\n  if (node.flags & ts.NodeFlags.Let) {\n    return 'let';\n  }\n  if (node.flags & ts.NodeFlags.Const) {\n    return 'const';\n  }\n  return 'var';\n}\nexports.getDeclarationKind = getDeclarationKind;\n/**\n * Gets a ts.Node's accessibility level\n * @param node The ts.Node\n * @returns accessibility \"public\", \"protected\", \"private\", or null\n */\nfunction getTSNodeAccessibility(node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  if (modifiers == null) {\n    return null;\n  }\n  for (const modifier of modifiers) {\n    switch (modifier.kind) {\n      case SyntaxKind.PublicKeyword:\n        return 'public';\n      case SyntaxKind.ProtectedKeyword:\n        return 'protected';\n      case SyntaxKind.PrivateKeyword:\n        return 'private';\n      default:\n        break;\n    }\n  }\n  return null;\n}\nexports.getTSNodeAccessibility = getTSNodeAccessibility;\n/**\n * Finds the next token based on the previous one and its parent\n * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren\n * @param previousToken The previous TSToken\n * @param parent The parent TSNode\n * @param ast The TS AST\n * @returns the next TSToken\n */\nfunction findNextToken(previousToken, parent, ast) {\n  return find(parent);\n  function find(n) {\n    if (ts.isToken(n) && n.pos === previousToken.end) {\n      // this is token that starts at the end of previous token - return it\n      return n;\n    }\n    return firstDefined(n.getChildren(ast), child => {\n      const shouldDiveInChildNode =\n      // previous token is enclosed somewhere in the child\n      child.pos <= previousToken.pos && child.end > previousToken.end ||\n      // previous token ends exactly at the beginning of child\n      child.pos === previousToken.end;\n      return shouldDiveInChildNode && nodeHasTokens(child, ast) ? find(child) : undefined;\n    });\n  }\n}\nexports.findNextToken = findNextToken;\n/**\n * Find the first matching ancestor based on the given predicate function.\n * @param node The current ts.Node\n * @param predicate The predicate function to apply to each checked ancestor\n * @returns a matching parent ts.Node\n */\nfunction findFirstMatchingAncestor(node, predicate) {\n  while (node) {\n    if (predicate(node)) {\n      return node;\n    }\n    node = node.parent;\n  }\n  return undefined;\n}\nexports.findFirstMatchingAncestor = findFirstMatchingAncestor;\n/**\n * Returns true if a given ts.Node has a JSX token within its hierarchy\n * @param node ts.Node to be checked\n * @returns has JSX ancestor\n */\nfunction hasJSXAncestor(node) {\n  return !!findFirstMatchingAncestor(node, isJSXToken);\n}\nexports.hasJSXAncestor = hasJSXAncestor;\n/**\n * Unescape the text content of string literals, e.g. &amp; -> &\n * @param text The escaped string literal text.\n * @returns The unescaped string literal text.\n */\nfunction unescapeStringLiteralText(text) {\n  return text.replace(/&(?:#\\d+|#x[\\da-fA-F]+|[0-9a-zA-Z]+);/g, entity => {\n    const item = entity.slice(1, -1);\n    if (item[0] === '#') {\n      const codePoint = item[1] === 'x' ? parseInt(item.slice(2), 16) : parseInt(item.slice(1), 10);\n      return codePoint > 0x10ffff // RangeError: Invalid code point\n      ? entity : String.fromCodePoint(codePoint);\n    }\n    return xhtml_entities_1.xhtmlEntities[item] || entity;\n  });\n}\nexports.unescapeStringLiteralText = unescapeStringLiteralText;\n/**\n * Returns true if a given ts.Node is a computed property\n * @param node ts.Node to be checked\n * @returns is Computed Property\n */\nfunction isComputedProperty(node) {\n  return node.kind === SyntaxKind.ComputedPropertyName;\n}\nexports.isComputedProperty = isComputedProperty;\n/**\n * Returns true if a given ts.Node is optional (has QuestionToken)\n * @param node ts.Node to be checked\n * @returns is Optional\n */\nfunction isOptional(node) {\n  return node.questionToken ? node.questionToken.kind === SyntaxKind.QuestionToken : false;\n}\nexports.isOptional = isOptional;\n/**\n * Returns true if the node is an optional chain node\n */\nfunction isChainExpression(node) {\n  return node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;\n}\nexports.isChainExpression = isChainExpression;\n/**\n * Returns true of the child of property access expression is an optional chain\n */\nfunction isChildUnwrappableOptionalChain(node, child) {\n  return isChainExpression(child) &&\n  // (x?.y).z is semantically different, and as such .z is no longer optional\n  node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;\n}\nexports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;\n/**\n * Returns the type of a given ts.Token\n * @param token the ts.Token\n * @returns the token type\n */\nfunction getTokenType(token) {\n  let keywordKind;\n  if (isAtLeast50 && token.kind === SyntaxKind.Identifier) {\n    keywordKind = ts.identifierToKeywordKind(token);\n  } else if ('originalKeywordKind' in token) {\n    // eslint-disable-next-line deprecation/deprecation -- intentional fallback for older TS versions\n    keywordKind = token.originalKeywordKind;\n  }\n  if (keywordKind) {\n    if (keywordKind === SyntaxKind.NullKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Null;\n    } else if (keywordKind >= SyntaxKind.FirstFutureReservedWord && keywordKind <= SyntaxKind.LastKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n    }\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n  if (token.kind >= SyntaxKind.FirstKeyword && token.kind <= SyntaxKind.LastFutureReservedWord) {\n    if (token.kind === SyntaxKind.FalseKeyword || token.kind === SyntaxKind.TrueKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Boolean;\n    }\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n  if (token.kind >= SyntaxKind.FirstPunctuation && token.kind <= SyntaxKind.LastPunctuation) {\n    return ts_estree_1.AST_TOKEN_TYPES.Punctuator;\n  }\n  if (token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral && token.kind <= SyntaxKind.TemplateTail) {\n    return ts_estree_1.AST_TOKEN_TYPES.Template;\n  }\n  switch (token.kind) {\n    case SyntaxKind.NumericLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.Numeric;\n    case SyntaxKind.JsxText:\n      return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n    case SyntaxKind.StringLiteral:\n      // A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,\n      // must actually be an ESTree-JSXText token\n      if (token.parent && (token.parent.kind === SyntaxKind.JsxAttribute || token.parent.kind === SyntaxKind.JsxElement)) {\n        return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n      }\n      return ts_estree_1.AST_TOKEN_TYPES.String;\n    case SyntaxKind.RegularExpressionLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.RegularExpression;\n    case SyntaxKind.Identifier:\n    case SyntaxKind.ConstructorKeyword:\n    case SyntaxKind.GetKeyword:\n    case SyntaxKind.SetKeyword:\n    // intentional fallthrough\n    default:\n  }\n  // Some JSX tokens have to be determined based on their parent\n  if (token.parent && token.kind === SyntaxKind.Identifier) {\n    if (isJSXToken(token.parent)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n    if (token.parent.kind === SyntaxKind.PropertyAccessExpression && hasJSXAncestor(token)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n  }\n  return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n}\nexports.getTokenType = getTokenType;\n/**\n * Extends and formats a given ts.Token, for a given AST\n * @param token the ts.Token\n * @param ast   the AST object\n * @returns the converted Token\n */\nfunction convertToken(token, ast) {\n  const start = token.kind === SyntaxKind.JsxText ? token.getFullStart() : token.getStart(ast);\n  const end = token.getEnd();\n  const value = ast.text.slice(start, end);\n  const tokenType = getTokenType(token);\n  if (tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast),\n      regex: {\n        pattern: value.slice(1, value.lastIndexOf('/')),\n        flags: value.slice(value.lastIndexOf('/') + 1)\n      }\n    };\n  } else {\n    // @ts-expect-error TS is complaining about `value` not being the correct\n    // type but it is\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast)\n    };\n  }\n}\nexports.convertToken = convertToken;\n/**\n * Converts all tokens for the given AST\n * @param ast the AST object\n * @returns the converted Tokens\n */\nfunction convertTokens(ast) {\n  const result = [];\n  /**\n   * @param node the ts.Node\n   */\n  function walk(node) {\n    // TypeScript generates tokens for types in JSDoc blocks. Comment tokens\n    // and their children should not be walked or added to the resulting tokens list.\n    if (isComment(node) || isJSDocComment(node)) {\n      return;\n    }\n    if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {\n      const converted = convertToken(node, ast);\n      if (converted) {\n        result.push(converted);\n      }\n    } else {\n      node.getChildren(ast).forEach(walk);\n    }\n  }\n  walk(ast);\n  return result;\n}\nexports.convertTokens = convertTokens;\nclass TSError extends Error {\n  constructor(message, fileName, index, lineNumber, column) {\n    super(message);\n    this.fileName = fileName;\n    this.index = index;\n    this.lineNumber = lineNumber;\n    this.column = column;\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n  }\n}\nexports.TSError = TSError;\n/**\n * @param ast     the AST object\n * @param start   the index at which the error starts\n * @param message the error message\n * @returns converted error object\n */\nfunction createError(ast, start, message) {\n  const loc = ast.getLineAndCharacterOfPosition(start);\n  return new TSError(message, ast.fileName, start, loc.line + 1, loc.character);\n}\nexports.createError = createError;\n/**\n * @param n the TSNode\n * @param ast the TS AST\n */\nfunction nodeHasTokens(n, ast) {\n  // If we have a token or node that has a non-zero width, it must have tokens.\n  // Note: getWidth() does not take trivia into account.\n  return n.kind === SyntaxKind.EndOfFileToken ? !!n.jsDoc : n.getWidth(ast) !== 0;\n}\nexports.nodeHasTokens = nodeHasTokens;\n/**\n * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).\n * @template T\n * @template U\n * @param array\n * @param callback\n */\nfunction firstDefined(array, callback) {\n  if (array === undefined) {\n    return undefined;\n  }\n  for (let i = 0; i < array.length; i++) {\n    const result = callback(array[i], i);\n    if (result !== undefined) {\n      return result;\n    }\n  }\n  return undefined;\n}\nexports.firstDefined = firstDefined;\nfunction identifierIsThisKeyword(id) {\n  return (\n    // eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions\n    (isAtLeast50 ? ts.identifierToKeywordKind(id) : id.originalKeywordKind) === SyntaxKind.ThisKeyword\n  );\n}\nexports.identifierIsThisKeyword = identifierIsThisKeyword;\nfunction isThisIdentifier(node) {\n  return !!node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node);\n}\nexports.isThisIdentifier = isThisIdentifier;\nfunction isThisInTypeQuery(node) {\n  if (!isThisIdentifier(node)) {\n    return false;\n  }\n  while (ts.isQualifiedName(node.parent) && node.parent.left === node) {\n    node = node.parent;\n  }\n  return node.parent.kind === SyntaxKind.TypeQuery;\n}\nexports.isThisInTypeQuery = isThisInTypeQuery;","map":{"version":3,"names":["ts","__importStar","require","getModifiers_1","xhtml_entities_1","ts_estree_1","version_check_1","isAtLeast50","typescriptVersionIsAtLeast","SyntaxKind","LOGICAL_OPERATORS","BarBarToken","AmpersandAmpersandToken","QuestionQuestionToken","isAssignmentOperator","operator","kind","FirstAssignment","LastAssignment","exports","isLogicalOperator","includes","getTextForTokenKind","tokenToString","isESTreeClassMember","node","SemicolonClassElement","hasModifier","modifierKind","modifiers","getModifiers","some","modifier","getLastModifier","_a","length","isComma","token","CommaToken","isComment","SingleLineCommentTrivia","MultiLineCommentTrivia","isJSDocComment","JSDocComment","getBinaryExpressionType","AST_NODE_TYPES","AssignmentExpression","LogicalExpression","BinaryExpression","getLineAndCharacterFor","pos","ast","loc","getLineAndCharacterOfPosition","line","column","character","getLocFor","start","end","canContainDirective","Block","parent","Constructor","GetAccessor","SetAccessor","ArrowFunction","FunctionExpression","FunctionDeclaration","MethodDeclaration","getRange","getStart","getEnd","isToken","FirstToken","LastToken","isJSXToken","JsxElement","JsxAttribute","getDeclarationKind","flags","NodeFlags","Let","Const","getTSNodeAccessibility","PublicKeyword","ProtectedKeyword","PrivateKeyword","findNextToken","previousToken","find","n","firstDefined","getChildren","child","shouldDiveInChildNode","nodeHasTokens","undefined","findFirstMatchingAncestor","predicate","hasJSXAncestor","unescapeStringLiteralText","text","replace","entity","item","slice","codePoint","parseInt","String","fromCodePoint","xhtmlEntities","isComputedProperty","ComputedPropertyName","isOptional","questionToken","QuestionToken","isChainExpression","type","ChainExpression","isChildUnwrappableOptionalChain","expression","ParenthesizedExpression","getTokenType","keywordKind","Identifier","identifierToKeywordKind","originalKeywordKind","NullKeyword","AST_TOKEN_TYPES","Null","FirstFutureReservedWord","LastKeyword","Keyword","FirstKeyword","LastFutureReservedWord","FalseKeyword","TrueKeyword","Boolean","FirstPunctuation","LastPunctuation","Punctuator","NoSubstitutionTemplateLiteral","TemplateTail","Template","NumericLiteral","Numeric","JsxText","JSXText","StringLiteral","RegularExpressionLiteral","RegularExpression","ConstructorKeyword","GetKeyword","SetKeyword","JSXIdentifier","PropertyAccessExpression","convertToken","getFullStart","value","tokenType","range","regex","pattern","lastIndexOf","convertTokens","result","walk","EndOfFileToken","converted","push","forEach","TSError","Error","constructor","message","fileName","index","lineNumber","Object","defineProperty","new","target","name","enumerable","configurable","createError","jsDoc","getWidth","array","callback","i","identifierIsThisKeyword","id","ThisKeyword","isThisIdentifier","isThisInTypeQuery","isQualifiedName","left","TypeQuery"],"sources":["../src/node-utils.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}