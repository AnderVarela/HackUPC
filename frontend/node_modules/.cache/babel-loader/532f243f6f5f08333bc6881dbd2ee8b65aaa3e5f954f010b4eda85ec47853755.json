{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Converter = exports.convertError = void 0;\n// There's lots of funny stuff due to the typing of ts.Node\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst node_utils_1 = require(\"./node-utils\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst version_check_1 = require(\"./version-check\");\nconst SyntaxKind = ts.SyntaxKind;\n/**\n * Extends and formats a given error object\n * @param error the error object\n * @returns converted error object\n */\nfunction convertError(error) {\n  return (0, node_utils_1.createError)(error.file, error.start, 'message' in error && error.message || error.messageText);\n}\nexports.convertError = convertError;\nclass Converter {\n  /**\n   * Converts a TypeScript node into an ESTree node\n   * @param ast the full TypeScript AST\n   * @param options additional options for the conversion\n   * @returns the converted ESTreeNode\n   */\n  constructor(ast, options) {\n    this.esTreeNodeToTSNodeMap = new WeakMap();\n    this.tsNodeToESTreeNodeMap = new WeakMap();\n    this.allowPattern = false;\n    this.inTypeMode = false;\n    this.ast = ast;\n    this.options = Object.assign({}, options);\n  }\n  getASTMaps() {\n    return {\n      esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,\n      tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap\n    };\n  }\n  convertProgram() {\n    return this.converter(this.ast);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @param inTypeMode flag to determine if we are in typeMode\n   * @param allowPattern flag to determine if patterns are allowed\n   * @returns the converted ESTree node\n   */\n  converter(node, parent, inTypeMode, allowPattern) {\n    /**\n     * Exit early for null and undefined\n     */\n    if (!node) {\n      return null;\n    }\n    const typeMode = this.inTypeMode;\n    const pattern = this.allowPattern;\n    if (inTypeMode !== undefined) {\n      this.inTypeMode = inTypeMode;\n    }\n    if (allowPattern !== undefined) {\n      this.allowPattern = allowPattern;\n    }\n    const result = this.convertNode(node, parent !== null && parent !== void 0 ? parent : node.parent);\n    this.registerTSNodeInNodeMap(node, result);\n    this.inTypeMode = typeMode;\n    this.allowPattern = pattern;\n    return result;\n  }\n  /**\n   * Fixes the exports of the given ts.Node\n   * @param node the ts.Node\n   * @param result result\n   * @returns the ESTreeNode with fixed exports\n   */\n  fixExports(node, result) {\n    // check for exports\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n    if ((modifiers === null || modifiers === void 0 ? void 0 : modifiers[0].kind) === SyntaxKind.ExportKeyword) {\n      /**\n       * Make sure that original node is registered instead of export\n       */\n      this.registerTSNodeInNodeMap(node, result);\n      const exportKeyword = modifiers[0];\n      const nextModifier = modifiers[1];\n      const declarationIsDefault = nextModifier && nextModifier.kind === SyntaxKind.DefaultKeyword;\n      const varToken = declarationIsDefault ? (0, node_utils_1.findNextToken)(nextModifier, this.ast, this.ast) : (0, node_utils_1.findNextToken)(exportKeyword, this.ast, this.ast);\n      result.range[0] = varToken.getStart(this.ast);\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n      if (declarationIsDefault) {\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n          declaration: result,\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          exportKind: 'value'\n        });\n      } else {\n        const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration || result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n        const isDeclare = 'declare' in result && result.declare === true;\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n          // @ts-expect-error - TODO, narrow the types here\n          declaration: result,\n          specifiers: [],\n          source: null,\n          exportKind: isType || isDeclare ? 'type' : 'value',\n          range: [exportKeyword.getStart(this.ast), result.range[1]],\n          assertions: []\n        });\n      }\n    }\n    return result;\n  }\n  /**\n   * Register specific TypeScript node into map with first ESTree node provided\n   */\n  registerTSNodeInNodeMap(node, result) {\n    if (result && this.options.shouldPreserveNodeMaps) {\n      if (!this.tsNodeToESTreeNodeMap.has(node)) {\n        this.tsNodeToESTreeNodeMap.set(node, result);\n      }\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertPattern(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, true);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertChild(child, parent) {\n    return this.converter(child, parent, this.inTypeMode, false);\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * @param child the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertType(child, parent) {\n    return this.converter(child, parent, true, false);\n  }\n  createNode(node, data) {\n    const result = data;\n    if (!result.range) {\n      result.range = (0, node_utils_1.getRange)(\n      // this is completely valid, but TS hates it\n      node, this.ast);\n    }\n    if (!result.loc) {\n      result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n    }\n    if (result && this.options.shouldPreserveNodeMaps) {\n      this.esTreeNodeToTSNodeMap.set(result, node);\n    }\n    return result;\n  }\n  convertBindingNameWithTypeAnnotation(name, tsType, parent) {\n    const id = this.convertPattern(name);\n    if (tsType) {\n      id.typeAnnotation = this.convertTypeAnnotation(tsType, parent);\n      this.fixParentLocation(id, id.typeAnnotation.range);\n    }\n    return id;\n  }\n  /**\n   * Converts a child into a type annotation. This creates an intermediary\n   * TypeAnnotation node to match what Flow does.\n   * @param child The TypeScript AST node to convert.\n   * @param parent parentNode\n   * @returns The type annotation node.\n   */\n  convertTypeAnnotation(child, parent) {\n    // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon\n    const offset = (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.FunctionType || (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.ConstructorType ? 2 : 1;\n    const annotationStartCol = child.getFullStart() - offset;\n    const loc = (0, node_utils_1.getLocFor)(annotationStartCol, child.end, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,\n      loc,\n      range: [annotationStartCol, child.end],\n      typeAnnotation: this.convertType(child)\n    };\n  }\n  /**\n   * Coverts body Nodes and add a directive field to StringLiterals\n   * @param nodes of ts.Node\n   * @param parent parentNode\n   * @returns Array of body statements\n   */\n  convertBodyExpressions(nodes, parent) {\n    let allowDirectives = (0, node_utils_1.canContainDirective)(parent);\n    return nodes.map(statement => {\n      const child = this.convertChild(statement);\n      if (allowDirectives) {\n        if ((child === null || child === void 0 ? void 0 : child.expression) && ts.isExpressionStatement(statement) && ts.isStringLiteral(statement.expression)) {\n          const raw = child.expression.raw;\n          child.directive = raw.slice(1, -1);\n          return child; // child can be null, but it's filtered below\n        } else {\n          allowDirectives = false;\n        }\n      }\n      return child; // child can be null, but it's filtered below\n    })\n    // filter out unknown nodes for now\n    .filter(statement => statement);\n  }\n  /**\n   * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node\n   * @param typeArguments ts.NodeArray typeArguments\n   * @param node parent used to create this node\n   * @returns TypeParameterInstantiation node\n   */\n  convertTypeArgumentsToTypeParameters(typeArguments, node) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeArguments, this.ast, this.ast);\n    return this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,\n      range: [typeArguments.pos - 1, greaterThanToken.end],\n      params: typeArguments.map(typeArgument => this.convertType(typeArgument))\n    });\n  }\n  /**\n   * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node\n   * @param typeParameters ts.Node typeParameters\n   * @returns TypeParameterDeclaration node\n   */\n  convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {\n    const greaterThanToken = (0, node_utils_1.findNextToken)(typeParameters, this.ast, this.ast);\n    return {\n      type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,\n      range: [typeParameters.pos - 1, greaterThanToken.end],\n      loc: (0, node_utils_1.getLocFor)(typeParameters.pos - 1, greaterThanToken.end, this.ast),\n      params: typeParameters.map(typeParameter => this.convertType(typeParameter))\n    };\n  }\n  /**\n   * Converts an array of ts.Node parameters into an array of ESTreeNode params\n   * @param parameters An array of ts.Node params to be converted\n   * @returns an array of converted ESTreeNode params\n   */\n  convertParameters(parameters) {\n    if (!(parameters === null || parameters === void 0 ? void 0 : parameters.length)) {\n      return [];\n    }\n    return parameters.map(param => {\n      const convertedParam = this.convertChild(param);\n      const decorators = (0, getModifiers_1.getDecorators)(param);\n      if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n        convertedParam.decorators = decorators.map(el => this.convertChild(el));\n      }\n      return convertedParam;\n    });\n  }\n  convertChainExpression(node, tsNode) {\n    const {\n      child,\n      isOptional\n    } = (() => {\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        return {\n          child: node.object,\n          isOptional: node.optional\n        };\n      }\n      if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        return {\n          child: node.callee,\n          isOptional: node.optional\n        };\n      }\n      return {\n        child: node.expression,\n        isOptional: false\n      };\n    })();\n    const isChildUnwrappable = (0, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);\n    if (!isChildUnwrappable && !isOptional) {\n      return node;\n    }\n    if (isChildUnwrappable && (0, node_utils_1.isChainExpression)(child)) {\n      // unwrap the chain expression child\n      const newChild = child.expression;\n      if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n        node.object = newChild;\n      } else if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n        node.callee = newChild;\n      } else {\n        node.expression = newChild;\n      }\n    }\n    return this.createNode(tsNode, {\n      type: ts_estree_1.AST_NODE_TYPES.ChainExpression,\n      expression: node\n    });\n  }\n  /**\n   * For nodes that are copied directly from the TypeScript AST into\n   * ESTree mostly as-is. The only difference is the addition of a type\n   * property instead of a kind property. Recursively copies all children.\n   */\n  deeplyCopy(node) {\n    if (node.kind === ts.SyntaxKind.JSDocFunctionType) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'JSDoc types can only be used inside documentation comments.');\n    }\n    const customType = `TS${SyntaxKind[node.kind]}`;\n    /**\n     * If the \"errorOnUnknownASTType\" option is set to true, throw an error,\n     * otherwise fallback to just including the unknown type as-is.\n     */\n    if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {\n      throw new Error(`Unknown AST_NODE_TYPE: \"${customType}\"`);\n    }\n    const result = this.createNode(node, {\n      type: customType\n    });\n    if ('type' in node) {\n      result.typeAnnotation = node.type && 'kind' in node.type && ts.isTypeNode(node.type) ? this.convertTypeAnnotation(node.type, node) : null;\n    }\n    if ('typeArguments' in node) {\n      result.typeParameters = node.typeArguments && 'pos' in node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null;\n    }\n    if ('typeParameters' in node) {\n      result.typeParameters = node.typeParameters && 'pos' in node.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters) : null;\n    }\n    const decorators = (0, getModifiers_1.getDecorators)(node);\n    if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {\n      result.decorators = decorators.map(el => this.convertChild(el));\n    }\n    // keys we never want to clone from the base typescript node as they\n    // introduce garbage into our AST\n    const KEYS_TO_NOT_COPY = new Set(['_children', 'decorators', 'end', 'flags', 'illegalDecorators', 'heritageClauses', 'locals', 'localSymbol', 'jsDoc', 'kind', 'modifierFlagsCache', 'modifiers', 'nextContainer', 'parent', 'pos', 'symbol', 'transformFlags', 'type', 'typeArguments', 'typeParameters']);\n    Object.entries(node).filter(([key]) => !KEYS_TO_NOT_COPY.has(key)).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        result[key] = value.map(el => this.convertChild(el));\n      } else if (value && typeof value === 'object' && value.kind) {\n        // need to check node[key].kind to ensure we don't try to convert a symbol\n        result[key] = this.convertChild(value);\n      } else {\n        result[key] = value;\n      }\n    });\n    return result;\n  }\n  convertJSXIdentifier(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n      name: node.getText()\n    });\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n  convertJSXNamespaceOrIdentifier(node) {\n    // TypeScript@5.1 added in ts.JsxNamespacedName directly\n    // We prefer using that if it's relevant for this node type\n    if (node.kind === ts.SyntaxKind.JsxNamespacedName) {\n      const result = this.createNode(node, {\n        type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n        namespace: this.createNode(node.namespace, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: node.namespace.text\n        }),\n        name: this.createNode(node.name, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: node.name.text\n        })\n      });\n      this.registerTSNodeInNodeMap(node, result);\n      return result;\n    }\n    // TypeScript@<5.1 has to manually parse the JSX attributes\n    const text = node.getText();\n    const colonIndex = text.indexOf(':');\n    // this is intentional we can ignore conversion if `:` is in first character\n    if (colonIndex > 0) {\n      const range = (0, node_utils_1.getRange)(node, this.ast);\n      // @ts-expect-error -- TypeScript@<5.1 doesn't have ts.JsxNamespacedName\n      const result = this.createNode(node, {\n        type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n        namespace: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(0, colonIndex),\n          range: [range[0], range[0] + colonIndex]\n        }),\n        name: this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n          name: text.slice(colonIndex + 1),\n          range: [range[0] + colonIndex + 1, range[1]]\n        }),\n        range\n      });\n      this.registerTSNodeInNodeMap(node, result);\n      return result;\n    }\n    return this.convertJSXIdentifier(node);\n  }\n  /**\n   * Converts a TypeScript JSX node.tagName into an ESTree node.name\n   * @param node the tagName object from a JSX ts.Node\n   * @param parent\n   * @returns the converted ESTree name object\n   */\n  convertJSXTagName(node, parent) {\n    let result;\n    switch (node.kind) {\n      case SyntaxKind.PropertyAccessExpression:\n        if (node.name.kind === SyntaxKind.PrivateIdentifier) {\n          // This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.\n          // So we shouldn't ever get into this state to begin with.\n          throw new Error('Non-private identifier expected.');\n        }\n        result = this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,\n          object: this.convertJSXTagName(node.expression, parent),\n          property: this.convertJSXIdentifier(node.name)\n        });\n        break;\n      case SyntaxKind.ThisKeyword:\n      case SyntaxKind.Identifier:\n      default:\n        return this.convertJSXNamespaceOrIdentifier(node);\n    }\n    this.registerTSNodeInNodeMap(node, result);\n    return result;\n  }\n  convertMethodSignature(node) {\n    const result = this.createNode(node, {\n      type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,\n      computed: (0, node_utils_1.isComputedProperty)(node.name),\n      key: this.convertChild(node.name),\n      params: this.convertParameters(node.parameters),\n      kind: (() => {\n        switch (node.kind) {\n          case SyntaxKind.GetAccessor:\n            return 'get';\n          case SyntaxKind.SetAccessor:\n            return 'set';\n          case SyntaxKind.MethodSignature:\n            return 'method';\n        }\n      })()\n    });\n    if ((0, node_utils_1.isOptional)(node)) {\n      result.optional = true;\n    }\n    if (node.type) {\n      result.returnType = this.convertTypeAnnotation(node.type, node);\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n      result.readonly = true;\n    }\n    if (node.typeParameters) {\n      result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n    }\n    const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n    if (accessibility) {\n      result.accessibility = accessibility;\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n      result.export = true;\n    }\n    if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n      result.static = true;\n    }\n    return result;\n  }\n  convertAssertClasue(node) {\n    return node === undefined ? [] : node.elements.map(element => this.convertChild(element));\n  }\n  /**\n   * Applies the given TS modifiers to the given result object.\n   *\n   * This method adds not standardized `modifiers` property in nodes\n   *\n   * @param result\n   * @param modifiers original ts.Nodes from the node.modifiers array\n   * @returns the current result object will be mutated\n   */\n  applyModifiersToResult(result, modifiers) {\n    if (!modifiers) {\n      return;\n    }\n    const remainingModifiers = [];\n    /**\n     * Some modifiers are explicitly handled by applying them as\n     * boolean values on the result node. As well as adding them\n     * to the result, we remove them from the array, so that they\n     * are not handled twice.\n     */\n    for (const modifier of modifiers) {\n      switch (modifier.kind) {\n        /**\n         * Ignore ExportKeyword and DefaultKeyword, they are handled\n         * via the fixExports utility function\n         */\n        case SyntaxKind.ExportKeyword:\n        case SyntaxKind.DefaultKeyword:\n          break;\n        case SyntaxKind.ConstKeyword:\n          result.const = true;\n          break;\n        case SyntaxKind.DeclareKeyword:\n          result.declare = true;\n          break;\n        default:\n          remainingModifiers.push(this.convertChild(modifier));\n          break;\n      }\n    }\n    /**\n     * If there are still valid modifiers available which have\n     * not been explicitly handled above, we just convert and\n     * add the modifiers array to the result node.\n     */\n    if (remainingModifiers.length > 0) {\n      result.modifiers = remainingModifiers;\n    }\n  }\n  /**\n   * Uses the provided range location to adjust the location data of the given Node\n   * @param result The node that will have its location data mutated\n   * @param childRange The child node range used to expand location\n   */\n  fixParentLocation(result, childRange) {\n    if (childRange[0] < result.range[0]) {\n      result.range[0] = childRange[0];\n      result.loc.start = (0, node_utils_1.getLineAndCharacterFor)(result.range[0], this.ast);\n    }\n    if (childRange[1] > result.range[1]) {\n      result.range[1] = childRange[1];\n      result.loc.end = (0, node_utils_1.getLineAndCharacterFor)(result.range[1], this.ast);\n    }\n  }\n  assertModuleSpecifier(node, allowNull) {\n    var _a;\n    if (!allowNull && node.moduleSpecifier == null) {\n      throw (0, node_utils_1.createError)(this.ast, node.pos, 'Module specifier must be a string literal.');\n    }\n    if (node.moduleSpecifier && ((_a = node.moduleSpecifier) === null || _a === void 0 ? void 0 : _a.kind) !== SyntaxKind.StringLiteral) {\n      throw (0, node_utils_1.createError)(this.ast, node.moduleSpecifier.pos, 'Module specifier must be a string literal.');\n    }\n  }\n  /**\n   * Converts a TypeScript node into an ESTree node.\n   * The core of the conversion logic:\n   * Identify and convert each relevant TypeScript SyntaxKind\n   * @param node the child ts.Node\n   * @param parent parentNode\n   * @returns the converted ESTree node\n   */\n  convertNode(node, parent) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    switch (node.kind) {\n      case SyntaxKind.SourceFile:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Program,\n            body: this.convertBodyExpressions(node.statements, node),\n            sourceType: node.externalModuleIndicator ? 'module' : 'script',\n            range: [node.getStart(this.ast), node.endOfFileToken.end]\n          });\n        }\n      case SyntaxKind.Block:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.BlockStatement,\n            body: this.convertBodyExpressions(node.statements, node)\n          });\n        }\n      case SyntaxKind.Identifier:\n        {\n          if ((0, node_utils_1.isThisInTypeQuery)(node)) {\n            // special case for `typeof this.foo` - TS emits an Identifier for `this`\n            // but we want to treat it as a ThisExpression for consistency\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n            });\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: node.text\n          });\n        }\n      case SyntaxKind.PrivateIdentifier:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,\n            // typescript includes the `#` in the text\n            name: node.text.slice(1)\n          });\n        }\n      case SyntaxKind.WithStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WithStatement,\n          object: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      // Control Flow\n      case SyntaxKind.ReturnStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.LabeledStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,\n          label: this.convertChild(node.label),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ContinueStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,\n          label: this.convertChild(node.label)\n        });\n      case SyntaxKind.BreakStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.BreakStatement,\n          label: this.convertChild(node.label)\n        });\n      // Choice\n      case SyntaxKind.IfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.IfStatement,\n          test: this.convertChild(node.expression),\n          consequent: this.convertChild(node.thenStatement),\n          alternate: this.convertChild(node.elseStatement)\n        });\n      case SyntaxKind.SwitchStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,\n          discriminant: this.convertChild(node.expression),\n          cases: node.caseBlock.clauses.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.CaseClause:\n      case SyntaxKind.DefaultClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.SwitchCase,\n          // expression is present in case only\n          test: node.kind === SyntaxKind.CaseClause ? this.convertChild(node.expression) : null,\n          consequent: node.statements.map(el => this.convertChild(el))\n        });\n      // Exceptions\n      case SyntaxKind.ThrowStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TryStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TryStatement,\n          block: this.convertChild(node.tryBlock),\n          handler: this.convertChild(node.catchClause),\n          finalizer: this.convertChild(node.finallyBlock)\n        });\n      case SyntaxKind.CatchClause:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.CatchClause,\n          param: node.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type) : null,\n          body: this.convertChild(node.block)\n        });\n      // Loops\n      case SyntaxKind.WhileStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.WhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      /**\n       * Unlike other parsers, TypeScript calls a \"DoWhileStatement\"\n       * a \"DoStatement\"\n       */\n      case SyntaxKind.DoStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,\n          test: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForStatement,\n          init: this.convertChild(node.initializer),\n          test: this.convertChild(node.condition),\n          update: this.convertChild(node.incrementor),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForInStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForInStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement)\n        });\n      case SyntaxKind.ForOfStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,\n          left: this.convertPattern(node.initializer),\n          right: this.convertChild(node.expression),\n          body: this.convertChild(node.statement),\n          await: Boolean(node.awaitModifier && node.awaitModifier.kind === SyntaxKind.AwaitKeyword)\n        });\n      // Declarations\n      case SyntaxKind.FunctionDeclaration:\n        {\n          const isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n          const result = this.createNode(node, {\n            type: isDeclare || !node.body ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body) || undefined\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (isDeclare) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.VariableDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,\n            id: this.convertBindingNameWithTypeAnnotation(node.name, node.type, node),\n            init: this.convertChild(node.initializer)\n          });\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n          return result;\n        }\n      case SyntaxKind.VariableStatement:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n            declarations: node.declarationList.declarations.map(el => this.convertChild(el)),\n            kind: (0, node_utils_1.getDeclarationKind)(node.declarationList)\n          });\n          /**\n           * Semantically, decorators are not allowed on variable declarations,\n           * Pre 4.8 TS would include them in the AST, so we did as well.\n           * However as of 4.8 TS no longer includes it (as it is, well, invalid).\n           *\n           * So for consistency across versions, we no longer include it either.\n           */\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      // mostly for for-of, for-in\n      case SyntaxKind.VariableDeclarationList:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n          declarations: node.declarations.map(el => this.convertChild(el)),\n          kind: (0, node_utils_1.getDeclarationKind)(node)\n        });\n      // Expressions\n      case SyntaxKind.ExpressionStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,\n          expression: this.convertChild(node.expression)\n        });\n      case SyntaxKind.ThisKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ThisExpression\n        });\n      case SyntaxKind.ArrayLiteralExpression:\n        {\n          // TypeScript uses ArrayLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n              elements: node.elements.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,\n              elements: node.elements.map(el => this.convertChild(el))\n            });\n          }\n        }\n      case SyntaxKind.ObjectLiteralExpression:\n        {\n          // TypeScript uses ObjectLiteralExpression in destructuring assignment, too\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n              properties: node.properties.map(el => this.convertPattern(el))\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n              properties: node.properties.map(el => this.convertChild(el))\n            });\n          }\n        }\n      case SyntaxKind.PropertyAssignment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Property,\n          key: this.convertChild(node.name),\n          value: this.converter(node.initializer, node, this.inTypeMode, this.allowPattern),\n          computed: (0, node_utils_1.isComputedProperty)(node.name),\n          method: false,\n          shorthand: false,\n          kind: 'init'\n        });\n      case SyntaxKind.ShorthandPropertyAssignment:\n        {\n          if (node.objectAssignmentInitializer) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.name),\n                right: this.convertChild(node.objectAssignmentInitializer)\n              }),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: this.convertChild(node.name),\n              computed: false,\n              method: false,\n              shorthand: true,\n              kind: 'init'\n            });\n          }\n        }\n      case SyntaxKind.ComputedPropertyName:\n        return this.convertChild(node.expression);\n      case SyntaxKind.PropertyDeclaration:\n        {\n          const isAbstract = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);\n          const isAccessor = (0, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);\n          // eslint-disable-next-line @typescript-eslint/explicit-function-return-type -- TODO - add ignore IIFE option\n          const type = (() => {\n            if (isAccessor) {\n              if (isAbstract) {\n                return ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;\n              }\n              return ts_estree_1.AST_NODE_TYPES.AccessorProperty;\n            }\n            if (isAbstract) {\n              return ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;\n            }\n            return ts_estree_1.AST_NODE_TYPES.PropertyDefinition;\n          })();\n          const result = this.createNode(node, {\n            type,\n            key: this.convertChild(node.name),\n            value: isAbstract ? null : this.convertChild(node.initializer),\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n            override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n          });\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          if ((node.name.kind === SyntaxKind.Identifier || node.name.kind === SyntaxKind.ComputedPropertyName || node.name.kind === SyntaxKind.PrivateIdentifier) && node.questionToken) {\n            result.optional = true;\n          }\n          if (node.exclamationToken) {\n            result.definite = true;\n          }\n          if (result.key.type === ts_estree_1.AST_NODE_TYPES.Literal && node.questionToken) {\n            result.optional = true;\n          }\n          return result;\n        }\n      case SyntaxKind.GetAccessor:\n      case SyntaxKind.SetAccessor:\n        {\n          if (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) {\n            return this.convertMethodSignature(node);\n          }\n        }\n      // otherwise, it is a non-type accessor - intentional fallthrough\n      case SyntaxKind.MethodDeclaration:\n        {\n          const method = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            generator: !!node.asteriskToken,\n            expression: false,\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end],\n            params: []\n          });\n          if (node.type) {\n            method.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(method, method.typeParameters.range);\n          }\n          let result;\n          if (parent.kind === SyntaxKind.ObjectLiteralExpression) {\n            method.params = node.parameters.map(el => this.convertChild(el));\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.Property,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              method: node.kind === SyntaxKind.MethodDeclaration,\n              shorthand: false,\n              kind: 'init'\n            });\n          } else {\n            // class\n            /**\n             * Unlike in object literal methods, class method params can have decorators\n             */\n            method.params = this.convertParameters(node.parameters);\n            /**\n             * TypeScript class methods can be defined as \"abstract\"\n             */\n            const methodDefinitionType = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition;\n            result = this.createNode(node, {\n              type: methodDefinitionType,\n              key: this.convertChild(node.name),\n              value: method,\n              computed: (0, node_utils_1.isComputedProperty)(node.name),\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n              kind: 'method',\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)\n            });\n            const decorators = (0, getModifiers_1.getDecorators)(node);\n            if (decorators) {\n              result.decorators = decorators.map(el => this.convertChild(el));\n            }\n            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n            if (accessibility) {\n              result.accessibility = accessibility;\n            }\n          }\n          if (node.questionToken) {\n            result.optional = true;\n          }\n          if (node.kind === SyntaxKind.GetAccessor) {\n            result.kind = 'get';\n          } else if (node.kind === SyntaxKind.SetAccessor) {\n            result.kind = 'set';\n          } else if (!result.static && node.name.kind === SyntaxKind.StringLiteral && node.name.text === 'constructor' && result.type !== ts_estree_1.AST_NODE_TYPES.Property) {\n            result.kind = 'constructor';\n          }\n          return result;\n        }\n      // TypeScript uses this even for static methods named \"constructor\"\n      case SyntaxKind.Constructor:\n        {\n          const lastModifier = (0, node_utils_1.getLastModifier)(node);\n          const constructorToken = lastModifier && (0, node_utils_1.findNextToken)(lastModifier, node, this.ast) || node.getFirstToken();\n          const constructor = this.createNode(node, {\n            type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            generator: false,\n            expression: false,\n            async: false,\n            body: this.convertChild(node.body),\n            range: [node.parameters.pos - 1, node.end]\n          });\n          // Process typeParameters\n          if (node.typeParameters) {\n            constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n            this.fixParentLocation(constructor, constructor.typeParameters.range);\n          }\n          // Process returnType\n          if (node.type) {\n            constructor.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          const constructorKey = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n            name: 'constructor',\n            range: [constructorToken.getStart(this.ast), constructorToken.end]\n          });\n          const isStatic = (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);\n          const result = this.createNode(node, {\n            type: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition,\n            key: constructorKey,\n            value: constructor,\n            computed: false,\n            static: isStatic,\n            kind: isStatic ? 'method' : 'constructor',\n            override: false\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          return result;\n        }\n      case SyntaxKind.FunctionExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n            id: this.convertChild(node.name),\n            generator: !!node.asteriskToken,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: false\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.SuperKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Super\n        });\n      case SyntaxKind.ArrayBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n          elements: node.elements.map(el => this.convertPattern(el))\n        });\n      // occurs with missing array elements like [,]\n      case SyntaxKind.OmittedExpression:\n        return null;\n      case SyntaxKind.ObjectBindingPattern:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n          properties: node.elements.map(el => this.convertPattern(el))\n        });\n      case SyntaxKind.BindingElement:\n        {\n          if (parent.kind === SyntaxKind.ArrayBindingPattern) {\n            const arrayItem = this.convertChild(node.name, parent);\n            if (node.initializer) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: arrayItem,\n                right: this.convertChild(node.initializer)\n              });\n            } else if (node.dotDotDotToken) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: arrayItem\n              });\n            } else {\n              return arrayItem;\n            }\n          } else {\n            let result;\n            if (node.dotDotDotToken) {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                argument: this.convertChild((_a = node.propertyName) !== null && _a !== void 0 ? _a : node.name)\n              });\n            } else {\n              result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.Property,\n                key: this.convertChild((_b = node.propertyName) !== null && _b !== void 0 ? _b : node.name),\n                value: this.convertChild(node.name),\n                computed: Boolean(node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName),\n                method: false,\n                shorthand: !node.propertyName,\n                kind: 'init'\n              });\n            }\n            if (node.initializer) {\n              result.value = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertChild(node.name),\n                right: this.convertChild(node.initializer),\n                range: [node.name.getStart(this.ast), node.initializer.end]\n              });\n            }\n            return result;\n          }\n        }\n      case SyntaxKind.ArrowFunction:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,\n            generator: false,\n            id: null,\n            params: this.convertParameters(node.parameters),\n            body: this.convertChild(node.body),\n            async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n            expression: node.body.kind !== SyntaxKind.Block\n          });\n          // Process returnType\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.YieldExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.YieldExpression,\n          delegate: !!node.asteriskToken,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.AwaitExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,\n          argument: this.convertChild(node.expression)\n        });\n      // Template Literals\n      case SyntaxKind.NoSubstitutionTemplateLiteral:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n          quasis: [this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),\n              cooked: node.text\n            },\n            tail: true\n          })],\n          expressions: []\n        });\n      case SyntaxKind.TemplateExpression:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n            quasis: [this.convertChild(node.head)],\n            expressions: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.expressions.push(this.convertChild(templateSpan.expression));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n      case SyntaxKind.TaggedTemplateExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          tag: this.convertChild(node.tag),\n          quasi: this.convertChild(node.template)\n        });\n      case SyntaxKind.TemplateHead:\n      case SyntaxKind.TemplateMiddle:\n      case SyntaxKind.TemplateTail:\n        {\n          const tail = node.kind === SyntaxKind.TemplateTail;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n            value: {\n              raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),\n              cooked: node.text\n            },\n            tail\n          });\n        }\n      // Patterns\n      case SyntaxKind.SpreadAssignment:\n      case SyntaxKind.SpreadElement:\n        {\n          if (this.allowPattern) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertPattern(node.expression)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SpreadElement,\n              argument: this.convertChild(node.expression)\n            });\n          }\n        }\n      case SyntaxKind.Parameter:\n        {\n          let parameter;\n          let result;\n          if (node.dotDotDotToken) {\n            parameter = result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.RestElement,\n              argument: this.convertChild(node.name)\n            });\n          } else if (node.initializer) {\n            parameter = this.convertChild(node.name);\n            result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n              left: parameter,\n              right: this.convertChild(node.initializer)\n            });\n            const modifiers = (0, getModifiers_1.getModifiers)(node);\n            if (modifiers) {\n              // AssignmentPattern should not contain modifiers in range\n              result.range[0] = parameter.range[0];\n              result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);\n            }\n          } else {\n            parameter = result = this.convertChild(node.name, parent);\n          }\n          if (node.type) {\n            parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            this.fixParentLocation(parameter, parameter.typeAnnotation.range);\n          }\n          if (node.questionToken) {\n            if (node.questionToken.end > parameter.range[1]) {\n              parameter.range[1] = node.questionToken.end;\n              parameter.loc.end = (0, node_utils_1.getLineAndCharacterFor)(parameter.range[1], this.ast);\n            }\n            parameter.optional = true;\n          }\n          const modifiers = (0, getModifiers_1.getModifiers)(node);\n          if (modifiers) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,\n              accessibility: (_c = (0, node_utils_1.getTSNodeAccessibility)(node)) !== null && _c !== void 0 ? _c : undefined,\n              readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n              export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined,\n              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node) || undefined,\n              parameter: result\n            });\n          }\n          return result;\n        }\n      // Classes\n      case SyntaxKind.ClassDeclaration:\n      case SyntaxKind.ClassExpression:\n        {\n          const heritageClauses = (_d = node.heritageClauses) !== null && _d !== void 0 ? _d : [];\n          const classNodeType = node.kind === SyntaxKind.ClassDeclaration ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration : ts_estree_1.AST_NODE_TYPES.ClassExpression;\n          const superClass = heritageClauses.find(clause => clause.token === SyntaxKind.ExtendsKeyword);\n          const implementsClause = heritageClauses.find(clause => clause.token === SyntaxKind.ImplementsKeyword);\n          const result = this.createNode(node, {\n            type: classNodeType,\n            id: this.convertChild(node.name),\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ClassBody,\n              body: [],\n              range: [node.members.pos - 1, node.end]\n            }),\n            superClass: (superClass === null || superClass === void 0 ? void 0 : superClass.types[0]) ? this.convertChild(superClass.types[0].expression) : null\n          });\n          if (superClass) {\n            if (superClass.types.length > 1) {\n              throw (0, node_utils_1.createError)(this.ast, superClass.types[1].pos, 'Classes can only extend a single class.');\n            }\n            if ((_e = superClass.types[0]) === null || _e === void 0 ? void 0 : _e.typeArguments) {\n              result.superTypeParameters = this.convertTypeArgumentsToTypeParameters(superClass.types[0].typeArguments, superClass.types[0]);\n            }\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (implementsClause) {\n            result.implements = implementsClause.types.map(el => this.convertChild(el));\n          }\n          /**\n           * TypeScript class declarations can be defined as \"abstract\"\n           */\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          const decorators = (0, getModifiers_1.getDecorators)(node);\n          if (decorators) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n          }\n          const filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);\n          if (filteredMembers.length) {\n            result.body.body = filteredMembers.map(el => this.convertChild(el));\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      // Modules\n      case SyntaxKind.ModuleBlock:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,\n          body: this.convertBodyExpressions(node.statements, node)\n        });\n      case SyntaxKind.ImportDeclaration:\n        {\n          this.assertModuleSpecifier(node, false);\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,\n            source: this.convertChild(node.moduleSpecifier),\n            specifiers: [],\n            importKind: 'value',\n            assertions: this.convertAssertClasue(node.assertClause)\n          });\n          if (node.importClause) {\n            if (node.importClause.isTypeOnly) {\n              result.importKind = 'type';\n            }\n            if (node.importClause.name) {\n              result.specifiers.push(this.convertChild(node.importClause));\n            }\n            if (node.importClause.namedBindings) {\n              switch (node.importClause.namedBindings.kind) {\n                case SyntaxKind.NamespaceImport:\n                  result.specifiers.push(this.convertChild(node.importClause.namedBindings));\n                  break;\n                case SyntaxKind.NamedImports:\n                  result.specifiers = result.specifiers.concat(node.importClause.namedBindings.elements.map(el => this.convertChild(el)));\n                  break;\n              }\n            }\n          }\n          return result;\n        }\n      case SyntaxKind.NamespaceImport:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,\n          local: this.convertChild(node.name)\n        });\n      case SyntaxKind.ImportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,\n          local: this.convertChild(node.name),\n          imported: this.convertChild((_f = node.propertyName) !== null && _f !== void 0 ? _f : node.name),\n          importKind: node.isTypeOnly ? 'type' : 'value'\n        });\n      case SyntaxKind.ImportClause:\n        {\n          const local = this.convertChild(node.name);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,\n            local,\n            range: local.range\n          });\n        }\n      case SyntaxKind.ExportDeclaration:\n        {\n          if (((_g = node.exportClause) === null || _g === void 0 ? void 0 : _g.kind) === SyntaxKind.NamedExports) {\n            this.assertModuleSpecifier(node, true);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              specifiers: node.exportClause.elements.map(el => this.convertChild(el)),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              declaration: null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          } else {\n            this.assertModuleSpecifier(node, false);\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,\n              source: this.convertChild(node.moduleSpecifier),\n              exportKind: node.isTypeOnly ? 'type' : 'value',\n              exported:\n              // note - for compat with 3.7.x, where node.exportClause is always undefined and\n              //        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this\n              //        cannot be shortened to an optional chain, or else you end up with\n              //        undefined === undefined, and the true path will hard error at runtime\n              node.exportClause && node.exportClause.kind === SyntaxKind.NamespaceExport ? this.convertChild(node.exportClause.name) : null,\n              assertions: this.convertAssertClasue(node.assertClause)\n            });\n          }\n        }\n      case SyntaxKind.ExportSpecifier:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,\n          local: this.convertChild((_h = node.propertyName) !== null && _h !== void 0 ? _h : node.name),\n          exported: this.convertChild(node.name),\n          exportKind: node.isTypeOnly ? 'type' : 'value'\n        });\n      case SyntaxKind.ExportAssignment:\n        if (node.isExportEquals) {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,\n            expression: this.convertChild(node.expression)\n          });\n        } else {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n            declaration: this.convertChild(node.expression),\n            exportKind: 'value'\n          });\n        }\n      // Unary Operations\n      case SyntaxKind.PrefixUnaryExpression:\n      case SyntaxKind.PostfixUnaryExpression:\n        {\n          const operator = (0, node_utils_1.getTextForTokenKind)(node.operator);\n          /**\n           * ESTree uses UpdateExpression for ++/--\n           */\n          if (operator === '++' || operator === '--') {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n              operator,\n              prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n              argument: this.convertChild(node.operand)\n            });\n          }\n        }\n      case SyntaxKind.DeleteExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'delete',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.VoidExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'void',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TypeOfExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n          operator: 'typeof',\n          prefix: true,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.TypeOperator:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,\n          operator: (0, node_utils_1.getTextForTokenKind)(node.operator),\n          typeAnnotation: this.convertChild(node.type)\n        });\n      // Binary Operations\n      case SyntaxKind.BinaryExpression:\n        {\n          // TypeScript uses BinaryExpression for sequences as well\n          if ((0, node_utils_1.isComma)(node.operatorToken)) {\n            const result = this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,\n              expressions: []\n            });\n            const left = this.convertChild(node.left);\n            if (left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression && node.left.kind !== SyntaxKind.ParenthesizedExpression) {\n              result.expressions = result.expressions.concat(left.expressions);\n            } else {\n              result.expressions.push(left);\n            }\n            result.expressions.push(this.convertChild(node.right));\n            return result;\n          } else {\n            const type = (0, node_utils_1.getBinaryExpressionType)(node.operatorToken);\n            if (this.allowPattern && type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {\n              return this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                left: this.convertPattern(node.left, node),\n                right: this.convertChild(node.right)\n              });\n            }\n            return this.createNode(node, {\n              type,\n              operator: (0, node_utils_1.getTextForTokenKind)(node.operatorToken.kind),\n              left: this.converter(node.left, node, this.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),\n              right: this.convertChild(node.right)\n            });\n          }\n        }\n      case SyntaxKind.PropertyAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.name);\n          const computed = false;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.ElementAccessExpression:\n        {\n          const object = this.convertChild(node.expression);\n          const property = this.convertChild(node.argumentExpression);\n          const computed = true;\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n            object,\n            property,\n            computed,\n            optional: node.questionDotToken !== undefined\n          });\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.CallExpression:\n        {\n          if (node.expression.kind === SyntaxKind.ImportKeyword) {\n            if (node.arguments.length !== 1 && node.arguments.length !== 2) {\n              throw (0, node_utils_1.createError)(this.ast, node.arguments.pos, 'Dynamic import requires exactly one or two arguments.');\n            }\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.ImportExpression,\n              source: this.convertChild(node.arguments[0]),\n              attributes: node.arguments[1] ? this.convertChild(node.arguments[1]) : null\n            });\n          }\n          const callee = this.convertChild(node.expression);\n          const args = node.arguments.map(el => this.convertChild(el));\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.CallExpression,\n            callee,\n            arguments: args,\n            optional: node.questionDotToken !== undefined\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return this.convertChainExpression(result, node);\n        }\n      case SyntaxKind.NewExpression:\n        {\n          // NOTE - NewExpression cannot have an optional chain in it\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.NewExpression,\n            callee: this.convertChild(node.expression),\n            arguments: node.arguments ? node.arguments.map(el => this.convertChild(el)) : []\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return result;\n        }\n      case SyntaxKind.ConditionalExpression:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,\n          test: this.convertChild(node.condition),\n          consequent: this.convertChild(node.whenTrue),\n          alternate: this.convertChild(node.whenFalse)\n        });\n      case SyntaxKind.MetaProperty:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.MetaProperty,\n            meta: this.createNode(\n            // TODO: do we really want to convert it to Token?\n            node.getFirstToken(), {\n              type: ts_estree_1.AST_NODE_TYPES.Identifier,\n              name: (0, node_utils_1.getTextForTokenKind)(node.keywordToken)\n            }),\n            property: this.convertChild(node.name)\n          });\n        }\n      case SyntaxKind.Decorator:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Decorator,\n            expression: this.convertChild(node.expression)\n          });\n        }\n      // Literals\n      case SyntaxKind.StringLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: parent.kind === SyntaxKind.JsxAttribute ? (0, node_utils_1.unescapeStringLiteralText)(node.text) : node.text,\n            raw: node.getText()\n          });\n        }\n      case SyntaxKind.NumericLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: Number(node.text),\n            raw: node.getText()\n          });\n        }\n      case SyntaxKind.BigIntLiteral:\n        {\n          const range = (0, node_utils_1.getRange)(node, this.ast);\n          const rawValue = this.ast.text.slice(range[0], range[1]);\n          const bigint = rawValue\n          // remove suffix `n`\n          .slice(0, -1)\n          // `BigInt` doesn't accept numeric separator\n          // and `bigint` property should not include numeric separator\n          .replace(/_/g, '');\n          const value = typeof BigInt !== 'undefined' ? BigInt(bigint) : null;\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            raw: rawValue,\n            value: value,\n            bigint: value == null ? bigint : String(value),\n            range\n          });\n        }\n      case SyntaxKind.RegularExpressionLiteral:\n        {\n          const pattern = node.text.slice(1, node.text.lastIndexOf('/'));\n          const flags = node.text.slice(node.text.lastIndexOf('/') + 1);\n          let regex = null;\n          try {\n            regex = new RegExp(pattern, flags);\n          } catch (exception) {\n            regex = null;\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: regex,\n            raw: node.text,\n            regex: {\n              pattern,\n              flags\n            }\n          });\n        }\n      case SyntaxKind.TrueKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: true,\n          raw: 'true'\n        });\n      case SyntaxKind.FalseKeyword:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.Literal,\n          value: false,\n          raw: 'false'\n        });\n      case SyntaxKind.NullKeyword:\n        {\n          if (!version_check_1.typescriptVersionIsAtLeast['4.0'] && this.inTypeMode) {\n            // 4.0 started nesting null types inside a LiteralType node, but we still need to support pre-4.0\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          }\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.Literal,\n            value: null,\n            raw: 'null'\n          });\n        }\n      case SyntaxKind.EmptyStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.EmptyStatement\n        });\n      case SyntaxKind.DebuggerStatement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement\n        });\n      // JSX\n      case SyntaxKind.JsxElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n          openingElement: this.convertChild(node.openingElement),\n          closingElement: this.convertChild(node.closingElement),\n          children: node.children.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXFragment,\n          openingFragment: this.convertChild(node.openingFragment),\n          closingFragment: this.convertChild(node.closingFragment),\n          children: node.children.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxSelfClosingElement:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n            /**\n             * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,\n             * TypeScript does not seem to have the idea of openingElement when tag is self-closing\n             */\n            openingElement: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n              selfClosing: true,\n              name: this.convertJSXTagName(node.tagName, node),\n              attributes: node.attributes.properties.map(el => this.convertChild(el)),\n              range: (0, node_utils_1.getRange)(node, this.ast)\n            }),\n            closingElement: null,\n            children: []\n          });\n        }\n      case SyntaxKind.JsxOpeningElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,\n          selfClosing: false,\n          name: this.convertJSXTagName(node.tagName, node),\n          attributes: node.attributes.properties.map(el => this.convertChild(el))\n        });\n      case SyntaxKind.JsxClosingElement:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,\n          name: this.convertJSXTagName(node.tagName, node)\n        });\n      case SyntaxKind.JsxOpeningFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment\n        });\n      case SyntaxKind.JsxClosingFragment:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment\n        });\n      case SyntaxKind.JsxExpression:\n        {\n          const expression = node.expression ? this.convertChild(node.expression) : this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,\n            range: [node.getStart(this.ast) + 1, node.getEnd() - 1]\n          });\n          if (node.dotDotDotToken) {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,\n              expression\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,\n              expression\n            });\n          }\n        }\n      case SyntaxKind.JsxAttribute:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,\n            name: this.convertJSXNamespaceOrIdentifier(node.name),\n            value: this.convertChild(node.initializer)\n          });\n        }\n      case SyntaxKind.JsxText:\n        {\n          const start = node.getFullStart();\n          const end = node.getEnd();\n          const text = this.ast.text.slice(start, end);\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXText,\n            value: (0, node_utils_1.unescapeStringLiteralText)(text),\n            raw: text,\n            range: [start, end]\n          });\n        }\n      case SyntaxKind.JsxSpreadAttribute:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,\n          argument: this.convertChild(node.expression)\n        });\n      case SyntaxKind.QualifiedName:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,\n            left: this.convertChild(node.left),\n            right: this.convertChild(node.right)\n          });\n        }\n      // TypeScript specific\n      case SyntaxKind.TypeReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,\n            typeName: this.convertType(node.typeName),\n            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined\n          });\n        }\n      case SyntaxKind.TypeParameter:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,\n            name: this.convertType(node.name),\n            constraint: node.constraint ? this.convertType(node.constraint) : undefined,\n            default: node.default ? this.convertType(node.default) : undefined,\n            in: (0, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),\n            out: (0, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),\n            const: (0, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node)\n          });\n        }\n      case SyntaxKind.ThisType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSThisType\n        });\n      case SyntaxKind.AnyKeyword:\n      case SyntaxKind.BigIntKeyword:\n      case SyntaxKind.BooleanKeyword:\n      case SyntaxKind.NeverKeyword:\n      case SyntaxKind.NumberKeyword:\n      case SyntaxKind.ObjectKeyword:\n      case SyntaxKind.StringKeyword:\n      case SyntaxKind.SymbolKeyword:\n      case SyntaxKind.UnknownKeyword:\n      case SyntaxKind.VoidKeyword:\n      case SyntaxKind.UndefinedKeyword:\n      case SyntaxKind.IntrinsicKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`]\n          });\n        }\n      case SyntaxKind.NonNullExpression:\n        {\n          const nnExpr = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,\n            expression: this.convertChild(node.expression)\n          });\n          return this.convertChainExpression(nnExpr, node);\n        }\n      case SyntaxKind.TypeLiteral:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,\n            members: node.members.map(el => this.convertChild(el))\n          });\n        }\n      case SyntaxKind.ArrayType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSArrayType,\n            elementType: this.convertType(node.elementType)\n          });\n        }\n      case SyntaxKind.IndexedAccessType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,\n            objectType: this.convertType(node.objectType),\n            indexType: this.convertType(node.indexType)\n          });\n        }\n      case SyntaxKind.ConditionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,\n            checkType: this.convertType(node.checkType),\n            extendsType: this.convertType(node.extendsType),\n            trueType: this.convertType(node.trueType),\n            falseType: this.convertType(node.falseType)\n          });\n        }\n      case SyntaxKind.TypeQuery:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,\n            exprName: this.convertType(node.exprName),\n            typeParameters: node.typeArguments && this.convertTypeArgumentsToTypeParameters(node.typeArguments, node)\n          });\n        }\n      case SyntaxKind.MappedType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSMappedType,\n            typeParameter: this.convertType(node.typeParameter),\n            nameType: (_j = this.convertType(node.nameType)) !== null && _j !== void 0 ? _j : null\n          });\n          if (node.readonlyToken) {\n            if (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {\n              result.readonly = true;\n            } else {\n              result.readonly = (0, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind);\n            }\n          }\n          if (node.questionToken) {\n            if (node.questionToken.kind === SyntaxKind.QuestionToken) {\n              result.optional = true;\n            } else {\n              result.optional = (0, node_utils_1.getTextForTokenKind)(node.questionToken.kind);\n            }\n          }\n          if (node.type) {\n            result.typeAnnotation = this.convertType(node.type);\n          }\n          return result;\n        }\n      case SyntaxKind.ParenthesizedExpression:\n        return this.convertChild(node.expression, parent);\n      case SyntaxKind.TypeAliasDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n            id: this.convertChild(node.name),\n            typeAnnotation: this.convertType(node.type)\n          });\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // Process typeParameters\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.MethodSignature:\n        {\n          return this.convertMethodSignature(node);\n        }\n      case SyntaxKind.PropertySignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,\n            optional: (0, node_utils_1.isOptional)(node) || undefined,\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            key: this.convertChild(node.name),\n            typeAnnotation: node.type ? this.convertTypeAnnotation(node.type, node) : undefined,\n            initializer: this.convertChild(\n            // @ts-expect-error TODO breaking change remove this from the AST\n            node.initializer) || undefined,\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,\n            export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined\n          });\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          return result;\n        }\n      case SyntaxKind.IndexSignature:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,\n            parameters: node.parameters.map(el => this.convertChild(el))\n          });\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {\n            result.readonly = true;\n          }\n          const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);\n          if (accessibility) {\n            result.accessibility = accessibility;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {\n            result.export = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {\n            result.static = true;\n          }\n          return result;\n        }\n      case SyntaxKind.ConstructorType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,\n            params: this.convertParameters(node.parameters),\n            abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)\n          });\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.FunctionType:\n      case SyntaxKind.ConstructSignature:\n      case SyntaxKind.CallSignature:\n        {\n          const type = node.kind === SyntaxKind.ConstructSignature ? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration : node.kind === SyntaxKind.CallSignature ? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration : ts_estree_1.AST_NODE_TYPES.TSFunctionType;\n          const result = this.createNode(node, {\n            type: type,\n            params: this.convertParameters(node.parameters)\n          });\n          if (node.type) {\n            result.returnType = this.convertTypeAnnotation(node.type, node);\n          }\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          return result;\n        }\n      case SyntaxKind.ExpressionWithTypeArguments:\n        {\n          const parentKind = parent.kind;\n          const type = parentKind === SyntaxKind.InterfaceDeclaration ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage : parentKind === SyntaxKind.HeritageClause ? ts_estree_1.AST_NODE_TYPES.TSClassImplements : ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;\n          const result = this.createNode(node, {\n            type,\n            expression: this.convertChild(node.expression)\n          });\n          if (node.typeArguments) {\n            result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);\n          }\n          return result;\n        }\n      case SyntaxKind.InterfaceDeclaration:\n        {\n          const interfaceHeritageClauses = (_k = node.heritageClauses) !== null && _k !== void 0 ? _k : [];\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n            body: this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,\n              body: node.members.map(member => this.convertChild(member)),\n              range: [node.members.pos - 1, node.end]\n            }),\n            id: this.convertChild(node.name)\n          });\n          if (node.typeParameters) {\n            result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);\n          }\n          if (interfaceHeritageClauses.length > 0) {\n            const interfaceExtends = [];\n            const interfaceImplements = [];\n            for (const heritageClause of interfaceHeritageClauses) {\n              if (heritageClause.token === SyntaxKind.ExtendsKeyword) {\n                for (const n of heritageClause.types) {\n                  interfaceExtends.push(this.convertChild(n, node));\n                }\n              } else {\n                for (const n of heritageClause.types) {\n                  interfaceImplements.push(this.convertChild(n, node));\n                }\n              }\n            }\n            if (interfaceExtends.length) {\n              result.extends = interfaceExtends;\n            }\n            if (interfaceImplements.length) {\n              result.implements = interfaceImplements;\n            }\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {\n            result.abstract = true;\n          }\n          if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {\n            result.declare = true;\n          }\n          // check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.TypePredicate:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,\n            asserts: node.assertsModifier !== undefined,\n            parameterName: this.convertChild(node.parameterName),\n            typeAnnotation: null\n          });\n          /**\n           * Specific fix for type-guard location data\n           */\n          if (node.type) {\n            result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n            result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;\n            result.typeAnnotation.range = result.typeAnnotation.typeAnnotation.range;\n          }\n          return result;\n        }\n      case SyntaxKind.ImportType:\n        return this.createNode(node, {\n          type: ts_estree_1.AST_NODE_TYPES.TSImportType,\n          isTypeOf: !!node.isTypeOf,\n          parameter: this.convertChild(node.argument),\n          qualifier: this.convertChild(node.qualifier),\n          typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null\n        });\n      case SyntaxKind.EnumDeclaration:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,\n            id: this.convertChild(node.name),\n            members: node.members.map(el => this.convertChild(el))\n          });\n          // apply modifiers first...\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));\n          // ...then check for exports\n          return this.fixExports(node, result);\n        }\n      case SyntaxKind.EnumMember:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,\n            id: this.convertChild(node.name)\n          });\n          if (node.initializer) {\n            result.initializer = this.convertChild(node.initializer);\n          }\n          if (node.name.kind === ts.SyntaxKind.ComputedPropertyName) {\n            result.computed = true;\n          }\n          return result;\n        }\n      case SyntaxKind.ModuleDeclaration:\n        {\n          const result = this.createNode(node, Object.assign({\n            type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration\n          }, (() => {\n            const id = this.convertChild(node.name);\n            const body = this.convertChild(node.body);\n            // the constraints checked by this function are syntactically enforced by TS\n            // the checks mostly exist for type's sake\n            if (node.flags & ts.NodeFlags.GlobalAugmentation) {\n              if (body == null || body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {\n                throw new Error('Expected a valid module body');\n              }\n              if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                throw new Error('global module augmentation must have an Identifier id');\n              }\n              return {\n                kind: 'global',\n                id,\n                body,\n                global: true\n              };\n            } else if (node.flags & ts.NodeFlags.Namespace) {\n              if (body == null) {\n                throw new Error('Expected a module body');\n              }\n              if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                throw new Error('`namespace`s must have an Identifier id');\n              }\n              return {\n                kind: 'namespace',\n                id,\n                body\n              };\n            } else {\n              return Object.assign({\n                kind: 'module',\n                id\n              }, body != null ? {\n                body\n              } : {});\n            }\n          })()));\n          this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));\n          // ...then check for exports\n          return this.fixExports(node, result);\n        }\n      // TypeScript specific types\n      case SyntaxKind.ParenthesizedType:\n        {\n          return this.convertType(node.type);\n        }\n      case SyntaxKind.UnionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSUnionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n      case SyntaxKind.IntersectionType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,\n            types: node.types.map(el => this.convertType(el))\n          });\n        }\n      case SyntaxKind.AsExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,\n            expression: this.convertChild(node.expression),\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      case SyntaxKind.InferType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSInferType,\n            typeParameter: this.convertType(node.typeParameter)\n          });\n        }\n      case SyntaxKind.LiteralType:\n        {\n          if (version_check_1.typescriptVersionIsAtLeast['4.0'] && node.literal.kind === SyntaxKind.NullKeyword) {\n            // 4.0 started nesting null types inside a LiteralType node\n            // but our AST is designed around the old way of null being a keyword\n            return this.createNode(node.literal, {\n              type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword\n            });\n          } else {\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,\n              literal: this.convertType(node.literal)\n            });\n          }\n        }\n      case SyntaxKind.TypeAssertionExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,\n            typeAnnotation: this.convertType(node.type),\n            expression: this.convertChild(node.expression)\n          });\n        }\n      case SyntaxKind.ImportEqualsDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,\n            id: this.convertChild(node.name),\n            moduleReference: this.convertChild(node.moduleReference),\n            importKind: node.isTypeOnly ? 'type' : 'value',\n            isExport: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)\n          });\n        }\n      case SyntaxKind.ExternalModuleReference:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,\n            expression: this.convertChild(node.expression)\n          });\n        }\n      case SyntaxKind.NamespaceExportDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,\n            id: this.convertChild(node.name)\n          });\n        }\n      case SyntaxKind.AbstractKeyword:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword\n          });\n        }\n      // Tuple\n      case SyntaxKind.TupleType:\n        {\n          // In TS 4.0, the `elementTypes` property was changed to `elements`.\n          // To support both at compile time, we cast to access the newer version\n          // if the former does not exist.\n          const elementTypes = 'elementTypes' in node ? node.elementTypes.map(el => this.convertType(el)) : node.elements.map(el => this.convertType(el));\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTupleType,\n            elementTypes\n          });\n        }\n      case SyntaxKind.NamedTupleMember:\n        {\n          const member = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,\n            elementType: this.convertType(node.type, node),\n            label: this.convertChild(node.name, node),\n            optional: node.questionToken != null\n          });\n          if (node.dotDotDotToken) {\n            // adjust the start to account for the \"...\"\n            member.range[0] = member.label.range[0];\n            member.loc.start = member.label.loc.start;\n            return this.createNode(node, {\n              type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n              typeAnnotation: member\n            });\n          }\n          return member;\n        }\n      case SyntaxKind.OptionalType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      case SyntaxKind.RestType:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n            typeAnnotation: this.convertType(node.type)\n          });\n        }\n      // Template Literal Types\n      case SyntaxKind.TemplateLiteralType:\n        {\n          const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,\n            quasis: [this.convertChild(node.head)],\n            types: []\n          });\n          node.templateSpans.forEach(templateSpan => {\n            result.types.push(this.convertChild(templateSpan.type));\n            result.quasis.push(this.convertChild(templateSpan.literal));\n          });\n          return result;\n        }\n      case SyntaxKind.ClassStaticBlockDeclaration:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.StaticBlock,\n            body: this.convertBodyExpressions(node.body.statements, node)\n          });\n        }\n      case SyntaxKind.AssertEntry:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,\n            key: this.convertChild(node.name),\n            value: this.convertChild(node.value)\n          });\n        }\n      case SyntaxKind.SatisfiesExpression:\n        {\n          return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,\n            expression: this.convertChild(node.expression),\n            typeAnnotation: this.convertChild(node.type)\n          });\n        }\n      default:\n        return this.deeplyCopy(node);\n    }\n  }\n}\nexports.Converter = Converter;","map":{"version":3,"names":["ts","__importStar","require","getModifiers_1","node_utils_1","ts_estree_1","version_check_1","SyntaxKind","convertError","error","createError","file","start","message","messageText","exports","Converter","constructor","ast","options","esTreeNodeToTSNodeMap","WeakMap","tsNodeToESTreeNodeMap","allowPattern","inTypeMode","Object","assign","getASTMaps","convertProgram","converter","node","parent","typeMode","pattern","undefined","result","convertNode","registerTSNodeInNodeMap","fixExports","modifiers","getModifiers","kind","ExportKeyword","exportKeyword","nextModifier","declarationIsDefault","DefaultKeyword","varToken","findNextToken","range","getStart","loc","getLocFor","createNode","type","AST_NODE_TYPES","ExportDefaultDeclaration","declaration","exportKind","isType","TSInterfaceDeclaration","TSTypeAliasDeclaration","isDeclare","declare","ExportNamedDeclaration","specifiers","source","assertions","shouldPreserveNodeMaps","has","set","convertPattern","child","convertChild","convertType","data","getRange","convertBindingNameWithTypeAnnotation","name","tsType","id","typeAnnotation","convertTypeAnnotation","fixParentLocation","offset","FunctionType","ConstructorType","annotationStartCol","getFullStart","end","TSTypeAnnotation","convertBodyExpressions","nodes","allowDirectives","canContainDirective","map","statement","expression","isExpressionStatement","isStringLiteral","raw","directive","slice","filter","convertTypeArgumentsToTypeParameters","typeArguments","greaterThanToken","TSTypeParameterInstantiation","pos","params","typeArgument","convertTSTypeParametersToTypeParametersDeclaration","typeParameters","TSTypeParameterDeclaration","typeParameter","convertParameters","parameters","length","param","convertedParam","decorators","getDecorators","el","convertChainExpression","tsNode","isOptional","MemberExpression","object","optional","CallExpression","callee","isChildUnwrappable","isChildUnwrappableOptionalChain","isChainExpression","newChild","ChainExpression","deeplyCopy","JSDocFunctionType","customType","errorOnUnknownASTType","Error","isTypeNode","KEYS_TO_NOT_COPY","Set","entries","key","forEach","value","Array","isArray","convertJSXIdentifier","JSXIdentifier","getText","convertJSXNamespaceOrIdentifier","JsxNamespacedName","JSXNamespacedName","namespace","text","colonIndex","indexOf","convertJSXTagName","PropertyAccessExpression","PrivateIdentifier","JSXMemberExpression","property","ThisKeyword","Identifier","convertMethodSignature","TSMethodSignature","computed","isComputedProperty","GetAccessor","SetAccessor","MethodSignature","returnType","hasModifier","ReadonlyKeyword","readonly","accessibility","getTSNodeAccessibility","export","StaticKeyword","static","convertAssertClasue","elements","element","applyModifiersToResult","remainingModifiers","modifier","ConstKeyword","const","DeclareKeyword","push","childRange","getLineAndCharacterFor","assertModuleSpecifier","allowNull","moduleSpecifier","_a","StringLiteral","SourceFile","Program","body","statements","sourceType","externalModuleIndicator","endOfFileToken","Block","BlockStatement","isThisInTypeQuery","ThisExpression","WithStatement","ReturnStatement","argument","LabeledStatement","label","ContinueStatement","BreakStatement","IfStatement","test","consequent","thenStatement","alternate","elseStatement","SwitchStatement","discriminant","cases","caseBlock","clauses","CaseClause","DefaultClause","SwitchCase","ThrowStatement","TryStatement","block","tryBlock","handler","catchClause","finalizer","finallyBlock","CatchClause","variableDeclaration","WhileStatement","DoStatement","DoWhileStatement","ForStatement","init","initializer","condition","update","incrementor","ForInStatement","left","right","ForOfStatement","await","Boolean","awaitModifier","AwaitKeyword","FunctionDeclaration","TSDeclareFunction","generator","asteriskToken","async","AsyncKeyword","VariableDeclaration","VariableDeclarator","exclamationToken","definite","VariableStatement","declarations","declarationList","getDeclarationKind","VariableDeclarationList","ExpressionStatement","ArrayLiteralExpression","ArrayPattern","ArrayExpression","ObjectLiteralExpression","ObjectPattern","properties","ObjectExpression","PropertyAssignment","Property","method","shorthand","ShorthandPropertyAssignment","objectAssignmentInitializer","AssignmentPattern","ComputedPropertyName","PropertyDeclaration","isAbstract","AbstractKeyword","isAccessor","AccessorKeyword","TSAbstractAccessorProperty","AccessorProperty","TSAbstractPropertyDefinition","PropertyDefinition","override","OverrideKeyword","questionToken","Literal","InterfaceDeclaration","TypeLiteral","MethodDeclaration","TSEmptyBodyFunctionExpression","FunctionExpression","methodDefinitionType","TSAbstractMethodDefinition","MethodDefinition","Constructor","lastModifier","getLastModifier","constructorToken","getFirstToken","constructorKey","isStatic","SuperKeyword","Super","ArrayBindingPattern","OmittedExpression","ObjectBindingPattern","BindingElement","arrayItem","dotDotDotToken","RestElement","propertyName","_b","ArrowFunction","ArrowFunctionExpression","YieldExpression","delegate","AwaitExpression","NoSubstitutionTemplateLiteral","TemplateLiteral","quasis","TemplateElement","cooked","tail","expressions","TemplateExpression","head","templateSpans","templateSpan","literal","TaggedTemplateExpression","tag","quasi","template","TemplateHead","TemplateMiddle","TemplateTail","SpreadAssignment","SpreadElement","Parameter","parameter","TSParameterProperty","_c","ClassDeclaration","ClassExpression","heritageClauses","_d","classNodeType","superClass","find","clause","token","ExtendsKeyword","implementsClause","ImplementsKeyword","ClassBody","members","types","_e","superTypeParameters","implements","abstract","filteredMembers","isESTreeClassMember","ModuleBlock","TSModuleBlock","ImportDeclaration","importKind","assertClause","importClause","isTypeOnly","namedBindings","NamespaceImport","NamedImports","concat","ImportNamespaceSpecifier","local","ImportSpecifier","imported","_f","ImportClause","ImportDefaultSpecifier","ExportDeclaration","_g","exportClause","NamedExports","ExportAllDeclaration","exported","NamespaceExport","ExportSpecifier","_h","ExportAssignment","isExportEquals","TSExportAssignment","PrefixUnaryExpression","PostfixUnaryExpression","operator","getTextForTokenKind","UpdateExpression","prefix","operand","UnaryExpression","DeleteExpression","VoidExpression","TypeOfExpression","TypeOperator","TSTypeOperator","BinaryExpression","isComma","operatorToken","SequenceExpression","ParenthesizedExpression","getBinaryExpressionType","AssignmentExpression","questionDotToken","ElementAccessExpression","argumentExpression","ImportKeyword","arguments","ImportExpression","attributes","args","NewExpression","ConditionalExpression","whenTrue","whenFalse","MetaProperty","meta","keywordToken","Decorator","JsxAttribute","unescapeStringLiteralText","NumericLiteral","Number","BigIntLiteral","rawValue","bigint","replace","BigInt","String","RegularExpressionLiteral","lastIndexOf","flags","regex","RegExp","exception","TrueKeyword","FalseKeyword","NullKeyword","typescriptVersionIsAtLeast","TSNullKeyword","EmptyStatement","DebuggerStatement","JsxElement","JSXElement","openingElement","closingElement","children","JsxFragment","JSXFragment","openingFragment","closingFragment","JsxSelfClosingElement","JSXOpeningElement","selfClosing","tagName","JsxOpeningElement","JsxClosingElement","JSXClosingElement","JsxOpeningFragment","JSXOpeningFragment","JsxClosingFragment","JSXClosingFragment","JsxExpression","JSXEmptyExpression","getEnd","JSXSpreadChild","JSXExpressionContainer","JSXAttribute","JsxText","JSXText","JsxSpreadAttribute","JSXSpreadAttribute","QualifiedName","TSQualifiedName","TypeReference","TSTypeReference","typeName","TypeParameter","TSTypeParameter","constraint","default","in","InKeyword","out","OutKeyword","ThisType","TSThisType","AnyKeyword","BigIntKeyword","BooleanKeyword","NeverKeyword","NumberKeyword","ObjectKeyword","StringKeyword","SymbolKeyword","UnknownKeyword","VoidKeyword","UndefinedKeyword","IntrinsicKeyword","NonNullExpression","nnExpr","TSNonNullExpression","TSTypeLiteral","ArrayType","TSArrayType","elementType","IndexedAccessType","TSIndexedAccessType","objectType","indexType","ConditionalType","TSConditionalType","checkType","extendsType","trueType","falseType","TypeQuery","TSTypeQuery","exprName","MappedType","TSMappedType","nameType","_j","readonlyToken","QuestionToken","TypeAliasDeclaration","PropertySignature","TSPropertySignature","IndexSignature","TSIndexSignature","TSConstructorType","ConstructSignature","CallSignature","TSConstructSignatureDeclaration","TSCallSignatureDeclaration","TSFunctionType","ExpressionWithTypeArguments","parentKind","TSInterfaceHeritage","HeritageClause","TSClassImplements","TSInstantiationExpression","interfaceHeritageClauses","_k","TSInterfaceBody","member","interfaceExtends","interfaceImplements","heritageClause","n","extends","TypePredicate","TSTypePredicate","asserts","assertsModifier","parameterName","ImportType","TSImportType","isTypeOf","qualifier","EnumDeclaration","TSEnumDeclaration","EnumMember","TSEnumMember","ModuleDeclaration","TSModuleDeclaration","NodeFlags","GlobalAugmentation","global","Namespace","ParenthesizedType","UnionType","TSUnionType","IntersectionType","TSIntersectionType","AsExpression","TSAsExpression","InferType","TSInferType","LiteralType","TSLiteralType","TypeAssertionExpression","TSTypeAssertion","ImportEqualsDeclaration","TSImportEqualsDeclaration","moduleReference","isExport","ExternalModuleReference","TSExternalModuleReference","NamespaceExportDeclaration","TSNamespaceExportDeclaration","TSAbstractKeyword","TupleType","elementTypes","TSTupleType","NamedTupleMember","TSNamedTupleMember","TSRestType","OptionalType","TSOptionalType","RestType","TemplateLiteralType","TSTemplateLiteralType","ClassStaticBlockDeclaration","StaticBlock","AssertEntry","ImportAttribute","SatisfiesExpression","TSSatisfiesExpression"],"sources":["../src/convert.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}