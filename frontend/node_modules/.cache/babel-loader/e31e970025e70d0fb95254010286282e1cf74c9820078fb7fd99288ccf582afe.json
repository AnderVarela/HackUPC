{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _UnusedVarsVisitor_scopeManager;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectUnusedVariables = void 0;\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst Visitor_1 = require(\"@typescript-eslint/scope-manager/dist/referencer/Visitor\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nclass UnusedVarsVisitor extends Visitor_1.Visitor {\n  // readonly #unusedVariables = new Set<TSESLint.Scope.Variable>();\n  constructor(context) {\n    super({\n      visitChildrenEvenIfSelectorExists: true\n    });\n    _UnusedVarsVisitor_scopeManager.set(this, void 0);\n    //#endregion HELPERS\n    //#region VISITORS\n    // NOTE - This is a simple visitor - meaning it does not support selectors\n    this.ClassDeclaration = this.visitClass;\n    this.ClassExpression = this.visitClass;\n    this.FunctionDeclaration = this.visitFunction;\n    this.FunctionExpression = this.visitFunction;\n    this.MethodDefinition = this.visitSetter;\n    this.Property = this.visitSetter;\n    this.TSCallSignatureDeclaration = this.visitFunctionTypeSignature;\n    this.TSConstructorType = this.visitFunctionTypeSignature;\n    this.TSConstructSignatureDeclaration = this.visitFunctionTypeSignature;\n    this.TSDeclareFunction = this.visitFunctionTypeSignature;\n    this.TSEmptyBodyFunctionExpression = this.visitFunctionTypeSignature;\n    this.TSFunctionType = this.visitFunctionTypeSignature;\n    this.TSMethodSignature = this.visitFunctionTypeSignature;\n    __classPrivateFieldSet(this, _UnusedVarsVisitor_scopeManager, utils_1.ESLintUtils.nullThrows(context.getSourceCode().scopeManager, 'Missing required scope manager'), \"f\");\n  }\n  static collectUnusedVariables(context) {\n    const program = context.getSourceCode().ast;\n    const cached = this.RESULTS_CACHE.get(program);\n    if (cached) {\n      return cached;\n    }\n    const visitor = new this(context);\n    visitor.visit(program);\n    const unusedVars = visitor.collectUnusedVariables(visitor.getScope(program));\n    this.RESULTS_CACHE.set(program, unusedVars);\n    return unusedVars;\n  }\n  collectUnusedVariables(scope, unusedVariables = new Set()) {\n    for (const variable of scope.variables) {\n      if (\n      // skip function expression names,\n      scope.functionExpressionScope ||\n      // variables marked with markVariableAsUsed(),\n      variable.eslintUsed ||\n      // implicit lib variables (from @typescript-eslint/scope-manager),\n      variable instanceof scope_manager_1.ImplicitLibVariable ||\n      // basic exported variables\n      isExported(variable) ||\n      // variables implicitly exported via a merged declaration\n      isMergableExported(variable) ||\n      // used variables\n      isUsedVariable(variable)) {\n        continue;\n      }\n      unusedVariables.add(variable);\n    }\n    for (const childScope of scope.childScopes) {\n      this.collectUnusedVariables(childScope, unusedVariables);\n    }\n    return unusedVariables;\n  }\n  //#region HELPERS\n  getScope(currentNode) {\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== utils_1.AST_NODE_TYPES.Program;\n    let node = currentNode;\n    while (node) {\n      const scope = __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").acquire(node, inner);\n      if (scope) {\n        if (scope.type === 'function-expression-name') {\n          return scope.childScopes[0];\n        }\n        return scope;\n      }\n      node = node.parent;\n    }\n    return __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").scopes[0];\n  }\n  markVariableAsUsed(variableOrIdentifierOrName, parent) {\n    if (typeof variableOrIdentifierOrName !== 'string' && !('type' in variableOrIdentifierOrName)) {\n      variableOrIdentifierOrName.eslintUsed = true;\n      return;\n    }\n    let name;\n    let node;\n    if (typeof variableOrIdentifierOrName === 'string') {\n      name = variableOrIdentifierOrName;\n      node = parent;\n    } else {\n      name = variableOrIdentifierOrName.name;\n      node = variableOrIdentifierOrName;\n    }\n    let currentScope = this.getScope(node);\n    while (currentScope) {\n      const variable = currentScope.variables.find(scopeVar => scopeVar.name === name);\n      if (variable) {\n        variable.eslintUsed = true;\n        return;\n      }\n      currentScope = currentScope.upper;\n    }\n  }\n  visitClass(node) {\n    // skip a variable of class itself name in the class scope\n    const scope = this.getScope(node);\n    for (const variable of scope.variables) {\n      if (variable.identifiers[0] === scope.block.id) {\n        this.markVariableAsUsed(variable);\n        return;\n      }\n    }\n  }\n  visitFunction(node) {\n    const scope = this.getScope(node);\n    // skip implicit \"arguments\" variable\n    const variable = scope.set.get('arguments');\n    if ((variable === null || variable === void 0 ? void 0 : variable.defs.length) === 0) {\n      this.markVariableAsUsed(variable);\n    }\n  }\n  visitFunctionTypeSignature(node) {\n    // function type signature params create variables because they can be referenced within the signature,\n    // but they obviously aren't unused variables for the purposes of this rule.\n    for (const param of node.params) {\n      this.visitPattern(param, name => {\n        this.markVariableAsUsed(name);\n      });\n    }\n  }\n  visitSetter(node) {\n    if (node.kind === 'set') {\n      // ignore setter parameters because they're syntactically required to exist\n      for (const param of node.value.params) {\n        this.visitPattern(param, id => {\n          this.markVariableAsUsed(id);\n        });\n      }\n    }\n  }\n  ForInStatement(node) {\n    /**\n     * (Brad Zacher): I hate that this has to exist.\n     * But it is required for compat with the base ESLint rule.\n     *\n     * In 2015, ESLint decided to add an exception for these two specific cases\n     * ```\n     * for (var key in object) return;\n     *\n     * var key;\n     * for (key in object) return;\n     * ```\n     *\n     * I disagree with it, but what are you going to do...\n     *\n     * https://github.com/eslint/eslint/issues/2342\n     */\n    let idOrVariable;\n    if (node.left.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n      const variable = __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").getDeclaredVariables(node.left)[0];\n      if (!variable) {\n        return;\n      }\n      idOrVariable = variable;\n    }\n    if (node.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n      idOrVariable = node.left;\n    }\n    if (idOrVariable == null) {\n      return;\n    }\n    let body = node.body;\n    if (node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n      if (node.body.body.length !== 1) {\n        return;\n      }\n      body = node.body.body[0];\n    }\n    if (body.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {\n      return;\n    }\n    this.markVariableAsUsed(idOrVariable);\n  }\n  Identifier(node) {\n    const scope = this.getScope(node);\n    if (scope.type === utils_1.TSESLint.Scope.ScopeType.function && node.name === 'this') {\n      // this parameters should always be considered used as they're pseudo-parameters\n      if ('params' in scope.block && scope.block.params.includes(node)) {\n        this.markVariableAsUsed(node);\n      }\n    }\n  }\n  TSEnumDeclaration(node) {\n    // enum members create variables because they can be referenced within the enum,\n    // but they obviously aren't unused variables for the purposes of this rule.\n    const scope = this.getScope(node);\n    for (const variable of scope.variables) {\n      this.markVariableAsUsed(variable);\n    }\n  }\n  TSMappedType(node) {\n    // mapped types create a variable for their type name, but it's not necessary to reference it,\n    // so we shouldn't consider it as unused for the purpose of this rule.\n    this.markVariableAsUsed(node.typeParameter.name);\n  }\n  TSModuleDeclaration(node) {\n    // -- global augmentation can be in any file, and they do not need exports\n    if (node.global === true) {\n      this.markVariableAsUsed('global', node.parent);\n    }\n  }\n  TSParameterProperty(node) {\n    let identifier = null;\n    switch (node.parameter.type) {\n      case utils_1.AST_NODE_TYPES.AssignmentPattern:\n        if (node.parameter.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n          identifier = node.parameter.left;\n        }\n        break;\n      case utils_1.AST_NODE_TYPES.Identifier:\n        identifier = node.parameter;\n        break;\n    }\n    if (identifier) {\n      this.markVariableAsUsed(identifier);\n    }\n  }\n}\n_UnusedVarsVisitor_scopeManager = new WeakMap();\nUnusedVarsVisitor.RESULTS_CACHE = new WeakMap();\n//#region private helpers\n/**\n * Checks the position of given nodes.\n * @param inner A node which is expected as inside.\n * @param outer A node which is expected as outside.\n * @returns `true` if the `inner` node exists in the `outer` node.\n */\nfunction isInside(inner, outer) {\n  return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n}\n/**\n * Determine if an identifier is referencing an enclosing name.\n * This only applies to declarations that create their own scope (modules, functions, classes)\n * @param ref The reference to check.\n * @param nodes The candidate function nodes.\n * @returns True if it's a self-reference, false if not.\n */\nfunction isSelfReference(ref, nodes) {\n  let scope = ref.from;\n  while (scope) {\n    if (nodes.has(scope.block)) {\n      return true;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\nconst MERGABLE_TYPES = new Set([utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration, utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.FunctionDeclaration]);\n/**\n * Determine if the variable is directly exported\n * @param variable the variable to check\n * @param target the type of node that is expected to be exported\n */\nfunction isMergableExported(variable) {\n  var _a, _b;\n  // If all of the merged things are of the same type, TS will error if not all of them are exported - so we only need to find one\n  for (const def of variable.defs) {\n    // parameters can never be exported.\n    // their `node` prop points to the function decl, which can be exported\n    // so we need to special case them\n    if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n      continue;\n    }\n    if (MERGABLE_TYPES.has(def.node.type) && ((_a = def.node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration || ((_b = def.node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Determines if a given variable is being exported from a module.\n * @param variable eslint-scope variable object.\n * @returns True if the variable is exported, false if not.\n */\nfunction isExported(variable) {\n  const definition = variable.defs[0];\n  if (definition) {\n    let node = definition.node;\n    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n      node = node.parent;\n    } else if (definition.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n      return false;\n    }\n    return node.parent.type.indexOf('Export') === 0;\n  }\n  return false;\n}\n/**\n * Determines if the variable is used.\n * @param variable The variable to check.\n * @returns True if the variable is used\n */\nfunction isUsedVariable(variable) {\n  /**\n   * Gets a list of function definitions for a specified variable.\n   * @param variable eslint-scope variable object.\n   * @returns Function nodes.\n   */\n  function getFunctionDefinitions(variable) {\n    const functionDefinitions = new Set();\n    variable.defs.forEach(def => {\n      var _a, _b;\n      // FunctionDeclarations\n      if (def.type === utils_1.TSESLint.Scope.DefinitionType.FunctionName) {\n        functionDefinitions.add(def.node);\n      }\n      // FunctionExpressions\n      if (def.type === utils_1.TSESLint.Scope.DefinitionType.Variable && (((_a = def.node.init) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.FunctionExpression || ((_b = def.node.init) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {\n        functionDefinitions.add(def.node.init);\n      }\n    });\n    return functionDefinitions;\n  }\n  function getTypeDeclarations(variable) {\n    const nodes = new Set();\n    variable.defs.forEach(def => {\n      if (def.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration || def.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {\n        nodes.add(def.node);\n      }\n    });\n    return nodes;\n  }\n  function getModuleDeclarations(variable) {\n    const nodes = new Set();\n    variable.defs.forEach(def => {\n      if (def.node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {\n        nodes.add(def.node);\n      }\n    });\n    return nodes;\n  }\n  /**\n   * Checks if the ref is contained within one of the given nodes\n   */\n  function isInsideOneOf(ref, nodes) {\n    for (const node of nodes) {\n      if (isInside(ref.identifier, node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * If a given reference is left-hand side of an assignment, this gets\n   * the right-hand side node of the assignment.\n   *\n   * In the following cases, this returns null.\n   *\n   * - The reference is not the LHS of an assignment expression.\n   * - The reference is inside of a loop.\n   * - The reference is inside of a function scope which is different from\n   *   the declaration.\n   * @param ref A reference to check.\n   * @param prevRhsNode The previous RHS node.\n   * @returns The RHS node or null.\n   */\n  function getRhsNode(ref, prevRhsNode) {\n    /**\n     * Checks whether the given node is in a loop or not.\n     * @param node The node to check.\n     * @returns `true` if the node is in a loop.\n     */\n    function isInLoop(node) {\n      let currentNode = node;\n      while (currentNode) {\n        if (utils_1.ASTUtils.isFunction(currentNode)) {\n          break;\n        }\n        if (utils_1.ASTUtils.isLoop(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parent;\n      }\n      return false;\n    }\n    const id = ref.identifier;\n    const parent = id.parent;\n    const grandparent = parent.parent;\n    const refScope = ref.from.variableScope;\n    const varScope = ref.resolved.scope.variableScope;\n    const canBeUsedLater = refScope !== varScope || isInLoop(id);\n    /*\n     * Inherits the previous node if this reference is in the node.\n     * This is for `a = a + a`-like code.\n     */\n    if (prevRhsNode && isInside(id, prevRhsNode)) {\n      return prevRhsNode;\n    }\n    if (parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement && id === parent.left && !canBeUsedLater) {\n      return parent.right;\n    }\n    return null;\n  }\n  /**\n   * Checks whether a given reference is a read to update itself or not.\n   * @param ref A reference to check.\n   * @param rhsNode The RHS node of the previous assignment.\n   * @returns The reference is a read to update itself.\n   */\n  function isReadForItself(ref, rhsNode) {\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param id An Identifier node to check.\n     * @param rhsNode The RHS node of the previous assignment.\n     * @returns `true` if the `id` node exists inside of a function node which can be used later.\n     */\n    function isInsideOfStorableFunction(id, rhsNode) {\n      /**\n       * Finds a function node from ancestors of a node.\n       * @param node A start node to find.\n       * @returns A found function node.\n       */\n      function getUpperFunction(node) {\n        let currentNode = node;\n        while (currentNode) {\n          if (utils_1.ASTUtils.isFunction(currentNode)) {\n            return currentNode;\n          }\n          currentNode = currentNode.parent;\n        }\n        return null;\n      }\n      /**\n       * Checks whether a given function node is stored to somewhere or not.\n       * If the function node is stored, the function can be used later.\n       * @param funcNode A function node to check.\n       * @param rhsNode The RHS node of the previous assignment.\n       * @returns `true` if under the following conditions:\n       *      - the funcNode is assigned to a variable.\n       *      - the funcNode is bound as an argument of a function call.\n       *      - the function is bound to a property and the object satisfies above conditions.\n       */\n      function isStorableFunction(funcNode, rhsNode) {\n        let node = funcNode;\n        let parent = funcNode.parent;\n        while (parent && isInside(parent, rhsNode)) {\n          switch (parent.type) {\n            case utils_1.AST_NODE_TYPES.SequenceExpression:\n              if (parent.expressions[parent.expressions.length - 1] !== node) {\n                return false;\n              }\n              break;\n            case utils_1.AST_NODE_TYPES.CallExpression:\n            case utils_1.AST_NODE_TYPES.NewExpression:\n              return parent.callee !== node;\n            case utils_1.AST_NODE_TYPES.AssignmentExpression:\n            case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n            case utils_1.AST_NODE_TYPES.YieldExpression:\n              return true;\n            default:\n              if (parent.type.endsWith('Statement') || parent.type.endsWith('Declaration')) {\n                /*\n                 * If it encountered statements, this is a complex pattern.\n                 * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                 */\n                return true;\n              }\n          }\n          node = parent;\n          parent = parent.parent;\n        }\n        return false;\n      }\n      const funcNode = getUpperFunction(id);\n      return !!funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n    const id = ref.identifier;\n    const parent = id.parent;\n    const grandparent = parent.parent;\n    return ref.isRead() && (\n    // in RHS of an assignment for itself. e.g. `a = a + 1`\n    // self update. e.g. `a += 1`, `a++`\n    parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement && parent.left === id || parent.type === utils_1.AST_NODE_TYPES.UpdateExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement || !!rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n  }\n  const functionNodes = getFunctionDefinitions(variable);\n  const isFunctionDefinition = functionNodes.size > 0;\n  const typeDeclNodes = getTypeDeclarations(variable);\n  const isTypeDecl = typeDeclNodes.size > 0;\n  const moduleDeclNodes = getModuleDeclarations(variable);\n  const isModuleDecl = moduleDeclNodes.size > 0;\n  let rhsNode = null;\n  return variable.references.some(ref => {\n    const forItself = isReadForItself(ref, rhsNode);\n    rhsNode = getRhsNode(ref, rhsNode);\n    return ref.isRead() && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes)) && !(isTypeDecl && isInsideOneOf(ref, typeDeclNodes)) && !(isModuleDecl && isSelfReference(ref, moduleDeclNodes));\n  });\n}\n//#endregion private helpers\n/**\n * Collects the set of unused variables for a given context.\n *\n * Due to complexity, this does not take into consideration:\n * - variables within declaration files\n * - variables within ambient module declarations\n */\nfunction collectUnusedVariables(context) {\n  return UnusedVarsVisitor.collectUnusedVariables(context);\n}\nexports.collectUnusedVariables = collectUnusedVariables;","map":{"version":3,"names":["scope_manager_1","require","Visitor_1","utils_1","UnusedVarsVisitor","Visitor","constructor","context","visitChildrenEvenIfSelectorExists","_UnusedVarsVisitor_scopeManager","set","ClassDeclaration","visitClass","ClassExpression","FunctionDeclaration","visitFunction","FunctionExpression","MethodDefinition","visitSetter","Property","TSCallSignatureDeclaration","visitFunctionTypeSignature","TSConstructorType","TSConstructSignatureDeclaration","TSDeclareFunction","TSEmptyBodyFunctionExpression","TSFunctionType","TSMethodSignature","__classPrivateFieldSet","ESLintUtils","nullThrows","getSourceCode","scopeManager","collectUnusedVariables","program","ast","cached","RESULTS_CACHE","get","visitor","visit","unusedVars","getScope","scope","unusedVariables","Set","variable","variables","functionExpressionScope","eslintUsed","ImplicitLibVariable","isExported","isMergableExported","isUsedVariable","add","childScope","childScopes","currentNode","inner","type","AST_NODE_TYPES","Program","node","__classPrivateFieldGet","acquire","parent","scopes","markVariableAsUsed","variableOrIdentifierOrName","name","currentScope","find","scopeVar","upper","identifiers","block","id","defs","length","param","params","visitPattern","kind","value","ForInStatement","idOrVariable","left","VariableDeclaration","getDeclaredVariables","Identifier","body","BlockStatement","ReturnStatement","TSESLint","Scope","ScopeType","function","includes","TSEnumDeclaration","TSMappedType","typeParameter","TSModuleDeclaration","global","TSParameterProperty","identifier","parameter","AssignmentPattern","WeakMap","isInside","outer","range","isSelfReference","ref","nodes","from","has","MERGABLE_TYPES","TSInterfaceDeclaration","TSTypeAliasDeclaration","def","DefinitionType","Parameter","_a","ExportNamedDeclaration","_b","ExportDefaultDeclaration","definition","VariableDeclarator","indexOf","getFunctionDefinitions","functionDefinitions","forEach","FunctionName","Variable","init","ArrowFunctionExpression","getTypeDeclarations","getModuleDeclarations","isInsideOneOf","getRhsNode","prevRhsNode","isInLoop","ASTUtils","isFunction","isLoop","grandparent","refScope","variableScope","varScope","resolved","canBeUsedLater","AssignmentExpression","ExpressionStatement","right","isReadForItself","rhsNode","isInsideOfStorableFunction","getUpperFunction","isStorableFunction","funcNode","SequenceExpression","expressions","CallExpression","NewExpression","callee","TaggedTemplateExpression","YieldExpression","endsWith","isRead","UpdateExpression","functionNodes","isFunctionDefinition","size","typeDeclNodes","isTypeDecl","moduleDeclNodes","isModuleDecl","references","some","forItself","exports"],"sources":["../../src/util/collectUnusedVariables.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}