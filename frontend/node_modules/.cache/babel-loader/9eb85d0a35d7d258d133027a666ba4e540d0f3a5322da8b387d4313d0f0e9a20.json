{"ast":null,"code":"/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar os = require('os');\nvar assert = require('assert');\nvar Int64 = require('node-int64');\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator;\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function () {\n  return this.buf.length - this.writeOffset;\n};\n\n// How much we can read\nAccumulator.prototype.readAvail = function () {\n  return this.writeOffset - this.readOffset;\n};\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function (size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n};\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function (buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n};\nAccumulator.prototype.assertReadableSize = function (size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size + \" bytes but only have \" + this.readAvail());\n  }\n};\nAccumulator.prototype.peekString = function (size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n};\nAccumulator.prototype.readString = function (size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n};\nAccumulator.prototype.peekInt = function (size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n      var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n      if (isBigEndian) {\n        // On a big endian system we can simply pass the buffer directly\n        return new Int64(big);\n      }\n      // Otherwise we need to byteswap\n      return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n};\nAccumulator.prototype.readInt = function (bytes) {\n  var ival = this.peekInt(bytes);\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n  this.readOffset += bytes;\n  return ival;\n};\nAccumulator.prototype.peekDouble = function () {\n  this.assertReadableSize(8);\n  return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);\n};\nAccumulator.prototype.readDouble = function () {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n};\nAccumulator.prototype.readAdvance = function (size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size + \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n};\nAccumulator.prototype.writeByte = function (value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n};\nAccumulator.prototype.writeInt = function (value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n};\nAccumulator.prototype.writeDouble = function (value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n};\nvar BSER_ARRAY = 0x00;\nvar BSER_OBJECT = 0x01;\nvar BSER_STRING = 0x02;\nvar BSER_INT8 = 0x03;\nvar BSER_INT16 = 0x04;\nvar BSER_INT32 = 0x05;\nvar BSER_INT64 = 0x06;\nvar BSER_REAL = 0x07;\nvar BSER_TRUE = 0x08;\nvar BSER_FALSE = 0x09;\nvar BSER_NULL = 0x0a;\nvar BSER_TEMPLATE = 0x0b;\nvar BSER_SKIP = 0x0c;\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\nBunserBuf.prototype.append = function (buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n};\nBunserBuf.prototype.processLater = function () {\n  var self = this;\n  process.nextTick(function () {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n};\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function (synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n};\nBunserBuf.prototype.raise = function (reason) {\n  throw new Error(reason + \", in Buffer of length \" + this.buf.buf.length + \" (\" + this.buf.readAvail() + \" readable) at offset \" + this.buf.readOffset + \" buffer: \" + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n};\nBunserBuf.prototype.expectCode = function (expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n};\nBunserBuf.prototype.decodeAny = function () {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n};\nBunserBuf.prototype.decodeArray = function () {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n};\nBunserBuf.prototype.decodeObject = function () {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n};\nBunserBuf.prototype.decodeTemplate = function () {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n};\nBunserBuf.prototype.decodeString = function () {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n};\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function (relaxSizeAsserts) {\n  if (relaxSizeAsserts && this.buf.readAvail() < 1) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n  if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n};\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error('excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error('no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer;\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length - 1 - i];\n  }\n  return swap;\n}\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\nfunction dump_any(buf, val) {\n  switch (typeof val) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof v == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof v == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(e.message + ' (while serializing object property with name `' + key + \"')\");\n        }\n      }\n      return;\n    default:\n      throw new Error('cannot serialize type ' + typeof val + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer;","map":{"version":3,"names":["EE","require","EventEmitter","util","os","assert","Int64","isBigEndian","endianness","nextPow2","size","Math","pow","ceil","log","LN2","Accumulator","initsize","buf","Buffer","alloc","readOffset","writeOffset","exports","prototype","writeAvail","length","readAvail","reserve","copy","append","isBuffer","byteLength","write","assertReadableSize","Error","peekString","toString","readString","str","peekInt","readInt8","readInt16BE","readInt16LE","readInt32BE","readInt32LE","big","slice","byteswap64","readInt","bytes","ival","isFinite","valueOf","peekDouble","readDoubleBE","readDoubleLE","readDouble","dval","readAdvance","writeByte","value","writeInt8","writeInt","writeInt16BE","writeInt16LE","writeInt32BE","writeInt32LE","writeDouble","writeDoubleBE","writeDoubleLE","BSER_ARRAY","BSER_OBJECT","BSER_STRING","BSER_INT8","BSER_INT16","BSER_INT32","BSER_INT64","BSER_REAL","BSER_TRUE","BSER_FALSE","BSER_NULL","BSER_TEMPLATE","BSER_SKIP","ST_NEED_PDU","ST_FILL_PDU","MAX_INT8","MAX_INT16","MAX_INT32","BunserBuf","call","state","inherits","synchronous","process","err","emit","processLater","self","nextTick","expectCode","pduLen","decodeInt","val","decodeAny","raise","reason","JSON","stringify","toJSON","expected","code","decodeString","decodeArray","decodeObject","decodeTemplate","nitems","arr","i","push","res","key","keys","obj","keyidx","len","relaxSizeAsserts","loadFromBuffer","input","result","swap","dump_int64","be","toBuffer","le","dump_int","abs","dump_any","floor","Array","isArray","Object","num_keys","v","e","message","dumpToBuffer","off"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bser/index.js"],"sourcesContent":["/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\nvar os = require('os');\nvar assert = require('assert');\nvar Int64 = require('node-int64');\n\n// BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\nvar isBigEndian = os.endianness() == 'BE';\n\n// Find the next power-of-2 >= size\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n}\n\n// Expandable buffer that we can provide a size hint for\nfunction Accumulator(initsize) {\n  this.buf = Buffer.alloc(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n}\n// For testing\nexports.Accumulator = Accumulator\n\n// How much we can write into this buffer without allocating\nAccumulator.prototype.writeAvail = function() {\n  return this.buf.length - this.writeOffset;\n}\n\n// How much we can read\nAccumulator.prototype.readAvail = function() {\n  return this.writeOffset - this.readOffset;\n}\n\n// Ensure that we have enough space for size bytes\nAccumulator.prototype.reserve = function(size) {\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // If we can make room by shunting down, do so\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  }\n\n  // If we made enough room, no need to allocate more\n  if (size < this.writeAvail()) {\n    return;\n  }\n\n  // Allocate a replacement and copy it in\n  var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}\n\n// Append buffer or string.  Will resize as needed\nAccumulator.prototype.append = function(buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n}\n\nAccumulator.prototype.assertReadableSize = function(size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size +\n        \" bytes but only have \" + this.readAvail());\n  }\n}\n\nAccumulator.prototype.peekString = function(size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n}\n\nAccumulator.prototype.readString = function(size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n}\n\nAccumulator.prototype.peekInt = function(size) {\n  this.assertReadableSize(size);\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n    case 2:\n      return isBigEndian ?\n        this.buf.readInt16BE(this.readOffset, size) :\n        this.buf.readInt16LE(this.readOffset, size);\n    case 4:\n      return isBigEndian ?\n        this.buf.readInt32BE(this.readOffset, size) :\n        this.buf.readInt32LE(this.readOffset, size);\n    case 8:\n        var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n        if (isBigEndian) {\n          // On a big endian system we can simply pass the buffer directly\n          return new Int64(big);\n        }\n        // Otherwise we need to byteswap\n        return new Int64(byteswap64(big));\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n}\n\nAccumulator.prototype.readInt = function(bytes) {\n  var ival = this.peekInt(bytes);\n  if (ival instanceof Int64 && isFinite(ival.valueOf())) {\n    ival = ival.valueOf();\n  }\n  this.readOffset += bytes;\n  return ival;\n}\n\nAccumulator.prototype.peekDouble = function() {\n  this.assertReadableSize(8);\n  return isBigEndian ?\n    this.buf.readDoubleBE(this.readOffset) :\n    this.buf.readDoubleLE(this.readOffset);\n}\n\nAccumulator.prototype.readDouble = function() {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n}\n\nAccumulator.prototype.readAdvance = function(size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size +\n        \" would seek off the start of the buffer\");\n  }\n  this.readOffset += size;\n}\n\nAccumulator.prototype.writeByte = function(value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n}\n\nAccumulator.prototype.writeInt = function(value, size) {\n  this.reserve(size);\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n      break;\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n      break;\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n  this.writeOffset += size;\n}\n\nAccumulator.prototype.writeDouble = function(value) {\n  this.reserve(8);\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n  this.writeOffset += 8;\n}\n\nvar BSER_ARRAY     = 0x00;\nvar BSER_OBJECT    = 0x01;\nvar BSER_STRING    = 0x02;\nvar BSER_INT8      = 0x03;\nvar BSER_INT16     = 0x04;\nvar BSER_INT32     = 0x05;\nvar BSER_INT64     = 0x06;\nvar BSER_REAL      = 0x07;\nvar BSER_TRUE      = 0x08;\nvar BSER_FALSE     = 0x09;\nvar BSER_NULL      = 0x0a;\nvar BSER_TEMPLATE  = 0x0b;\nvar BSER_SKIP      = 0x0c;\n\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32767;\nvar MAX_INT32 = 2147483647;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function(buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n  this.processLater();\n}\n\nBunserBuf.prototype.processLater = function() {\n  var self = this;\n  process.nextTick(function() {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}\n\n// Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\nBunserBuf.prototype.process = function(synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    }\n    // Validate BSER header\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true /* relaxed */);\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    }\n    // Ensure that we have a big enough buffer to read the rest of the PDU\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    }\n\n    // We have enough to decode it\n    var val = this.decodeAny();\n    if (synchronous) {\n      return val;\n    }\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n}\n\nBunserBuf.prototype.raise = function(reason) {\n  throw new Error(reason + \", in Buffer of length \" +\n      this.buf.buf.length + \" (\" + this.buf.readAvail() +\n      \" readable) at offset \" + this.buf.readOffset + \" buffer: \" +\n      JSON.stringify(this.buf.buf.slice(\n          this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n}\n\nBunserBuf.prototype.expectCode = function(expected) {\n  var code = this.buf.readInt(1);\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeAny = function() {\n  var code = this.buf.peekInt(1);\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n    case BSER_STRING:\n      return this.decodeString();\n    case BSER_ARRAY:\n      return this.decodeArray();\n    case BSER_OBJECT:\n      return this.decodeObject();\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n}\n\nBunserBuf.prototype.decodeArray = function() {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeObject = function() {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n  return res;\n}\n\nBunserBuf.prototype.decodeTemplate = function() {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n    arr.push(obj);\n  }\n  return arr;\n}\n\nBunserBuf.prototype.decodeString = function() {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}\n\n// This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\nBunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n  var code = this.buf.peekInt(1);\n  var size = 0;\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n    case BSER_INT16:\n      size = 2;\n      break;\n    case BSER_INT32:\n      size = 4;\n      break;\n    case BSER_INT64:\n      size = 8;\n      break;\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && (this.buf.readAvail() < 1 + size)) {\n    return false;\n  }\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}\n\n// synchronously BSER decode a string and return the value\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n  if (buf.buf.readAvail()) {\n    throw Error(\n        'excess data found after input buffer, use BunserBuf instead');\n  }\n  if (typeof result === 'undefined') {\n    throw Error(\n        'no bser found in string and no error raised!?');\n  }\n  return result;\n}\nexports.loadFromBuffer = loadFromBuffer\n\n// Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\nfunction byteswap64(buf) {\n  var swap = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length -1 - i];\n  }\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  }\n  // We need to byte swap to get the correct representation\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof(val)) {\n    case 'number':\n      // check if it is an integer or a float\n      if (isFinite(val) && Math.floor(val) === val) {\n        dump_int(buf, val);\n      } else {\n        buf.writeByte(BSER_REAL);\n        buf.writeDouble(val);\n      }\n      return;\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n        return;\n      }\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val);\n\n      // First pass to compute number of defined keys\n      var num_keys = keys.length;\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          num_keys--;\n        }\n      }\n      dump_int(buf, num_keys);\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n        if (typeof(v) == 'undefined') {\n          // Don't include it\n          continue;\n        }\n        dump_any(buf, key);\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(\n            e.message + ' (while serializing object property with name `' +\n              key + \"')\");\n        }\n      }\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof(val) + ' to BSER');\n  }\n}\n\n// BSER encode value and return a buffer of the contents\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator();\n  // Build out the header\n  buf.writeByte(0);\n  buf.writeByte(1);\n  // Reserve room for an int32 to hold our PDU length\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val);\n\n  // Compute PDU length\n  var off = buf.writeOffset;\n  var len = off - 7 /* the header length */;\n  buf.writeOffset = 3; // The length value to fill in\n  buf.writeInt(len, 4); // write the length in the space we reserved\n  buf.writeOffset = off;\n\n  return buf.buf.slice(0, off);\n}\nexports.dumpToBuffer = dumpToBuffer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}