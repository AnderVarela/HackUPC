{"ast":null,"code":"import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}","map":{"version":3,"names":["encodeU32","getSectionMetadata","traverse","shiftSection","overrideBytesInBuffer","resizeSectionByteSize","ast","uint8Buffer","section","deltaBytes","sectionMetadata","Error","size","loc","start","column","end","newSectionSize","value","newBytes","oldu32EncodedLen","newu32EncodedLen","length","deltaInSizeEncoding","vectorOfSize","encounteredSection","SectionMetadata","path","node","resizeSectionVecSize","deltaElements","newValue"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/helper-wasm-section/esm/resize.js"],"sourcesContent":["import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}