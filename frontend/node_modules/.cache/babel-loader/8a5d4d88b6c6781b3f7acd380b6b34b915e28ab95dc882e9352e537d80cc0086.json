{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst types_1 = require(\"./types\");\nconst __1 = require(\"..\");\nconst codegen_1 = require(\"../codegen\");\nconst ref_error_1 = require(\"../ref_error\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst ref_1 = require(\"../../vocabularies/jtd/ref\");\nconst util_1 = require(\"../util\");\nconst quote_1 = require(\"../../runtime/quote\");\nconst genSerialize = {\n  elements: serializeElements,\n  values: serializeValues,\n  discriminator: serializeDiscriminator,\n  properties: serializeProperties,\n  optionalProperties: serializeProperties,\n  enum: serializeString,\n  type: serializeType,\n  ref: serializeRef\n};\nfunction compileSerializer(sch, definitions) {\n  const _sch = __1.getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  const serializeName = gen.scopeName(\"serialize\");\n  const cxt = {\n    self: this,\n    gen,\n    schema: sch.schema,\n    schemaEnv: sch,\n    definitions,\n    data: names_1.default.data\n  };\n  let sourceCode;\n  try {\n    this._compilations.add(sch);\n    sch.serializeName = serializeName;\n    gen.func(serializeName, names_1.default.data, false, () => {\n      gen.let(names_1.default.json, (0, codegen_1.str)``);\n      serializeCode(cxt);\n      gen.return(names_1.default.json);\n    });\n    gen.optimize(this.opts.code.optimize);\n    const serializeFuncCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;\n    const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);\n    const serialize = makeSerialize(this.scope.get());\n    this.scope.value(serializeName, {\n      ref: serialize\n    });\n    sch.serialize = serialize;\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling serializer, function code:\", sourceCode);\n    delete sch.serialize;\n    delete sch.serializeName;\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n  return sch;\n}\nexports.default = compileSerializer;\nfunction serializeCode(cxt) {\n  let form;\n  for (const key of types_1.jtdForms) {\n    if (key in cxt.schema) {\n      form = key;\n      break;\n    }\n  }\n  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);\n}\nfunction serializeNullable(cxt, serializeForm) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  if (!schema.nullable) return serializeForm(cxt);\n  gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`\"null\"`), () => serializeForm(cxt));\n}\nfunction serializeElements(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`[`);\n  const first = gen.let(\"first\", true);\n  gen.forOf(\"el\", data, el => {\n    addComma(cxt, first);\n    serializeCode({\n      ...cxt,\n      schema: schema.elements,\n      data: el\n    });\n  });\n  gen.add(names_1.default.json, (0, codegen_1.str)`]`);\n}\nfunction serializeValues(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{`);\n  const first = gen.let(\"first\", true);\n  gen.forIn(\"key\", data, key => serializeKeyValue(cxt, key, schema.values, first));\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\nfunction serializeKeyValue(cxt, key, schema, first) {\n  const {\n    gen,\n    data\n  } = cxt;\n  addComma(cxt, first);\n  serializeString({\n    ...cxt,\n    data: key\n  });\n  gen.add(names_1.default.json, (0, codegen_1.str)`:`);\n  const value = gen.const(\"value\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);\n  serializeCode({\n    ...cxt,\n    schema,\n    data: value\n  });\n}\nfunction serializeDiscriminator(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    discriminator\n  } = schema;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);\n  const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator)}`);\n  serializeString({\n    ...cxt,\n    data: tag\n  });\n  gen.if(false);\n  for (const tagValue in schema.mapping) {\n    gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n    const sch = schema.mapping[tagValue];\n    serializeSchemaProperties({\n      ...cxt,\n      schema: sch\n    }, discriminator);\n  }\n  gen.endIf();\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\nfunction serializeProperties(cxt) {\n  const {\n    gen\n  } = cxt;\n  gen.add(names_1.default.json, (0, codegen_1.str)`{`);\n  serializeSchemaProperties(cxt);\n  gen.add(names_1.default.json, (0, codegen_1.str)`}`);\n}\nfunction serializeSchemaProperties(cxt, discriminator) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    properties,\n    optionalProperties\n  } = schema;\n  const props = keys(properties);\n  const optProps = keys(optionalProperties);\n  const allProps = allProperties(props.concat(optProps));\n  let first = !discriminator;\n  let firstProp;\n  for (const key of props) {\n    if (first) first = false;else gen.add(names_1.default.json, (0, codegen_1.str)`,`);\n    serializeProperty(key, properties[key], keyValue(key));\n  }\n  if (first) firstProp = gen.let(\"first\", true);\n  for (const key of optProps) {\n    const value = keyValue(key);\n    gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {\n      addComma(cxt, firstProp);\n      serializeProperty(key, optionalProperties[key], value);\n    });\n  }\n  if (schema.additionalProperties) {\n    gen.forIn(\"key\", data, key => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));\n  }\n  function keys(ps) {\n    return ps ? Object.keys(ps) : [];\n  }\n  function allProperties(ps) {\n    if (discriminator) ps.push(discriminator);\n    if (new Set(ps).size !== ps.length) {\n      throw new Error(\"JTD: properties/optionalProperties/disciminator overlap\");\n    }\n    return ps;\n  }\n  function keyValue(key) {\n    return gen.const(\"value\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);\n  }\n  function serializeProperty(key, propSchema, value) {\n    gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);\n    serializeCode({\n      ...cxt,\n      schema: propSchema,\n      data: value\n    });\n  }\n  function isAdditional(key, ps) {\n    return ps.length ? (0, codegen_1.and)(...ps.map(p => (0, codegen_1._)`${key} !== ${p}`)) : true;\n  }\n}\nfunction serializeType(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  switch (schema.type) {\n    case \"boolean\":\n      gen.add(names_1.default.json, (0, codegen_1._)`${data} ? \"true\" : \"false\"`);\n      break;\n    case \"string\":\n      serializeString(cxt);\n      break;\n    case \"timestamp\":\n      gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'\"' + ${data}.toISOString() + '\"'`), () => serializeString(cxt));\n      break;\n    default:\n      serializeNumber(cxt);\n  }\n}\nfunction serializeString({\n  gen,\n  data\n}) {\n  gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);\n}\nfunction serializeNumber({\n  gen,\n  data\n}) {\n  gen.add(names_1.default.json, (0, codegen_1._)`\"\" + ${data}`);\n}\nfunction serializeRef(cxt) {\n  const {\n    gen,\n    self,\n    data,\n    definitions,\n    schema,\n    schemaEnv\n  } = cxt;\n  const {\n    ref\n  } = schema;\n  const refSchema = definitions[ref];\n  if (!refSchema) throw new ref_error_1.default(self.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n  if (!(0, ref_1.hasRef)(refSchema)) return serializeCode({\n    ...cxt,\n    schema: refSchema\n  });\n  const {\n    root\n  } = schemaEnv;\n  const sch = compileSerializer.call(self, new __1.SchemaEnv({\n    schema: refSchema,\n    root\n  }), definitions);\n  gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);\n}\nfunction getSerialize(gen, sch) {\n  return sch.serialize ? gen.scopeValue(\"serialize\", {\n    ref: sch.serialize\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.serialize`;\n}\nfunction serializeEmpty({\n  gen,\n  data\n}) {\n  gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);\n}\nfunction addComma({\n  gen\n}, first) {\n  if (first) {\n    gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));\n  } else {\n    gen.add(names_1.default.json, (0, codegen_1.str)`,`);\n  }\n}","map":{"version":3,"names":["types_1","require","__1","codegen_1","ref_error_1","names_1","code_1","ref_1","util_1","quote_1","genSerialize","elements","serializeElements","values","serializeValues","discriminator","serializeDiscriminator","properties","serializeProperties","optionalProperties","enum","serializeString","type","serializeType","ref","serializeRef","compileSerializer","sch","definitions","_sch","getCompilingSchema","call","es5","lines","opts","code","ownProperties","gen","CodeGen","scope","serializeName","scopeName","cxt","self","schema","schemaEnv","data","default","sourceCode","_compilations","add","func","let","json","str","serializeCode","return","optimize","serializeFuncCode","toString","scopeRefs","makeSerialize","Function","serialize","get","value","e","logger","error","delete","exports","form","key","jtdForms","serializeNullable","serializeEmpty","serializeForm","nullable","if","_","first","forOf","el","addComma","forIn","serializeKeyValue","const","getProperty","JSON","stringify","tag","tagValue","mapping","elseIf","serializeSchemaProperties","endIf","props","keys","optProps","allProps","allProperties","concat","firstProp","serializeProperty","keyValue","and","isOwnProperty","additionalProperties","isAdditional","ps","Object","push","Set","size","length","Error","propSchema","map","p","serializeNumber","useFunc","refSchema","uriResolver","hasRef","root","SchemaEnv","getSerialize","scopeValue","assign"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\jtd\\serialize.ts"],"sourcesContent":["import type Ajv from \"../../core\"\nimport type {SchemaObject} from \"../../types\"\nimport {jtdForms, JTDForm, SchemaObjectMap} from \"./types\"\nimport {SchemaEnv, getCompilingSchema} from \"..\"\nimport {_, str, and, getProperty, CodeGen, Code, Name} from \"../codegen\"\nimport MissingRefError from \"../ref_error\"\nimport N from \"../names\"\nimport {isOwnProperty} from \"../../vocabularies/code\"\nimport {hasRef} from \"../../vocabularies/jtd/ref\"\nimport {useFunc} from \"../util\"\nimport quote from \"../../runtime/quote\"\n\nconst genSerialize: {[F in JTDForm]: (cxt: SerializeCxt) => void} = {\n  elements: serializeElements,\n  values: serializeValues,\n  discriminator: serializeDiscriminator,\n  properties: serializeProperties,\n  optionalProperties: serializeProperties,\n  enum: serializeString,\n  type: serializeType,\n  ref: serializeRef,\n}\n\ninterface SerializeCxt {\n  readonly gen: CodeGen\n  readonly self: Ajv // current Ajv instance\n  readonly schemaEnv: SchemaEnv\n  readonly definitions: SchemaObjectMap\n  schema: SchemaObject\n  data: Code\n}\n\nexport default function compileSerializer(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const serializeName = gen.scopeName(\"serialize\")\n  const cxt: SerializeCxt = {\n    self: this,\n    gen,\n    schema: sch.schema as SchemaObject,\n    schemaEnv: sch,\n    definitions,\n    data: N.data,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    sch.serializeName = serializeName\n    gen.func(serializeName, N.data, false, () => {\n      gen.let(N.json, str``)\n      serializeCode(cxt)\n      gen.return(N.json)\n    })\n    gen.optimize(this.opts.code.optimize)\n    const serializeFuncCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${serializeFuncCode}`\n    const makeSerialize = new Function(`${N.scope}`, sourceCode)\n    const serialize: (data: unknown) => string = makeSerialize(this.scope.get())\n    this.scope.value(serializeName, {ref: serialize})\n    sch.serialize = serialize\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling serializer, function code:\", sourceCode)\n    delete sch.serialize\n    delete sch.serializeName\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n  return sch\n}\n\nfunction serializeCode(cxt: SerializeCxt): void {\n  let form: JTDForm | undefined\n  for (const key of jtdForms) {\n    if (key in cxt.schema) {\n      form = key\n      break\n    }\n  }\n  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty)\n}\n\nfunction serializeNullable(cxt: SerializeCxt, serializeForm: (_cxt: SerializeCxt) => void): void {\n  const {gen, schema, data} = cxt\n  if (!schema.nullable) return serializeForm(cxt)\n  gen.if(\n    _`${data} === undefined || ${data} === null`,\n    () => gen.add(N.json, _`\"null\"`),\n    () => serializeForm(cxt)\n  )\n}\n\nfunction serializeElements(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  gen.add(N.json, str`[`)\n  const first = gen.let(\"first\", true)\n  gen.forOf(\"el\", data, (el) => {\n    addComma(cxt, first)\n    serializeCode({...cxt, schema: schema.elements, data: el})\n  })\n  gen.add(N.json, str`]`)\n}\n\nfunction serializeValues(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  gen.add(N.json, str`{`)\n  const first = gen.let(\"first\", true)\n  gen.forIn(\"key\", data, (key) => serializeKeyValue(cxt, key, schema.values, first))\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeKeyValue(cxt: SerializeCxt, key: Name, schema: SchemaObject, first?: Name): void {\n  const {gen, data} = cxt\n  addComma(cxt, first)\n  serializeString({...cxt, data: key})\n  gen.add(N.json, str`:`)\n  const value = gen.const(\"value\", _`${data}${getProperty(key)}`)\n  serializeCode({...cxt, schema, data: value})\n}\n\nfunction serializeDiscriminator(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  const {discriminator} = schema\n  gen.add(N.json, str`{${JSON.stringify(discriminator)}:`)\n  const tag = gen.const(\"tag\", _`${data}${getProperty(discriminator)}`)\n  serializeString({...cxt, data: tag})\n  gen.if(false)\n  for (const tagValue in schema.mapping) {\n    gen.elseIf(_`${tag} === ${tagValue}`)\n    const sch = schema.mapping[tagValue]\n    serializeSchemaProperties({...cxt, schema: sch}, discriminator)\n  }\n  gen.endIf()\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeProperties(cxt: SerializeCxt): void {\n  const {gen} = cxt\n  gen.add(N.json, str`{`)\n  serializeSchemaProperties(cxt)\n  gen.add(N.json, str`}`)\n}\n\nfunction serializeSchemaProperties(cxt: SerializeCxt, discriminator?: string): void {\n  const {gen, schema, data} = cxt\n  const {properties, optionalProperties} = schema\n  const props = keys(properties)\n  const optProps = keys(optionalProperties)\n  const allProps = allProperties(props.concat(optProps))\n  let first = !discriminator\n  let firstProp: Name | undefined\n\n  for (const key of props) {\n    if (first) first = false\n    else gen.add(N.json, str`,`)\n    serializeProperty(key, properties[key], keyValue(key))\n  }\n  if (first) firstProp = gen.let(\"first\", true)\n  for (const key of optProps) {\n    const value = keyValue(key)\n    gen.if(and(_`${value} !== undefined`, isOwnProperty(gen, data, key)), () => {\n      addComma(cxt, firstProp)\n      serializeProperty(key, optionalProperties[key], value)\n    })\n  }\n  if (schema.additionalProperties) {\n    gen.forIn(\"key\", data, (key) =>\n      gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp))\n    )\n  }\n\n  function keys(ps?: SchemaObjectMap): string[] {\n    return ps ? Object.keys(ps) : []\n  }\n\n  function allProperties(ps: string[]): string[] {\n    if (discriminator) ps.push(discriminator)\n    if (new Set(ps).size !== ps.length) {\n      throw new Error(\"JTD: properties/optionalProperties/disciminator overlap\")\n    }\n    return ps\n  }\n\n  function keyValue(key: string): Name {\n    return gen.const(\"value\", _`${data}${getProperty(key)}`)\n  }\n\n  function serializeProperty(key: string, propSchema: SchemaObject, value: Name): void {\n    gen.add(N.json, str`${JSON.stringify(key)}:`)\n    serializeCode({...cxt, schema: propSchema, data: value})\n  }\n\n  function isAdditional(key: Name, ps: string[]): Code | true {\n    return ps.length ? and(...ps.map((p) => _`${key} !== ${p}`)) : true\n  }\n}\n\nfunction serializeType(cxt: SerializeCxt): void {\n  const {gen, schema, data} = cxt\n  switch (schema.type) {\n    case \"boolean\":\n      gen.add(N.json, _`${data} ? \"true\" : \"false\"`)\n      break\n    case \"string\":\n      serializeString(cxt)\n      break\n    case \"timestamp\":\n      gen.if(\n        _`${data} instanceof Date`,\n        () => gen.add(N.json, _`'\"' + ${data}.toISOString() + '\"'`),\n        () => serializeString(cxt)\n      )\n      break\n    default:\n      serializeNumber(cxt)\n  }\n}\n\nfunction serializeString({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`${useFunc(gen, quote)}(${data})`)\n}\n\nfunction serializeNumber({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`\"\" + ${data}`)\n}\n\nfunction serializeRef(cxt: SerializeCxt): void {\n  const {gen, self, data, definitions, schema, schemaEnv} = cxt\n  const {ref} = schema\n  const refSchema = definitions[ref]\n  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n  if (!hasRef(refSchema)) return serializeCode({...cxt, schema: refSchema})\n  const {root} = schemaEnv\n  const sch = compileSerializer.call(self, new SchemaEnv({schema: refSchema, root}), definitions)\n  gen.add(N.json, _`${getSerialize(gen, sch)}(${data})`)\n}\n\nfunction getSerialize(gen: CodeGen, sch: SchemaEnv): Code {\n  return sch.serialize\n    ? gen.scopeValue(\"serialize\", {ref: sch.serialize})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.serialize`\n}\n\nfunction serializeEmpty({gen, data}: SerializeCxt): void {\n  gen.add(N.json, _`JSON.stringify(${data})`)\n}\n\nfunction addComma({gen}: SerializeCxt, first?: Name): void {\n  if (first) {\n    gen.if(\n      first,\n      () => gen.assign(first, false),\n      () => gen.add(N.json, str`,`)\n    )\n  } else {\n    gen.add(N.json, str`,`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}