{"ast":null,"code":"'use strict';\n\nvar fs = require('fs'),\n  path = require('path');\nvar cache;\n\n/**\n * Perform <code>path.relative()</code> but try to detect and correct sym-linked node modules.\n * @param {string} from The base path\n * @param {string} to The full path\n */\nfunction enhancedRelative(from, to) {\n  // relative path\n  var relative = path.relative(from, to);\n\n  // trailing is the relative path portion without any '../'\n  var trailing = relative.replace(/^\\.{2}[\\\\\\/]/, ''),\n    leading = to.replace(trailing, '');\n\n  // within project is what we want\n  var isInProject = relative === trailing;\n  if (isInProject) {\n    return relative;\n  }\n  // otherwise look at symbolic linked modules\n  else {\n    var splitTrailing = trailing.split(/[\\\\\\/]/);\n\n    // ensure failures can retry with fresh cache\n    for (var i = cache ? 2 : 1, foundPath = false; i > 0 && !foundPath; i--) {\n      // ensure cache\n      cache = cache || indexLinkedModules(from);\n\n      // take elements from the trailing path and append them the the leading path in an attempt to find a package.json\n      for (var j = 0; j < splitTrailing.length && !foundPath; j++) {\n        // find the name of packages in the actual file location\n        //  start at the lowest concrete directory that appears in the relative path\n        var packagePath = path.join.apply(path, [leading].concat(splitTrailing.slice(0, j + 1))),\n          packageJsonPath = path.join(packagePath, 'package.json'),\n          packageName = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n\n        // lookup any package name in the cache\n        var linkedPackagePath = !!packageName && cache[packageName];\n        if (linkedPackagePath) {\n          // the remaining portion of the trailing path, not including the package path\n          var remainingPath = path.join.apply(path, splitTrailing.slice(j + 1));\n\n          // validate the remaining path in the linked location\n          //  failure implies we will keep trying nested sym-linked packages\n          var linkedFilePath = path.join(linkedPackagePath, remainingPath),\n            isValid = !!linkedFilePath && fs.existsSync(linkedFilePath) && fs.statSync(linkedFilePath).isFile();\n\n          // path is found where valid\n          foundPath = isValid && linkedFilePath;\n        }\n      }\n\n      // cache cannot be trusted if a file can't be found\n      //  set the cache to false to trigger its rebuild\n      cache = !!foundPath && cache;\n    }\n\n    // the relative path should now be within the project\n    return foundPath ? path.relative(from, foundPath) : relative;\n  }\n}\nmodule.exports = enhancedRelative;\n\n/**\n * Make a hash of linked modules within the given directory by breadth-first search.\n * @param {string} directory A path to start searching\n * @returns {object} A collection of sym-linked paths within the project keyed by their package name\n */\nfunction indexLinkedModules(directory) {\n  var buffer = listSymLinkedModules(directory),\n    hash = {};\n\n  // while there are items in the buffer\n  while (buffer.length > 0) {\n    var modulePath = buffer.shift(),\n      packageJsonPath = path.join(modulePath, 'package.json'),\n      packageName = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n    if (packageName) {\n      // add this path keyed by package name, so long as it doesn't exist at a lower level\n      hash[packageName] = hash[packageName] || modulePath;\n\n      // detect nested module and push to the buffer (breadth-first)\n      buffer.push.apply(buffer, listSymLinkedModules(modulePath));\n    }\n  }\n  return hash;\n  function listSymLinkedModules(directory) {\n    var modulesPath = path.join(directory, 'node_modules'),\n      hasNodeModules = fs.existsSync(modulesPath) && fs.statSync(modulesPath).isDirectory(),\n      subdirectories = !!hasNodeModules && fs.readdirSync(modulesPath) || [];\n    return subdirectories.map(joinDirectory).filter(testIsSymLink);\n    function joinDirectory(subdirectory) {\n      return path.join(modulesPath, subdirectory);\n    }\n    function testIsSymLink(directory) {\n      return fs.lstatSync(directory).isSymbolicLink(); // must use lstatSync not statSync\n    }\n  }\n}","map":{"version":3,"names":["fs","require","path","cache","enhancedRelative","from","to","relative","trailing","replace","leading","isInProject","splitTrailing","split","i","foundPath","indexLinkedModules","j","length","packagePath","join","apply","concat","slice","packageJsonPath","packageName","existsSync","name","linkedPackagePath","remainingPath","linkedFilePath","isValid","statSync","isFile","module","exports","directory","buffer","listSymLinkedModules","hash","modulePath","shift","push","modulesPath","hasNodeModules","isDirectory","subdirectories","readdirSync","map","joinDirectory","filter","testIsSymLink","subdirectory","lstatSync","isSymbolicLink"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/adjust-sourcemap-loader/codec/utility/enhanced-relative.js"],"sourcesContent":["'use strict';\n\nvar fs   = require('fs'),\n    path = require('path');\n\nvar cache;\n\n/**\n * Perform <code>path.relative()</code> but try to detect and correct sym-linked node modules.\n * @param {string} from The base path\n * @param {string} to The full path\n */\nfunction enhancedRelative(from, to) {\n\n  // relative path\n  var relative = path.relative(from, to);\n\n  // trailing is the relative path portion without any '../'\n  var trailing = relative.replace(/^\\.{2}[\\\\\\/]/, ''),\n      leading  = to.replace(trailing, '');\n\n  // within project is what we want\n  var isInProject = (relative === trailing);\n  if (isInProject) {\n    return relative;\n  }\n  // otherwise look at symbolic linked modules\n  else {\n    var splitTrailing = trailing.split(/[\\\\\\/]/);\n\n    // ensure failures can retry with fresh cache\n    for (var i = cache ? 2 : 1, foundPath = false; (i > 0) && !foundPath; i--) {\n\n      // ensure cache\n      cache = cache || indexLinkedModules(from);\n\n      // take elements from the trailing path and append them the the leading path in an attempt to find a package.json\n      for (var j = 0; (j < splitTrailing.length) && !foundPath; j++) {\n\n        // find the name of packages in the actual file location\n        //  start at the lowest concrete directory that appears in the relative path\n        var packagePath     = path.join.apply(path, [leading].concat(splitTrailing.slice(0, j + 1))),\n            packageJsonPath = path.join(packagePath, 'package.json'),\n            packageName     = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n\n        // lookup any package name in the cache\n        var linkedPackagePath = !!packageName && cache[packageName];\n        if (linkedPackagePath) {\n\n          // the remaining portion of the trailing path, not including the package path\n          var remainingPath = path.join.apply(path, splitTrailing.slice(j + 1));\n\n          // validate the remaining path in the linked location\n          //  failure implies we will keep trying nested sym-linked packages\n          var linkedFilePath = path.join(linkedPackagePath, remainingPath),\n              isValid        = !!linkedFilePath && fs.existsSync(linkedFilePath) &&\n                fs.statSync(linkedFilePath).isFile();\n\n          // path is found where valid\n          foundPath = isValid && linkedFilePath;\n        }\n      }\n\n      // cache cannot be trusted if a file can't be found\n      //  set the cache to false to trigger its rebuild\n      cache = !!foundPath && cache;\n    }\n\n    // the relative path should now be within the project\n    return foundPath ? path.relative(from, foundPath) : relative;\n  }\n}\n\nmodule.exports = enhancedRelative;\n\n/**\n * Make a hash of linked modules within the given directory by breadth-first search.\n * @param {string} directory A path to start searching\n * @returns {object} A collection of sym-linked paths within the project keyed by their package name\n */\nfunction indexLinkedModules(directory) {\n  var buffer = listSymLinkedModules(directory),\n      hash   = {};\n\n  // while there are items in the buffer\n  while (buffer.length > 0) {\n    var modulePath      = buffer.shift(),\n        packageJsonPath = path.join(modulePath, 'package.json'),\n        packageName     = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n    if (packageName) {\n\n      // add this path keyed by package name, so long as it doesn't exist at a lower level\n      hash[packageName] = hash[packageName] || modulePath;\n\n      // detect nested module and push to the buffer (breadth-first)\n      buffer.push.apply(buffer, listSymLinkedModules(modulePath));\n    }\n  }\n  return hash;\n\n  function listSymLinkedModules(directory) {\n    var modulesPath    = path.join(directory, 'node_modules'),\n        hasNodeModules = fs.existsSync(modulesPath) && fs.statSync(modulesPath).isDirectory(),\n        subdirectories = !!hasNodeModules && fs.readdirSync(modulesPath) || [];\n\n    return subdirectories\n      .map(joinDirectory)\n      .filter(testIsSymLink);\n\n    function joinDirectory(subdirectory) {\n      return path.join(modulesPath, subdirectory);\n    }\n\n    function testIsSymLink(directory) {\n      return fs.lstatSync(directory).isSymbolicLink();  // must use lstatSync not statSync\n    }\n  }\n}"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAKC,OAAO,CAAC,IAAI,CAAC;EACpBC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAE1B,IAAIE,KAAK;;AAET;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,IAAI,EAAEC,EAAE,EAAE;EAElC;EACA,IAAIC,QAAQ,GAAGL,IAAI,CAACK,QAAQ,CAACF,IAAI,EAAEC,EAAE,CAAC;;EAEtC;EACA,IAAIE,QAAQ,GAAGD,QAAQ,CAACE,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;IAC/CC,OAAO,GAAIJ,EAAE,CAACG,OAAO,CAACD,QAAQ,EAAE,EAAE,CAAC;;EAEvC;EACA,IAAIG,WAAW,GAAIJ,QAAQ,KAAKC,QAAS;EACzC,IAAIG,WAAW,EAAE;IACf,OAAOJ,QAAQ;EACjB;EACA;EAAA,KACK;IACH,IAAIK,aAAa,GAAGJ,QAAQ,CAACK,KAAK,CAAC,QAAQ,CAAC;;IAE5C;IACA,KAAK,IAAIC,CAAC,GAAGX,KAAK,GAAG,CAAC,GAAG,CAAC,EAAEY,SAAS,GAAG,KAAK,EAAGD,CAAC,GAAG,CAAC,IAAK,CAACC,SAAS,EAAED,CAAC,EAAE,EAAE;MAEzE;MACAX,KAAK,GAAGA,KAAK,IAAIa,kBAAkB,CAACX,IAAI,CAAC;;MAEzC;MACA,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAGA,CAAC,GAAGL,aAAa,CAACM,MAAM,IAAK,CAACH,SAAS,EAAEE,CAAC,EAAE,EAAE;QAE7D;QACA;QACA,IAAIE,WAAW,GAAOjB,IAAI,CAACkB,IAAI,CAACC,KAAK,CAACnB,IAAI,EAAE,CAACQ,OAAO,CAAC,CAACY,MAAM,CAACV,aAAa,CAACW,KAAK,CAAC,CAAC,EAAEN,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UACxFO,eAAe,GAAGtB,IAAI,CAACkB,IAAI,CAACD,WAAW,EAAE,cAAc,CAAC;UACxDM,WAAW,GAAOzB,EAAE,CAAC0B,UAAU,CAACF,eAAe,CAAC,IAAIvB,OAAO,CAACuB,eAAe,CAAC,CAACG,IAAI;;QAErF;QACA,IAAIC,iBAAiB,GAAG,CAAC,CAACH,WAAW,IAAItB,KAAK,CAACsB,WAAW,CAAC;QAC3D,IAAIG,iBAAiB,EAAE;UAErB;UACA,IAAIC,aAAa,GAAG3B,IAAI,CAACkB,IAAI,CAACC,KAAK,CAACnB,IAAI,EAAEU,aAAa,CAACW,KAAK,CAACN,CAAC,GAAG,CAAC,CAAC,CAAC;;UAErE;UACA;UACA,IAAIa,cAAc,GAAG5B,IAAI,CAACkB,IAAI,CAACQ,iBAAiB,EAAEC,aAAa,CAAC;YAC5DE,OAAO,GAAU,CAAC,CAACD,cAAc,IAAI9B,EAAE,CAAC0B,UAAU,CAACI,cAAc,CAAC,IAChE9B,EAAE,CAACgC,QAAQ,CAACF,cAAc,CAAC,CAACG,MAAM,CAAC,CAAC;;UAE1C;UACAlB,SAAS,GAAGgB,OAAO,IAAID,cAAc;QACvC;MACF;;MAEA;MACA;MACA3B,KAAK,GAAG,CAAC,CAACY,SAAS,IAAIZ,KAAK;IAC9B;;IAEA;IACA,OAAOY,SAAS,GAAGb,IAAI,CAACK,QAAQ,CAACF,IAAI,EAAEU,SAAS,CAAC,GAAGR,QAAQ;EAC9D;AACF;AAEA2B,MAAM,CAACC,OAAO,GAAG/B,gBAAgB;;AAEjC;AACA;AACA;AACA;AACA;AACA,SAASY,kBAAkBA,CAACoB,SAAS,EAAE;EACrC,IAAIC,MAAM,GAAGC,oBAAoB,CAACF,SAAS,CAAC;IACxCG,IAAI,GAAK,CAAC,CAAC;;EAEf;EACA,OAAOF,MAAM,CAACnB,MAAM,GAAG,CAAC,EAAE;IACxB,IAAIsB,UAAU,GAAQH,MAAM,CAACI,KAAK,CAAC,CAAC;MAChCjB,eAAe,GAAGtB,IAAI,CAACkB,IAAI,CAACoB,UAAU,EAAE,cAAc,CAAC;MACvDf,WAAW,GAAOzB,EAAE,CAAC0B,UAAU,CAACF,eAAe,CAAC,IAAIvB,OAAO,CAACuB,eAAe,CAAC,CAACG,IAAI;IACrF,IAAIF,WAAW,EAAE;MAEf;MACAc,IAAI,CAACd,WAAW,CAAC,GAAGc,IAAI,CAACd,WAAW,CAAC,IAAIe,UAAU;;MAEnD;MACAH,MAAM,CAACK,IAAI,CAACrB,KAAK,CAACgB,MAAM,EAAEC,oBAAoB,CAACE,UAAU,CAAC,CAAC;IAC7D;EACF;EACA,OAAOD,IAAI;EAEX,SAASD,oBAAoBA,CAACF,SAAS,EAAE;IACvC,IAAIO,WAAW,GAAMzC,IAAI,CAACkB,IAAI,CAACgB,SAAS,EAAE,cAAc,CAAC;MACrDQ,cAAc,GAAG5C,EAAE,CAAC0B,UAAU,CAACiB,WAAW,CAAC,IAAI3C,EAAE,CAACgC,QAAQ,CAACW,WAAW,CAAC,CAACE,WAAW,CAAC,CAAC;MACrFC,cAAc,GAAG,CAAC,CAACF,cAAc,IAAI5C,EAAE,CAAC+C,WAAW,CAACJ,WAAW,CAAC,IAAI,EAAE;IAE1E,OAAOG,cAAc,CAClBE,GAAG,CAACC,aAAa,CAAC,CAClBC,MAAM,CAACC,aAAa,CAAC;IAExB,SAASF,aAAaA,CAACG,YAAY,EAAE;MACnC,OAAOlD,IAAI,CAACkB,IAAI,CAACuB,WAAW,EAAES,YAAY,CAAC;IAC7C;IAEA,SAASD,aAAaA,CAACf,SAAS,EAAE;MAChC,OAAOpC,EAAE,CAACqD,SAAS,CAACjB,SAAS,CAAC,CAACkB,cAAc,CAAC,CAAC,CAAC,CAAE;IACpD;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}