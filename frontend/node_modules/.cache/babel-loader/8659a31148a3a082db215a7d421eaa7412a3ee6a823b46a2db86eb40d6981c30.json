{"ast":null,"code":"let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\nlet feature = require('caniuse-lite/dist/unpacker/feature');\nlet {\n  parse\n} = require('postcss');\nlet Browsers = require('./browsers');\nlet brackets = require('./brackets');\nlet Value = require('./value');\nlet utils = require('./utils');\nlet data = feature(featureQueries);\nlet supported = [];\nfor (let browser in data.stats) {\n  let versions = data.stats[browser];\n  for (let version in versions) {\n    let support = versions[version];\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0]);\n        if (prefixed.length > 1) {\n          return this.convert(prefixed);\n        }\n        return i;\n      }\n      if (typeof i === 'object') {\n        return this.add(i, all);\n      }\n      return i;\n    });\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i;\n      }\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0]);\n      }\n      return this.cleanBrackets(i);\n    });\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = [''];\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`]);\n      result.push(' or ');\n    }\n    result[result.length - 1] = '';\n    return result;\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true;\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true;\n      }\n    }\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true;\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content'];\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`);\n    return !check.test(all);\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node);\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes;\n    }\n    nodes = nodes.filter(i => i !== '');\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim();\n      if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {\n        return [brackets.stringify(nodes)];\n      }\n    }\n    return nodes.map(i => this.normalize(i));\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':');\n    let prop = parts[0];\n    let value = parts[1];\n    if (!value) value = '';\n    return [prop.trim(), value.trim()];\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str);\n    if (this.disabled(rule.first)) {\n      return rule.nodes;\n    }\n    let result = {\n      warn: () => null\n    };\n    let prefixer = this.prefixer().add[rule.first.prop];\n    prefixer && prefixer.process && prefixer.process(rule.first, result);\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl);\n      }\n      Value.save(this.all, decl);\n    }\n    return rule.nodes;\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache;\n    }\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i);\n    });\n    let browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n    this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n    return this.prefixerCache;\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params);\n    ast = this.normalize(ast);\n    ast = this.remove(ast, rule.params);\n    ast = this.add(ast, rule.params);\n    ast = this.cleanBrackets(ast);\n    rule.params = brackets.stringify(ast);\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0;\n    while (i < nodes.length) {\n      if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2);\n          continue;\n        }\n        i += 2;\n        continue;\n      }\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all);\n      }\n      i += 1;\n    }\n    return nodes;\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str);\n    let unprefixed = this.all.unprefixed(prop);\n    let cleaner = this.all.cleaner();\n    if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n      return true;\n    }\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str);\n    let rule = parse('a{}').first;\n    rule.append({\n      prop,\n      raws: {\n        before: ''\n      },\n      value\n    });\n    return rule;\n  }\n}\nmodule.exports = Supports;","map":{"version":3,"names":["featureQueries","require","feature","parse","Browsers","brackets","Value","utils","data","supported","browser","stats","versions","version","support","test","push","Supports","constructor","Prefixes","all","add","nodes","map","i","isProp","prefixed","length","convert","cleanBrackets","progress","result","prop","value","disabled","node","options","grid","includes","flexbox","other","isHack","unprefixed","check","RegExp","escapeRegexp","isNot","isOr","normalize","filter","firstNode","trim","stringify","str","parts","split","rule","virtual","first","warn","prefixer","process","decl","values","save","prefixerCache","filtered","browsers","selected","ast","params","remove","toRemove","splice","cleaner","checker","append","raws","before","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/autoprefixer/lib/supports.js"],"sourcesContent":["let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')\nlet feature = require('caniuse-lite/dist/unpacker/feature')\nlet { parse } = require('postcss')\n\nlet Browsers = require('./browsers')\nlet brackets = require('./brackets')\nlet Value = require('./value')\nlet utils = require('./utils')\n\nlet data = feature(featureQueries)\n\nlet supported = []\nfor (let browser in data.stats) {\n  let versions = data.stats[browser]\n  for (let version in versions) {\n    let support = versions[version]\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version)\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes\n    this.all = all\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0])\n        if (prefixed.length > 1) {\n          return this.convert(prefixed)\n        }\n\n        return i\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all)\n      }\n\n      return i\n    })\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0])\n      }\n\n      return this.cleanBrackets(i)\n    })\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = ['']\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`])\n      result.push(' or ')\n    }\n    result[result.length - 1] = ''\n    return result\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content']\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`)\n    return !check.test(all)\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return (\n      typeof node === 'object' &&\n      node.length === 1 &&\n      typeof node[0] === 'string'\n    )\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes\n    }\n\n    nodes = nodes.filter(i => i !== '')\n\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim()\n\n      if (\n        firstNode.includes(':') ||\n        firstNode === 'selector' ||\n        firstNode === 'not selector'\n      ) {\n        return [brackets.stringify(nodes)]\n      }\n    }\n    return nodes.map(i => this.normalize(i))\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':')\n    let prop = parts[0]\n    let value = parts[1]\n    if (!value) value = ''\n    return [prop.trim(), value.trim()]\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str)\n    if (this.disabled(rule.first)) {\n      return rule.nodes\n    }\n\n    let result = { warn: () => null }\n\n    let prefixer = this.prefixer().add[rule.first.prop]\n    prefixer && prefixer.process && prefixer.process(rule.first, result)\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl)\n      }\n      Value.save(this.all, decl)\n    }\n\n    return rule.nodes\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i)\n    })\n\n    let browsers = new Browsers(\n      this.all.browsers.data,\n      filtered,\n      this.all.options\n    )\n    this.prefixerCache = new this.Prefixes(\n      this.all.data,\n      browsers,\n      this.all.options\n    )\n    return this.prefixerCache\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params)\n    ast = this.normalize(ast)\n    ast = this.remove(ast, rule.params)\n    ast = this.add(ast, rule.params)\n    ast = this.cleanBrackets(ast)\n    rule.params = brackets.stringify(ast)\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0\n    while (i < nodes.length) {\n      if (\n        !this.isNot(nodes[i - 1]) &&\n        this.isProp(nodes[i]) &&\n        this.isOr(nodes[i + 1])\n      ) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2)\n          continue\n        }\n\n        i += 2\n        continue\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all)\n      }\n\n      i += 1\n    }\n    return nodes\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str)\n    let unprefixed = this.all.unprefixed(prop)\n\n    let cleaner = this.all.cleaner()\n\n    if (\n      cleaner.remove[prop] &&\n      cleaner.remove[prop].remove &&\n      !this.isHack(all, unprefixed)\n    ) {\n      return true\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str)\n    let rule = parse('a{}').first\n    rule.append({ prop, raws: { before: '' }, value })\n    return rule\n  }\n}\n\nmodule.exports = Supports\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}