{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst transform = {\n  trimStart: s => s.trimStart(),\n  trimEnd: s => s.trimEnd(),\n  trimLeft: s => s.trimStart(),\n  trimRight: s => s.trimEnd(),\n  trim: s => s.trim(),\n  toLowerCase: s => s.toLowerCase(),\n  toUpperCase: s => s.toUpperCase(),\n  toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s\n};\nconst getDef = Object.assign(_getDef, {\n  transform\n});\nfunction _getDef() {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt) {\n      const {\n        gen,\n        data,\n        schema,\n        parentSchema,\n        it\n      } = cxt;\n      const {\n        parentData,\n        parentDataProperty\n      } = it;\n      const tNames = schema;\n      if (!tNames.length) return;\n      let cfg;\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema);\n        cfg = gen.scopeValue(\"obj\", {\n          ref: config,\n          code: (0, codegen_1.stringify)(config)\n        });\n      }\n      gen.if((0, codegen_1._)`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()));\n        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, data);\n      });\n      function transformExpr(ts) {\n        if (!ts.length) return data;\n        const t = ts.pop();\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`);\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t],\n          code: (0, codegen_1._)`require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`\n        });\n        const arg = transformExpr(ts);\n        return cfg && t === \"toEnumCase\" ? (0, codegen_1._)`${func}(${arg}, ${cfg})` : (0, codegen_1._)`${func}(${arg})`;\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        enum: Object.keys(transform)\n      }\n    }\n  };\n}\nfunction getEnumCaseCfg(parentSchema) {\n  // build hash table to enum values\n  const cfg = {\n    hash: {}\n  };\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue;\n    const k = configKey(v);\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n    }\n    cfg.hash[k] = v;\n  }\n  return cfg;\n}\nfunction configKey(s) {\n  return s.toLowerCase();\n}\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"names":["codegen_1","require","transform","trimStart","s","trimEnd","trimLeft","trimRight","trim","toLowerCase","toUpperCase","toEnumCase","cfg","hash","configKey","getDef","Object","assign","_getDef","keyword","schemaType","before","code","cxt","gen","data","schema","parentSchema","it","parentData","parentDataProperty","tNames","length","includes","config","getEnumCaseCfg","scopeValue","ref","stringify","if","_","transformExpr","slice","ts","t","pop","Error","func","getProperty","arg","metaSchema","type","items","enum","keys","v","k","exports","default","module"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv-keywords\\src\\definitions\\transform.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordCxt, Code, Name} from \"ajv\"\nimport {_, stringify, getProperty} from \"ajv/dist/compile/codegen\"\n\ntype TransformName =\n  | \"trimStart\"\n  | \"trimEnd\"\n  | \"trimLeft\"\n  | \"trimRight\"\n  | \"trim\"\n  | \"toLowerCase\"\n  | \"toUpperCase\"\n  | \"toEnumCase\"\n\ninterface TransformConfig {\n  hash: Record<string, string | undefined>\n}\n\ntype Transform = (s: string, cfg?: TransformConfig) => string\n\nconst transform: {[key in TransformName]: Transform} = {\n  trimStart: (s) => s.trimStart(),\n  trimEnd: (s) => s.trimEnd(),\n  trimLeft: (s) => s.trimStart(),\n  trimRight: (s) => s.trimEnd(),\n  trim: (s) => s.trim(),\n  toLowerCase: (s) => s.toLowerCase(),\n  toUpperCase: (s) => s.toUpperCase(),\n  toEnumCase: (s, cfg) => cfg?.hash[configKey(s)] || s,\n}\n\nconst getDef: (() => CodeKeywordDefinition) & {\n  transform: typeof transform\n} = Object.assign(_getDef, {transform})\n\nfunction _getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt: KeywordCxt) {\n      const {gen, data, schema, parentSchema, it} = cxt\n      const {parentData, parentDataProperty} = it\n      const tNames: string[] = schema\n      if (!tNames.length) return\n      let cfg: Name | undefined\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema)\n        cfg = gen.scopeValue(\"obj\", {ref: config, code: stringify(config)})\n      }\n      gen.if(_`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()))\n        gen.assign(_`${parentData}[${parentDataProperty}]`, data)\n      })\n\n      function transformExpr(ts: string[]): Code {\n        if (!ts.length) return data\n        const t = ts.pop() as string\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`)\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t as TransformName],\n          code: _`require(\"ajv-keywords/dist/definitions/transform\").transform${getProperty(t)}`,\n        })\n        const arg = transformExpr(ts)\n        return cfg && t === \"toEnumCase\" ? _`${func}(${arg}, ${cfg})` : _`${func}(${arg})`\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", enum: Object.keys(transform)},\n    },\n  }\n}\n\nfunction getEnumCaseCfg(parentSchema: AnySchemaObject): TransformConfig {\n  // build hash table to enum values\n  const cfg: TransformConfig = {hash: {}}\n\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"')\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue\n    const k = configKey(v)\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique')\n    }\n    cfg.hash[k] = v\n  }\n\n  return cfg\n}\n\nfunction configKey(s: string): string {\n  return s.toLowerCase()\n}\n\nexport default getDef\nmodule.exports = getDef\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}