{"ast":null,"code":"/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nconst {\n  readFileSync\n} = require(\"fs\");\nconst {\n  join\n} = require(\"path\");\nconst ejs = require(\"ejs\");\nconst MagicString = require(\"magic-string\");\nconst json5 = require(\"json5\");\n// See https://github.com/surma/rollup-plugin-off-main-thread/issues/49\nconst matchAll = require(\"string.prototype.matchall\");\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) => chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\",\n  // Silence the warning about ESM being badly supported in workers.\n  silenceESMWorkerWarning: false\n};\n\n// A regexp to find static `new Worker` invocations.\n// Matches `new Worker(...file part...`\n// File part matches one of:\n// - '...'\n// - \"...\"\n// - `import.meta.url`\n// - new URL('...', import.meta.url)\n// - new URL(\"...\", import.meta.url)\nconst workerRegexpForTransform = /(new\\s+Worker\\()\\s*(('.*?'|\".*?\")|import\\.meta\\.url|new\\s+URL\\(('.*?'|\".*?\"),\\s*import\\.meta\\.url\\))/gs;\n\n// A regexp to find static `new Worker` invocations we've rewritten during the transform phase.\n// Matches `new Worker(...file part..., ...options...`.\n// File part matches one of:\n// - new URL('...', module.uri)\n// - new URL(\"...\", module.uri)\nconst workerRegexpForOutput = /new\\s+Worker\\(new\\s+URL\\((?:'.*?'|\".*?\"),\\s*module\\.uri\\)\\s*(,([^)]+))/gs;\nlet longWarningAlreadyShown = false;\nmodule.exports = function (opts = {}) {\n  opts = Object.assign({}, defaultOpts, opts);\n  opts.loader = ejs.render(opts.loader, opts);\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n  let workerFiles;\n  let isEsmOutput = () => {\n    throw new Error(\"outputOptions hasn't been called yet\");\n  };\n  return {\n    name: \"off-main-thread\",\n    async buildStart(options) {\n      workerFiles = [];\n    },\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const path = id.slice(urlLoaderPrefix.length);\n      const resolved = await this.resolve(path, importer);\n      if (!resolved) throw Error(`Cannot find module '${path}' from '${importer}'`);\n      const newId = resolved.id;\n      return urlLoaderPrefix + newId;\n    },\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({\n        id: realId,\n        type: \"chunk\"\n      });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n    async transform(code, id) {\n      const ms = new MagicString(code);\n      const replacementPromises = [];\n      for (const match of matchAll(code, workerRegexpForTransform)) {\n        let [fullMatch, partBeforeArgs, workerSource, directWorkerFile, workerFile] = match;\n        const workerParametersEndIndex = match.index + fullMatch.length;\n        const matchIndex = match.index;\n        const workerParametersStartIndex = matchIndex + partBeforeArgs.length;\n        let workerIdPromise;\n        if (workerSource === \"import.meta.url\") {\n          // Turn the current file into a chunk\n          workerIdPromise = Promise.resolve(id);\n        } else {\n          // Otherwise it's a string literal either directly or in the `new URL(...)`.\n          if (directWorkerFile) {\n            const fullMatchWithOpts = `${fullMatch}, …)`;\n            const fullReplacement = `new Worker(new URL(${directWorkerFile}, import.meta.url), …)`;\n            if (!longWarningAlreadyShown) {\n              this.warn(`rollup-plugin-off-main-thread:\n\\`${fullMatchWithOpts}\\` suggests that the Worker should be relative to the document, not the script.\nIn the bundler, we don't know what the final document's URL will be, and instead assume it's a URL relative to the current module.\nThis might lead to incorrect behaviour during runtime.\nIf you did mean to use a URL relative to the current module, please change your code to the following form:\n\\`${fullReplacement}\\`\nThis will become a hard error in the future.`, matchIndex);\n              longWarningAlreadyShown = true;\n            } else {\n              this.warn(`rollup-plugin-off-main-thread: Treating \\`${fullMatchWithOpts}\\` as \\`${fullReplacement}\\``, matchIndex);\n            }\n            workerFile = directWorkerFile;\n          }\n\n          // Cut off surrounding quotes.\n          workerFile = workerFile.slice(1, -1);\n          if (!/^\\.{1,2}\\//.test(workerFile)) {\n            let isError = false;\n            if (directWorkerFile) {\n              // If direct worker file, it must be in `./something` form.\n              isError = true;\n            } else {\n              // If `new URL(...)` it can be in `new URL('something', import.meta.url)` form too,\n              // so just check it's not absolute.\n              if (/^(\\/|https?:)/.test(workerFile)) {\n                isError = true;\n              } else {\n                // If it does turn out to be `new URL('something', import.meta.url)` form,\n                // prepend `./` so that it becomes valid module specifier.\n                workerFile = `./${workerFile}`;\n              }\n            }\n            if (isError) {\n              this.warn(`Paths passed to the Worker constructor must be relative to the current file, i.e. start with ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`, matchIndex);\n              continue;\n            }\n          }\n          workerIdPromise = this.resolve(workerFile, id).then(res => res.id);\n        }\n        replacementPromises.push((async () => {\n          const resolvedWorkerFile = await workerIdPromise;\n          workerFiles.push(resolvedWorkerFile);\n          const chunkRefId = this.emitFile({\n            id: resolvedWorkerFile,\n            type: \"chunk\"\n          });\n          ms.overwrite(workerParametersStartIndex, workerParametersEndIndex, `new URL(import.meta.ROLLUP_FILE_URL_${chunkRefId}, import.meta.url)`);\n        })());\n      }\n\n      // No matches found.\n      if (!replacementPromises.length) {\n        return;\n      }\n\n      // Wait for all the scheduled replacements to finish.\n      await Promise.all(replacementPromises);\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({\n          hires: true\n        })\n      };\n    },\n    resolveFileUrl(chunk) {\n      return JSON.stringify(chunk.relativePath);\n    },\n    outputOptions({\n      format\n    }) {\n      if (format === \"esm\" || format === \"es\") {\n        if (!opts.silenceESMWorkerWarning) {\n          this.warn('Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`');\n        }\n        // In ESM, we never prepend a loader.\n        isEsmOutput = () => true;\n      } else if (format !== \"amd\") {\n        this.error(`\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`);\n      } else {\n        isEsmOutput = () => false;\n      }\n    },\n    renderDynamicImport() {\n      if (isEsmOutput()) return;\n\n      // In our loader, `require` simply return a promise directly.\n      // This is tinier and simpler output than the Rollup's default.\n      return {\n        left: 'require(',\n        right: ')'\n      };\n    },\n    resolveImportMeta(property) {\n      if (isEsmOutput()) return;\n      if (property === 'url') {\n        // In our loader, `module.uri` is already fully resolved\n        // so we can emit something shorter than the Rollup's default.\n        return `module.uri`;\n      }\n    },\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput()) return;\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\");\n        return;\n      }\n      const ms = new MagicString(code);\n      for (const match of matchAll(code, workerRegexpForOutput)) {\n        let [fullMatch, optionsWithCommaStr, optionsStr] = match;\n        let options;\n        try {\n          options = json5.parse(optionsStr);\n        } catch (e) {\n          // If we couldn't parse the options object, maybe it's something dynamic or has nested\n          // parentheses or something like that. In that case, treat it as a warning\n          // and not a hard error, just like we wouldn't break on unmatched regex.\n          console.warn(\"Couldn't match options object\", fullMatch, \": \", e);\n          continue;\n        }\n        if (!(\"type\" in options)) {\n          // Nothing to do.\n          continue;\n        }\n        delete options.type;\n        const replacementEnd = match.index + fullMatch.length;\n        const replacementStart = replacementEnd - optionsWithCommaStr.length;\n        optionsStr = json5.stringify(options);\n        optionsWithCommaStr = optionsStr === \"{}\" ? \"\" : `, ${optionsStr}`;\n        ms.overwrite(replacementStart, replacementEnd, optionsWithCommaStr);\n      }\n\n      // Mangle define() call\n      ms.remove(0, \"define(\".length);\n      // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n      ms.prepend(`${opts.amdFunctionName}(`);\n\n      // Prepend loader if it’s an entry point or a worker file\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n      const newCode = ms.toString();\n      const hasCodeChanged = code !== newCode;\n      return {\n        code: newCode,\n        // Avoid generating sourcemaps if possible as it can be a very expensive operation\n        map: hasCodeChanged ? ms.generateMap({\n          hires: true\n        }) : null\n      };\n    }\n  };\n};","map":{"version":3,"names":["readFileSync","require","join","ejs","MagicString","json5","matchAll","defaultOpts","loader","__dirname","useEval","amdFunctionName","prependLoader","chunk","workerFiles","isEntry","includes","facadeModuleId","urlLoaderScheme","silenceESMWorkerWarning","workerRegexpForTransform","workerRegexpForOutput","longWarningAlreadyShown","module","exports","opts","Object","assign","render","urlLoaderPrefix","isEsmOutput","Error","name","buildStart","options","resolveId","id","importer","startsWith","path","slice","length","resolved","resolve","newId","load","realId","chunkRef","emitFile","type","transform","code","ms","replacementPromises","match","fullMatch","partBeforeArgs","workerSource","directWorkerFile","workerFile","workerParametersEndIndex","index","matchIndex","workerParametersStartIndex","workerIdPromise","Promise","fullMatchWithOpts","fullReplacement","warn","test","isError","then","res","push","resolvedWorkerFile","chunkRefId","overwrite","all","toString","map","generateMap","hires","resolveFileUrl","JSON","stringify","relativePath","outputOptions","format","error","renderDynamicImport","left","right","resolveImportMeta","property","renderChunk","banner","optionsWithCommaStr","optionsStr","parse","e","console","replacementEnd","replacementStart","remove","prepend","newCode","hasCodeChanged"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@surma/rollup-plugin-off-main-thread/index.js"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nconst { readFileSync } = require(\"fs\");\nconst { join } = require(\"path\");\nconst ejs = require(\"ejs\");\nconst MagicString = require(\"magic-string\");\nconst json5 = require(\"json5\");\n// See https://github.com/surma/rollup-plugin-off-main-thread/issues/49\nconst matchAll = require(\"string.prototype.matchall\");\n\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) =>\n    chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\",\n  // Silence the warning about ESM being badly supported in workers.\n  silenceESMWorkerWarning: false\n};\n\n// A regexp to find static `new Worker` invocations.\n// Matches `new Worker(...file part...`\n// File part matches one of:\n// - '...'\n// - \"...\"\n// - `import.meta.url`\n// - new URL('...', import.meta.url)\n// - new URL(\"...\", import.meta.url)\nconst workerRegexpForTransform = /(new\\s+Worker\\()\\s*(('.*?'|\".*?\")|import\\.meta\\.url|new\\s+URL\\(('.*?'|\".*?\"),\\s*import\\.meta\\.url\\))/gs;\n\n// A regexp to find static `new Worker` invocations we've rewritten during the transform phase.\n// Matches `new Worker(...file part..., ...options...`.\n// File part matches one of:\n// - new URL('...', module.uri)\n// - new URL(\"...\", module.uri)\nconst workerRegexpForOutput = /new\\s+Worker\\(new\\s+URL\\((?:'.*?'|\".*?\"),\\s*module\\.uri\\)\\s*(,([^)]+))/gs;\n\nlet longWarningAlreadyShown = false;\n\nmodule.exports = function(opts = {}) {\n  opts = Object.assign({}, defaultOpts, opts);\n\n  opts.loader = ejs.render(opts.loader, opts);\n\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n\n  let workerFiles;\n  let isEsmOutput = () => { throw new Error(\"outputOptions hasn't been called yet\") };\n  return {\n    name: \"off-main-thread\",\n\n    async buildStart(options) {\n      workerFiles = [];\n    },\n\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const path = id.slice(urlLoaderPrefix.length);\n      const resolved = await this.resolve(path, importer);\n      if (!resolved)\n        throw Error(`Cannot find module '${path}' from '${importer}'`);\n      const newId = resolved.id;\n\n      return urlLoaderPrefix + newId;\n    },\n\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({ id: realId, type: \"chunk\" });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n\n    async transform(code, id) {\n      const ms = new MagicString(code);\n\n      const replacementPromises = [];\n\n      for (const match of matchAll(code, workerRegexpForTransform)) {\n        let [\n          fullMatch,\n          partBeforeArgs,\n          workerSource,\n          directWorkerFile,\n          workerFile,\n        ] = match;\n\n        const workerParametersEndIndex = match.index + fullMatch.length;\n        const matchIndex = match.index;\n        const workerParametersStartIndex = matchIndex + partBeforeArgs.length;\n\n        let workerIdPromise;\n        if (workerSource === \"import.meta.url\") {\n          // Turn the current file into a chunk\n          workerIdPromise = Promise.resolve(id);\n        } else {\n          // Otherwise it's a string literal either directly or in the `new URL(...)`.\n          if (directWorkerFile) {\n            const fullMatchWithOpts = `${fullMatch}, …)`;\n            const fullReplacement = `new Worker(new URL(${directWorkerFile}, import.meta.url), …)`;\n\n            if (!longWarningAlreadyShown) {\n              this.warn(\n                `rollup-plugin-off-main-thread:\n\\`${fullMatchWithOpts}\\` suggests that the Worker should be relative to the document, not the script.\nIn the bundler, we don't know what the final document's URL will be, and instead assume it's a URL relative to the current module.\nThis might lead to incorrect behaviour during runtime.\nIf you did mean to use a URL relative to the current module, please change your code to the following form:\n\\`${fullReplacement}\\`\nThis will become a hard error in the future.`,\n                matchIndex\n              );\n              longWarningAlreadyShown = true;\n            } else {\n              this.warn(\n                `rollup-plugin-off-main-thread: Treating \\`${fullMatchWithOpts}\\` as \\`${fullReplacement}\\``,\n                matchIndex\n              );\n            }\n            workerFile = directWorkerFile;\n          }\n\n          // Cut off surrounding quotes.\n          workerFile = workerFile.slice(1, -1);\n\n          if (!/^\\.{1,2}\\//.test(workerFile)) {\n            let isError = false;\n            if (directWorkerFile) {\n              // If direct worker file, it must be in `./something` form.\n              isError = true;\n            } else {\n              // If `new URL(...)` it can be in `new URL('something', import.meta.url)` form too,\n              // so just check it's not absolute.\n              if (/^(\\/|https?:)/.test(workerFile)) {\n                isError = true;\n              } else {\n                // If it does turn out to be `new URL('something', import.meta.url)` form,\n                // prepend `./` so that it becomes valid module specifier.\n                workerFile = `./${workerFile}`;\n              }\n            }\n            if (isError) {\n              this.warn(\n                `Paths passed to the Worker constructor must be relative to the current file, i.e. start with ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`,\n                matchIndex\n              );\n              continue;\n            }\n          }\n\n          workerIdPromise = this.resolve(workerFile, id).then(res => res.id);\n        }\n\n        replacementPromises.push(\n          (async () => {\n            const resolvedWorkerFile = await workerIdPromise;\n            workerFiles.push(resolvedWorkerFile);\n            const chunkRefId = this.emitFile({\n              id: resolvedWorkerFile,\n              type: \"chunk\"\n            });\n\n            ms.overwrite(\n              workerParametersStartIndex,\n              workerParametersEndIndex,\n              `new URL(import.meta.ROLLUP_FILE_URL_${chunkRefId}, import.meta.url)`\n            );\n          })()\n        );\n      }\n\n      // No matches found.\n      if (!replacementPromises.length) {\n        return;\n      }\n\n      // Wait for all the scheduled replacements to finish.\n      await Promise.all(replacementPromises);\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({ hires: true })\n      };\n    },\n\n    resolveFileUrl(chunk) {\n      return JSON.stringify(chunk.relativePath);\n    },\n\n    outputOptions({ format }) {\n      if (format === \"esm\" || format === \"es\") {\n        if (!opts.silenceESMWorkerWarning) {\n          this.warn(\n            'Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`'\n          );\n        }\n        // In ESM, we never prepend a loader.\n        isEsmOutput = () => true;\n      } else if (format !== \"amd\") {\n        this.error(\n          `\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`\n        );\n      } else {\n        isEsmOutput = () => false;\n      }\n    },\n\n    renderDynamicImport() {\n      if (isEsmOutput()) return;\n\n      // In our loader, `require` simply return a promise directly.\n      // This is tinier and simpler output than the Rollup's default.\n      return {\n        left: 'require(',\n        right: ')'\n      };\n    },\n\n    resolveImportMeta(property) {\n      if (isEsmOutput()) return;\n\n      if (property === 'url') {\n        // In our loader, `module.uri` is already fully resolved\n        // so we can emit something shorter than the Rollup's default.\n        return `module.uri`;\n      }\n    },\n\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput()) return;\n\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\n          \"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\"\n        );\n        return;\n      }\n      const ms = new MagicString(code);\n\n      for (const match of matchAll(code, workerRegexpForOutput)) {\n        let [fullMatch, optionsWithCommaStr, optionsStr] = match;\n        let options;\n        try {\n          options = json5.parse(optionsStr);\n        } catch (e) {\n          // If we couldn't parse the options object, maybe it's something dynamic or has nested\n          // parentheses or something like that. In that case, treat it as a warning\n          // and not a hard error, just like we wouldn't break on unmatched regex.\n          console.warn(\"Couldn't match options object\", fullMatch, \": \", e);\n          continue;\n        }\n        if (!(\"type\" in options)) {\n          // Nothing to do.\n          continue;\n        }\n        delete options.type;\n        const replacementEnd = match.index + fullMatch.length;\n        const replacementStart = replacementEnd - optionsWithCommaStr.length;\n        optionsStr = json5.stringify(options);\n        optionsWithCommaStr = optionsStr === \"{}\" ? \"\" : `, ${optionsStr}`;\n        ms.overwrite(\n          replacementStart,\n          replacementEnd,\n          optionsWithCommaStr\n        );\n      }\n\n      // Mangle define() call\n      ms.remove(0, \"define(\".length);\n      // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n      ms.prepend(`${opts.amdFunctionName}(`);\n\n      // Prepend loader if it’s an entry point or a worker file\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n\n      const newCode = ms.toString();\n      const hasCodeChanged = code !== newCode;\n      return {\n        code: newCode,\n        // Avoid generating sourcemaps if possible as it can be a very expensive operation\n        map: hasCodeChanged ? ms.generateMap({ hires: true }) : null\n      };\n    }\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}