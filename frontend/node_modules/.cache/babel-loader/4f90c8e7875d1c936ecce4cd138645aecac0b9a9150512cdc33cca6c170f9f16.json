{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar minimatch = require('minimatch');\nvar createDebug = require('debug');\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NOOP_STRATEGY = {\n  required: false,\n  merge() {\n    return undefined;\n  },\n  validate() {}\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n  name: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate(value) {\n      if (typeof value !== 'string') {\n        throw new TypeError('Property must be a string.');\n      }\n    }\n  },\n  files: NOOP_STRATEGY,\n  ignores: NOOP_STRATEGY\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new TypeError('Expected value to be an array.');\n  }\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n  assertIsArray(value);\n  if (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n    throw new TypeError('Expected array to only contain strings and functions.');\n  }\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n  if (!Array.isArray(value) || value.length === 0) {\n    throw new TypeError('Expected value to be a non-empty array.');\n  }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type Object\n */\nconst filesAndIgnoresSchema = Object.freeze({\n  files: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate(value) {\n      // first check if it's an array\n      assertIsNonEmptyArray(value);\n\n      // then check each member\n      value.forEach(item => {\n        if (Array.isArray(item)) {\n          assertIsArrayOfStringsAndFunctions(item);\n        } else if (typeof item !== 'string' && typeof item !== 'function') {\n          throw new TypeError('Items must be a string, a function, or an array of strings and functions.');\n        }\n      });\n    }\n  },\n  ignores: {\n    required: false,\n    merge() {\n      return undefined;\n    },\n    validate: assertIsArrayOfStringsAndFunctions\n  }\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst minimatchCache = new Map();\nconst negatedMinimatchCache = new Map();\nconst debug = createDebug('@hwc/config-array');\nconst MINIMATCH_OPTIONS = {\n  // matchBase: true,\n  dot: true\n};\nconst CONFIG_TYPES = new Set(['array', 'function']);\nconst FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Asserts that the files and ignores keys of a config object are valid as per base schema.\n * @param {object} config The config object to check.\n * @returns {void}\n * @throws {TypeError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidFilesAndIgnores(config) {\n  if (!config || typeof config !== 'object') {\n    return;\n  }\n  const validateConfig = {};\n  if ('files' in config) {\n    validateConfig.files = config.files;\n  }\n  if ('ignores' in config) {\n    validateConfig.ignores = config.ignores;\n  }\n  FILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns \n */\nfunction doMatch(filepath, pattern, options = {}) {\n  let cache = minimatchCache;\n  if (options.flipNegate) {\n    cache = negatedMinimatchCache;\n  }\n  let matcher = cache.get(pattern);\n  if (!matcher) {\n    matcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));\n    cache.set(pattern, matcher);\n  }\n  return matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n  async function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n        item = item(context);\n        if (item.then) {\n          item = await item;\n        }\n      }\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  /*\n   * Async iterables cannot be used with the spread operator, so we need to manually\n   * create the array to return.\n   */\n  const asyncIterable = await flatTraverse(items);\n  const configs = [];\n  for await (const config of asyncIterable) {\n    configs.push(config);\n  }\n  return configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n  function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n        item = item(context);\n        if (item.then) {\n          throw new TypeError('Async config functions are not supported.');\n        }\n      }\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n  return [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n  // all files outside of the basePath are ignored\n  if (relativeFilePath.startsWith('..')) {\n    return true;\n  }\n  return ignores.reduce((ignored, matcher) => {\n    if (!ignored) {\n      if (typeof matcher === 'function') {\n        return matcher(filePath);\n      }\n\n      // don't check negated patterns because we're not ignored yet\n      if (!matcher.startsWith('!')) {\n        return doMatch(relativeFilePath, matcher);\n      }\n\n      // otherwise we're still not ignored\n      return false;\n    }\n\n    // only need to check negated patterns because we're ignored\n    if (typeof matcher === 'string' && matcher.startsWith('!')) {\n      return !doMatch(relativeFilePath, matcher, {\n        flipNegate: true\n      });\n    }\n    return ignored;\n  }, false);\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, basePath, config) {\n  /*\n   * For both files and ignores, functions are passed the absolute\n   * file path while strings are compared against the relative\n   * file path.\n   */\n  const relativeFilePath = path.relative(basePath, filePath);\n  return Object.keys(config).length > 1 && !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n}\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n  /*\n   * For both files and ignores, functions are passed the absolute\n   * file path while strings are compared against the relative\n   * file path.\n   */\n  const relativeFilePath = path.relative(basePath, filePath);\n\n  // match both strings and functions\n  const match = pattern => {\n    if (isString(pattern)) {\n      return doMatch(relativeFilePath, pattern);\n    }\n    if (typeof pattern === 'function') {\n      return pattern(filePath);\n    }\n    throw new TypeError(`Unexpected matcher type ${pattern}.`);\n  };\n\n  // check for all matches to config.files\n  let filePathMatchesPattern = config.files.some(pattern => {\n    if (Array.isArray(pattern)) {\n      return pattern.every(match);\n    }\n    return match(pattern);\n  });\n\n  /*\n   * If the file path matches the config.files patterns, then check to see\n   * if there are any files to ignore.\n   */\n  if (filePathMatchesPattern && config.ignores) {\n    filePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n  }\n  return filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n  // TODO: Throw more verbose error\n  if (!configArray.isNormalized()) {\n    throw new Error('ConfigArray must be normalized to perform this operation.');\n  }\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n  if (extraConfigTypes.length > 2) {\n    throw new TypeError('configTypes must be an array with at most two items.');\n  }\n  for (const configType of extraConfigTypes) {\n    if (!CONFIG_TYPES.has(configType)) {\n      throw new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n  isNormalized: Symbol('isNormalized'),\n  configCache: Symbol('configCache'),\n  schema: Symbol('schema'),\n  finalizeConfig: Symbol('finalizeConfig'),\n  preprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n  /**\n   * Creates a new instance of ConfigArray.\n   * @param {Iterable|Function|Object} configs An iterable yielding config\n   *      objects, or a config function, or a config object.\n   * @param {string} [options.basePath=\"\"] The path of the config file\n   * @param {boolean} [options.normalized=false] Flag indicating if the\n   *      configs have already been normalized.\n   * @param {Object} [options.schema] The additional schema \n   *      definitions to use for the ConfigArray schema.\n   * @param {Array<string>} [options.configTypes] List of config types supported.\n   */\n  constructor(configs, {\n    basePath = '',\n    normalized = false,\n    schema: customSchema,\n    extraConfigTypes = []\n  } = {}) {\n    super();\n\n    /**\n     * Tracks if the array has been normalized.\n     * @property isNormalized\n     * @type boolean\n     * @private\n     */\n    this[ConfigArraySymbol.isNormalized] = normalized;\n\n    /**\n     * The schema used for validating and merging configs.\n     * @property schema\n     * @type ObjectSchema\n     * @private\n     */\n    this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(Object.assign({}, customSchema, baseSchema));\n\n    /**\n     * The path of the config file that this array was loaded from.\n     * This is used to calculate filename matches.\n     * @property basePath\n     * @type string\n     */\n    this.basePath = basePath;\n    assertExtraConfigTypes(extraConfigTypes);\n\n    /**\n     * The supported config types.\n     * @property configTypes\n     * @type Array<string>\n     */\n    this.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n    /**\n     * A cache to store calculated configs for faster repeat lookup.\n     * @property configCache\n     * @type Map\n     * @private\n     */\n    this[ConfigArraySymbol.configCache] = new Map();\n\n    // init cache\n    dataCache.set(this, {\n      explicitMatches: new Map(),\n      directoryMatches: new Map(),\n      files: undefined,\n      ignores: undefined\n    });\n\n    // load the configs into this array\n    if (Array.isArray(configs)) {\n      this.push(...configs);\n    } else {\n      this.push(configs);\n    }\n  }\n\n  /**\n   * Prevent normal array methods from creating a new `ConfigArray` instance.\n   * This is to ensure that methods such as `slice()` won't try to create a \n   * new instance of `ConfigArray` behind the scenes as doing so may throw\n   * an error due to the different constructor signature.\n   * @returns {Function} The `Array` constructor.\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  /**\n   * Returns the `files` globs from every config object in the array.\n   * This can be used to determine which files will be matched by a\n   * config array or to use as a glob pattern when no patterns are provided\n   * for a command line interface.\n   * @returns {Array<string|Function>} An array of matchers.\n   */\n  get files() {\n    assertNormalized(this);\n\n    // if this data has been cached, retrieve it\n    const cache = dataCache.get(this);\n    if (cache.files) {\n      return cache.files;\n    }\n\n    // otherwise calculate it\n\n    const result = [];\n    for (const config of this) {\n      if (config.files) {\n        config.files.forEach(filePattern => {\n          result.push(filePattern);\n        });\n      }\n    }\n\n    // store result\n    cache.files = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n\n  /**\n   * Returns ignore matchers that should always be ignored regardless of\n   * the matching `files` fields in any configs. This is necessary to mimic\n   * the behavior of things like .gitignore and .eslintignore, allowing a\n   * globbing operation to be faster.\n   * @returns {string[]} An array of string patterns and functions to be ignored.\n   */\n  get ignores() {\n    assertNormalized(this);\n\n    // if this data has been cached, retrieve it\n    const cache = dataCache.get(this);\n    if (cache.ignores) {\n      return cache.ignores;\n    }\n\n    // otherwise calculate it\n\n    const result = [];\n    for (const config of this) {\n      /*\n       * We only count ignores if there are no other keys in the object.\n       * In this case, it acts list a globally ignored pattern. If there\n       * are additional keys, then ignores act like exclusions.\n       */\n      if (config.ignores && Object.keys(config).length === 1) {\n        result.push(...config.ignores);\n      }\n    }\n\n    // store result\n    cache.ignores = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n\n  /**\n   * Indicates if the config array has been normalized.\n   * @returns {boolean} True if the config array is normalized, false if not.\n   */\n  isNormalized() {\n    return this[ConfigArraySymbol.isNormalized];\n  }\n\n  /**\n   * Normalizes a config array by flattening embedded arrays and executing\n   * config functions.\n   * @param {ConfigContext} context The context object for config functions.\n   * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n   */\n  async normalize(context = {}) {\n    if (!this.isNormalized()) {\n      const normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this.forEach(assertValidFilesAndIgnores);\n      this[ConfigArraySymbol.isNormalized] = true;\n\n      // prevent further changes\n      Object.freeze(this);\n    }\n    return this;\n  }\n\n  /**\n   * Normalizes a config array by flattening embedded arrays and executing\n   * config functions.\n   * @param {ConfigContext} context The context object for config functions.\n   * @returns {ConfigArray} The current ConfigArray instance.\n   */\n  normalizeSync(context = {}) {\n    if (!this.isNormalized()) {\n      const normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this.forEach(assertValidFilesAndIgnores);\n      this[ConfigArraySymbol.isNormalized] = true;\n\n      // prevent further changes\n      Object.freeze(this);\n    }\n    return this;\n  }\n\n  /**\n   * Finalizes the state of a config before being cached and returned by\n   * `getConfig()`. Does nothing by default but is provided to be\n   * overridden by subclasses as necessary.\n   * @param {Object} config The config to finalize.\n   * @returns {Object} The finalized config.\n   */\n  [ConfigArraySymbol.finalizeConfig](config) {\n    return config;\n  }\n\n  /**\n   * Preprocesses a config during the normalization process. This is the\n   * method to override if you want to convert an array item before it is\n   * validated for the first time. For example, if you want to replace a\n   * string with an object, this is the method to override.\n   * @param {Object} config The config to preprocess.\n   * @returns {Object} The config to use in place of the argument.\n   */\n  [ConfigArraySymbol.preprocessConfig](config) {\n    return config;\n  }\n\n  /**\n   * Determines if a given file path explicitly matches a `files` entry\n   * and also doesn't match an `ignores` entry. Configs that don't have\n   * a `files` property are not considered an explicit match.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the file path matches a `files` entry\n   * \t\tor false if not.\n   */\n  isExplicitMatch(filePath) {\n    assertNormalized(this);\n    const cache = dataCache.get(this);\n\n    // first check the cache to avoid duplicate work\n    let result = cache.explicitMatches.get(filePath);\n    if (typeof result == 'boolean') {\n      return result;\n    }\n\n    // TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n    const relativeFilePath = path.relative(this.basePath, filePath);\n    if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath}`);\n\n      // cache and return result\n      cache.explicitMatches.set(filePath, false);\n      return false;\n    }\n\n    // filePath isn't automatically ignored, so try to find a match\n\n    for (const config of this) {\n      if (!config.files) {\n        continue;\n      }\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        cache.explicitMatches.set(filePath, true);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the config object for a given file path.\n   * @param {string} filePath The complete path of a file to get a config for.\n   * @returns {Object} The config object for this file.\n   */\n  getConfig(filePath) {\n    assertNormalized(this);\n    const cache = this[ConfigArraySymbol.configCache];\n\n    // first check the cache for a filename match to avoid duplicate work\n    if (cache.has(filePath)) {\n      return cache.get(filePath);\n    }\n    let finalConfig;\n\n    // next check to see if the file should be ignored\n\n    // check if this should be ignored due to its directory\n    if (this.isDirectoryIgnored(path.dirname(filePath))) {\n      debug(`Ignoring ${filePath} based on directory pattern`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // TODO: Maybe move elsewhere?\n    const relativeFilePath = path.relative(this.basePath, filePath);\n    if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath} based on file pattern`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // filePath isn't automatically ignored, so try to construct config\n\n    const matchingConfigIndices = [];\n    let matchFound = false;\n    const universalPattern = /\\/\\*{1,2}$/;\n    this.forEach((config, index) => {\n      if (!config.files) {\n        if (!config.ignores) {\n          debug(`Anonymous universal config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n        if (pathMatchesIgnores(filePath, this.basePath, config)) {\n          debug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n        debug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);\n        return;\n      }\n\n      /*\n       * If a config has a files pattern ending in /** or /*, and the\n       * filePath only matches those patterns, then the config is only\n       * applied if there is another config where the filePath matches\n       * a file with a specific extensions such as *.js.\n       */\n\n      const universalFiles = config.files.filter(pattern => universalPattern.test(pattern));\n\n      // universal patterns were found so we need to check the config twice\n      if (universalFiles.length) {\n        debug('Universal files patterns found. Checking carefully.');\n        const nonUniversalFiles = config.files.filter(pattern => !universalPattern.test(pattern));\n\n        // check that the config matches without the non-universal files first\n        if (nonUniversalFiles.length && pathMatches(filePath, this.basePath, {\n          files: nonUniversalFiles,\n          ignores: config.ignores\n        })) {\n          debug(`Matching config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          matchFound = true;\n          return;\n        }\n\n        // if there wasn't a match then check if it matches with universal files\n        if (universalFiles.length && pathMatches(filePath, this.basePath, {\n          files: universalFiles,\n          ignores: config.ignores\n        })) {\n          debug(`Matching config found for ${filePath}`);\n          matchingConfigIndices.push(index);\n          return;\n        }\n\n        // if we make here, then there was no match\n        return;\n      }\n\n      // the normal case\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        matchingConfigIndices.push(index);\n        matchFound = true;\n        return;\n      }\n    });\n\n    // if matching both files and ignores, there will be no config to create\n    if (!matchFound) {\n      debug(`No matching configs found for ${filePath}`);\n\n      // cache and return result - finalConfig is undefined at this point\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // check to see if there is a config cached by indices\n    finalConfig = cache.get(matchingConfigIndices.toString());\n    if (finalConfig) {\n      // also store for filename for faster lookup next time\n      cache.set(filePath, finalConfig);\n      return finalConfig;\n    }\n\n    // otherwise construct the config\n\n    finalConfig = matchingConfigIndices.reduce((result, index) => {\n      return this[ConfigArraySymbol.schema].merge(result, this[index]);\n    }, {}, this);\n    finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n    cache.set(filePath, finalConfig);\n    cache.set(matchingConfigIndices.toString(), finalConfig);\n    return finalConfig;\n  }\n\n  /**\n   * Determines if the given filepath is ignored based on the configs.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the path is ignored, false if not.\n   * @deprecated Use `isFileIgnored` instead.\n   */\n  isIgnored(filePath) {\n    return this.isFileIgnored(filePath);\n  }\n\n  /**\n   * Determines if the given filepath is ignored based on the configs.\n   * @param {string} filePath The complete path of a file to check.\n   * @returns {boolean} True if the path is ignored, false if not.\n   */\n  isFileIgnored(filePath) {\n    return this.getConfig(filePath) === undefined;\n  }\n\n  /**\n   * Determines if the given directory is ignored based on the configs.\n   * This checks only default `ignores` that don't have `files` in the \n   * same config. A pattern such as `/foo` be considered to ignore the directory\n   * while a pattern such as `/foo/**` is not considered to ignore the\n   * directory because it is matching files.\n   * @param {string} directoryPath The complete path of a directory to check.\n   * @returns {boolean} True if the directory is ignored, false if not. Will\n   * \t\treturn true for any directory that is not inside of `basePath`.\n   * @throws {Error} When the `ConfigArray` is not normalized.\n   */\n  isDirectoryIgnored(directoryPath) {\n    assertNormalized(this);\n    const relativeDirectoryPath = path.relative(this.basePath, directoryPath).replace(/\\\\/g, '/');\n    if (relativeDirectoryPath.startsWith('..')) {\n      return true;\n    }\n\n    // first check the cache\n    const cache = dataCache.get(this).directoryMatches;\n    if (cache.has(relativeDirectoryPath)) {\n      return cache.get(relativeDirectoryPath);\n    }\n    const directoryParts = relativeDirectoryPath.split('/');\n    let relativeDirectoryToCheck = '';\n    let result = false;\n\n    /*\n     * In order to get the correct gitignore-style ignores, where an\n     * ignored parent directory cannot have any descendants unignored,\n     * we need to check every directory starting at the parent all\n     * the way down to the actual requested directory.\n     * \n     * We aggressively cache all of this info to make sure we don't\n     * have to recalculate everything for every call.\n     */\n    do {\n      relativeDirectoryToCheck += directoryParts.shift() + '/';\n      result = shouldIgnorePath(this.ignores, path.join(this.basePath, relativeDirectoryToCheck), relativeDirectoryToCheck);\n      cache.set(relativeDirectoryToCheck, result);\n    } while (!result && directoryParts.length);\n\n    // also cache the result for the requested path\n    cache.set(relativeDirectoryPath, result);\n    return result;\n  }\n}\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;","map":{"version":3,"names":["path","require","minimatch","createDebug","objectSchema","NOOP_STRATEGY","required","merge","undefined","validate","baseSchema","Object","freeze","name","value","TypeError","files","ignores","assertIsArray","Array","isArray","assertIsArrayOfStringsAndFunctions","some","item","assertIsNonEmptyArray","length","filesAndIgnoresSchema","forEach","Minimatch","minimatchCache","Map","negatedMinimatchCache","debug","MINIMATCH_OPTIONS","dot","CONFIG_TYPES","Set","FILES_AND_IGNORES_SCHEMA","ObjectSchema","isString","assertValidFilesAndIgnores","config","validateConfig","doMatch","filepath","pattern","options","cache","flipNegate","matcher","get","assign","set","match","normalize","items","context","extraConfigTypes","allowFunctions","includes","allowArrays","flatTraverse","array","then","asyncIterable","configs","push","normalizeSync","shouldIgnorePath","filePath","relativeFilePath","startsWith","reduce","ignored","pathMatchesIgnores","basePath","relative","keys","pathMatches","filePathMatchesPattern","every","assertNormalized","configArray","isNormalized","Error","assertExtraConfigTypes","configType","has","ConfigArraySymbol","Symbol","configCache","schema","finalizeConfig","preprocessConfig","dataCache","WeakMap","ConfigArray","constructor","normalized","customSchema","explicitMatches","directoryMatches","species","result","filePattern","normalizedConfigs","map","bind","isExplicitMatch","getConfig","finalConfig","isDirectoryIgnored","dirname","matchingConfigIndices","matchFound","universalPattern","index","universalFiles","filter","test","nonUniversalFiles","toString","isIgnored","isFileIgnored","directoryPath","relativeDirectoryPath","replace","directoryParts","split","relativeDirectoryToCheck","shift","join","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@humanwhocodes/config-array/api.js"],"sourcesContent":["'use strict';\n\nvar path = require('path');\nvar minimatch = require('minimatch');\nvar createDebug = require('debug');\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NOOP_STRATEGY = {\n\trequired: false,\n\tmerge() {\n\t\treturn undefined;\n\t},\n\tvalidate() { }\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n\tname: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError('Property must be a string.');\n\t\t\t}\n\t\t}\n\t},\n\tfiles: NOOP_STRATEGY,\n\tignores: NOOP_STRATEGY\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n\tif (!Array.isArray(value)) {\n\t\tthrow new TypeError('Expected value to be an array.');\n\t}\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n\tassertIsArray(value);\n\n\tif (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n\t\tthrow new TypeError('Expected array to only contain strings and functions.');\n\t}\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n\tif (!Array.isArray(value) || value.length === 0) {\n\t\tthrow new TypeError('Expected value to be a non-empty array.');\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type Object\n */\nconst filesAndIgnoresSchema = Object.freeze({\n\tfiles: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\n\t\t\t// first check if it's an array\n\t\t\tassertIsNonEmptyArray(value);\n\n\t\t\t// then check each member\n\t\t\tvalue.forEach(item => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\n\t\t\t\t} else if (typeof item !== 'string' && typeof item !== 'function') {\n\t\t\t\t\tthrow new TypeError('Items must be a string, a function, or an array of strings and functions.');\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t},\n\tignores: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate: assertIsArrayOfStringsAndFunctions\n\t}\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst minimatchCache = new Map();\nconst negatedMinimatchCache = new Map();\nconst debug = createDebug('@hwc/config-array');\n\nconst MINIMATCH_OPTIONS = {\n\t// matchBase: true,\n\tdot: true\n};\n\nconst CONFIG_TYPES = new Set(['array', 'function']);\n\nconst FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Asserts that the files and ignores keys of a config object are valid as per base schema.\n * @param {object} config The config object to check.\n * @returns {void}\n * @throws {TypeError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidFilesAndIgnores(config) {\n\tif (!config || typeof config !== 'object') {\n\t\treturn;\n\t}\n\tconst validateConfig = { };\n\tif ('files' in config) {\n\t\tvalidateConfig.files = config.files;\n\t}\n\tif ('ignores' in config) {\n\t\tvalidateConfig.ignores = config.ignores;\n\t}\n\tFILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns \n */\nfunction doMatch(filepath, pattern, options = {}) {\n\n\tlet cache = minimatchCache;\n\n\tif (options.flipNegate) {\n\t\tcache = negatedMinimatchCache;\n\t}\n\n\tlet matcher = cache.get(pattern);\n\n\tif (!matcher) {\n\t\tmatcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));\n\t\tcache.set(pattern, matcher);\n\t}\n\n\treturn matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tasync function* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\titem = await item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Async iterables cannot be used with the spread operator, so we need to manually\n\t * create the array to return.\n\t */\n\tconst asyncIterable = await flatTraverse(items);\n\tconst configs = [];\n\n\tfor await (const config of asyncIterable) {\n\t\tconfigs.push(config);\n\t}\n\n\treturn configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tfunction* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\tthrow new TypeError('Async config functions are not supported.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n\n\t// all files outside of the basePath are ignored\n\tif (relativeFilePath.startsWith('..')) {\n\t\treturn true;\n\t}\n\n\treturn ignores.reduce((ignored, matcher) => {\n\n\t\tif (!ignored) {\n\n\t\t\tif (typeof matcher === 'function') {\n\t\t\t\treturn matcher(filePath);\n\t\t\t}\n\n\t\t\t// don't check negated patterns because we're not ignored yet\n\t\t\tif (!matcher.startsWith('!')) {\n\t\t\t\treturn doMatch(relativeFilePath, matcher);\n\t\t\t}\n\n\t\t\t// otherwise we're still not ignored\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// only need to check negated patterns because we're ignored\n\t\tif (typeof matcher === 'string' && matcher.startsWith('!')) {\n\t\t\treturn !doMatch(relativeFilePath, matcher, {\n\t\t\t\tflipNegate: true\n\t\t\t});\n\t\t}\n\n\t\treturn ignored;\n\n\t}, false);\n\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\treturn Object.keys(config).length > 1 &&\n\t\t!shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n}\n\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {string} basePath The base path for the config.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\t// match both strings and functions\n\tconst match = pattern => {\n\n\t\tif (isString(pattern)) {\n\t\t\treturn doMatch(relativeFilePath, pattern);\n\t\t}\n\n\t\tif (typeof pattern === 'function') {\n\t\t\treturn pattern(filePath);\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\n\t};\n\n\t// check for all matches to config.files\n\tlet filePathMatchesPattern = config.files.some(pattern => {\n\t\tif (Array.isArray(pattern)) {\n\t\t\treturn pattern.every(match);\n\t\t}\n\n\t\treturn match(pattern);\n\t});\n\n\t/*\n\t * If the file path matches the config.files patterns, then check to see\n\t * if there are any files to ignore.\n\t */\n\tif (filePathMatchesPattern && config.ignores) {\n\t\tfilePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);\n\t}\n\n\treturn filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n\t// TODO: Throw more verbose error\n\tif (!configArray.isNormalized()) {\n\t\tthrow new Error('ConfigArray must be normalized to perform this operation.');\n\t}\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n\tif (extraConfigTypes.length > 2) {\n\t\tthrow new TypeError('configTypes must be an array with at most two items.');\n\t}\n\n\tfor (const configType of extraConfigTypes) {\n\t\tif (!CONFIG_TYPES.has(configType)) {\n\t\t\tthrow new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n\tisNormalized: Symbol('isNormalized'),\n\tconfigCache: Symbol('configCache'),\n\tschema: Symbol('schema'),\n\tfinalizeConfig: Symbol('finalizeConfig'),\n\tpreprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n\n\t/**\n\t * Creates a new instance of ConfigArray.\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\n\t *      objects, or a config function, or a config object.\n\t * @param {string} [options.basePath=\"\"] The path of the config file\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\n\t *      configs have already been normalized.\n\t * @param {Object} [options.schema] The additional schema \n\t *      definitions to use for the ConfigArray schema.\n\t * @param {Array<string>} [options.configTypes] List of config types supported.\n\t */\n\tconstructor(configs, {\n\t\tbasePath = '',\n\t\tnormalized = false,\n\t\tschema: customSchema,\n\t\textraConfigTypes = []\n\t} = {}\n\t) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Tracks if the array has been normalized.\n\t\t * @property isNormalized\n\t\t * @type boolean\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\n\n\t\t/**\n\t\t * The schema used for validating and merging configs.\n\t\t * @property schema\n\t\t * @type ObjectSchema\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(\n\t\t\tObject.assign({}, customSchema, baseSchema)\n\t\t);\n\n\t\t/**\n\t\t * The path of the config file that this array was loaded from.\n\t\t * This is used to calculate filename matches.\n\t\t * @property basePath\n\t\t * @type string\n\t\t */\n\t\tthis.basePath = basePath;\n\n\t\tassertExtraConfigTypes(extraConfigTypes);\n\n\t\t/**\n\t\t * The supported config types.\n\t\t * @property configTypes\n\t\t * @type Array<string>\n\t\t */\n\t\tthis.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n\t\t/**\n\t\t * A cache to store calculated configs for faster repeat lookup.\n\t\t * @property configCache\n\t\t * @type Map\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\n\n\t\t// init cache\n\t\tdataCache.set(this, {\n\t\t\texplicitMatches: new Map(),\n\t\t\tdirectoryMatches: new Map(),\n\t\t\tfiles: undefined,\n\t\t\tignores: undefined\n\t\t});\n\n\t\t// load the configs into this array\n\t\tif (Array.isArray(configs)) {\n\t\t\tthis.push(...configs);\n\t\t} else {\n\t\t\tthis.push(configs);\n\t\t}\n\n\t}\n\n\t/**\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\n\t * This is to ensure that methods such as `slice()` won't try to create a \n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\n\t * an error due to the different constructor signature.\n\t * @returns {Function} The `Array` constructor.\n\t */\n\tstatic get [Symbol.species]() {\n\t\treturn Array;\n\t}\n\n\t/**\n\t * Returns the `files` globs from every config object in the array.\n\t * This can be used to determine which files will be matched by a\n\t * config array or to use as a glob pattern when no patterns are provided\n\t * for a command line interface.\n\t * @returns {Array<string|Function>} An array of matchers.\n\t */\n\tget files() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.files) {\n\t\t\treturn cache.files;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\t\t\tif (config.files) {\n\t\t\t\tconfig.files.forEach(filePattern => {\n\t\t\t\t\tresult.push(filePattern);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.files = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns ignore matchers that should always be ignored regardless of\n\t * the matching `files` fields in any configs. This is necessary to mimic\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\n\t * globbing operation to be faster.\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\n\t */\n\tget ignores() {\n\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.ignores) {\n\t\t\treturn cache.ignores;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\n\t\t\t/*\n\t\t\t * We only count ignores if there are no other keys in the object.\n\t\t\t * In this case, it acts list a globally ignored pattern. If there\n\t\t\t * are additional keys, then ignores act like exclusions.\n\t\t\t */\n\t\t\tif (config.ignores && Object.keys(config).length === 1) {\n\t\t\t\tresult.push(...config.ignores);\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.ignores = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Indicates if the config array has been normalized.\n\t * @returns {boolean} True if the config array is normalized, false if not.\n\t */\n\tisNormalized() {\n\t\treturn this[ConfigArraySymbol.isNormalized];\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n\t */\n\tasync normalize(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidFilesAndIgnores);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {ConfigArray} The current ConfigArray instance.\n\t */\n\tnormalizeSync(context = {}) {\n\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\t\tthis.forEach(assertValidFilesAndIgnores);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Finalizes the state of a config before being cached and returned by\n\t * `getConfig()`. Does nothing by default but is provided to be\n\t * overridden by subclasses as necessary.\n\t * @param {Object} config The config to finalize.\n\t * @returns {Object} The finalized config.\n\t */\n\t[ConfigArraySymbol.finalizeConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Preprocesses a config during the normalization process. This is the\n\t * method to override if you want to convert an array item before it is\n\t * validated for the first time. For example, if you want to replace a\n\t * string with an object, this is the method to override.\n\t * @param {Object} config The config to preprocess.\n\t * @returns {Object} The config to use in place of the argument.\n\t */\n\t[ConfigArraySymbol.preprocessConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Determines if a given file path explicitly matches a `files` entry\n\t * and also doesn't match an `ignores` entry. Configs that don't have\n\t * a `files` property are not considered an explicit match.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the file path matches a `files` entry\n\t * \t\tor false if not.\n\t */\n\tisExplicitMatch(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = dataCache.get(this);\n\n\t\t// first check the cache to avoid duplicate work\n\t\tlet result = cache.explicitMatches.get(filePath);\n\n\t\tif (typeof result == 'boolean') {\n\t\t\treturn result;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath}`);\n\n\t\t\t// cache and return result\n\t\t\tcache.explicitMatches.set(filePath, false);\n\t\t\treturn false;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to find a match\n\n\t\tfor (const config of this) {\n\n\t\t\tif (!config.files) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tcache.explicitMatches.set(filePath, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the config object for a given file path.\n\t * @param {string} filePath The complete path of a file to get a config for.\n\t * @returns {Object} The config object for this file.\n\t */\n\tgetConfig(filePath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst cache = this[ConfigArraySymbol.configCache];\n\n\t\t// first check the cache for a filename match to avoid duplicate work\n\t\tif (cache.has(filePath)) {\n\t\t\treturn cache.get(filePath);\n\t\t}\n\n\t\tlet finalConfig;\n\n\t\t// next check to see if the file should be ignored\n\n\t\t// check if this should be ignored due to its directory\n\t\tif (this.isDirectoryIgnored(path.dirname(filePath))) {\n\t\t\tdebug(`Ignoring ${filePath} based on directory pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// TODO: Maybe move elsewhere?\n\t\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath} based on file pattern`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to construct config\n\n\t\tconst matchingConfigIndices = [];\n\t\tlet matchFound = false;\n\t\tconst universalPattern = /\\/\\*{1,2}$/;\n\n\t\tthis.forEach((config, index) => {\n\n\t\t\tif (!config.files) {\n\n\t\t\t\tif (!config.ignores) {\n\t\t\t\t\tdebug(`Anonymous universal config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (pathMatchesIgnores(filePath, this.basePath, config)) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdebug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a config has a files pattern ending in /** or /*, and the\n\t\t\t * filePath only matches those patterns, then the config is only\n\t\t\t * applied if there is another config where the filePath matches\n\t\t\t * a file with a specific extensions such as *.js.\n\t\t\t */\n\n\t\t\tconst universalFiles = config.files.filter(\n\t\t\t\tpattern => universalPattern.test(pattern)\n\t\t\t);\n\n\t\t\t// universal patterns were found so we need to check the config twice\n\t\t\tif (universalFiles.length) {\n\n\t\t\t\tdebug('Universal files patterns found. Checking carefully.');\n\n\t\t\t\tconst nonUniversalFiles = config.files.filter(\n\t\t\t\t\tpattern => !universalPattern.test(pattern)\n\t\t\t\t);\n\n\t\t\t\t// check that the config matches without the non-universal files first\n\t\t\t\tif (\n\t\t\t\t\tnonUniversalFiles.length && \n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: nonUniversalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\tmatchFound = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there wasn't a match then check if it matches with universal files\n\t\t\t\tif (\n\t\t\t\t\tuniversalFiles.length &&\n\t\t\t\t\tpathMatches(\n\t\t\t\t\t\tfilePath, this.basePath,\n\t\t\t\t\t\t{ files: universalFiles, ignores: config.ignores }\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if we make here, then there was no match\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// the normal case\n\t\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\tmatchFound = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t});\n\n\t\t// if matching both files and ignores, there will be no config to create\n\t\tif (!matchFound) {\n\t\t\tdebug(`No matching configs found for ${filePath}`);\n\n\t\t\t// cache and return result - finalConfig is undefined at this point\n\t\t\tcache.set(filePath, finalConfig);\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// check to see if there is a config cached by indices\n\t\tfinalConfig = cache.get(matchingConfigIndices.toString());\n\n\t\tif (finalConfig) {\n\n\t\t\t// also store for filename for faster lookup next time\n\t\t\tcache.set(filePath, finalConfig);\n\n\t\t\treturn finalConfig;\n\t\t}\n\n\t\t// otherwise construct the config\n\n\t\tfinalConfig = matchingConfigIndices.reduce((result, index) => {\n\t\t\treturn this[ConfigArraySymbol.schema].merge(result, this[index]);\n\t\t}, {}, this);\n\n\t\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n\n\t\tcache.set(filePath, finalConfig);\n\t\tcache.set(matchingConfigIndices.toString(), finalConfig);\n\n\t\treturn finalConfig;\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t * @deprecated Use `isFileIgnored` instead.\n\t */\n\tisIgnored(filePath) {\n\t\treturn this.isFileIgnored(filePath);\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t */\n\tisFileIgnored(filePath) {\n\t\treturn this.getConfig(filePath) === undefined;\n\t}\n\n\t/**\n\t * Determines if the given directory is ignored based on the configs.\n\t * This checks only default `ignores` that don't have `files` in the \n\t * same config. A pattern such as `/foo` be considered to ignore the directory\n\t * while a pattern such as `/foo/**` is not considered to ignore the\n\t * directory because it is matching files.\n\t * @param {string} directoryPath The complete path of a directory to check.\n\t * @returns {boolean} True if the directory is ignored, false if not. Will\n\t * \t\treturn true for any directory that is not inside of `basePath`.\n\t * @throws {Error} When the `ConfigArray` is not normalized.\n\t */\n\tisDirectoryIgnored(directoryPath) {\n\n\t\tassertNormalized(this);\n\n\t\tconst relativeDirectoryPath = path.relative(this.basePath, directoryPath)\n\t\t\t.replace(/\\\\/g, '/');\n\n\t\tif (relativeDirectoryPath.startsWith('..')) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// first check the cache\n\t\tconst cache = dataCache.get(this).directoryMatches;\n\n\t\tif (cache.has(relativeDirectoryPath)) {\n\t\t\treturn cache.get(relativeDirectoryPath);\n\t\t}\n\n\t\tconst directoryParts = relativeDirectoryPath.split('/');\n\t\tlet relativeDirectoryToCheck = '';\n\t\tlet result = false;\n\n\t\t/*\n\t\t * In order to get the correct gitignore-style ignores, where an\n\t\t * ignored parent directory cannot have any descendants unignored,\n\t\t * we need to check every directory starting at the parent all\n\t\t * the way down to the actual requested directory.\n\t\t * \n\t\t * We aggressively cache all of this info to make sure we don't\n\t\t * have to recalculate everything for every call.\n\t\t */\n\t\tdo {\n\n\t\t\trelativeDirectoryToCheck += directoryParts.shift() + '/';\n\n\t\t\tresult = shouldIgnorePath(\n\t\t\t\tthis.ignores,\n\t\t\t\tpath.join(this.basePath, relativeDirectoryToCheck),\n\t\t\t\trelativeDirectoryToCheck\n\t\t\t);\n\n\t\t\tcache.set(relativeDirectoryToCheck, result);\n\n\t\t} while (!result && directoryParts.length);\n\n\t\t// also cache the result for the requested path\n\t\tcache.set(relativeDirectoryPath, result);\n\n\t\treturn result;\n\t}\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}