{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.moduleContextFromModuleAST = moduleContextFromModuleAST;\nexports.ModuleContext = void 0;\nvar _nodes = require(\"../../nodes.js\");\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction moduleContextFromModuleAST(m) {\n  var moduleContext = new ModuleContext();\n  if (!(m.type === \"Module\")) {\n    throw new Error('m.type === \"Module\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n  m.fields.forEach(function (field) {\n    switch (field.type) {\n      case \"Start\":\n        {\n          moduleContext.setStart(field.index);\n          break;\n        }\n      case \"TypeInstruction\":\n        {\n          moduleContext.addType(field);\n          break;\n        }\n      case \"Func\":\n        {\n          moduleContext.addFunction(field);\n          break;\n        }\n      case \"Global\":\n        {\n          moduleContext.defineGlobal(field);\n          break;\n        }\n      case \"ModuleImport\":\n        {\n          switch (field.descr.type) {\n            case \"GlobalType\":\n              {\n                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);\n                break;\n              }\n            case \"Memory\":\n              {\n                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);\n                break;\n              }\n            case \"FuncImportDescr\":\n              {\n                moduleContext.importFunction(field.descr);\n                break;\n              }\n            case \"Table\":\n              {\n                // FIXME(sven): not implemented yet\n                break;\n              }\n            default:\n              throw new Error(\"Unsupported ModuleImport of type \" + JSON.stringify(field.descr.type));\n          }\n          break;\n        }\n      case \"Memory\":\n        {\n          moduleContext.addMemory(field.limits.min, field.limits.max);\n          break;\n        }\n    }\n  });\n  return moduleContext;\n}\n/**\n * Module context for type checking\n */\n\nvar ModuleContext = /*#__PURE__*/function () {\n  function ModuleContext() {\n    _classCallCheck(this, ModuleContext);\n    this.funcs = [];\n    this.funcsOffsetByIdentifier = [];\n    this.types = [];\n    this.globals = [];\n    this.globalsOffsetByIdentifier = [];\n    this.mems = []; // Current stack frame\n\n    this.locals = [];\n    this.labels = [];\n    this[\"return\"] = [];\n    this.debugName = \"unknown\";\n    this.start = null;\n  }\n  /**\n   * Set start segment\n   */\n\n  _createClass(ModuleContext, [{\n    key: \"setStart\",\n    value: function setStart(index) {\n      this.start = index.value;\n    }\n    /**\n     * Get start function\n     */\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      return this.start;\n    }\n    /**\n     * Reset the active stack frame\n     */\n  }, {\n    key: \"newContext\",\n    value: function newContext(debugName, expectedResult) {\n      this.locals = [];\n      this.labels = [expectedResult];\n      this[\"return\"] = expectedResult;\n      this.debugName = debugName;\n    }\n    /**\n     * Functions\n     */\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(func) {\n      /* eslint-disable */\n      // $FlowIgnore\n      var _ref = func.signature || {},\n        _ref$params = _ref.params,\n        args = _ref$params === void 0 ? [] : _ref$params,\n        _ref$results = _ref.results,\n        result = _ref$results === void 0 ? [] : _ref$results;\n      /* eslint-enable */\n\n      args = args.map(function (arg) {\n        return arg.valtype;\n      });\n      this.funcs.push({\n        args: args,\n        result: result\n      });\n      if (typeof func.name !== \"undefined\") {\n        // $FlowIgnore\n        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"importFunction\",\n    value: function importFunction(funcimport) {\n      if ((0, _nodes.isSignature)(funcimport.signature)) {\n        // eslint-disable-next-line prefer-const\n        var _funcimport$signature = funcimport.signature,\n          args = _funcimport$signature.params,\n          result = _funcimport$signature.results;\n        args = args.map(function (arg) {\n          return arg.valtype;\n        });\n        this.funcs.push({\n          args: args,\n          result: result\n        });\n      } else {\n        if (!(0, _nodes.isNumberLiteral)(funcimport.signature)) {\n          throw new Error('isNumberLiteral(funcimport.signature)' + \" error: \" + (undefined || \"unknown\"));\n        }\n        var typeId = funcimport.signature.value;\n        if (!this.hasType(typeId)) {\n          throw new Error('this.hasType(typeId)' + \" error: \" + (undefined || \"unknown\"));\n        }\n        var signature = this.getType(typeId);\n        this.funcs.push({\n          args: signature.params.map(function (arg) {\n            return arg.valtype;\n          }),\n          result: signature.results\n        });\n      }\n      if (typeof funcimport.id !== \"undefined\") {\n        // imports are first, we can assume their index in the array\n        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(index) {\n      return typeof this.getFunction(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(index) {\n      if (typeof index !== \"number\") {\n        throw new Error(\"getFunction only supported for number index\");\n      }\n      return this.funcs[index];\n    }\n  }, {\n    key: \"getFunctionOffsetByIdentifier\",\n    value: function getFunctionOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n      return this.funcsOffsetByIdentifier[name];\n    }\n    /**\n     * Labels\n     */\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(result) {\n      this.labels.unshift(result);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(index) {\n      return this.labels.length > index && index >= 0;\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(index) {\n      return this.labels[index];\n    }\n  }, {\n    key: \"popLabel\",\n    value: function popLabel() {\n      this.labels.shift();\n    }\n    /**\n     * Locals\n     */\n  }, {\n    key: \"hasLocal\",\n    value: function hasLocal(index) {\n      return typeof this.getLocal(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(index) {\n      return this.locals[index];\n    }\n  }, {\n    key: \"addLocal\",\n    value: function addLocal(type) {\n      this.locals.push(type);\n    }\n    /**\n     * Types\n     */\n  }, {\n    key: \"addType\",\n    value: function addType(type) {\n      if (!(type.functype.type === \"Signature\")) {\n        throw new Error('type.functype.type === \"Signature\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n      this.types.push(type.functype);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(index) {\n      return this.types[index] !== undefined;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this.types[index];\n    }\n    /**\n     * Globals\n     */\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(index) {\n      return this.globals.length > index && index >= 0;\n    }\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal(index) {\n      return this.globals[index].type;\n    }\n  }, {\n    key: \"getGlobalOffsetByIdentifier\",\n    value: function getGlobalOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      // $FlowIgnore\n      return this.globalsOffsetByIdentifier[name];\n    }\n  }, {\n    key: \"defineGlobal\",\n    value: function defineGlobal(global) {\n      var type = global.globalType.valtype;\n      var mutability = global.globalType.mutability;\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n      if (typeof global.name !== \"undefined\") {\n        // $FlowIgnore\n        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;\n      }\n    }\n  }, {\n    key: \"importGlobal\",\n    value: function importGlobal(type, mutability) {\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n    }\n  }, {\n    key: \"isMutableGlobal\",\n    value: function isMutableGlobal(index) {\n      return this.globals[index].mutability === \"var\";\n    }\n  }, {\n    key: \"isImmutableGlobal\",\n    value: function isImmutableGlobal(index) {\n      return this.globals[index].mutability === \"const\";\n    }\n    /**\n     * Memories\n     */\n  }, {\n    key: \"hasMemory\",\n    value: function hasMemory(index) {\n      return this.mems.length > index && index >= 0;\n    }\n  }, {\n    key: \"addMemory\",\n    value: function addMemory(min, max) {\n      this.mems.push({\n        min: min,\n        max: max\n      });\n    }\n  }, {\n    key: \"getMemory\",\n    value: function getMemory(index) {\n      return this.mems[index];\n    }\n  }]);\n  return ModuleContext;\n}();\nexports.ModuleContext = ModuleContext;","map":{"version":3,"names":["Object","defineProperty","exports","value","moduleContextFromModuleAST","ModuleContext","_nodes","require","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","m","moduleContext","type","Error","undefined","fields","forEach","field","setStart","index","addType","addFunction","defineGlobal","descr","importGlobal","valtype","mutability","addMemory","limits","min","max","importFunction","JSON","stringify","funcs","funcsOffsetByIdentifier","types","globals","globalsOffsetByIdentifier","mems","locals","labels","debugName","start","getStart","newContext","expectedResult","func","_ref","signature","_ref$params","params","args","_ref$results","results","result","map","arg","push","name","funcimport","isSignature","_funcimport$signature","isNumberLiteral","typeId","hasType","getType","id","hasFunction","getFunction","getFunctionOffsetByIdentifier","addLabel","unshift","hasLabel","getLabel","popLabel","shift","hasLocal","getLocal","addLocal","functype","hasGlobal","getGlobal","getGlobalOffsetByIdentifier","global","globalType","isMutableGlobal","isImmutableGlobal","hasMemory","getMemory"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/lib/transform/ast-module-to-module-context/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.moduleContextFromModuleAST = moduleContextFromModuleAST;\nexports.ModuleContext = void 0;\n\nvar _nodes = require(\"../../nodes.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction moduleContextFromModuleAST(m) {\n  var moduleContext = new ModuleContext();\n\n  if (!(m.type === \"Module\")) {\n    throw new Error('m.type === \"Module\"' + \" error: \" + (undefined || \"unknown\"));\n  }\n\n  m.fields.forEach(function (field) {\n    switch (field.type) {\n      case \"Start\":\n        {\n          moduleContext.setStart(field.index);\n          break;\n        }\n\n      case \"TypeInstruction\":\n        {\n          moduleContext.addType(field);\n          break;\n        }\n\n      case \"Func\":\n        {\n          moduleContext.addFunction(field);\n          break;\n        }\n\n      case \"Global\":\n        {\n          moduleContext.defineGlobal(field);\n          break;\n        }\n\n      case \"ModuleImport\":\n        {\n          switch (field.descr.type) {\n            case \"GlobalType\":\n              {\n                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);\n                break;\n              }\n\n            case \"Memory\":\n              {\n                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);\n                break;\n              }\n\n            case \"FuncImportDescr\":\n              {\n                moduleContext.importFunction(field.descr);\n                break;\n              }\n\n            case \"Table\":\n              {\n                // FIXME(sven): not implemented yet\n                break;\n              }\n\n            default:\n              throw new Error(\"Unsupported ModuleImport of type \" + JSON.stringify(field.descr.type));\n          }\n\n          break;\n        }\n\n      case \"Memory\":\n        {\n          moduleContext.addMemory(field.limits.min, field.limits.max);\n          break;\n        }\n    }\n  });\n  return moduleContext;\n}\n/**\n * Module context for type checking\n */\n\n\nvar ModuleContext = /*#__PURE__*/function () {\n  function ModuleContext() {\n    _classCallCheck(this, ModuleContext);\n\n    this.funcs = [];\n    this.funcsOffsetByIdentifier = [];\n    this.types = [];\n    this.globals = [];\n    this.globalsOffsetByIdentifier = [];\n    this.mems = []; // Current stack frame\n\n    this.locals = [];\n    this.labels = [];\n    this[\"return\"] = [];\n    this.debugName = \"unknown\";\n    this.start = null;\n  }\n  /**\n   * Set start segment\n   */\n\n\n  _createClass(ModuleContext, [{\n    key: \"setStart\",\n    value: function setStart(index) {\n      this.start = index.value;\n    }\n    /**\n     * Get start function\n     */\n\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      return this.start;\n    }\n    /**\n     * Reset the active stack frame\n     */\n\n  }, {\n    key: \"newContext\",\n    value: function newContext(debugName, expectedResult) {\n      this.locals = [];\n      this.labels = [expectedResult];\n      this[\"return\"] = expectedResult;\n      this.debugName = debugName;\n    }\n    /**\n     * Functions\n     */\n\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(func) {\n      /* eslint-disable */\n      // $FlowIgnore\n      var _ref = func.signature || {},\n          _ref$params = _ref.params,\n          args = _ref$params === void 0 ? [] : _ref$params,\n          _ref$results = _ref.results,\n          result = _ref$results === void 0 ? [] : _ref$results;\n      /* eslint-enable */\n\n\n      args = args.map(function (arg) {\n        return arg.valtype;\n      });\n      this.funcs.push({\n        args: args,\n        result: result\n      });\n\n      if (typeof func.name !== \"undefined\") {\n        // $FlowIgnore\n        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"importFunction\",\n    value: function importFunction(funcimport) {\n      if ((0, _nodes.isSignature)(funcimport.signature)) {\n        // eslint-disable-next-line prefer-const\n        var _funcimport$signature = funcimport.signature,\n            args = _funcimport$signature.params,\n            result = _funcimport$signature.results;\n        args = args.map(function (arg) {\n          return arg.valtype;\n        });\n        this.funcs.push({\n          args: args,\n          result: result\n        });\n      } else {\n        if (!(0, _nodes.isNumberLiteral)(funcimport.signature)) {\n          throw new Error('isNumberLiteral(funcimport.signature)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var typeId = funcimport.signature.value;\n\n        if (!this.hasType(typeId)) {\n          throw new Error('this.hasType(typeId)' + \" error: \" + (undefined || \"unknown\"));\n        }\n\n        var signature = this.getType(typeId);\n        this.funcs.push({\n          args: signature.params.map(function (arg) {\n            return arg.valtype;\n          }),\n          result: signature.results\n        });\n      }\n\n      if (typeof funcimport.id !== \"undefined\") {\n        // imports are first, we can assume their index in the array\n        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;\n      }\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(index) {\n      return typeof this.getFunction(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(index) {\n      if (typeof index !== \"number\") {\n        throw new Error(\"getFunction only supported for number index\");\n      }\n\n      return this.funcs[index];\n    }\n  }, {\n    key: \"getFunctionOffsetByIdentifier\",\n    value: function getFunctionOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      return this.funcsOffsetByIdentifier[name];\n    }\n    /**\n     * Labels\n     */\n\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(result) {\n      this.labels.unshift(result);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(index) {\n      return this.labels.length > index && index >= 0;\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(index) {\n      return this.labels[index];\n    }\n  }, {\n    key: \"popLabel\",\n    value: function popLabel() {\n      this.labels.shift();\n    }\n    /**\n     * Locals\n     */\n\n  }, {\n    key: \"hasLocal\",\n    value: function hasLocal(index) {\n      return typeof this.getLocal(index) !== \"undefined\";\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(index) {\n      return this.locals[index];\n    }\n  }, {\n    key: \"addLocal\",\n    value: function addLocal(type) {\n      this.locals.push(type);\n    }\n    /**\n     * Types\n     */\n\n  }, {\n    key: \"addType\",\n    value: function addType(type) {\n      if (!(type.functype.type === \"Signature\")) {\n        throw new Error('type.functype.type === \"Signature\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      this.types.push(type.functype);\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(index) {\n      return this.types[index] !== undefined;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this.types[index];\n    }\n    /**\n     * Globals\n     */\n\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(index) {\n      return this.globals.length > index && index >= 0;\n    }\n  }, {\n    key: \"getGlobal\",\n    value: function getGlobal(index) {\n      return this.globals[index].type;\n    }\n  }, {\n    key: \"getGlobalOffsetByIdentifier\",\n    value: function getGlobalOffsetByIdentifier(name) {\n      if (!(typeof name === \"string\")) {\n        throw new Error('typeof name === \"string\"' + \" error: \" + (undefined || \"unknown\"));\n      }\n\n      // $FlowIgnore\n      return this.globalsOffsetByIdentifier[name];\n    }\n  }, {\n    key: \"defineGlobal\",\n    value: function defineGlobal(global) {\n      var type = global.globalType.valtype;\n      var mutability = global.globalType.mutability;\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n\n      if (typeof global.name !== \"undefined\") {\n        // $FlowIgnore\n        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;\n      }\n    }\n  }, {\n    key: \"importGlobal\",\n    value: function importGlobal(type, mutability) {\n      this.globals.push({\n        type: type,\n        mutability: mutability\n      });\n    }\n  }, {\n    key: \"isMutableGlobal\",\n    value: function isMutableGlobal(index) {\n      return this.globals[index].mutability === \"var\";\n    }\n  }, {\n    key: \"isImmutableGlobal\",\n    value: function isImmutableGlobal(index) {\n      return this.globals[index].mutability === \"const\";\n    }\n    /**\n     * Memories\n     */\n\n  }, {\n    key: \"hasMemory\",\n    value: function hasMemory(index) {\n      return this.mems.length > index && index >= 0;\n    }\n  }, {\n    key: \"addMemory\",\n    value: function addMemory(min, max) {\n      this.mems.push({\n        min: min,\n        max: max\n      });\n    }\n  }, {\n    key: \"getMemory\",\n    value: function getMemory(index) {\n      return this.mems[index];\n    }\n  }]);\n\n  return ModuleContext;\n}();\n\nexports.ModuleContext = ModuleContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}