{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst metadata_1 = require(\"./metadata\");\nconst nullable_1 = require(\"./nullable\");\nconst error_1 = require(\"./error\");\nconst types_1 = require(\"../discriminator/types\");\nconst error = {\n  message: cxt => {\n    const {\n      schema,\n      params\n    } = cxt;\n    return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag \"${schema}\" must be string` : `value of tag \"${schema}\" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, \"object\");\n  },\n  params: cxt => {\n    const {\n      schema,\n      params\n    } = cxt;\n    return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, \"object\");\n  }\n};\nconst def = {\n  keyword: \"discriminator\",\n  schemaType: \"string\",\n  implements: [\"mapping\"],\n  error,\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema\n    } = cxt;\n    const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);\n    gen.if(cond);\n    validateDiscriminator();\n    gen.elseIf((0, codegen_1.not)(valid));\n    cxt.error();\n    gen.endIf();\n    cxt.ok(valid);\n    function validateDiscriminator() {\n      const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);\n      gen.if((0, codegen_1._)`${tag} === undefined`);\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag\n      });\n      gen.elseIf((0, codegen_1._)`typeof ${tag} == \"string\"`);\n      validateMapping(tag);\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag\n      }, {\n        instancePath: schema\n      });\n      gen.endIf();\n    }\n    function validateMapping(tag) {\n      gen.if(false);\n      for (const tagValue in parentSchema.mapping) {\n        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(tagValue));\n      }\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag\n      }, {\n        instancePath: schema,\n        schemaPath: \"mapping\",\n        parentSchema: true\n      });\n      gen.endIf();\n    }\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n      cxt.subschema({\n        keyword: \"mapping\",\n        schemaProp,\n        jtdDiscriminator: schema\n      }, _valid);\n      return _valid;\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","metadata_1","nullable_1","error_1","types_1","error","message","cxt","schema","params","discrError","DiscrError","Tag","typeErrorMessage","_","tag","typeErrorParams","def","keyword","schemaType","implements","code","checkMetadata","gen","data","parentSchema","valid","cond","checkNullableObject","if","validateDiscriminator","elseIf","not","endIf","ok","const","getProperty","validateMapping","else","instancePath","tagValue","mapping","assign","applyTagSchema","Mapping","schemaPath","schemaProp","_valid","name","subschema","jtdDiscriminator","exports","default"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\discriminator.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not, getProperty, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\n\nexport type JTDDiscriminatorError =\n  | _JTDTypeError<\"discriminator\", \"object\", string>\n  | DiscrErrorObj<DiscrError.Tag>\n  | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? params.discrError === DiscrError.Tag\n        ? `tag \"${schema}\" must be string`\n        : `value of tag \"${schema}\" must be in mapping`\n      : typeErrorMessage(cxt, \"object\")\n  },\n  params: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? _`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`\n      : typeErrorParams(cxt, \"object\")\n  },\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  schemaType: \"string\",\n  implements: [\"mapping\"],\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, parentSchema} = cxt\n    const [valid, cond] = checkNullableObject(cxt, data)\n\n    gen.if(cond)\n    validateDiscriminator()\n    gen.elseIf(not(valid))\n    cxt.error()\n    gen.endIf()\n    cxt.ok(valid)\n\n    function validateDiscriminator(): void {\n      const tag = gen.const(\"tag\", _`${data}${getProperty(schema)}`)\n      gen.if(_`${tag} === undefined`)\n      cxt.error(false, {discrError: DiscrError.Tag, tag})\n      gen.elseIf(_`typeof ${tag} == \"string\"`)\n      validateMapping(tag)\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Tag, tag}, {instancePath: schema})\n      gen.endIf()\n    }\n\n    function validateMapping(tag: Name): void {\n      gen.if(false)\n      for (const tagValue in parentSchema.mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(tagValue))\n      }\n      gen.else()\n      cxt.error(\n        false,\n        {discrError: DiscrError.Mapping, tag},\n        {instancePath: schema, schemaPath: \"mapping\", parentSchema: true}\n      )\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp: string): Name {\n      const _valid = gen.name(\"valid\")\n      cxt.subschema(\n        {\n          keyword: \"mapping\",\n          schemaProp,\n          jtdDiscriminator: schema,\n        },\n        _valid\n      )\n      return _valid\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}