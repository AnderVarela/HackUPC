{"ast":null,"code":"import esutils from \"esutils\";\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nexport default (({\n  types: t\n}) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  }\n\n  // Converts a JSXAttribute to the equivalent ObjectExpression property\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  }\n\n  // Convert a JSX attribute name to an Object expression property name\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n    if (esutils.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n    return t.stringLiteral(node.name.name);\n  }\n\n  // Convert a JSX attribute value to a JavaScript expression value\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n    return value;\n  }\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr));\n\n        // ignore JSX Elements without spread or with lone spread:\n        if (!hasSpread || path.node.attributes.length === 1) return;\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["esutils","types","t","convertAttributesAssign","attributes","args","i","current","length","node","isJSXSpreadAttribute","push","objectExpression","argument","name","getAttributeName","value","getAttributeValue","properties","objectProperty","callExpression","memberExpression","identifier","convertAttributeSpread","spreadElement","inherits","isJSXNamespacedName","stringLiteral","namespace","keyword","isIdentifierNameES6","booleanLiteral","isJSXExpressionContainer","expression","isStringLiteral","replace","extra","raw","visitor","JSXOpeningElement","path","state","useSpread","opts","hasSpread","some","attr","jsxSpreadAttribute","map"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@babel/preset-modules/src/plugins/transform-jsx-spread/index.js"],"sourcesContent":["import esutils from \"esutils\";\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nexport default ({ types: t }) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n    return t.callExpression(\n      t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n      args\n    );\n  }\n\n  // Converts a JSXAttribute to the equivalent ObjectExpression property\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  }\n\n  // Convert a JSX attribute name to an Object expression property name\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(\n        node.name.namespace.name + \":\" + node.name.name.name\n      );\n    }\n    if (esutils.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n    return t.stringLiteral(node.name.name);\n  }\n\n  // Convert a JSX attribute value to a JavaScript expression value\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr =>\n          t.isJSXSpreadAttribute(attr)\n        );\n\n        // ignore JSX Elements without spread or with lone spread:\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [\n            t.jsxSpreadAttribute(\n              t.objectExpression(\n                path.node.attributes.map(convertAttributeSpread)\n              )\n            ),\n          ];\n        } else {\n          path.node.attributes = [\n            t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes)),\n          ];\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}