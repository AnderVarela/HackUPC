{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\nvar _regexpuCore = require(\"regexpu-core\");\nvar _core = require(\"@babel/core\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _semver = require(\"semver\");\nvar _features = require(\"./features.js\");\nvar _util = require(\"./util.js\");\nconst versionKey = \"@babel/plugin-regexp-features/version\";\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {},\n  manipulateOptions = () => {}\n}) {\n  return {\n    name,\n    manipulateOptions,\n    pre() {\n      var _file$get;\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime\n      } = options;\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n      if (runtime !== undefined) {\n        if (file.has(_features.runtimeKey) && file.get(_features.runtimeKey) !== runtime && (0, _features.hasFeature)(newFeatures, _features.FEATURES.duplicateNamedCaptureGroups)) {\n          throw new Error(`The 'runtime' option must be the same for ` + `'@babel/plugin-transform-named-capturing-groups-regex' and ` + `'@babel/plugin-proposal-duplicate-named-capturing-groups-regex'.`);\n        }\n        if (feature === \"namedCaptureGroups\") {\n          if (!runtime || !file.has(_features.runtimeKey)) file.set(_features.runtimeKey, runtime);\n        } else {\n          file.set(_features.runtimeKey, runtime);\n        }\n      }\n      {\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, \"7.22.15\");\n          return;\n        }\n      }\n      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), \"7.22.15\")) {\n        file.set(versionKey, \"7.22.15\");\n      }\n    },\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2, _newFlags;\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node.pattern, features);\n        if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) {\n          return;\n        }\n        const namedCaptureGroups = {\n          __proto__: null\n        };\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n        let newFlags;\n        if (regexpuOptions.modifiers === \"transform\") {\n          regexpuOptions.onNewFlags = flags => {\n            newFlags = flags;\n          };\n        }\n        node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);\n        if (regexpuOptions.namedGroups === \"transform\" && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n        node.flags = (0, _util.transformFlags)(regexpuOptions, (_newFlags = newFlags) != null ? _newFlags : node.flags);\n      }\n    }\n  };\n}\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}","map":{"version":3,"names":["_regexpuCore","require","_core","_helperAnnotateAsPure","_semver","_features","_util","versionKey","createRegExpFeaturePlugin","name","feature","options","manipulateOptions","pre","_file$get","file","features","get","featuresKey","newFeatures","enableFeature","FEATURES","useUnicodeFlag","runtime","unicodeFlag","set","undefined","has","runtimeKey","hasFeature","duplicateNamedCaptureGroups","Error","lt","visitor","RegExpLiteral","path","_file$get2","_newFlags","node","regexpuOptions","generateRegexpuOptions","pattern","canSkipRegexpu","namedCaptureGroups","__proto__","namedGroups","onNamedGroup","index","prev","Array","isArray","push","newFlags","modifiers","onNewFlags","flags","Object","keys","length","isRegExpTest","call","types","callExpression","addHelper","valueToNode","default","replaceWith","transformFlags","parentPath","isMemberExpression","object","computed","isIdentifier"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\helper-create-regexp-features-plugin\\src\\index.ts"],"sourcesContent":["import rewritePattern from \"regexpu-core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport { types as t, type PluginObject } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport semver from \"semver\";\n\nimport {\n  featuresKey,\n  FEATURES,\n  enableFeature,\n  runtimeKey,\n  hasFeature,\n} from \"./features.ts\";\nimport {\n  generateRegexpuOptions,\n  canSkipRegexpu,\n  transformFlags,\n} from \"./util.ts\";\n\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nexport interface Options {\n  name: string;\n  feature: keyof typeof FEATURES;\n  options?: {\n    useUnicodeFlag?: boolean;\n    runtime?: boolean;\n  };\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n}\n\nexport function createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {},\n  manipulateOptions = () => {},\n}: Options): PluginObject {\n  return {\n    name,\n\n    manipulateOptions,\n\n    pre() {\n      const { file } = this;\n      const features = file.get(featuresKey) ?? 0;\n      let newFeatures = enableFeature(features, FEATURES[feature]);\n\n      const { useUnicodeFlag, runtime } = options;\n      if (useUnicodeFlag === false) {\n        newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);\n      }\n      if (newFeatures !== features) {\n        file.set(featuresKey, newFeatures);\n      }\n\n      if (runtime !== undefined) {\n        if (\n          file.has(runtimeKey) &&\n          file.get(runtimeKey) !== runtime &&\n          (process.env.BABEL_8_BREAKING ||\n            // This check. Is necessary because in Babel 7 we allow multiple\n            // copies of transform-named-capturing-groups-regex with\n            // conflicting 'runtime' options.\n            hasFeature(newFeatures, FEATURES.duplicateNamedCaptureGroups))\n        ) {\n          throw new Error(\n            `The 'runtime' option must be the same for ` +\n              `'@babel/plugin-transform-named-capturing-groups-regex' and ` +\n              `'@babel/plugin-proposal-duplicate-named-capturing-groups-regex'.`,\n          );\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          file.set(runtimeKey, runtime);\n        } else if (\n          // This check. Is necessary because in Babel 7 we allow multiple\n          // copies of transform-named-capturing-groups-regex with\n          // conflicting 'runtime' options.\n          feature === \"namedCaptureGroups\"\n        ) {\n          if (!runtime || !file.has(runtimeKey)) file.set(runtimeKey, runtime);\n        } else {\n          file.set(runtimeKey, runtime);\n        }\n      }\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // Until 7.21.4, we used to encode the version as a number.\n        // If file.get(versionKey) is a number, it has thus been\n        // set by an older version of this plugin.\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, PACKAGE_JSON.version);\n          return;\n        }\n      }\n      if (\n        !file.get(versionKey) ||\n        semver.lt(file.get(versionKey), PACKAGE_JSON.version)\n      ) {\n        file.set(versionKey, PACKAGE_JSON.version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        const { node } = path;\n        const { file } = this;\n        const features = file.get(featuresKey);\n        const runtime = file.get(runtimeKey) ?? true;\n\n        const regexpuOptions = generateRegexpuOptions(node.pattern, features);\n        if (canSkipRegexpu(node, regexpuOptions)) {\n          return;\n        }\n\n        const namedCaptureGroups: Record<string, number | number[]> = {\n          __proto__: null,\n        };\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n\n        let newFlags;\n        if (regexpuOptions.modifiers === \"transform\") {\n          regexpuOptions.onNewFlags = flags => {\n            newFlags = flags;\n          };\n        }\n\n        node.pattern = rewritePattern(node.pattern, node.flags, regexpuOptions);\n\n        if (\n          regexpuOptions.namedGroups === \"transform\" &&\n          Object.keys(namedCaptureGroups).length > 0 &&\n          runtime &&\n          !isRegExpTest(path)\n        ) {\n          const call = t.callExpression(this.addHelper(\"wrapRegExp\"), [\n            node,\n            t.valueToNode(namedCaptureGroups),\n          ]);\n          annotateAsPure(call);\n\n          path.replaceWith(call);\n        }\n\n        node.flags = transformFlags(regexpuOptions, newFlags ?? node.flags);\n      },\n    },\n  };\n}\n\nfunction isRegExpTest(path: NodePath<t.RegExpLiteral>) {\n  return (\n    path.parentPath.isMemberExpression({\n      object: path.node,\n      computed: false,\n    }) && path.parentPath.get(\"property\").isIdentifier({ name: \"test\" })\n  );\n}\n"],"mappings":";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAEA,IAAAC,KAAA,GAAAD,OAAA;AACA,IAAAE,qBAAA,GAAAF,OAAA;AAEA,IAAAG,OAAA,GAAAH,OAAA;AAEA,IAAAI,SAAA,GAAAJ,OAAA;AAOA,IAAAK,KAAA,GAAAL,OAAA;AAMA,MAAMM,UAAU,GAAG,uCAAuC;AAYnD,SAASC,yBAAyBA,CAAC;EACxCC,IAAI;EACJC,OAAO;EACPC,OAAO,GAAG,CAAC,CAAC;EACZC,iBAAiB,GAAGA,CAAA,KAAM,CAAC;AACpB,CAAC,EAAgB;EACxB,OAAO;IACLH,IAAI;IAEJG,iBAAiB;IAEjBC,GAAGA,CAAA,EAAG;MAAA,IAAAC,SAAA;MACJ,MAAM;QAAEC;MAAK,CAAC,GAAG,IAAI;MACrB,MAAMC,QAAQ,IAAAF,SAAA,GAAGC,IAAI,CAACE,GAAG,CAACZ,SAAA,CAAAa,WAAW,CAAC,YAAAJ,SAAA,GAAI,CAAC;MAC3C,IAAIK,WAAW,GAAG,IAAAd,SAAA,CAAAe,aAAa,EAACJ,QAAQ,EAAEX,SAAA,CAAAgB,QAAQ,CAACX,OAAO,CAAC,CAAC;MAE5D,MAAM;QAAEY,cAAc;QAAEC;MAAQ,CAAC,GAAGZ,OAAO;MAC3C,IAAIW,cAAc,KAAK,KAAK,EAAE;QAC5BH,WAAW,GAAG,IAAAd,SAAA,CAAAe,aAAa,EAACD,WAAW,EAAEd,SAAA,CAAAgB,QAAQ,CAACG,WAAW,CAAC;MAChE;MACA,IAAIL,WAAW,KAAKH,QAAQ,EAAE;QAC5BD,IAAI,CAACU,GAAG,CAACpB,SAAA,CAAAa,WAAW,EAAEC,WAAW,CAAC;MACpC;MAEA,IAAII,OAAO,KAAKG,SAAS,EAAE;QACzB,IACEX,IAAI,CAACY,GAAG,CAACtB,SAAA,CAAAuB,UAAU,CAAC,IACpBb,IAAI,CAACE,GAAG,CAACZ,SAAA,CAAAuB,UAAU,CAAC,KAAKL,OAAO,IAK9B,IAAAlB,SAAA,CAAAwB,UAAU,EAACV,WAAW,EAAEd,SAAA,CAAAgB,QAAQ,CAACS,2BAA2B,CAAE,EAChE;UACA,MAAM,IAAIC,KAAK,CACZ,4CAA2C,GACzC,6DAA4D,GAC5D,kEACL,CAAC;QACH;QAIO,IAILrB,OAAO,KAAK,oBAAoB,EAChC;UACA,IAAI,CAACa,OAAO,IAAI,CAACR,IAAI,CAACY,GAAG,CAACtB,SAAA,CAAAuB,UAAU,CAAC,EAAEb,IAAI,CAACU,GAAG,CAACpB,SAAA,CAAAuB,UAAU,EAAEL,OAAO,CAAC;QACtE,CAAC,MAAM;UACLR,IAAI,CAACU,GAAG,CAACpB,SAAA,CAAAuB,UAAU,EAAEL,OAAO,CAAC;QAC/B;MACF;MAEmC;QAIjC,IAAI,OAAOR,IAAI,CAACE,GAAG,CAACV,UAAU,CAAC,KAAK,QAAQ,EAAE;UAC5CQ,IAAI,CAACU,GAAG,CAAClB,UAAU,WAAsB,CAAC;UAC1C;QACF;MACF;MACA,IACE,CAACQ,IAAI,CAACE,GAAG,CAACV,UAAU,CAAC,IACrBH,OAAM,CAAC4B,EAAE,CAACjB,IAAI,CAACE,GAAG,CAACV,UAAU,CAAC,WAAsB,CAAC,EACrD;QACAQ,IAAI,CAACU,GAAG,CAAClB,UAAU,WAAsB,CAAC;MAC5C;IACF,CAAC;IAED0B,OAAO,EAAE;MACPC,aAAaA,CAACC,IAAI,EAAE;QAAA,IAAAC,UAAA,EAAAC,SAAA;QAClB,MAAM;UAAEC;QAAK,CAAC,GAAGH,IAAI;QACrB,MAAM;UAAEpB;QAAK,CAAC,GAAG,IAAI;QACrB,MAAMC,QAAQ,GAAGD,IAAI,CAACE,GAAG,CAACZ,SAAA,CAAAa,WAAW,CAAC;QACtC,MAAMK,OAAO,IAAAa,UAAA,GAAGrB,IAAI,CAACE,GAAG,CAACZ,SAAA,CAAAuB,UAAU,CAAC,YAAAQ,UAAA,GAAI,IAAI;QAE5C,MAAMG,cAAc,GAAG,IAAAjC,KAAA,CAAAkC,sBAAsB,EAACF,IAAI,CAACG,OAAO,EAAEzB,QAAQ,CAAC;QACrE,IAAI,IAAAV,KAAA,CAAAoC,cAAc,EAACJ,IAAI,EAAEC,cAAc,CAAC,EAAE;UACxC;QACF;QAEA,MAAMI,kBAAqD,GAAG;UAC5DC,SAAS,EAAE;QACb,CAAC;QACD,IAAIL,cAAc,CAACM,WAAW,KAAK,WAAW,EAAE;UAC9CN,cAAc,CAACO,YAAY,GAAG,CAACrC,IAAI,EAAEsC,KAAK,KAAK;YAC7C,MAAMC,IAAI,GAAGL,kBAAkB,CAAClC,IAAI,CAAC;YACrC,IAAI,OAAOuC,IAAI,KAAK,QAAQ,EAAE;cAC5BL,kBAAkB,CAAClC,IAAI,CAAC,GAAG,CAACuC,IAAI,EAAED,KAAK,CAAC;YAC1C,CAAC,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;cAC9BA,IAAI,CAACG,IAAI,CAACJ,KAAK,CAAC;YAClB,CAAC,MAAM;cACLJ,kBAAkB,CAAClC,IAAI,CAAC,GAAGsC,KAAK;YAClC;UACF,CAAC;QACH;QAEA,IAAIK,QAAQ;QACZ,IAAIb,cAAc,CAACc,SAAS,KAAK,WAAW,EAAE;UAC5Cd,cAAc,CAACe,UAAU,GAAGC,KAAK,IAAI;YACnCH,QAAQ,GAAGG,KAAK;UAClB,CAAC;QACH;QAEAjB,IAAI,CAACG,OAAO,GAAGzC,YAAc,CAACsC,IAAI,CAACG,OAAO,EAAEH,IAAI,CAACiB,KAAK,EAAEhB,cAAc,CAAC;QAEvE,IACEA,cAAc,CAACM,WAAW,KAAK,WAAW,IAC1CW,MAAM,CAACC,IAAI,CAACd,kBAAkB,CAAC,CAACe,MAAM,GAAG,CAAC,IAC1CnC,OAAO,IACP,CAACoC,YAAY,CAACxB,IAAI,CAAC,EACnB;UACA,MAAMyB,IAAI,GAAG1D,KAAA,CAAA2D,KAAC,CAACC,cAAc,CAAC,IAAI,CAACC,SAAS,CAAC,YAAY,CAAC,EAAE,CAC1DzB,IAAI,EACJpC,KAAA,CAAA2D,KAAC,CAACG,WAAW,CAACrB,kBAAkB,CAAC,CAClC,CAAC;UACF,IAAAxC,qBAAA,CAAA8D,OAAc,EAACL,IAAI,CAAC;UAEpBzB,IAAI,CAAC+B,WAAW,CAACN,IAAI,CAAC;QACxB;QAEAtB,IAAI,CAACiB,KAAK,GAAG,IAAAjD,KAAA,CAAA6D,cAAc,EAAC5B,cAAc,GAAAF,SAAA,GAAEe,QAAQ,YAAAf,SAAA,GAAIC,IAAI,CAACiB,KAAK,CAAC;MACrE;IACF;EACF,CAAC;AACH;AAEA,SAASI,YAAYA,CAACxB,IAA+B,EAAE;EACrD,OACEA,IAAI,CAACiC,UAAU,CAACC,kBAAkB,CAAC;IACjCC,MAAM,EAAEnC,IAAI,CAACG,IAAI;IACjBiC,QAAQ,EAAE;EACZ,CAAC,CAAC,IAAIpC,IAAI,CAACiC,UAAU,CAACnD,GAAG,CAAC,UAAU,CAAC,CAACuD,YAAY,CAAC;IAAE/D,IAAI,EAAE;EAAO,CAAC,CAAC;AAExE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}