{"ast":null,"code":"/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n  constructor() {\n    this._indexes = {\n      __proto__: null\n    };\n    this.array = [];\n  }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast(set) {\n  return set;\n}\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nfunction get(setarr, key) {\n  return cast(setarr)._indexes[key];\n}\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nfunction put(setarr, key) {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n  const {\n    array,\n    _indexes: indexes\n  } = cast(setarr);\n  const length = array.push(key);\n  return indexes[key] = length - 1;\n}\n/**\n * Pops the last added item out of the SetArray.\n */\nfunction pop(setarr) {\n  const {\n    array,\n    _indexes: indexes\n  } = cast(setarr);\n  if (array.length === 0) return;\n  const last = array.pop();\n  indexes[last] = undefined;\n}\n/**\n * Removes the key, if it exists in the set.\n */\nfunction remove(setarr, key) {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n  const {\n    array,\n    _indexes: indexes\n  } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\nexport { SetArray, get, pop, put, remove };","map":{"version":3,"names":["SetArray","constructor","_indexes","__proto__","array","cast","set","get","setarr","key","put","index","undefined","indexes","length","push","pop","last","remove","i","k"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\set-array\\src\\set-array.ts"],"sourcesContent":["type Key = string | number | symbol;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray<T extends Key = Key> {\n  private declare _indexes: Record<T, number | undefined>;\n  declare array: readonly T[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n}\n\ninterface PublicSet<T extends Key> {\n  array: T[];\n  _indexes: SetArray<T>['_indexes'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\n  return set as any;\n}\n\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\n  return cast(setarr)._indexes[key];\n}\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n\n  const { array, _indexes: indexes } = cast(setarr);\n\n  const length = array.push(key);\n  return (indexes[key] = length - 1);\n}\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\n  const { array, _indexes: indexes } = cast(setarr);\n  if (array.length === 0) return;\n\n  const last = array.pop()!;\n  indexes[last] = undefined;\n}\n\n/**\n * Removes the key, if it exists in the set.\n */\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]!--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\n"],"mappings":"AAEA;;;;;;;;MAQaA,QAAQ;EAInBC,YAAA;IACE,IAAI,CAACC,QAAQ,GAAG;MAAEC,SAAS,EAAE;IAAI,CAAS;IAC1C,IAAI,CAACC,KAAK,GAAG,EAAE;;;AASnB;;;;AAIA,SAASC,IAAIA,CAAgBC,GAAgB;EAC3C,OAAOA,GAAU;AACnB;AAEA;;;SAGgBC,GAAGA,CAAgBC,MAAmB,EAAEC,GAAM;EAC5D,OAAOJ,IAAI,CAACG,MAAM,CAAC,CAACN,QAAQ,CAACO,GAAG,CAAC;AACnC;AAEA;;;;SAIgBC,GAAGA,CAAgBF,MAAmB,EAAEC,GAAM;;EAE5D,MAAME,KAAK,GAAGJ,GAAG,CAACC,MAAM,EAAEC,GAAG,CAAC;EAC9B,IAAIE,KAAK,KAAKC,SAAS,EAAE,OAAOD,KAAK;EAErC,MAAM;IAAEP,KAAK;IAAEF,QAAQ,EAAEW;EAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;EAEjD,MAAMM,MAAM,GAAGV,KAAK,CAACW,IAAI,CAACN,GAAG,CAAC;EAC9B,OAAQI,OAAO,CAACJ,GAAG,CAAC,GAAGK,MAAM,GAAG,CAAC;AACnC;AAEA;;;SAGgBE,GAAGA,CAAgBR,MAAmB;EACpD,MAAM;IAAEJ,KAAK;IAAEF,QAAQ,EAAEW;EAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;EACjD,IAAIJ,KAAK,CAACU,MAAM,KAAK,CAAC,EAAE;EAExB,MAAMG,IAAI,GAAGb,KAAK,CAACY,GAAG,EAAG;EACzBH,OAAO,CAACI,IAAI,CAAC,GAAGL,SAAS;AAC3B;AAEA;;;SAGgBM,MAAMA,CAAgBV,MAAmB,EAAEC,GAAM;EAC/D,MAAME,KAAK,GAAGJ,GAAG,CAACC,MAAM,EAAEC,GAAG,CAAC;EAC9B,IAAIE,KAAK,KAAKC,SAAS,EAAE;EAEzB,MAAM;IAAER,KAAK;IAAEF,QAAQ,EAAEW;EAAO,CAAE,GAAGR,IAAI,CAACG,MAAM,CAAC;EACjD,KAAK,IAAIW,CAAC,GAAGR,KAAK,GAAG,CAAC,EAAEQ,CAAC,GAAGf,KAAK,CAACU,MAAM,EAAEK,CAAC,EAAE,EAAE;IAC7C,MAAMC,CAAC,GAAGhB,KAAK,CAACe,CAAC,CAAC;IAClBf,KAAK,CAACe,CAAC,GAAG,CAAC,CAAC,GAAGC,CAAC;IAChBP,OAAO,CAACO,CAAC,CAAE,EAAE;;EAEfP,OAAO,CAACJ,GAAG,CAAC,GAAGG,SAAS;EACxBR,KAAK,CAACY,GAAG,EAAE;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}