{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExportVisitor_referencer, _ExportVisitor_exportNode;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst Visitor_1 = require(\"./Visitor\");\nclass ExportVisitor extends Visitor_1.Visitor {\n  constructor(node, referencer) {\n    super(referencer);\n    _ExportVisitor_referencer.set(this, void 0);\n    _ExportVisitor_exportNode.set(this, void 0);\n    __classPrivateFieldSet(this, _ExportVisitor_exportNode, node, \"f\");\n    __classPrivateFieldSet(this, _ExportVisitor_referencer, referencer, \"f\");\n  }\n  static visit(referencer, node) {\n    const exportReferencer = new ExportVisitor(node, referencer);\n    exportReferencer.visit(node);\n  }\n  Identifier(node) {\n    if (__classPrivateFieldGet(this, _ExportVisitor_exportNode, \"f\").exportKind === 'type') {\n      // export type { T };\n      // type exports can only reference types\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node);\n    } else {\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceDualValueType(node);\n    }\n  }\n  ExportDefaultDeclaration(node) {\n    if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {\n      // export default A;\n      // this could be a type or a variable\n      this.visit(node.declaration);\n    } else {\n      // export const a = 1;\n      // export something();\n      // etc\n      // these not included in the scope of this visitor as they are all guaranteed to be values or declare variables\n    }\n  }\n  ExportNamedDeclaration(node) {\n    if (node.source) {\n      // export ... from 'foo';\n      // these are external identifiers so there shouldn't be references or defs\n      return;\n    }\n    if (!node.declaration) {\n      // export { x };\n      this.visitChildren(node);\n    } else {\n      // export const x = 1;\n      // this is not included in the scope of this visitor as it creates a variable\n    }\n  }\n  ExportSpecifier(node) {\n    if (node.exportKind === 'type') {\n      // export { type T };\n      // type exports can only reference types\n      //\n      // we can't let this fall through to the Identifier selector because the exportKind is on this node\n      // and we don't have access to the `.parent` during scope analysis\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node.local);\n    } else {\n      this.visit(node.local);\n    }\n  }\n}\nexports.ExportVisitor = ExportVisitor;\n_ExportVisitor_referencer = new WeakMap(), _ExportVisitor_exportNode = new WeakMap();","map":{"version":3,"names":["types_1","require","Visitor_1","ExportVisitor","Visitor","constructor","node","referencer","_ExportVisitor_referencer","set","_ExportVisitor_exportNode","__classPrivateFieldSet","visit","exportReferencer","Identifier","__classPrivateFieldGet","exportKind","currentScope","referenceType","referenceDualValueType","ExportDefaultDeclaration","declaration","type","AST_NODE_TYPES","ExportNamedDeclaration","source","visitChildren","ExportSpecifier","local","exports"],"sources":["../../src/referencer/ExportVisitor.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAGA,MAAAC,SAAA,GAAAD,OAAA;AAOA,MAAME,aAAc,SAAQD,SAAA,CAAAE,OAAO;EAIjCC,YAAYC,IAAgB,EAAEC,UAAsB;IAClD,KAAK,CAACA,UAAU,CAAC;IAJVC,yBAAA,CAAAC,GAAA;IACAC,yBAAA,CAAAD,GAAA;IAIPE,sBAAA,KAAI,EAAAD,yBAAA,EAAeJ,IAAI;IACvBK,sBAAA,KAAI,EAAAH,yBAAA,EAAeD,UAAU;EAC/B;EAEA,OAAOK,KAAKA,CAACL,UAAsB,EAAED,IAAgB;IACnD,MAAMO,gBAAgB,GAAG,IAAIV,aAAa,CAACG,IAAI,EAAEC,UAAU,CAAC;IAC5DM,gBAAgB,CAACD,KAAK,CAACN,IAAI,CAAC;EAC9B;EAEUQ,UAAUA,CAACR,IAAyB;IAC5C,IAAIS,sBAAA,KAAI,EAAAL,yBAAA,MAAY,CAACM,UAAU,KAAK,MAAM,EAAE;MAC1C;MACA;MACAD,sBAAA,KAAI,EAAAP,yBAAA,MAAY,CAACS,YAAY,EAAE,CAACC,aAAa,CAACZ,IAAI,CAAC;KACpD,MAAM;MACLS,sBAAA,KAAI,EAAAP,yBAAA,MAAY,CAACS,YAAY,EAAE,CAACE,sBAAsB,CAACb,IAAI,CAAC;;EAEhE;EAEUc,wBAAwBA,CAChCd,IAAuC;IAEvC,IAAIA,IAAI,CAACe,WAAW,CAACC,IAAI,KAAKtB,OAAA,CAAAuB,cAAc,CAACT,UAAU,EAAE;MACvD;MACA;MACA,IAAI,CAACF,KAAK,CAACN,IAAI,CAACe,WAAW,CAAC;KAC7B,MAAM;MACL;MACA;MACA;MACA;IAAA;EAEJ;EAEUG,sBAAsBA,CAC9BlB,IAAqC;IAErC,IAAIA,IAAI,CAACmB,MAAM,EAAE;MACf;MACA;MACA;;IAGF,IAAI,CAACnB,IAAI,CAACe,WAAW,EAAE;MACrB;MACA,IAAI,CAACK,aAAa,CAACpB,IAAI,CAAC;KACzB,MAAM;MACL;MACA;IAAA;EAEJ;EAEUqB,eAAeA,CAACrB,IAA8B;IACtD,IAAIA,IAAI,CAACU,UAAU,KAAK,MAAM,EAAE;MAC9B;MACA;MACA;MACA;MACA;MACAD,sBAAA,KAAI,EAAAP,yBAAA,MAAY,CAACS,YAAY,EAAE,CAACC,aAAa,CAACZ,IAAI,CAACsB,KAAK,CAAC;KAC1D,MAAM;MACL,IAAI,CAAChB,KAAK,CAACN,IAAI,CAACsB,KAAK,CAAC;;EAE1B;;AAGOC,OAAA,CAAA1B,aAAA,GAAAA,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}