{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\nconst events = require('./events');\nconst promise = require('./promise');\nconst walk = require('./walk');\nmodule.exports = parse;\nconst NDJSON_STATE = new Map();\n\n/**\n * Public function `parse`.\n *\n * Returns a promise and asynchronously parses a stream of JSON data. If\n * there are no errors, the promise is resolved with the parsed data. If\n * errors occur, the promise is rejected with the first error.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option reviver:   Transformation function, invoked depth-first.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON. In\n *                    this case, each call will be resolved with one value\n *                    from the stream. To parse the entire stream, calls\n *                    should be made sequentially one-at-a-time until the\n *                    returned promise resolves to `undefined`.\n **/\nfunction parse(stream, options = {}) {\n  const Promise = promise(options);\n  try {\n    check.assert.maybe.function(options.reviver, 'Invalid reviver option');\n  } catch (err) {\n    return Promise.reject(err);\n  }\n  const errors = [];\n  const scopes = [];\n  const reviver = options.reviver;\n  const shouldHandleNdjson = !!options.ndjson;\n  let emitter, resolve, reject, scopeKey;\n  if (shouldHandleNdjson && NDJSON_STATE.has(stream)) {\n    const state = NDJSON_STATE.get(stream);\n    NDJSON_STATE.delete(stream);\n    emitter = state.emitter;\n    setImmediate(state.resume);\n  } else {\n    emitter = walk(stream, options);\n  }\n  emitter.on(events.array, array);\n  emitter.on(events.object, object);\n  emitter.on(events.property, property);\n  emitter.on(events.string, value);\n  emitter.on(events.number, value);\n  emitter.on(events.literal, value);\n  emitter.on(events.endArray, endScope);\n  emitter.on(events.endObject, endScope);\n  emitter.on(events.end, end);\n  emitter.on(events.error, error);\n  emitter.on(events.dataError, error);\n  if (shouldHandleNdjson) {\n    emitter.on(events.endLine, endLine);\n  }\n  return new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  function array() {\n    if (errors.length > 0) {\n      return;\n    }\n    beginScope([]);\n  }\n  function beginScope(parsed) {\n    if (errors.length > 0) {\n      return;\n    }\n    if (scopes.length > 0) {\n      value(parsed);\n    }\n    scopes.push(parsed);\n  }\n  function value(v) {\n    if (errors.length > 0) {\n      return;\n    }\n    if (scopes.length === 0) {\n      return scopes.push(v);\n    }\n    const scope = scopes[scopes.length - 1];\n    if (scopeKey) {\n      scope[scopeKey] = v;\n      scopeKey = null;\n    } else {\n      scope.push(v);\n    }\n  }\n  function object() {\n    if (errors.length > 0) {\n      return;\n    }\n    beginScope({});\n  }\n  function property(name) {\n    if (errors.length > 0) {\n      return;\n    }\n    scopeKey = name;\n  }\n  function endScope() {\n    if (errors.length > 0) {\n      return;\n    }\n    if (scopes.length > 1) {\n      scopes.pop();\n    }\n  }\n  function end() {\n    if (shouldHandleNdjson) {\n      const resume = emitter.pause();\n      emitter.removeAllListeners();\n      NDJSON_STATE.set(stream, {\n        emitter,\n        resume\n      });\n    }\n    if (errors.length > 0) {\n      return reject(errors[0]);\n    }\n    if (reviver) {\n      scopes[0] = transform(scopes[0], '');\n    }\n    resolve(scopes[0]);\n  }\n  function transform(obj, key) {\n    if (obj && typeof obj === 'object') {\n      Object.entries(obj).forEach(([k, v]) => {\n        obj[k] = transform(v, k);\n      });\n    }\n    return reviver(key, obj);\n  }\n  function error(e) {\n    errors.push(e);\n  }\n  function endLine() {\n    if (scopes.length > 0) {\n      end();\n    }\n  }\n}","map":{"version":3,"names":["check","require","events","promise","walk","module","exports","parse","NDJSON_STATE","Map","stream","options","Promise","assert","maybe","function","reviver","err","reject","errors","scopes","shouldHandleNdjson","ndjson","emitter","resolve","scopeKey","has","state","get","delete","setImmediate","resume","on","array","object","property","string","value","number","literal","endArray","endScope","endObject","end","error","dataError","endLine","res","rej","length","beginScope","parsed","push","v","scope","name","pop","pause","removeAllListeners","set","transform","obj","key","Object","entries","forEach","k","e"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/src/parse.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst events = require('./events')\nconst promise = require('./promise')\nconst walk = require('./walk')\n\nmodule.exports = parse\n\nconst NDJSON_STATE = new Map()\n\n/**\n * Public function `parse`.\n *\n * Returns a promise and asynchronously parses a stream of JSON data. If\n * there are no errors, the promise is resolved with the parsed data. If\n * errors occur, the promise is rejected with the first error.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option reviver:   Transformation function, invoked depth-first.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON. In\n *                    this case, each call will be resolved with one value\n *                    from the stream. To parse the entire stream, calls\n *                    should be made sequentially one-at-a-time until the\n *                    returned promise resolves to `undefined`.\n **/\nfunction parse (stream, options = {}) {\n  const Promise = promise(options)\n\n  try {\n    check.assert.maybe.function(options.reviver, 'Invalid reviver option')\n  } catch (err) {\n    return Promise.reject(err)\n  }\n\n  const errors = []\n  const scopes = []\n  const reviver = options.reviver\n  const shouldHandleNdjson = !! options.ndjson\n\n  let emitter, resolve, reject, scopeKey\n  if (shouldHandleNdjson && NDJSON_STATE.has(stream)) {\n    const state = NDJSON_STATE.get(stream)\n    NDJSON_STATE.delete(stream)\n    emitter = state.emitter\n    setImmediate(state.resume)\n  } else {\n    emitter = walk(stream, options)\n  }\n\n  emitter.on(events.array, array)\n  emitter.on(events.object, object)\n  emitter.on(events.property, property)\n  emitter.on(events.string, value)\n  emitter.on(events.number, value)\n  emitter.on(events.literal, value)\n  emitter.on(events.endArray, endScope)\n  emitter.on(events.endObject, endScope)\n  emitter.on(events.end, end)\n  emitter.on(events.error, error)\n  emitter.on(events.dataError, error)\n\n  if (shouldHandleNdjson) {\n    emitter.on(events.endLine, endLine)\n  }\n\n  return new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  function array () {\n    if (errors.length > 0) {\n      return\n    }\n\n    beginScope([])\n  }\n\n  function beginScope (parsed) {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length > 0) {\n      value(parsed)\n    }\n\n    scopes.push(parsed)\n  }\n\n  function value (v) {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length === 0) {\n      return scopes.push(v)\n    }\n\n    const scope = scopes[scopes.length - 1]\n\n    if (scopeKey) {\n      scope[scopeKey] = v\n      scopeKey = null\n    } else {\n      scope.push(v)\n    }\n  }\n\n  function object () {\n    if (errors.length > 0) {\n      return\n    }\n\n    beginScope({})\n  }\n\n  function property (name) {\n    if (errors.length > 0) {\n      return\n    }\n\n    scopeKey = name\n  }\n\n  function endScope () {\n    if (errors.length > 0) {\n      return\n    }\n\n    if (scopes.length > 1) {\n      scopes.pop()\n    }\n  }\n\n  function end () {\n    if (shouldHandleNdjson) {\n      const resume = emitter.pause()\n      emitter.removeAllListeners()\n      NDJSON_STATE.set(stream, { emitter, resume })\n    }\n\n    if (errors.length > 0) {\n      return reject(errors[0])\n    }\n\n    if (reviver) {\n      scopes[0] = transform(scopes[0], '')\n    }\n\n    resolve(scopes[0])\n  }\n\n  function transform (obj, key) {\n    if (obj && typeof obj === 'object') {\n      Object.entries(obj).forEach(([ k, v ]) => {\n        obj[k] = transform(v, k)\n      })\n    }\n\n    return reviver(key, obj)\n  }\n\n  function error (e) {\n    errors.push(e)\n  }\n\n  function endLine () {\n    if (scopes.length > 0) {\n      end()\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}