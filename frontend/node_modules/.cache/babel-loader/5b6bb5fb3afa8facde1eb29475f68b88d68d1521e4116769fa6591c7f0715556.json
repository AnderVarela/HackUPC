{"ast":null,"code":"'use strict';\n\nconst assert = require('chai').assert;\nconst proxyquire = require('proxyquire');\nconst spooks = require('spooks');\nconst Promise = require('bluebird');\nconst modulePath = '../../src/unpipe';\nsuite('unpipe:', () => {\n  test('require does not throw', () => {\n    assert.doesNotThrow(() => {\n      require(modulePath);\n    });\n  });\n  test('require returns function', () => {\n    assert.isFunction(require(modulePath));\n  });\n  suite('require:', () => {\n    let log, results, unpipe;\n    setup(() => {\n      log = {};\n      results = {\n        parse: [Promise.resolve()]\n      };\n      unpipe = proxyquire(modulePath, {\n        './parse': spooks.fn({\n          name: 'parse',\n          log: log,\n          results: results.parse\n        })\n      });\n    });\n    test('unpipe expects two arguments', () => {\n      assert.lengthOf(unpipe, 2);\n    });\n    test('unpipe does not throw', () => {\n      assert.doesNotThrow(() => {\n        unpipe(() => {});\n      });\n    });\n    test('unpipe throws if callback is not provided', () => {\n      assert.throws(() => {\n        unpipe();\n      });\n    });\n    test('parse was not called', () => {\n      assert.strictEqual(log.counts.parse, 0);\n    });\n    suite('unpipe success:', () => {\n      let result, error, options;\n      setup(done => {\n        results.parse[0] = Promise.resolve('foo');\n        options = {\n          foo: 'bar',\n          ndjson: true\n        };\n        unpipe((err, res) => {\n          error = err;\n          result = res;\n          done();\n        }, options);\n      });\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1);\n      });\n      test('parse was called correctly', () => {\n        assert.isUndefined(log.these.parse[0]);\n        assert.lengthOf(log.args.parse[0], 2);\n        assert.isObject(log.args.parse[0][0]);\n        assert.isTrue(log.args.parse[0][0].readable);\n        assert.isTrue(log.args.parse[0][0].writable);\n        assert.isFunction(log.args.parse[0][0].pipe);\n        assert.isFunction(log.args.parse[0][0].read);\n        assert.isFunction(log.args.parse[0][0]._read);\n        assert.isFunction(log.args.parse[0][0].write);\n        assert.isFunction(log.args.parse[0][0]._write);\n        assert.notStrictEqual(log.args.parse[0][1], options);\n        assert.deepEqual(log.args.parse[0][1], {\n          foo: 'bar',\n          ndjson: false\n        });\n      });\n      test('parse result was returned', () => {\n        assert.strictEqual(result, 'foo');\n      });\n      test('did not fail', () => {\n        assert.isNull(error);\n      });\n    });\n    suite('unpipe error:', () => {\n      let result, error, options;\n      setup(done => {\n        results.parse[0] = Promise.reject('bar');\n        options = {};\n        unpipe((err, res) => {\n          error = err;\n          result = res;\n          done();\n        }, options);\n      });\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1);\n      });\n      test('parse result was not returned', () => {\n        assert.isUndefined(result);\n      });\n      test('failed', () => {\n        assert.strictEqual(error, 'bar');\n      });\n    });\n  });\n});","map":{"version":3,"names":["assert","require","proxyquire","spooks","Promise","modulePath","suite","test","doesNotThrow","isFunction","log","results","unpipe","setup","parse","resolve","fn","name","lengthOf","throws","strictEqual","counts","result","error","options","done","foo","ndjson","err","res","isUndefined","these","args","isObject","isTrue","readable","writable","pipe","read","_read","write","_write","notStrictEqual","deepEqual","isNull","reject"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/test/unit/unpipe.js"],"sourcesContent":["'use strict'\n\nconst assert = require('chai').assert\nconst proxyquire = require('proxyquire')\nconst spooks = require('spooks')\nconst Promise = require('bluebird')\n\nconst modulePath = '../../src/unpipe'\n\nsuite('unpipe:', () => {\n  test('require does not throw', () => {\n    assert.doesNotThrow(() => {\n      require(modulePath)\n    })\n  })\n\n  test('require returns function', () => {\n    assert.isFunction(require(modulePath))\n  })\n\n  suite('require:', () => {\n    let log, results, unpipe\n\n    setup(() => {\n      log = {}\n      results = {\n        parse: [ Promise.resolve() ]\n      }\n      unpipe = proxyquire(modulePath, {\n        './parse': spooks.fn({\n          name: 'parse',\n          log: log,\n          results: results.parse\n        })\n      })\n    })\n\n    test('unpipe expects two arguments', () => {\n      assert.lengthOf(unpipe, 2)\n    })\n\n    test('unpipe does not throw', () => {\n      assert.doesNotThrow(() => {\n        unpipe(() => {})\n      })\n    })\n\n    test('unpipe throws if callback is not provided', () => {\n      assert.throws(() => {\n        unpipe()\n      })\n    })\n\n    test('parse was not called', () => {\n      assert.strictEqual(log.counts.parse, 0)\n    })\n\n    suite('unpipe success:', () => {\n      let result, error, options\n\n      setup(done => {\n        results.parse[0] = Promise.resolve('foo')\n        options = { foo: 'bar', ndjson: true }\n        unpipe((err, res) => {\n          error = err\n          result = res\n          done()\n        }, options)\n      })\n\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1)\n      })\n\n      test('parse was called correctly', () => {\n        assert.isUndefined(log.these.parse[0])\n        assert.lengthOf(log.args.parse[0], 2)\n        assert.isObject(log.args.parse[0][0])\n        assert.isTrue(log.args.parse[0][0].readable)\n        assert.isTrue(log.args.parse[0][0].writable)\n        assert.isFunction(log.args.parse[0][0].pipe)\n        assert.isFunction(log.args.parse[0][0].read)\n        assert.isFunction(log.args.parse[0][0]._read)\n        assert.isFunction(log.args.parse[0][0].write)\n        assert.isFunction(log.args.parse[0][0]._write)\n        assert.notStrictEqual(log.args.parse[0][1], options)\n        assert.deepEqual(log.args.parse[0][1], { foo: 'bar', ndjson: false })\n      })\n\n      test('parse result was returned', () => {\n        assert.strictEqual(result, 'foo')\n      })\n\n      test('did not fail', () => {\n        assert.isNull(error)\n      })\n    })\n\n    suite('unpipe error:', () => {\n      let result, error, options\n\n      setup(done => {\n        results.parse[0] = Promise.reject('bar')\n        options = {}\n        unpipe((err, res) => {\n          error = err\n          result = res\n          done()\n        }, options)\n      })\n\n      test('parse was called once', () => {\n        assert.strictEqual(log.counts.parse, 1)\n      })\n\n      test('parse result was not returned', () => {\n        assert.isUndefined(result)\n      })\n\n      test('failed', () => {\n        assert.strictEqual(error, 'bar')\n      })\n    })\n  })\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}