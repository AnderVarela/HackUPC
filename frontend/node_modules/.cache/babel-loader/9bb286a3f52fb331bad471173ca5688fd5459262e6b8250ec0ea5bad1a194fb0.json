{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst regexpp_1 = require(\"@eslint-community/regexpp\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst EQ_OPERATORS = /^[=!]=/;\nconst regexpp = new regexpp_1.RegExpParser();\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-string-starts-ends-with',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      preferStartsWith: \"Use 'String#startsWith' method instead.\",\n      preferEndsWith: \"Use the 'String#endsWith' method instead.\"\n    },\n    schema: [],\n    fixable: 'code'\n  },\n  create(context) {\n    const globalScope = context.getScope();\n    const sourceCode = context.getSourceCode();\n    const service = (0, util_1.getParserServices)(context);\n    const typeChecker = service.program.getTypeChecker();\n    /**\n     * Check if a given node is a string.\n     * @param node The node to check.\n     */\n    function isStringType(node) {\n      const objectType = typeChecker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));\n      return (0, util_1.getTypeName)(typeChecker, objectType) === 'string';\n    }\n    /**\n     * Check if a given node is a `Literal` node that is null.\n     * @param node The node to check.\n     */\n    function isNull(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && evaluated.value == null;\n    }\n    /**\n     * Check if a given node is a `Literal` node that is a given value.\n     * @param node The node to check.\n     * @param value The expected value of the `Literal` node.\n     */\n    function isNumber(node, value) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && evaluated.value === value;\n    }\n    /**\n     * Check if a given node is a `Literal` node that is a character.\n     * @param node The node to check.\n     * @param kind The method name to get a character.\n     */\n    function isCharacter(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && typeof evaluated.value === 'string' &&\n      // checks if the string is a character long\n      evaluated.value[0] === evaluated.value;\n    }\n    /**\n     * Check if a given node is `==`, `===`, `!=`, or `!==`.\n     * @param node The node to check.\n     */\n    function isEqualityComparison(node) {\n      return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && EQ_OPERATORS.test(node.operator);\n    }\n    /**\n     * Check if two given nodes are the same meaning.\n     * @param node1 A node to compare.\n     * @param node2 Another node to compare.\n     */\n    function isSameTokens(node1, node2) {\n      const tokens1 = sourceCode.getTokens(node1);\n      const tokens2 = sourceCode.getTokens(node2);\n      if (tokens1.length !== tokens2.length) {\n        return false;\n      }\n      for (let i = 0; i < tokens1.length; ++i) {\n        const token1 = tokens1[i];\n        const token2 = tokens2[i];\n        if (token1.type !== token2.type || token1.value !== token2.value) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Check if a given node is the expression of the length of a string.\n     *\n     * - If `length` property access of `expectedObjectNode`, it's `true`.\n     *   E.g., `foo` → `foo.length` / `\"foo\"` → `\"foo\".length`\n     * - If `expectedObjectNode` is a string literal, `node` can be a number.\n     *   E.g., `\"foo\"` → `3`\n     *\n     * @param node The node to check.\n     * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n     */\n    function isLengthExpression(node, expectedObjectNode) {\n      if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        return (0, util_1.getPropertyName)(node, globalScope) === 'length' && isSameTokens(node.object, expectedObjectNode);\n      }\n      const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);\n      const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);\n      return evaluatedLength != null && evaluatedString != null && typeof evaluatedLength.value === 'number' && typeof evaluatedString.value === 'string' && evaluatedLength.value === evaluatedString.value.length;\n    }\n    /**\n     * Check if a given node is a negative index expression\n     *\n     * E.g. `s.slice(- <expr>)`, `s.substring(s.length - <expr>)`\n     *\n     * @param node The node to check.\n     * @param expectedIndexedNode The node which is expected as the receiver of index expression.\n     */\n    function isNegativeIndexExpression(node, expectedIndexedNode) {\n      return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '-' || node.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedIndexedNode);\n    }\n    /**\n     * Check if a given node is the expression of the last index.\n     *\n     * E.g. `foo.length - 1`\n     *\n     * @param node The node to check.\n     * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n     */\n    function isLastIndexExpression(node, expectedObjectNode) {\n      return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedObjectNode) && isNumber(node.right, 1);\n    }\n    /**\n     * Get the range of the property of a given `MemberExpression` node.\n     *\n     * - `obj[foo]` → the range of `[foo]`\n     * - `obf.foo` → the range of `.foo`\n     * - `(obj).foo` → the range of `.foo`\n     *\n     * @param node The member expression node to get.\n     */\n    function getPropertyRange(node) {\n      const dotOrOpenBracket = sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken);\n      return [dotOrOpenBracket.range[0], node.range[1]];\n    }\n    /**\n     * Parse a given `RegExp` pattern to that string if it's a static string.\n     * @param pattern The RegExp pattern text to parse.\n     * @param uFlag The Unicode flag of the RegExp.\n     */\n    function parseRegExpText(pattern, uFlag) {\n      // Parse it.\n      const ast = regexpp.parsePattern(pattern, undefined, undefined, uFlag);\n      if (ast.alternatives.length !== 1) {\n        return null;\n      }\n      // Drop `^`/`$` assertion.\n      const chars = ast.alternatives[0].elements;\n      const first = chars[0];\n      if (first.type === 'Assertion' && first.kind === 'start') {\n        chars.shift();\n      } else {\n        chars.pop();\n      }\n      // Check if it can determine a unique string.\n      if (!chars.every(c => c.type === 'Character')) {\n        return null;\n      }\n      // To string.\n      return String.fromCodePoint(...chars.map(c => c.value));\n    }\n    /**\n     * Parse a given node if it's a `RegExp` instance.\n     * @param node The node to parse.\n     */\n    function parseRegExp(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n        return null;\n      }\n      const {\n        source,\n        flags\n      } = evaluated.value;\n      const isStartsWith = source.startsWith('^');\n      const isEndsWith = source.endsWith('$');\n      if (isStartsWith === isEndsWith || flags.includes('i') || flags.includes('m')) {\n        return null;\n      }\n      const text = parseRegExpText(source, flags.includes('u'));\n      if (text == null) {\n        return null;\n      }\n      return {\n        isEndsWith,\n        isStartsWith,\n        text\n      };\n    }\n    function getLeftNode(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        return getLeftNode(node.expression);\n      }\n      let leftNode;\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        leftNode = node.callee;\n      } else {\n        leftNode = node;\n      }\n      if (leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n        throw new Error(`Expected a MemberExpression, got ${leftNode.type}`);\n      }\n      return leftNode;\n    }\n    /**\n     * Fix code with using the right operand as the search string.\n     * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`\n     * @param fixer The rule fixer.\n     * @param node The node which was reported.\n     * @param kind The kind of the report.\n     * @param isNegative The flag to fix to negative condition.\n     */\n    function* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {\n      // left is CallExpression or MemberExpression.\n      const leftNode = getLeftNode(node.left);\n      const propertyRange = getPropertyRange(leftNode);\n      if (isNegative) {\n        yield fixer.insertTextBefore(node, '!');\n      }\n      yield fixer.replaceTextRange([propertyRange[0], node.right.range[0]], `${isOptional ? '?.' : '.'}${kind}sWith(`);\n      yield fixer.replaceTextRange([node.right.range[1], node.range[1]], ')');\n    }\n    /**\n     * Fix code with using the first argument as the search string.\n     * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`\n     * @param fixer The rule fixer.\n     * @param node The node which was reported.\n     * @param kind The kind of the report.\n     * @param negative The flag to fix to negative condition.\n     */\n    function* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {\n      if (negative) {\n        yield fixer.insertTextBefore(node, '!');\n      }\n      yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? '?.' : '.'}${kind}sWith`);\n      yield fixer.removeRange([callNode.range[1], node.range[1]]);\n    }\n    function getParent(node) {\n      var _a;\n      return (0, util_1.nullThrows)(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? node.parent.parent : node.parent, util_1.NullThrowsReasons.MissingParent);\n    }\n    return {\n      // foo[0] === \"a\"\n      // foo.charAt(0) === \"a\"\n      // foo[foo.length - 1] === \"a\"\n      // foo.charAt(foo.length - 1) === \"a\"\n      [['BinaryExpression > MemberExpression.left[computed=true]', 'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"charAt\"][computed=false]', 'BinaryExpression > ChainExpression.left > MemberExpression[computed=true]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"charAt\"][computed=false]'].join(', ')](node) {\n        let parentNode = getParent(node);\n        let indexNode = null;\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === utils_1.AST_NODE_TYPES.CallExpression) {\n          if (parentNode.arguments.length === 1) {\n            indexNode = parentNode.arguments[0];\n          }\n          parentNode = getParent(parentNode);\n        } else {\n          indexNode = node.property;\n        }\n        if (indexNode == null || !isEqualityComparison(parentNode) || !isStringType(node.object)) {\n          return;\n        }\n        const isEndsWith = isLastIndexExpression(indexNode, node.object);\n        const isStartsWith = !isEndsWith && isNumber(indexNode, 0);\n        if (!isStartsWith && !isEndsWith) {\n          return;\n        }\n        const eqNode = parentNode;\n        context.report({\n          node: parentNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n          fix(fixer) {\n            // Don't fix if it can change the behavior.\n            if (!isCharacter(eqNode.right)) {\n              return null;\n            }\n            return fixWithRightOperand(fixer, eqNode, isStartsWith ? 'start' : 'end', eqNode.operator.startsWith('!'), node.optional);\n          }\n        });\n      },\n      // foo.indexOf('bar') === 0\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"indexOf\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"indexOf\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n        if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || !isNumber(parentNode.right, 0) || !isStringType(node.object)) {\n          return;\n        }\n        context.report({\n          node: parentNode,\n          messageId: 'preferStartsWith',\n          fix(fixer) {\n            return fixWithArgument(fixer, parentNode, callNode, node, 'start', parentNode.operator.startsWith('!'), node.optional);\n          }\n        });\n      },\n      // foo.lastIndexOf('bar') === foo.length - 3\n      // foo.lastIndexOf(bar) === foo.length - bar.length\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n        if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression || parentNode.right.operator !== '-' || !isLengthExpression(parentNode.right.left, node.object) || !isLengthExpression(parentNode.right.right, callNode.arguments[0]) || !isStringType(node.object)) {\n          return;\n        }\n        context.report({\n          node: parentNode,\n          messageId: 'preferEndsWith',\n          fix(fixer) {\n            return fixWithArgument(fixer, parentNode, callNode, node, 'end', parentNode.operator.startsWith('!'), node.optional);\n          }\n        });\n      },\n      // foo.match(/^bar/) === null\n      // foo.match(/bar$/) === null\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"match\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"match\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n        if (!isEqualityComparison(parentNode) || !isNull(parentNode.right) || !isStringType(node.object)) {\n          return;\n        }\n        const parsed = callNode.arguments.length === 1 ? parseRegExp(callNode.arguments[0]) : null;\n        if (parsed == null) {\n          return;\n        }\n        const {\n          isStartsWith,\n          text\n        } = parsed;\n        context.report({\n          node: callNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n          *fix(fixer) {\n            if (!parentNode.operator.startsWith('!')) {\n              yield fixer.insertTextBefore(parentNode, '!');\n            }\n            yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? '?.' : '.'}${isStartsWith ? 'start' : 'end'}sWith`);\n            yield fixer.replaceText(callNode.arguments[0], JSON.stringify(text));\n            yield fixer.removeRange([callNode.range[1], parentNode.range[1]]);\n          }\n        });\n      },\n      // foo.slice(0, 3) === 'bar'\n      // foo.slice(-3) === 'bar'\n      // foo.slice(-3, foo.length) === 'bar'\n      // foo.substring(0, 3) === 'bar'\n      // foo.substring(foo.length - 3) === 'bar'\n      // foo.substring(foo.length - 3, foo.length) === 'bar'\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"slice\"][computed=false]', 'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"substring\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"slice\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"substring\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n        if (!isEqualityComparison(parentNode) || !isStringType(node.object)) {\n          return;\n        }\n        const isEndsWith = (callNode.arguments.length === 1 || callNode.arguments.length === 2 && isLengthExpression(callNode.arguments[1], node.object)) && isNegativeIndexExpression(callNode.arguments[0], node.object);\n        const isStartsWith = !isEndsWith && callNode.arguments.length === 2 && isNumber(callNode.arguments[0], 0) && !isNegativeIndexExpression(callNode.arguments[1], node.object);\n        if (!isStartsWith && !isEndsWith) {\n          return;\n        }\n        const eqNode = parentNode;\n        const negativeIndexSupported = node.property.name === 'slice';\n        context.report({\n          node: parentNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n          fix(fixer) {\n            // Don't fix if it can change the behavior.\n            if (eqNode.operator.length === 2 && (eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal || typeof eqNode.right.value !== 'string')) {\n              return null;\n            }\n            // code being checked is likely mistake:\n            // unequal length of strings being checked for equality\n            // or reliant on behavior of substring (negative indices interpreted as 0)\n            if (isStartsWith) {\n              if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {\n                return null;\n              }\n            } else {\n              const posNode = callNode.arguments[0];\n              const posNodeIsAbsolutelyValid = posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression && posNode.operator === '-' && isLengthExpression(posNode.left, node.object) && isLengthExpression(posNode.right, eqNode.right) || negativeIndexSupported && posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression && posNode.operator === '-' && isLengthExpression(posNode.argument, eqNode.right);\n              if (!posNodeIsAbsolutelyValid) {\n                return null;\n              }\n            }\n            return fixWithRightOperand(fixer, parentNode, isStartsWith ? 'start' : 'end', parentNode.operator.startsWith('!'), node.optional);\n          }\n        });\n      },\n      // /^bar/.test(foo)\n      // /bar$/.test(foo)\n      'CallExpression > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n        const callNode = getParent(node);\n        const parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;\n        if (parsed == null) {\n          return;\n        }\n        const {\n          isStartsWith,\n          text\n        } = parsed;\n        const messageId = isStartsWith ? 'preferStartsWith' : 'preferEndsWith';\n        const methodName = isStartsWith ? 'startsWith' : 'endsWith';\n        context.report({\n          node: callNode,\n          messageId,\n          *fix(fixer) {\n            const argNode = callNode.arguments[0];\n            const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal && argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== utils_1.AST_NODE_TYPES.Identifier && argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n            yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n            if (needsParen) {\n              yield fixer.insertTextBefore(argNode, '(');\n              yield fixer.insertTextAfter(argNode, ')');\n            }\n            yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}${methodName}(${JSON.stringify(text)}`);\n          }\n        });\n      }\n    };\n  }\n});","map":{"version":3,"names":["regexpp_1","require","utils_1","util_1","EQ_OPERATORS","regexpp","RegExpParser","exports","default","createRule","name","defaultOptions","meta","type","docs","description","recommended","requiresTypeChecking","messages","preferStartsWith","preferEndsWith","schema","fixable","create","context","globalScope","getScope","sourceCode","getSourceCode","service","getParserServices","typeChecker","program","getTypeChecker","isStringType","node","objectType","getTypeAtLocation","esTreeNodeToTSNodeMap","get","getTypeName","isNull","evaluated","getStaticValue","value","isNumber","isCharacter","isEqualityComparison","AST_NODE_TYPES","BinaryExpression","test","operator","isSameTokens","node1","node2","tokens1","getTokens","tokens2","length","i","token1","token2","isLengthExpression","expectedObjectNode","MemberExpression","getPropertyName","object","evaluatedLength","evaluatedString","isNegativeIndexExpression","expectedIndexedNode","UnaryExpression","left","isLastIndexExpression","right","getPropertyRange","dotOrOpenBracket","getTokenAfter","isNotClosingParenToken","range","parseRegExpText","pattern","uFlag","ast","parsePattern","undefined","alternatives","chars","elements","first","kind","shift","pop","every","c","String","fromCodePoint","map","parseRegExp","RegExp","source","flags","isStartsWith","startsWith","isEndsWith","endsWith","includes","text","getLeftNode","ChainExpression","expression","leftNode","CallExpression","callee","Error","fixWithRightOperand","fixer","isNegative","isOptional","propertyRange","insertTextBefore","replaceTextRange","fixWithArgument","callNode","calleeNode","negative","removeRange","getParent","nullThrows","_a","parent","NullThrowsReasons","MissingParent","join","parentNode","indexNode","arguments","property","eqNode","report","messageId","fix","optional","parsed","replaceText","JSON","stringify","negativeIndexSupported","Literal","posNode","posNodeIsAbsolutelyValid","argument","CallExpression > MemberExpression.callee[property.name=\"test\"][computed=false]","methodName","argNode","needsParen","TemplateLiteral","Identifier","insertTextAfter"],"sources":["../../src/rules/prefer-string-starts-ends-with.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}