{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\nconst EventEmitter = require('events').EventEmitter;\nconst events = require('./events');\nconst promise = require('./promise');\nconst invalidTypes = {\n  undefined: true,\n  // eslint-disable-line no-undefined\n  function: true,\n  symbol: true\n};\nmodule.exports = eventify;\n\n/**\n * Public function `eventify`.\n *\n * Returns an event emitter and asynchronously traverses a data structure\n * (depth-first), emitting events as it encounters items. Sanely handles\n * promises, buffers, maps and other iterables. The event emitter is\n * decorated with a `pause` method that can be called to pause processing.\n *\n * @param data:       The data structure to traverse.\n *\n * @option promises:  'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:   'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:      'object' or 'ignore', default is 'object'.\n *\n * @option iterables:  'array' or 'ignore', default is 'array'.\n *\n * @option circular:   'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:  The number of data items to process per timeslice,\n *                     default is 16384.\n *\n * @option Promise:      The promise constructor to use, defaults to bluebird.\n **/\nfunction eventify(data, options = {}) {\n  const coercions = {};\n  const emitter = new EventEmitter();\n  const Promise = promise(options);\n  const references = new Map();\n  let count = 0;\n  let disableCoercions = false;\n  let ignoreCircularReferences;\n  let ignoreItems;\n  let pause;\n  let yieldRate;\n  emitter.pause = () => {\n    let resolve;\n    pause = new Promise(res => resolve = res);\n    return () => {\n      pause = null;\n      count = 0;\n      resolve();\n    };\n  };\n  parseOptions();\n  setImmediate(begin);\n  return emitter;\n  function parseOptions() {\n    parseCoercionOption('promises');\n    parseCoercionOption('buffers');\n    parseCoercionOption('maps');\n    parseCoercionOption('iterables');\n    if (Object.keys(coercions).length === 0) {\n      disableCoercions = true;\n    }\n    if (options.circular === 'ignore') {\n      ignoreCircularReferences = true;\n    }\n    check.assert.maybe.positive(options.yieldRate);\n    yieldRate = options.yieldRate || 16384;\n  }\n  function parseCoercionOption(key) {\n    if (options[key] !== 'ignore') {\n      coercions[key] = true;\n    }\n  }\n  function begin() {\n    return proceed(data).catch(error => emit(events.error, error)).then(() => emit(events.end));\n  }\n  function proceed(datum) {\n    if (++count % yieldRate !== 0) {\n      return coerce(datum).then(after);\n    }\n    return new Promise((resolve, reject) => {\n      setImmediate(() => {\n        coerce(datum).then(after).then(resolve).catch(reject);\n      });\n    });\n    function after(coerced) {\n      if (isInvalid(coerced)) {\n        return;\n      }\n      if (coerced === false || coerced === true || coerced === null) {\n        return literal(coerced);\n      }\n      if (Array.isArray(coerced)) {\n        return array(coerced);\n      }\n      const type = typeof coerced;\n      switch (type) {\n        case 'number':\n          return value(coerced, type);\n        case 'string':\n          return value(escapeString(coerced), type);\n        default:\n          return object(coerced);\n      }\n    }\n  }\n  function coerce(datum) {\n    if (disableCoercions || check.primitive(datum)) {\n      return Promise.resolve(datum);\n    }\n    if (check.thenable(datum)) {\n      return coerceThing(datum, 'promises', coercePromise).then(coerce);\n    }\n    if (check.instanceStrict(datum, Buffer)) {\n      return coerceThing(datum, 'buffers', coerceBuffer);\n    }\n    if (check.instanceStrict(datum, Map)) {\n      return coerceThing(datum, 'maps', coerceMap);\n    }\n    if (check.iterable(datum) && check.not.string(datum) && check.not.array(datum)) {\n      return coerceThing(datum, 'iterables', coerceIterable);\n    }\n    if (check.function(datum.toJSON)) {\n      return Promise.resolve(datum.toJSON());\n    }\n    return Promise.resolve(datum);\n  }\n  function coerceThing(datum, thing, fn) {\n    if (coercions[thing]) {\n      return fn(datum);\n    }\n    return Promise.resolve();\n  }\n  function coercePromise(p) {\n    return p;\n  }\n  function coerceBuffer(buffer) {\n    return Promise.resolve(buffer.toString());\n  }\n  function coerceMap(map) {\n    const result = {};\n    return coerceCollection(map, result, (item, key) => {\n      result[key] = item;\n    });\n  }\n  function coerceCollection(coll, target, push) {\n    coll.forEach(push);\n    return Promise.resolve(target);\n  }\n  function coerceIterable(iterable) {\n    const result = [];\n    return coerceCollection(iterable, result, item => {\n      result.push(item);\n    });\n  }\n  function isInvalid(datum) {\n    const type = typeof datum;\n    return !!invalidTypes[type] || type === 'number' && !isValidNumber(datum);\n  }\n  function isValidNumber(datum) {\n    return datum > Number.NEGATIVE_INFINITY && datum < Number.POSITIVE_INFINITY;\n  }\n  function literal(datum) {\n    return value(datum, 'literal');\n  }\n  function value(datum, type) {\n    return emit(events[type], datum);\n  }\n  function emit(event, eventData) {\n    return (pause || Promise.resolve()).then(() => emitter.emit(event, eventData)).catch(err => {\n      try {\n        emitter.emit(events.error, err);\n      } catch (_) {\n        // When calling user code, anything is possible\n      }\n    });\n  }\n  function array(datum) {\n    // For an array, collection:object and collection:array are the same.\n    return collection(datum, datum, 'array', item => {\n      if (isInvalid(item)) {\n        return proceed(null);\n      }\n      return proceed(item);\n    });\n  }\n  function collection(obj, arr, type, action) {\n    let ignoreThisItem;\n    return Promise.resolve().then(() => {\n      if (references.has(obj)) {\n        ignoreThisItem = ignoreItems = true;\n        if (!ignoreCircularReferences) {\n          return emit(events.dataError, new Error('Circular reference.'));\n        }\n      } else {\n        references.set(obj, true);\n      }\n    }).then(() => emit(events[type])).then(() => item(0));\n    function item(index) {\n      if (index >= arr.length) {\n        if (ignoreThisItem) {\n          ignoreItems = false;\n        }\n        if (ignoreItems) {\n          return Promise.resolve();\n        }\n        return emit(events.endPrefix + events[type]).then(() => references.delete(obj));\n      }\n      if (ignoreItems) {\n        return item(index + 1);\n      }\n      return action(arr[index]).then(() => item(index + 1));\n    }\n  }\n  function object(datum) {\n    // For an object, collection:object and collection:array are different.\n    return collection(datum, Object.keys(datum), 'object', key => {\n      const item = datum[key];\n      if (isInvalid(item)) {\n        return Promise.resolve();\n      }\n      return emit(events.property, escapeString(key)).then(() => proceed(item));\n    });\n  }\n  function escapeString(string) {\n    string = JSON.stringify(string);\n    return string.substring(1, string.length - 1);\n  }\n}","map":{"version":3,"names":["check","require","EventEmitter","events","promise","invalidTypes","undefined","function","symbol","module","exports","eventify","data","options","coercions","emitter","Promise","references","Map","count","disableCoercions","ignoreCircularReferences","ignoreItems","pause","yieldRate","resolve","res","parseOptions","setImmediate","begin","parseCoercionOption","Object","keys","length","circular","assert","maybe","positive","key","proceed","catch","error","emit","then","end","datum","coerce","after","reject","coerced","isInvalid","literal","Array","isArray","array","type","value","escapeString","object","primitive","thenable","coerceThing","coercePromise","instanceStrict","Buffer","coerceBuffer","coerceMap","iterable","not","string","coerceIterable","toJSON","thing","fn","p","buffer","toString","map","result","coerceCollection","item","coll","target","push","forEach","isValidNumber","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","event","eventData","err","_","collection","obj","arr","action","ignoreThisItem","has","dataError","Error","set","index","endPrefix","delete","property","JSON","stringify","substring"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/src/eventify.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst EventEmitter = require('events').EventEmitter\nconst events = require('./events')\nconst promise = require('./promise')\n\nconst invalidTypes = {\n  undefined: true, // eslint-disable-line no-undefined\n  function: true,\n  symbol: true\n}\n\nmodule.exports = eventify\n\n/**\n * Public function `eventify`.\n *\n * Returns an event emitter and asynchronously traverses a data structure\n * (depth-first), emitting events as it encounters items. Sanely handles\n * promises, buffers, maps and other iterables. The event emitter is\n * decorated with a `pause` method that can be called to pause processing.\n *\n * @param data:       The data structure to traverse.\n *\n * @option promises:  'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:   'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:      'object' or 'ignore', default is 'object'.\n *\n * @option iterables:  'array' or 'ignore', default is 'array'.\n *\n * @option circular:   'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:  The number of data items to process per timeslice,\n *                     default is 16384.\n *\n * @option Promise:      The promise constructor to use, defaults to bluebird.\n **/\nfunction eventify (data, options = {}) {\n  const coercions = {}\n  const emitter = new EventEmitter()\n  const Promise = promise(options)\n  const references = new Map()\n\n  let count = 0\n  let disableCoercions = false\n  let ignoreCircularReferences\n  let ignoreItems\n  let pause\n  let yieldRate\n\n  emitter.pause = () => {\n    let resolve\n    pause = new Promise(res => resolve = res)\n    return () => {\n      pause = null\n      count = 0\n      resolve()\n    }\n  }\n  parseOptions()\n  setImmediate(begin)\n\n  return emitter\n\n  function parseOptions () {\n    parseCoercionOption('promises')\n    parseCoercionOption('buffers')\n    parseCoercionOption('maps')\n    parseCoercionOption('iterables')\n\n    if (Object.keys(coercions).length === 0) {\n      disableCoercions = true\n    }\n\n    if (options.circular === 'ignore') {\n      ignoreCircularReferences = true\n    }\n\n    check.assert.maybe.positive(options.yieldRate)\n    yieldRate = options.yieldRate || 16384\n  }\n\n  function parseCoercionOption (key) {\n    if (options[key] !== 'ignore') {\n      coercions[key] = true\n    }\n  }\n\n  function begin () {\n    return proceed(data)\n      .catch(error => emit(events.error, error))\n      .then(() => emit(events.end))\n  }\n\n  function proceed (datum) {\n    if (++count % yieldRate !== 0) {\n      return coerce(datum).then(after)\n    }\n\n    return new Promise((resolve, reject) => {\n      setImmediate(() => {\n        coerce(datum)\n          .then(after)\n          .then(resolve)\n          .catch(reject)\n      })\n    })\n\n    function after (coerced) {\n      if (isInvalid(coerced)) {\n        return\n      }\n\n      if (coerced === false || coerced === true || coerced === null) {\n        return literal(coerced)\n      }\n\n      if (Array.isArray(coerced)) {\n        return array(coerced)\n      }\n\n      const type = typeof coerced\n\n      switch (type) {\n        case 'number':\n          return value(coerced, type)\n        case 'string':\n          return value(escapeString(coerced), type)\n        default:\n          return object(coerced)\n      }\n    }\n  }\n\n  function coerce (datum) {\n    if (disableCoercions || check.primitive(datum)) {\n      return Promise.resolve(datum)\n    }\n\n    if (check.thenable(datum)) {\n      return coerceThing(datum, 'promises', coercePromise).then(coerce)\n    }\n\n    if (check.instanceStrict(datum, Buffer)) {\n      return coerceThing(datum, 'buffers', coerceBuffer)\n    }\n\n    if (check.instanceStrict(datum, Map)) {\n      return coerceThing(datum, 'maps', coerceMap)\n    }\n\n    if (\n      check.iterable(datum) &&\n      check.not.string(datum) &&\n      check.not.array(datum)\n    ) {\n      return coerceThing(datum, 'iterables', coerceIterable)\n    }\n\n    if (check.function(datum.toJSON)) {\n      return Promise.resolve(datum.toJSON())\n    }\n\n    return Promise.resolve(datum)\n  }\n\n  function coerceThing (datum, thing, fn) {\n    if (coercions[thing]) {\n      return fn(datum)\n    }\n\n    return Promise.resolve()\n  }\n\n  function coercePromise (p) {\n    return p\n  }\n\n  function coerceBuffer (buffer) {\n    return Promise.resolve(buffer.toString())\n  }\n\n  function coerceMap (map) {\n    const result = {}\n\n    return coerceCollection(map, result, (item, key) => {\n      result[key] = item\n    })\n  }\n\n  function coerceCollection (coll, target, push) {\n    coll.forEach(push)\n\n    return Promise.resolve(target)\n  }\n\n  function coerceIterable (iterable) {\n    const result = []\n\n    return coerceCollection(iterable, result, item => {\n      result.push(item)\n    })\n  }\n\n  function isInvalid (datum) {\n    const type = typeof datum\n    return !! invalidTypes[type] || (\n      type === 'number' && ! isValidNumber(datum)\n    )\n  }\n\n  function isValidNumber (datum) {\n    return datum > Number.NEGATIVE_INFINITY && datum < Number.POSITIVE_INFINITY\n  }\n\n  function literal (datum) {\n    return value(datum, 'literal')\n  }\n\n  function value (datum, type) {\n    return emit(events[type], datum)\n  }\n\n  function emit (event, eventData) {\n    return (pause || Promise.resolve())\n      .then(() => emitter.emit(event, eventData))\n      .catch(err => {\n        try {\n          emitter.emit(events.error, err)\n        } catch (_) {\n          // When calling user code, anything is possible\n        }\n      })\n  }\n\n  function array (datum) {\n    // For an array, collection:object and collection:array are the same.\n    return collection(datum, datum, 'array', item => {\n      if (isInvalid(item)) {\n        return proceed(null)\n      }\n\n      return proceed(item)\n    })\n  }\n\n  function collection (obj, arr, type, action) {\n    let ignoreThisItem\n\n    return Promise.resolve()\n      .then(() => {\n        if (references.has(obj)) {\n          ignoreThisItem = ignoreItems = true\n\n          if (! ignoreCircularReferences) {\n            return emit(events.dataError, new Error('Circular reference.'))\n          }\n        } else {\n          references.set(obj, true)\n        }\n      })\n      .then(() => emit(events[type]))\n      .then(() => item(0))\n\n    function item (index) {\n      if (index >= arr.length) {\n        if (ignoreThisItem) {\n          ignoreItems = false\n        }\n\n        if (ignoreItems) {\n          return Promise.resolve()\n        }\n\n        return emit(events.endPrefix + events[type])\n          .then(() => references.delete(obj))\n      }\n\n      if (ignoreItems) {\n        return item(index + 1)\n      }\n\n      return action(arr[index])\n        .then(() => item(index + 1))\n    }\n  }\n\n  function object (datum) {\n    // For an object, collection:object and collection:array are different.\n    return collection(datum, Object.keys(datum), 'object', key => {\n      const item = datum[key]\n\n      if (isInvalid(item)) {\n        return Promise.resolve()\n      }\n\n      return emit(events.property, escapeString(key))\n        .then(() => proceed(item))\n    })\n  }\n\n  function escapeString (string) {\n    string = JSON.stringify(string)\n    return string.substring(1, string.length - 1)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}