{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'prefer-nullish-coalescing',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using the nullish coalescing operator instead of logical chaining',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    messages: {\n      preferNullishOverOr: 'Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.',\n      preferNullishOverTernary: 'Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.',\n      suggestNullish: 'Fix to nullish coalescing operator (`??`).',\n      noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n          type: 'boolean'\n        },\n        ignoreConditionalTests: {\n          type: 'boolean'\n        },\n        ignoreMixedLogicalExpressions: {\n          type: 'boolean'\n        },\n        ignorePrimitives: {\n          type: 'object',\n          properties: {\n            bigint: {\n              type: 'boolean'\n            },\n            boolean: {\n              type: 'boolean'\n            },\n            number: {\n              type: 'boolean'\n            },\n            string: {\n              type: 'boolean'\n            }\n          }\n        },\n        ignoreTernaryTests: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,\n    ignoreConditionalTests: true,\n    ignoreTernaryTests: true,\n    ignoreMixedLogicalExpressions: true,\n    ignorePrimitives: {\n      bigint: false,\n      boolean: false,\n      number: false,\n      string: false\n    }\n  }],\n  create(context, [{\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing,\n    ignoreConditionalTests,\n    ignoreMixedLogicalExpressions,\n    ignorePrimitives,\n    ignoreTernaryTests\n  }]) {\n    const parserServices = util.getParserServices(context);\n    const compilerOptions = parserServices.program.getCompilerOptions();\n    const sourceCode = context.getSourceCode();\n    const checker = parserServices.program.getTypeChecker();\n    const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');\n    if (!isStrictNullChecks && allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n      context.report({\n        loc: {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        },\n        messageId: 'noStrictNullCheck'\n      });\n    }\n    return {\n      ConditionalExpression(node) {\n        if (ignoreTernaryTests) {\n          return;\n        }\n        let operator;\n        let nodesInsideTestExpression = [];\n        if (node.test.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n          nodesInsideTestExpression = [node.test.left, node.test.right];\n          if (node.test.operator === '==' || node.test.operator === '!=' || node.test.operator === '===' || node.test.operator === '!==') {\n            operator = node.test.operator;\n          }\n        } else if (node.test.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.test.left.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.test.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n          nodesInsideTestExpression = [node.test.left.left, node.test.left.right, node.test.right.left, node.test.right.right];\n          if (node.test.operator === '||') {\n            if (node.test.left.operator === '===' && node.test.right.operator === '===') {\n              operator = '===';\n            } else if ((node.test.left.operator === '===' || node.test.right.operator === '===') && (node.test.left.operator === '==' || node.test.right.operator === '==') || node.test.left.operator === '==' && node.test.right.operator === '==') {\n              operator = '==';\n            }\n          } else if (node.test.operator === '&&') {\n            if (node.test.left.operator === '!==' && node.test.right.operator === '!==') {\n              operator = '!==';\n            } else if ((node.test.left.operator === '!==' || node.test.right.operator === '!==') && (node.test.left.operator === '!=' || node.test.right.operator === '!=') || node.test.left.operator === '!=' && node.test.right.operator === '!=') {\n              operator = '!=';\n            }\n          }\n        }\n        if (!operator) {\n          return;\n        }\n        let identifier;\n        let hasUndefinedCheck = false;\n        let hasNullCheck = false;\n        // we check that the test only contains null, undefined and the identifier\n        for (const testNode of nodesInsideTestExpression) {\n          if (util.isNullLiteral(testNode)) {\n            hasNullCheck = true;\n          } else if (util.isUndefinedIdentifier(testNode)) {\n            hasUndefinedCheck = true;\n          } else if ((operator === '!==' || operator === '!=') && util.isNodeEqual(testNode, node.consequent)) {\n            identifier = testNode;\n          } else if ((operator === '===' || operator === '==') && util.isNodeEqual(testNode, node.alternate)) {\n            identifier = testNode;\n          } else {\n            return;\n          }\n        }\n        if (!identifier) {\n          return;\n        }\n        const isFixable = (() => {\n          // it is fixable if we check for both null and undefined, or not if neither\n          if (hasUndefinedCheck === hasNullCheck) {\n            return hasUndefinedCheck;\n          }\n          // it is fixable if we loosely check for either null or undefined\n          if (operator === '==' || operator === '!=') {\n            return true;\n          }\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(identifier);\n          const type = checker.getTypeAtLocation(tsNode);\n          const flags = util.getTypeFlags(type);\n          if (flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n            return false;\n          }\n          const hasNullType = (flags & ts.TypeFlags.Null) !== 0;\n          // it is fixable if we check for undefined and the type is not nullable\n          if (hasUndefinedCheck && !hasNullType) {\n            return true;\n          }\n          const hasUndefinedType = (flags & ts.TypeFlags.Undefined) !== 0;\n          // it is fixable if we check for null and the type can't be undefined\n          return hasNullCheck && !hasUndefinedType;\n        })();\n        if (isFixable) {\n          context.report({\n            node,\n            messageId: 'preferNullishOverTernary',\n            suggest: [{\n              messageId: 'suggestNullish',\n              fix(fixer) {\n                const [left, right] = operator === '===' || operator === '==' ? [node.alternate, node.consequent] : [node.consequent, node.alternate];\n                return fixer.replaceText(node, `${sourceCode.text.slice(left.range[0], left.range[1])} ?? ${sourceCode.text.slice(right.range[0], right.range[1])}`);\n              }\n            }]\n          });\n        }\n      },\n      'LogicalExpression[operator = \"||\"]'(node) {\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = checker.getTypeAtLocation(tsNode.left);\n        const isNullish = util.isNullableType(type, {\n          allowUndefined: true\n        });\n        if (!isNullish) {\n          return;\n        }\n        if (ignoreConditionalTests === true && isConditionalTest(node)) {\n          return;\n        }\n        const isMixedLogical = isMixedLogicalExpression(node);\n        if (ignoreMixedLogicalExpressions === true && isMixedLogical) {\n          return;\n        }\n        const ignorableFlags = [ignorePrimitives.bigint && ts.TypeFlags.BigInt, ignorePrimitives.boolean && ts.TypeFlags.BooleanLiteral, ignorePrimitives.number && ts.TypeFlags.Number, ignorePrimitives.string && ts.TypeFlags.String].filter(flag => flag !== undefined).reduce((previous, flag) => previous | flag, 0);\n        if (type.types.some(t => tsutils.isTypeFlagSet(t, ignorableFlags))) {\n          return;\n        }\n        const barBarOperator = util.nullThrows(sourceCode.getTokenAfter(node.left, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === node.operator), util.NullThrowsReasons.MissingToken('operator', node.type));\n        function* fix(fixer) {\n          if (node.parent && util.isLogicalOrOperator(node.parent)) {\n            // '&&' and '??' operations cannot be mixed without parentheses (e.g. a && b ?? c)\n            if (node.left.type === utils_1.AST_NODE_TYPES.LogicalExpression && !util.isLogicalOrOperator(node.left.left)) {\n              yield fixer.insertTextBefore(node.left.right, '(');\n            } else {\n              yield fixer.insertTextBefore(node.left, '(');\n            }\n            yield fixer.insertTextAfter(node.right, ')');\n          }\n          yield fixer.replaceText(barBarOperator, '??');\n        }\n        context.report({\n          node: barBarOperator,\n          messageId: 'preferNullishOverOr',\n          suggest: [{\n            messageId: 'suggestNullish',\n            fix\n          }]\n        });\n      }\n    };\n  }\n});\nfunction isConditionalTest(node) {\n  const parents = new Set([node]);\n  let current = node.parent;\n  while (current) {\n    parents.add(current);\n    if ((current.type === utils_1.AST_NODE_TYPES.ConditionalExpression || current.type === utils_1.AST_NODE_TYPES.DoWhileStatement || current.type === utils_1.AST_NODE_TYPES.IfStatement || current.type === utils_1.AST_NODE_TYPES.ForStatement || current.type === utils_1.AST_NODE_TYPES.WhileStatement) && parents.has(current.test)) {\n      return true;\n    }\n    if ([utils_1.AST_NODE_TYPES.ArrowFunctionExpression, utils_1.AST_NODE_TYPES.FunctionExpression].includes(current.type)) {\n      /**\n       * This is a weird situation like:\n       * `if (() => a || b) {}`\n       * `if (function () { return a || b }) {}`\n       */\n      return false;\n    }\n    current = current.parent;\n  }\n  return false;\n}\nfunction isMixedLogicalExpression(node) {\n  const seen = new Set();\n  const queue = [node.parent, node.left, node.right];\n  for (const current of queue) {\n    if (seen.has(current)) {\n      continue;\n    }\n    seen.add(current);\n    if (current && current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n      if (current.operator === '&&') {\n        return true;\n      } else if (current.operator === '||') {\n        // check the pieces of the node to catch cases like `a || b || c && d`\n        queue.push(current.parent, current.left, current.right);\n      }\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","hasSuggestions","messages","preferNullishOverOr","preferNullishOverTernary","suggestNullish","noStrictNullCheck","schema","properties","allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing","ignoreConditionalTests","ignoreMixedLogicalExpressions","ignorePrimitives","bigint","boolean","number","string","ignoreTernaryTests","additionalProperties","defaultOptions","create","context","parserServices","getParserServices","compilerOptions","program","getCompilerOptions","sourceCode","getSourceCode","checker","getTypeChecker","isStrictNullChecks","isStrictCompilerOptionEnabled","report","loc","start","line","column","end","messageId","ConditionalExpression","node","operator","nodesInsideTestExpression","test","AST_NODE_TYPES","BinaryExpression","left","right","LogicalExpression","identifier","hasUndefinedCheck","hasNullCheck","testNode","isNullLiteral","isUndefinedIdentifier","isNodeEqual","consequent","alternate","isFixable","tsNode","esTreeNodeToTSNodeMap","get","getTypeAtLocation","flags","getTypeFlags","TypeFlags","Any","Unknown","hasNullType","Null","hasUndefinedType","Undefined","suggest","fix","fixer","replaceText","text","slice","range","LogicalExpression[operator = \"||\"]","isNullish","isNullableType","allowUndefined","isConditionalTest","isMixedLogical","isMixedLogicalExpression","ignorableFlags","BigInt","BooleanLiteral","Number","String","filter","flag","undefined","reduce","previous","types","some","t","isTypeFlagSet","barBarOperator","nullThrows","getTokenAfter","token","AST_TOKEN_TYPES","Punctuator","value","NullThrowsReasons","MissingToken","parent","isLogicalOrOperator","insertTextBefore","insertTextAfter","parents","Set","current","add","DoWhileStatement","IfStatement","ForStatement","WhileStatement","has","ArrowFunctionExpression","FunctionExpression","includes","seen","queue","push"],"sources":["../../src/rules/prefer-nullish-coalescing.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}