{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cleanupSemantic = exports.Diff = exports.DIFF_INSERT = exports.DIFF_EQUAL = exports.DIFF_DELETE = void 0;\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\n\nexports.DIFF_EQUAL = DIFF_EQUAL;\nclass Diff {\n  constructor(op, text) {\n    _defineProperty(this, 0, void 0);\n    _defineProperty(this, 1, void 0);\n    this[0] = op;\n    this[1] = text;\n  }\n}\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\n\nexports.Diff = Diff;\nvar diff_commonPrefix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\n\nvar diff_commonSuffix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\n\nvar diff_commonOverlap_ = function (text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length; // Eliminate the null case.\n\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  } // Truncate the longer string.\n\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length); // Quick check for the worst case.\n\n  if (text1 == text2) {\n    return text_length;\n  } // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupSemantic = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n  /** @type {?string} */\n\n  var lastEquality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n\n  var length_insertions1 = 0;\n  var length_deletions1 = 0; // Number of characters that changed after the equality.\n\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      } // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)); // Change second copy to insert.\n\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.\n\n        equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).\n\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  } // Normalize the diff.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs); // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nexports.cleanupSemantic = diff_cleanupSemantic;\nvar diff_cleanupSemanticLossless = function (diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    } // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n  var pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1]; // First, shift the edit as far left as possible.\n\n      var commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      } // Second, step character by character right, looking for the best fit.\n\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2); // The >= encourages trailing rather than leading whitespace on edits.\n\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n}; // Define some regex patterns for matching boundaries.\n\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupMerge = function (diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            } // Factor out any common suffixies.\n\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          } // Delete the offending records and add the merged ones.\n\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  } // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\n  var changes = false;\n  pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  } // If shifts were made, the diff needs reordering and another shift sweep.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","cleanupSemantic","Diff","DIFF_INSERT","DIFF_EQUAL","DIFF_DELETE","_defineProperty","obj","key","enumerable","configurable","writable","constructor","op","text","diff_commonPrefix","text1","text2","charAt","pointermin","pointermax","Math","min","length","pointermid","pointerstart","substring","floor","diff_commonSuffix","pointerend","diff_commonOverlap_","text1_length","text2_length","text_length","best","pattern","found","indexOf","diff_cleanupSemantic","diffs","changes","equalities","equalitiesLength","lastEquality","pointer","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","splice","diff_cleanupMerge","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","push","count_delete","count_insert","text_delete","text_insert","commonlength","pop"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/globals/node_modules/jest-diff/build/cleanupSemantic.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cleanupSemantic =\n  exports.Diff =\n  exports.DIFF_INSERT =\n  exports.DIFF_EQUAL =\n  exports.DIFF_DELETE =\n    void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\n\nexports.DIFF_EQUAL = DIFF_EQUAL;\n\nclass Diff {\n  constructor(op, text) {\n    _defineProperty(this, 0, void 0);\n\n    _defineProperty(this, 1, void 0);\n\n    this[0] = op;\n    this[1] = text;\n  }\n}\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\n\nexports.Diff = Diff;\n\nvar diff_commonPrefix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\n\nvar diff_commonSuffix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (\n    !text1 ||\n    !text2 ||\n    text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)\n  ) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\n\nvar diff_commonOverlap_ = function (text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length; // Eliminate the null case.\n\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  } // Truncate the longer string.\n\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n\n  var text_length = Math.min(text1_length, text2_length); // Quick check for the worst case.\n\n  if (text1 == text2) {\n    return text_length;\n  } // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\n  var best = 0;\n  var length = 1;\n\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n\n    if (found == -1) {\n      return best;\n    }\n\n    length += found;\n\n    if (\n      found == 0 ||\n      text1.substring(text_length - length) == text2.substring(0, length)\n    ) {\n      best = length;\n      length++;\n    }\n  }\n};\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupSemantic = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n  /** @type {?string} */\n\n  var lastEquality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n\n  var length_insertions1 = 0;\n  var length_deletions1 = 0; // Number of characters that changed after the equality.\n\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      } // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n\n      if (\n        lastEquality &&\n        lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1) &&\n        lastEquality.length <= Math.max(length_insertions2, length_deletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(\n          equalities[equalitiesLength - 1],\n          0,\n          new Diff(DIFF_DELETE, lastEquality)\n        ); // Change second copy to insert.\n\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.\n\n        equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).\n\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // Normalize the diff.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n\n  diff_cleanupSemanticLossless(diffs); // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n\n  pointer = 1;\n\n  while (pointer < diffs.length) {\n    if (\n      diffs[pointer - 1][0] == DIFF_DELETE &&\n      diffs[pointer][0] == DIFF_INSERT\n    ) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n\n      if (overlap_length1 >= overlap_length2) {\n        if (\n          overlap_length1 >= deletion.length / 2 ||\n          overlap_length1 >= insertion.length / 2\n        ) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))\n          );\n          diffs[pointer - 1][1] = deletion.substring(\n            0,\n            deletion.length - overlap_length1\n          );\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (\n          overlap_length2 >= deletion.length / 2 ||\n          overlap_length2 >= insertion.length / 2\n        ) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))\n          );\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(\n            0,\n            insertion.length - overlap_length2\n          );\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n\n      pointer++;\n    }\n\n    pointer++;\n  }\n};\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nexports.cleanupSemantic = diff_cleanupSemantic;\n\nvar diff_cleanupSemanticLossless = function (diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    } // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1]; // First, shift the edit as far left as possible.\n\n      var commonOffset = diff_commonSuffix(equality1, edit);\n\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      } // Second, step character by character right, looking for the best fit.\n\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore =\n        diff_cleanupSemanticScore_(equality1, edit) +\n        diff_cleanupSemanticScore_(edit, equality2);\n\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score =\n          diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2); // The >= encourages trailing rather than leading whitespace on edits.\n\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n\n        diffs[pointer][1] = bestEdit;\n\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n\n    pointer++;\n  }\n}; // Define some regex patterns for matching boundaries.\n\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupMerge = function (diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              if (\n                pointer - count_delete - count_insert > 0 &&\n                diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL\n              ) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                  text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(\n                  0,\n                  0,\n                  new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))\n                );\n                pointer++;\n              }\n\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            } // Factor out any common suffixies.\n\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) +\n                diffs[pointer][1];\n              text_insert = text_insert.substring(\n                0,\n                text_insert.length - commonlength\n              );\n              text_delete = text_delete.substring(\n                0,\n                text_delete.length - commonlength\n              );\n            }\n          } // Delete the offending records and add the merged ones.\n\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  } // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\n  var changes = false;\n  pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(\n          diffs[pointer][1].length - diffs[pointer - 1][1].length\n        ) == diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(\n            0,\n            diffs[pointer][1].length - diffs[pointer - 1][1].length\n          );\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // If shifts were made, the diff needs reordering and another shift sweep.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,eAAe,GACrBF,OAAO,CAACG,IAAI,GACZH,OAAO,CAACI,WAAW,GACnBJ,OAAO,CAACK,UAAU,GAClBL,OAAO,CAACM,WAAW,GACjB,KAAK,CAAC;AAEV,SAASC,eAAeA,CAACC,GAAG,EAAEC,GAAG,EAAER,KAAK,EAAE;EACxC,IAAIQ,GAAG,IAAID,GAAG,EAAE;IACdV,MAAM,CAACC,cAAc,CAACS,GAAG,EAAEC,GAAG,EAAE;MAC9BR,KAAK,EAAEA,KAAK;MACZS,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE;IACZ,CAAC,CAAC;EACJ,CAAC,MAAM;IACLJ,GAAG,CAACC,GAAG,CAAC,GAAGR,KAAK;EAClB;EACA,OAAOO,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAIF,WAAW,GAAG,CAAC,CAAC;AACpBN,OAAO,CAACM,WAAW,GAAGA,WAAW;AACjC,IAAIF,WAAW,GAAG,CAAC;AACnBJ,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC,IAAIC,UAAU,GAAG,CAAC;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAL,OAAO,CAACK,UAAU,GAAGA,UAAU;AAE/B,MAAMF,IAAI,CAAC;EACTU,WAAWA,CAACC,EAAE,EAAEC,IAAI,EAAE;IACpBR,eAAe,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;IAEhCA,eAAe,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;IAEhC,IAAI,CAAC,CAAC,CAAC,GAAGO,EAAE;IACZ,IAAI,CAAC,CAAC,CAAC,GAAGC,IAAI;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAf,OAAO,CAACG,IAAI,GAAGA,IAAI;AAEnB,IAAIa,iBAAiB,GAAG,SAAAA,CAAUC,KAAK,EAAEC,KAAK,EAAE;EAC9C;EACA,IAAI,CAACD,KAAK,IAAI,CAACC,KAAK,IAAID,KAAK,CAACE,MAAM,CAAC,CAAC,CAAC,IAAID,KAAK,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE;IAC1D,OAAO,CAAC;EACV,CAAC,CAAC;EACF;;EAEA,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACN,KAAK,CAACO,MAAM,EAAEN,KAAK,CAACM,MAAM,CAAC;EACrD,IAAIC,UAAU,GAAGJ,UAAU;EAC3B,IAAIK,YAAY,GAAG,CAAC;EAEpB,OAAON,UAAU,GAAGK,UAAU,EAAE;IAC9B,IACER,KAAK,CAACU,SAAS,CAACD,YAAY,EAAED,UAAU,CAAC,IACzCP,KAAK,CAACS,SAAS,CAACD,YAAY,EAAED,UAAU,CAAC,EACzC;MACAL,UAAU,GAAGK,UAAU;MACvBC,YAAY,GAAGN,UAAU;IAC3B,CAAC,MAAM;MACLC,UAAU,GAAGI,UAAU;IACzB;IAEAA,UAAU,GAAGH,IAAI,CAACM,KAAK,CAAC,CAACP,UAAU,GAAGD,UAAU,IAAI,CAAC,GAAGA,UAAU,CAAC;EACrE;EAEA,OAAOK,UAAU;AACnB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAII,iBAAiB,GAAG,SAAAA,CAAUZ,KAAK,EAAEC,KAAK,EAAE;EAC9C;EACA,IACE,CAACD,KAAK,IACN,CAACC,KAAK,IACND,KAAK,CAACE,MAAM,CAACF,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC,IAAIN,KAAK,CAACC,MAAM,CAACD,KAAK,CAACM,MAAM,GAAG,CAAC,CAAC,EAChE;IACA,OAAO,CAAC;EACV,CAAC,CAAC;EACF;;EAEA,IAAIJ,UAAU,GAAG,CAAC;EAClB,IAAIC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACN,KAAK,CAACO,MAAM,EAAEN,KAAK,CAACM,MAAM,CAAC;EACrD,IAAIC,UAAU,GAAGJ,UAAU;EAC3B,IAAIS,UAAU,GAAG,CAAC;EAElB,OAAOV,UAAU,GAAGK,UAAU,EAAE;IAC9B,IACER,KAAK,CAACU,SAAS,CAACV,KAAK,CAACO,MAAM,GAAGC,UAAU,EAAER,KAAK,CAACO,MAAM,GAAGM,UAAU,CAAC,IACrEZ,KAAK,CAACS,SAAS,CAACT,KAAK,CAACM,MAAM,GAAGC,UAAU,EAAEP,KAAK,CAACM,MAAM,GAAGM,UAAU,CAAC,EACrE;MACAV,UAAU,GAAGK,UAAU;MACvBK,UAAU,GAAGV,UAAU;IACzB,CAAC,MAAM;MACLC,UAAU,GAAGI,UAAU;IACzB;IAEAA,UAAU,GAAGH,IAAI,CAACM,KAAK,CAAC,CAACP,UAAU,GAAGD,UAAU,IAAI,CAAC,GAAGA,UAAU,CAAC;EACrE;EAEA,OAAOK,UAAU;AACnB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIM,mBAAmB,GAAG,SAAAA,CAAUd,KAAK,EAAEC,KAAK,EAAE;EAChD;EACA,IAAIc,YAAY,GAAGf,KAAK,CAACO,MAAM;EAC/B,IAAIS,YAAY,GAAGf,KAAK,CAACM,MAAM,CAAC,CAAC;;EAEjC,IAAIQ,YAAY,IAAI,CAAC,IAAIC,YAAY,IAAI,CAAC,EAAE;IAC1C,OAAO,CAAC;EACV,CAAC,CAAC;;EAEF,IAAID,YAAY,GAAGC,YAAY,EAAE;IAC/BhB,KAAK,GAAGA,KAAK,CAACU,SAAS,CAACK,YAAY,GAAGC,YAAY,CAAC;EACtD,CAAC,MAAM,IAAID,YAAY,GAAGC,YAAY,EAAE;IACtCf,KAAK,GAAGA,KAAK,CAACS,SAAS,CAAC,CAAC,EAAEK,YAAY,CAAC;EAC1C;EAEA,IAAIE,WAAW,GAAGZ,IAAI,CAACC,GAAG,CAACS,YAAY,EAAEC,YAAY,CAAC,CAAC,CAAC;;EAExD,IAAIhB,KAAK,IAAIC,KAAK,EAAE;IAClB,OAAOgB,WAAW;EACpB,CAAC,CAAC;EACF;EACA;;EAEA,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIX,MAAM,GAAG,CAAC;EAEd,OAAO,IAAI,EAAE;IACX,IAAIY,OAAO,GAAGnB,KAAK,CAACU,SAAS,CAACO,WAAW,GAAGV,MAAM,CAAC;IACnD,IAAIa,KAAK,GAAGnB,KAAK,CAACoB,OAAO,CAACF,OAAO,CAAC;IAElC,IAAIC,KAAK,IAAI,CAAC,CAAC,EAAE;MACf,OAAOF,IAAI;IACb;IAEAX,MAAM,IAAIa,KAAK;IAEf,IACEA,KAAK,IAAI,CAAC,IACVpB,KAAK,CAACU,SAAS,CAACO,WAAW,GAAGV,MAAM,CAAC,IAAIN,KAAK,CAACS,SAAS,CAAC,CAAC,EAAEH,MAAM,CAAC,EACnE;MACAW,IAAI,GAAGX,MAAM;MACbA,MAAM,EAAE;IACV;EACF;AACF,CAAC;AACD;AACA;AACA;AACA;;AAEA,IAAIe,oBAAoB,GAAG,SAAAA,CAAUC,KAAK,EAAE;EAC1C,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,UAAU,GAAG,EAAE,CAAC,CAAC;;EAErB,IAAIC,gBAAgB,GAAG,CAAC,CAAC,CAAC;;EAE1B;;EAEA,IAAIC,YAAY,GAAG,IAAI,CAAC,CAAC;;EAEzB,IAAIC,OAAO,GAAG,CAAC,CAAC,CAAC;EACjB;;EAEA,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,IAAIC,iBAAiB,GAAG,CAAC,CAAC,CAAC;;EAE3B,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,IAAIC,iBAAiB,GAAG,CAAC;EAEzB,OAAOJ,OAAO,GAAGL,KAAK,CAAChB,MAAM,EAAE;IAC7B,IAAIgB,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,EAAE;MACnC;MACAqC,UAAU,CAACC,gBAAgB,EAAE,CAAC,GAAGE,OAAO;MACxCC,kBAAkB,GAAGE,kBAAkB;MACvCD,iBAAiB,GAAGE,iBAAiB;MACrCD,kBAAkB,GAAG,CAAC;MACtBC,iBAAiB,GAAG,CAAC;MACrBL,YAAY,GAAGJ,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM;MACL;MACA,IAAIL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,IAAIzC,WAAW,EAAE;QACpC4C,kBAAkB,IAAIR,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM;MAChD,CAAC,MAAM;QACLyB,iBAAiB,IAAIT,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM;MAC/C,CAAC,CAAC;MACF;;MAEA,IACEoB,YAAY,IACZA,YAAY,CAACpB,MAAM,IACjBF,IAAI,CAAC4B,GAAG,CAACJ,kBAAkB,EAAEC,iBAAiB,CAAC,IACjDH,YAAY,CAACpB,MAAM,IAAIF,IAAI,CAAC4B,GAAG,CAACF,kBAAkB,EAAEC,iBAAiB,CAAC,EACtE;QACA;QACAT,KAAK,CAACW,MAAM,CACVT,UAAU,CAACC,gBAAgB,GAAG,CAAC,CAAC,EAChC,CAAC,EACD,IAAIxC,IAAI,CAACG,WAAW,EAAEsC,YAAY,CACpC,CAAC,CAAC,CAAC;;QAEHJ,KAAK,CAACE,UAAU,CAACC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGvC,WAAW,CAAC,CAAC;;QAE9DuC,gBAAgB,EAAE,CAAC,CAAC;;QAEpBA,gBAAgB,EAAE;QAClBE,OAAO,GAAGF,gBAAgB,GAAG,CAAC,GAAGD,UAAU,CAACC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACtEG,kBAAkB,GAAG,CAAC,CAAC,CAAC;;QAExBC,iBAAiB,GAAG,CAAC;QACrBC,kBAAkB,GAAG,CAAC;QACtBC,iBAAiB,GAAG,CAAC;QACrBL,YAAY,GAAG,IAAI;QACnBH,OAAO,GAAG,IAAI;MAChB;IACF;IAEAI,OAAO,EAAE;EACX,CAAC,CAAC;;EAEF,IAAIJ,OAAO,EAAE;IACXW,iBAAiB,CAACZ,KAAK,CAAC;EAC1B;EAEAa,4BAA4B,CAACb,KAAK,CAAC,CAAC,CAAC;EACrC;EACA;EACA;EACA;EACA;;EAEAK,OAAO,GAAG,CAAC;EAEX,OAAOA,OAAO,GAAGL,KAAK,CAAChB,MAAM,EAAE;IAC7B,IACEgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIvC,WAAW,IACpCkC,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,IAAIzC,WAAW,EAChC;MACA,IAAIkD,QAAQ,GAAGd,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACpC,IAAIU,SAAS,GAAGf,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;MACjC,IAAIW,eAAe,GAAGzB,mBAAmB,CAACuB,QAAQ,EAAEC,SAAS,CAAC;MAC9D,IAAIE,eAAe,GAAG1B,mBAAmB,CAACwB,SAAS,EAAED,QAAQ,CAAC;MAE9D,IAAIE,eAAe,IAAIC,eAAe,EAAE;QACtC,IACED,eAAe,IAAIF,QAAQ,CAAC9B,MAAM,GAAG,CAAC,IACtCgC,eAAe,IAAID,SAAS,CAAC/B,MAAM,GAAG,CAAC,EACvC;UACA;UACAgB,KAAK,CAACW,MAAM,CACVN,OAAO,EACP,CAAC,EACD,IAAI1C,IAAI,CAACE,UAAU,EAAEkD,SAAS,CAAC5B,SAAS,CAAC,CAAC,EAAE6B,eAAe,CAAC,CAC9D,CAAC;UACDhB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGS,QAAQ,CAAC3B,SAAS,CACxC,CAAC,EACD2B,QAAQ,CAAC9B,MAAM,GAAGgC,eACpB,CAAC;UACDhB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,SAAS,CAAC5B,SAAS,CAAC6B,eAAe,CAAC;UAC5DX,OAAO,EAAE;QACX;MACF,CAAC,MAAM;QACL,IACEY,eAAe,IAAIH,QAAQ,CAAC9B,MAAM,GAAG,CAAC,IACtCiC,eAAe,IAAIF,SAAS,CAAC/B,MAAM,GAAG,CAAC,EACvC;UACA;UACA;UACAgB,KAAK,CAACW,MAAM,CACVN,OAAO,EACP,CAAC,EACD,IAAI1C,IAAI,CAACE,UAAU,EAAEiD,QAAQ,CAAC3B,SAAS,CAAC,CAAC,EAAE8B,eAAe,CAAC,CAC7D,CAAC;UACDjB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGzC,WAAW;UACnCoC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,SAAS,CAAC5B,SAAS,CACzC,CAAC,EACD4B,SAAS,CAAC/B,MAAM,GAAGiC,eACrB,CAAC;UACDjB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGvC,WAAW;UACnCkC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGS,QAAQ,CAAC3B,SAAS,CAAC8B,eAAe,CAAC;UAC3DZ,OAAO,EAAE;QACX;MACF;MAEAA,OAAO,EAAE;IACX;IAEAA,OAAO,EAAE;EACX;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA7C,OAAO,CAACE,eAAe,GAAGqC,oBAAoB;AAE9C,IAAIc,4BAA4B,GAAG,SAAAA,CAAUb,KAAK,EAAE;EAClD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASkB,0BAA0BA,CAACC,GAAG,EAAEC,GAAG,EAAE;IAC5C,IAAI,CAACD,GAAG,IAAI,CAACC,GAAG,EAAE;MAChB;MACA,OAAO,CAAC;IACV,CAAC,CAAC;IACF;IACA;IACA;IACA;;IAEA,IAAIC,KAAK,GAAGF,GAAG,CAACxC,MAAM,CAACwC,GAAG,CAACnC,MAAM,GAAG,CAAC,CAAC;IACtC,IAAIsC,KAAK,GAAGF,GAAG,CAACzC,MAAM,CAAC,CAAC,CAAC;IACzB,IAAI4C,gBAAgB,GAAGF,KAAK,CAACG,KAAK,CAACC,qBAAqB,CAAC;IACzD,IAAIC,gBAAgB,GAAGJ,KAAK,CAACE,KAAK,CAACC,qBAAqB,CAAC;IACzD,IAAIE,WAAW,GAAGJ,gBAAgB,IAAIF,KAAK,CAACG,KAAK,CAACI,gBAAgB,CAAC;IACnE,IAAIC,WAAW,GAAGH,gBAAgB,IAAIJ,KAAK,CAACE,KAAK,CAACI,gBAAgB,CAAC;IACnE,IAAIE,UAAU,GAAGH,WAAW,IAAIN,KAAK,CAACG,KAAK,CAACO,eAAe,CAAC;IAC5D,IAAIC,UAAU,GAAGH,WAAW,IAAIP,KAAK,CAACE,KAAK,CAACO,eAAe,CAAC;IAC5D,IAAIE,UAAU,GAAGH,UAAU,IAAIX,GAAG,CAACK,KAAK,CAACU,kBAAkB,CAAC;IAC5D,IAAIC,UAAU,GAAGH,UAAU,IAAIZ,GAAG,CAACI,KAAK,CAACY,oBAAoB,CAAC;IAE9D,IAAIH,UAAU,IAAIE,UAAU,EAAE;MAC5B;MACA,OAAO,CAAC;IACV,CAAC,MAAM,IAAIL,UAAU,IAAIE,UAAU,EAAE;MACnC;MACA,OAAO,CAAC;IACV,CAAC,MAAM,IAAIT,gBAAgB,IAAI,CAACI,WAAW,IAAIE,WAAW,EAAE;MAC1D;MACA,OAAO,CAAC;IACV,CAAC,MAAM,IAAIF,WAAW,IAAIE,WAAW,EAAE;MACrC;MACA,OAAO,CAAC;IACV,CAAC,MAAM,IAAIN,gBAAgB,IAAIG,gBAAgB,EAAE;MAC/C;MACA,OAAO,CAAC;IACV;IAEA,OAAO,CAAC;EACV;EAEA,IAAIrB,OAAO,GAAG,CAAC,CAAC,CAAC;;EAEjB,OAAOA,OAAO,GAAGL,KAAK,CAAChB,MAAM,GAAG,CAAC,EAAE;IACjC,IACEgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,IACnCmC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,EACnC;MACA;MACA,IAAIwE,SAAS,GAAGrC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACrC,IAAIiC,IAAI,GAAGtC,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;MAC5B,IAAIkC,SAAS,GAAGvC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEvC,IAAImC,YAAY,GAAGnD,iBAAiB,CAACgD,SAAS,EAAEC,IAAI,CAAC;MAErD,IAAIE,YAAY,EAAE;QAChB,IAAIC,YAAY,GAAGH,IAAI,CAACnD,SAAS,CAACmD,IAAI,CAACtD,MAAM,GAAGwD,YAAY,CAAC;QAC7DH,SAAS,GAAGA,SAAS,CAAClD,SAAS,CAAC,CAAC,EAAEkD,SAAS,CAACrD,MAAM,GAAGwD,YAAY,CAAC;QACnEF,IAAI,GAAGG,YAAY,GAAGH,IAAI,CAACnD,SAAS,CAAC,CAAC,EAAEmD,IAAI,CAACtD,MAAM,GAAGwD,YAAY,CAAC;QACnED,SAAS,GAAGE,YAAY,GAAGF,SAAS;MACtC,CAAC,CAAC;;MAEF,IAAIG,aAAa,GAAGL,SAAS;MAC7B,IAAIM,QAAQ,GAAGL,IAAI;MACnB,IAAIM,aAAa,GAAGL,SAAS;MAC7B,IAAIM,SAAS,GACX3B,0BAA0B,CAACmB,SAAS,EAAEC,IAAI,CAAC,GAC3CpB,0BAA0B,CAACoB,IAAI,EAAEC,SAAS,CAAC;MAE7C,OAAOD,IAAI,CAAC3D,MAAM,CAAC,CAAC,CAAC,KAAK4D,SAAS,CAAC5D,MAAM,CAAC,CAAC,CAAC,EAAE;QAC7C0D,SAAS,IAAIC,IAAI,CAAC3D,MAAM,CAAC,CAAC,CAAC;QAC3B2D,IAAI,GAAGA,IAAI,CAACnD,SAAS,CAAC,CAAC,CAAC,GAAGoD,SAAS,CAAC5D,MAAM,CAAC,CAAC,CAAC;QAC9C4D,SAAS,GAAGA,SAAS,CAACpD,SAAS,CAAC,CAAC,CAAC;QAClC,IAAI2D,KAAK,GACP5B,0BAA0B,CAACmB,SAAS,EAAEC,IAAI,CAAC,GAC3CpB,0BAA0B,CAACoB,IAAI,EAAEC,SAAS,CAAC,CAAC,CAAC;;QAE/C,IAAIO,KAAK,IAAID,SAAS,EAAE;UACtBA,SAAS,GAAGC,KAAK;UACjBJ,aAAa,GAAGL,SAAS;UACzBM,QAAQ,GAAGL,IAAI;UACfM,aAAa,GAAGL,SAAS;QAC3B;MACF;MAEA,IAAIvC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIqC,aAAa,EAAE;QAC1C;QACA,IAAIA,aAAa,EAAE;UACjB1C,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGqC,aAAa;QACvC,CAAC,MAAM;UACL1C,KAAK,CAACW,MAAM,CAACN,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;UAC5BA,OAAO,EAAE;QACX;QAEAL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGsC,QAAQ;QAE5B,IAAIC,aAAa,EAAE;UACjB5C,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGuC,aAAa;QACvC,CAAC,MAAM;UACL5C,KAAK,CAACW,MAAM,CAACN,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;UAC5BA,OAAO,EAAE;QACX;MACF;IACF;IAEAA,OAAO,EAAE;EACX;AACF,CAAC,CAAC,CAAC;;AAEH,IAAIoB,qBAAqB,GAAG,cAAc;AAC1C,IAAIG,gBAAgB,GAAG,IAAI;AAC3B,IAAIG,eAAe,GAAG,QAAQ;AAC9B,IAAIG,kBAAkB,GAAG,UAAU;AACnC,IAAIE,oBAAoB,GAAG,aAAa;AACxC;AACA;AACA;AACA;AACA;;AAEA,IAAIxB,iBAAiB,GAAG,SAAAA,CAAUZ,KAAK,EAAE;EACvC;EACAA,KAAK,CAAC+C,IAAI,CAAC,IAAIpF,IAAI,CAACE,UAAU,EAAE,EAAE,CAAC,CAAC;EACpC,IAAIwC,OAAO,GAAG,CAAC;EACf,IAAI2C,YAAY,GAAG,CAAC;EACpB,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,YAAY;EAEhB,OAAO/C,OAAO,GAAGL,KAAK,CAAChB,MAAM,EAAE;IAC7B,QAAQgB,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;MACvB,KAAKzC,WAAW;QACdqF,YAAY,EAAE;QACdE,WAAW,IAAInD,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;QAChCA,OAAO,EAAE;QACT;MAEF,KAAKvC,WAAW;QACdkF,YAAY,EAAE;QACdE,WAAW,IAAIlD,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;QAChCA,OAAO,EAAE;QACT;MAEF,KAAKxC,UAAU;QACb;QACA,IAAImF,YAAY,GAAGC,YAAY,GAAG,CAAC,EAAE;UACnC,IAAID,YAAY,KAAK,CAAC,IAAIC,YAAY,KAAK,CAAC,EAAE;YAC5C;YACAG,YAAY,GAAG5E,iBAAiB,CAAC2E,WAAW,EAAED,WAAW,CAAC;YAE1D,IAAIE,YAAY,KAAK,CAAC,EAAE;cACtB,IACE/C,OAAO,GAAG2C,YAAY,GAAGC,YAAY,GAAG,CAAC,IACzCjD,KAAK,CAACK,OAAO,GAAG2C,YAAY,GAAGC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IACjDpF,UAAU,EACZ;gBACAmC,KAAK,CAACK,OAAO,GAAG2C,YAAY,GAAGC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IACjDE,WAAW,CAAChE,SAAS,CAAC,CAAC,EAAEiE,YAAY,CAAC;cAC1C,CAAC,MAAM;gBACLpD,KAAK,CAACW,MAAM,CACV,CAAC,EACD,CAAC,EACD,IAAIhD,IAAI,CAACE,UAAU,EAAEsF,WAAW,CAAChE,SAAS,CAAC,CAAC,EAAEiE,YAAY,CAAC,CAC7D,CAAC;gBACD/C,OAAO,EAAE;cACX;cAEA8C,WAAW,GAAGA,WAAW,CAAChE,SAAS,CAACiE,YAAY,CAAC;cACjDF,WAAW,GAAGA,WAAW,CAAC/D,SAAS,CAACiE,YAAY,CAAC;YACnD,CAAC,CAAC;;YAEFA,YAAY,GAAG/D,iBAAiB,CAAC8D,WAAW,EAAED,WAAW,CAAC;YAE1D,IAAIE,YAAY,KAAK,CAAC,EAAE;cACtBpD,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,GACf8C,WAAW,CAAChE,SAAS,CAACgE,WAAW,CAACnE,MAAM,GAAGoE,YAAY,CAAC,GACxDpD,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;cACnB8C,WAAW,GAAGA,WAAW,CAAChE,SAAS,CACjC,CAAC,EACDgE,WAAW,CAACnE,MAAM,GAAGoE,YACvB,CAAC;cACDF,WAAW,GAAGA,WAAW,CAAC/D,SAAS,CACjC,CAAC,EACD+D,WAAW,CAAClE,MAAM,GAAGoE,YACvB,CAAC;YACH;UACF,CAAC,CAAC;;UAEF/C,OAAO,IAAI2C,YAAY,GAAGC,YAAY;UACtCjD,KAAK,CAACW,MAAM,CAACN,OAAO,EAAE2C,YAAY,GAAGC,YAAY,CAAC;UAElD,IAAIC,WAAW,CAAClE,MAAM,EAAE;YACtBgB,KAAK,CAACW,MAAM,CAACN,OAAO,EAAE,CAAC,EAAE,IAAI1C,IAAI,CAACG,WAAW,EAAEoF,WAAW,CAAC,CAAC;YAC5D7C,OAAO,EAAE;UACX;UAEA,IAAI8C,WAAW,CAACnE,MAAM,EAAE;YACtBgB,KAAK,CAACW,MAAM,CAACN,OAAO,EAAE,CAAC,EAAE,IAAI1C,IAAI,CAACC,WAAW,EAAEuF,WAAW,CAAC,CAAC;YAC5D9C,OAAO,EAAE;UACX;UAEAA,OAAO,EAAE;QACX,CAAC,MAAM,IAAIA,OAAO,KAAK,CAAC,IAAIL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,EAAE;UAC/D;UACAmC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;UAC1CL,KAAK,CAACW,MAAM,CAACN,OAAO,EAAE,CAAC,CAAC;QAC1B,CAAC,MAAM;UACLA,OAAO,EAAE;QACX;QAEA4C,YAAY,GAAG,CAAC;QAChBD,YAAY,GAAG,CAAC;QAChBE,WAAW,GAAG,EAAE;QAChBC,WAAW,GAAG,EAAE;QAChB;IACJ;EACF;EAEA,IAAInD,KAAK,CAACA,KAAK,CAAChB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACrCgB,KAAK,CAACqD,GAAG,CAAC,CAAC,CAAC,CAAC;EACf,CAAC,CAAC;EACF;EACA;;EAEA,IAAIpD,OAAO,GAAG,KAAK;EACnBI,OAAO,GAAG,CAAC,CAAC,CAAC;;EAEb,OAAOA,OAAO,GAAGL,KAAK,CAAChB,MAAM,GAAG,CAAC,EAAE;IACjC,IACEgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,IACnCmC,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIxC,UAAU,EACnC;MACA;MACA,IACEmC,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAClB,SAAS,CACzBa,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM,GAAGgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACrB,MACnD,CAAC,IAAIgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAC1B;QACA;QACAL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,GACfL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GACrBL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAClB,SAAS,CACzB,CAAC,EACDa,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM,GAAGgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACrB,MACnD,CAAC;QACHgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACrEL,KAAK,CAACW,MAAM,CAACN,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5BJ,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM,IACLD,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAClB,SAAS,CAAC,CAAC,EAAEa,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM,CAAC,IAC5DgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EACrB;QACA;QACAL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIL,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9CL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,GACfL,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC,CAAClB,SAAS,CAACa,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACrB,MAAM,CAAC,GACzDgB,KAAK,CAACK,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACvBL,KAAK,CAACW,MAAM,CAACN,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC;QAC5BJ,OAAO,GAAG,IAAI;MAChB;IACF;IAEAI,OAAO,EAAE;EACX,CAAC,CAAC;;EAEF,IAAIJ,OAAO,EAAE;IACXW,iBAAiB,CAACZ,KAAK,CAAC;EAC1B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}