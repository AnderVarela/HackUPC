{"ast":null,"code":"// Port of python's argparse module, version 3.9.0:\n// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py\n\n'use strict';\n\n// Copyright (C) 2010-2020 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n\n/*\n * Command-line parsing library\n *\n * This module is an optparse-inspired command-line parsing library that:\n *\n *     - handles both optional and positional arguments\n *     - produces highly informative usage messages\n *     - supports parsers that dispatch to sub-parsers\n *\n * The following is a simple usage example that sums integers from the\n * command-line and writes the result to a file::\n *\n *     parser = argparse.ArgumentParser(\n *         description='sum the integers at the command line')\n *     parser.add_argument(\n *         'integers', metavar='int', nargs='+', type=int,\n *         help='an integer to be summed')\n *     parser.add_argument(\n *         '--log', default=sys.stdout, type=argparse.FileType('w'),\n *         help='the file where the sum should be written')\n *     args = parser.parse_args()\n *     args.log.write('%s' % sum(args.integers))\n *     args.log.close()\n *\n * The module contains the following public classes:\n *\n *     - ArgumentParser -- The main entry point for command-line parsing. As the\n *         example above shows, the add_argument() method is used to populate\n *         the parser with actions for optional and positional arguments. Then\n *         the parse_args() method is invoked to convert the args at the\n *         command-line into an object with attributes.\n *\n *     - ArgumentError -- The exception raised by ArgumentParser objects when\n *         there are errors with the parser's actions. Errors raised while\n *         parsing the command-line are caught by ArgumentParser and emitted\n *         as command-line messages.\n *\n *     - FileType -- A factory for defining types of files to be created. As the\n *         example above shows, instances of FileType are typically passed as\n *         the type= argument of add_argument() calls.\n *\n *     - Action -- The base class for parser actions. Typically actions are\n *         selected by passing strings like 'store_true' or 'append_const' to\n *         the action= argument of add_argument(). However, for greater\n *         customization of ArgumentParser actions, subclasses of Action may\n *         be defined and passed as the action= argument.\n *\n *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n *         ArgumentDefaultsHelpFormatter -- Formatter classes which\n *         may be passed as the formatter_class= argument to the\n *         ArgumentParser constructor. HelpFormatter is the default,\n *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n *         not to change the formatting for help text, and\n *         ArgumentDefaultsHelpFormatter adds information about argument defaults\n *         to the help.\n *\n * All other classes in this module are considered implementation details.\n * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only\n * considered public as object names -- the API of the formatter objects is\n * still considered an implementation detail.)\n */\nconst SUPPRESS = '==SUPPRESS==';\nconst OPTIONAL = '?';\nconst ZERO_OR_MORE = '*';\nconst ONE_OR_MORE = '+';\nconst PARSER = 'A...';\nconst REMAINDER = '...';\nconst _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';\n\n// ==================================\n// Utility functions used for porting\n// ==================================\nconst assert = require('assert');\nconst util = require('util');\nconst fs = require('fs');\nconst sub = require('./lib/sub');\nconst path = require('path');\nconst repr = util.inspect;\nfunction get_argv() {\n  // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)\n  return process.argv.slice(1);\n}\nfunction get_terminal_size() {\n  return {\n    columns: +process.env.COLUMNS || process.stdout.columns || 80\n  };\n}\nfunction hasattr(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\nfunction getattr(object, name, value) {\n  return hasattr(object, name) ? object[name] : value;\n}\nfunction setattr(object, name, value) {\n  object[name] = value;\n}\nfunction setdefault(object, name, value) {\n  if (!hasattr(object, name)) object[name] = value;\n  return object[name];\n}\nfunction delattr(object, name) {\n  delete object[name];\n}\nfunction range(from, to, step = 1) {\n  // range(10) is equivalent to range(0, 10)\n  if (arguments.length === 1) [to, from] = [from, 0];\n  if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n    throw new TypeError('argument cannot be interpreted as an integer');\n  }\n  if (step === 0) throw new TypeError('range() arg 3 must not be zero');\n  let result = [];\n  if (step > 0) {\n    for (let i = from; i < to; i += step) result.push(i);\n  } else {\n    for (let i = from; i > to; i += step) result.push(i);\n  }\n  return result;\n}\nfunction splitlines(str, keepends = false) {\n  let result;\n  if (!keepends) {\n    result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/);\n  } else {\n    result = [];\n    let parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/);\n    for (let i = 0; i < parts.length; i += 2) {\n      result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''));\n    }\n  }\n  if (!result[result.length - 1]) result.pop();\n  return result;\n}\nfunction _string_lstrip(string, prefix_chars) {\n  let idx = 0;\n  while (idx < string.length && prefix_chars.includes(string[idx])) idx++;\n  return idx ? string.slice(idx) : string;\n}\nfunction _string_split(string, sep, maxsplit) {\n  let result = string.split(sep);\n  if (result.length > maxsplit) {\n    result = result.slice(0, maxsplit).concat([result.slice(maxsplit).join(sep)]);\n  }\n  return result;\n}\nfunction _array_equal(array1, array2) {\n  if (array1.length !== array2.length) return false;\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) return false;\n  }\n  return true;\n}\nfunction _array_remove(array, item) {\n  let idx = array.indexOf(item);\n  if (idx === -1) throw new TypeError(sub('%r not in list', item));\n  array.splice(idx, 1);\n}\n\n// normalize choices to array;\n// this isn't required in python because `in` and `map` operators work with anything,\n// but in js dealing with multiple types here is too clunky\nfunction _choices_to_array(choices) {\n  if (choices === undefined) {\n    return [];\n  } else if (Array.isArray(choices)) {\n    return choices;\n  } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n    return Array.from(choices);\n  } else if (typeof choices === 'object' && choices !== null) {\n    return Object.keys(choices);\n  } else {\n    throw new Error(sub('invalid choices value: %r', choices));\n  }\n}\n\n// decorator that allows a class to be called without new\nfunction _callable(cls) {\n  let result = {\n    // object is needed for inferred class name\n    [cls.name]: function (...args) {\n      let this_class = new.target === result || !new.target;\n      return Reflect.construct(cls, args, this_class ? cls : new.target);\n    }\n  };\n  result[cls.name].prototype = cls.prototype;\n  // fix default tag for toString, e.g. [object Action] instead of [object Object]\n  cls.prototype[Symbol.toStringTag] = cls.name;\n  return result[cls.name];\n}\nfunction _alias(object, from, to) {\n  try {\n    let name = object.constructor.name;\n    Object.defineProperty(object, from, {\n      value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()', name, from, name, to)),\n      enumerable: false\n    });\n  } catch {}\n}\n\n// decorator that allows snake_case class methods to be called with camelCase and vice versa\nfunction _camelcase_alias(_class) {\n  for (let name of Object.getOwnPropertyNames(_class.prototype)) {\n    let camelcase = name.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase());\n    if (camelcase !== name) _alias(_class.prototype, camelcase, name);\n  }\n  return _class;\n}\nfunction _to_legacy_name(key) {\n  key = key.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase());\n  if (key === 'default') key = 'defaultValue';\n  if (key === 'const') key = 'constant';\n  return key;\n}\nfunction _to_new_name(key) {\n  if (key === 'defaultValue') key = 'default';\n  if (key === 'constant') key = 'const';\n  key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase());\n  return key;\n}\n\n// parse options\nlet no_default = Symbol('no_default_value');\nfunction _parse_opts(args, descriptor) {\n  function get_name() {\n    let stack = new Error().stack.split('\\n').map(x => x.match(/^    at (.*) \\(.*\\)$/)).filter(Boolean).map(m => m[1]).map(fn => fn.match(/[^ .]*$/)[0]);\n    if (stack.length && stack[0] === get_name.name) stack.shift();\n    if (stack.length && stack[0] === _parse_opts.name) stack.shift();\n    return stack.length ? stack[0] : '';\n  }\n  args = Array.from(args);\n  let kwargs = {};\n  let result = [];\n  let last_opt = args.length && args[args.length - 1];\n  if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) && (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n    kwargs = Object.assign({}, args.pop());\n  }\n\n  // LEGACY (v1 compatibility): camelcase\n  let renames = [];\n  for (let key of Object.keys(descriptor)) {\n    let old_name = _to_legacy_name(key);\n    if (old_name !== key && old_name in kwargs) {\n      if (key in kwargs) {\n        // default and defaultValue specified at the same time, happens often in old tests\n        //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n      } else {\n        kwargs[key] = kwargs[old_name];\n      }\n      renames.push([old_name, key]);\n      delete kwargs[old_name];\n    }\n  }\n  if (renames.length) {\n    let name = get_name();\n    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(([a, b]) => sub('%r -> %r', a, b))));\n  }\n  // end\n\n  let missing_positionals = [];\n  let positional_count = args.length;\n  for (let [key, def] of Object.entries(descriptor)) {\n    if (key[0] === '*') {\n      if (key.length > 0 && key[1] === '*') {\n        // LEGACY (v1 compatibility): camelcase\n        let renames = [];\n        for (let key of Object.keys(kwargs)) {\n          let new_name = _to_new_name(key);\n          if (new_name !== key && key in kwargs) {\n            if (new_name in kwargs) {\n              // default and defaultValue specified at the same time, happens often in old tests\n              //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))\n            } else {\n              kwargs[new_name] = kwargs[key];\n            }\n            renames.push([key, new_name]);\n            delete kwargs[key];\n          }\n        }\n        if (renames.length) {\n          let name = get_name();\n          deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(([a, b]) => sub('%r -> %r', a, b))));\n        }\n        // end\n        result.push(kwargs);\n        kwargs = {};\n      } else {\n        result.push(args);\n        args = [];\n      }\n    } else if (key in kwargs && args.length > 0) {\n      throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key));\n    } else if (key in kwargs) {\n      result.push(kwargs[key]);\n      delete kwargs[key];\n    } else if (args.length > 0) {\n      result.push(args.shift());\n    } else if (def !== no_default) {\n      result.push(def);\n    } else {\n      missing_positionals.push(key);\n    }\n  }\n  if (Object.keys(kwargs).length) {\n    throw new TypeError(sub('%s() got an unexpected keyword argument %r', get_name(), Object.keys(kwargs)[0]));\n  }\n  if (args.length) {\n    let from = Object.entries(descriptor).filter(([k, v]) => k[0] !== '*' && v !== no_default).length;\n    let to = Object.entries(descriptor).filter(([k]) => k[0] !== '*').length;\n    throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given', get_name(), from === to ? sub('from %s to %s', from, to) : to, from === to && to === 1 ? '' : 's', positional_count, positional_count === 1 ? 'was' : 'were'));\n  }\n  if (missing_positionals.length) {\n    let strs = missing_positionals.map(repr);\n    if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1];\n    let str_joined = strs.join(strs.length === 2 ? '' : ', ');\n    throw new TypeError(sub('%s() missing %i required positional argument%s: %s', get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined));\n  }\n  return result;\n}\nlet _deprecations = {};\nfunction deprecate(id, string) {\n  _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string);\n  _deprecations[id]();\n}\n\n// =============================\n// Utility functions and classes\n// =============================\nfunction _AttributeHolder(cls = Object) {\n  /*\n   *  Abstract base class that provides __repr__.\n   *\n   *  The __repr__ method returns a string in the format::\n   *      ClassName(attr=name, attr=name, ...)\n   *  The attributes are determined either by a class-level attribute,\n   *  '_kwarg_names', or by inspecting the instance __dict__.\n   */\n\n  return class _AttributeHolder extends cls {\n    [util.inspect.custom]() {\n      let type_name = this.constructor.name;\n      let arg_strings = [];\n      let star_args = {};\n      for (let arg of this._get_args()) {\n        arg_strings.push(repr(arg));\n      }\n      for (let [name, value] of this._get_kwargs()) {\n        if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n          arg_strings.push(sub('%s=%r', name, value));\n        } else {\n          star_args[name] = value;\n        }\n      }\n      if (Object.keys(star_args).length) {\n        arg_strings.push(sub('**%s', repr(star_args)));\n      }\n      return sub('%s(%s)', type_name, arg_strings.join(', '));\n    }\n    toString() {\n      return this[util.inspect.custom]();\n    }\n    _get_kwargs() {\n      return Object.entries(this);\n    }\n    _get_args() {\n      return [];\n    }\n  };\n}\nfunction _copy_items(items) {\n  if (items === undefined) {\n    return [];\n  }\n  return items.slice(0);\n}\n\n// ===============\n// Formatting Help\n// ===============\nconst HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {\n  /*\n   *  Formatter for generating usage messages and argument help strings.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n\n  constructor() {\n    let [prog, indent_increment, max_help_position, width] = _parse_opts(arguments, {\n      prog: no_default,\n      indent_increment: 2,\n      max_help_position: 24,\n      width: undefined\n    });\n\n    // default setting for width\n    if (width === undefined) {\n      width = get_terminal_size().columns;\n      width -= 2;\n    }\n    this._prog = prog;\n    this._indent_increment = indent_increment;\n    this._max_help_position = Math.min(max_help_position, Math.max(width - 20, indent_increment * 2));\n    this._width = width;\n    this._current_indent = 0;\n    this._level = 0;\n    this._action_max_length = 0;\n    this._root_section = this._Section(this, undefined);\n    this._current_section = this._root_section;\n    this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g; // equivalent to python /\\s+/ with ASCII flag\n    this._long_break_matcher = /\\n\\n\\n+/g;\n  }\n\n  // ===============================\n  // Section and indentation methods\n  // ===============================\n  _indent() {\n    this._current_indent += this._indent_increment;\n    this._level += 1;\n  }\n  _dedent() {\n    this._current_indent -= this._indent_increment;\n    assert(this._current_indent >= 0, 'Indent decreased below 0.');\n    this._level -= 1;\n  }\n  _add_item(func, args) {\n    this._current_section.items.push([func, args]);\n  }\n\n  // ========================\n  // Message building methods\n  // ========================\n  start_section(heading) {\n    this._indent();\n    let section = this._Section(this, this._current_section, heading);\n    this._add_item(section.format_help.bind(section), []);\n    this._current_section = section;\n  }\n  end_section() {\n    this._current_section = this._current_section.parent;\n    this._dedent();\n  }\n  add_text(text) {\n    if (text !== SUPPRESS && text !== undefined) {\n      this._add_item(this._format_text.bind(this), [text]);\n    }\n  }\n  add_usage(usage, actions, groups, prefix = undefined) {\n    if (usage !== SUPPRESS) {\n      let args = [usage, actions, groups, prefix];\n      this._add_item(this._format_usage.bind(this), args);\n    }\n  }\n  add_argument(action) {\n    if (action.help !== SUPPRESS) {\n      // find all invocations\n      let invocations = [this._format_action_invocation(action)];\n      for (let subaction of this._iter_indented_subactions(action)) {\n        invocations.push(this._format_action_invocation(subaction));\n      }\n\n      // update the maximum item length\n      let invocation_length = Math.max(...invocations.map(invocation => invocation.length));\n      let action_length = invocation_length + this._current_indent;\n      this._action_max_length = Math.max(this._action_max_length, action_length);\n\n      // add the item to the list\n      this._add_item(this._format_action.bind(this), [action]);\n    }\n  }\n  add_arguments(actions) {\n    for (let action of actions) {\n      this.add_argument(action);\n    }\n  }\n\n  // =======================\n  // Help-formatting methods\n  // =======================\n  format_help() {\n    let help = this._root_section.format_help();\n    if (help) {\n      help = help.replace(this._long_break_matcher, '\\n\\n');\n      help = help.replace(/^\\n+|\\n+$/g, '') + '\\n';\n    }\n    return help;\n  }\n  _join_parts(part_strings) {\n    return part_strings.filter(part => part && part !== SUPPRESS).join('');\n  }\n  _format_usage(usage, actions, groups, prefix) {\n    if (prefix === undefined) {\n      prefix = 'usage: ';\n    }\n\n    // if usage is specified, use that\n    if (usage !== undefined) {\n      usage = sub(usage, {\n        prog: this._prog\n      });\n\n      // if no optionals or positionals are available, usage is just prog\n    } else if (usage === undefined && !actions.length) {\n      usage = sub('%(prog)s', {\n        prog: this._prog\n      });\n\n      // if optionals and positionals are available, calculate usage\n    } else if (usage === undefined) {\n      let prog = sub('%(prog)s', {\n        prog: this._prog\n      });\n\n      // split optionals from positionals\n      let optionals = [];\n      let positionals = [];\n      for (let action of actions) {\n        if (action.option_strings.length) {\n          optionals.push(action);\n        } else {\n          positionals.push(action);\n        }\n      }\n\n      // build full usage string\n      let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups);\n      usage = [prog, action_usage].map(String).join(' ');\n\n      // wrap the usage parts if it's too long\n      let text_width = this._width - this._current_indent;\n      if (prefix.length + usage.length > text_width) {\n        // break usage into wrappable parts\n        let part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g;\n        let opt_usage = this._format_actions_usage(optionals, groups);\n        let pos_usage = this._format_actions_usage(positionals, groups);\n        let opt_parts = opt_usage.match(part_regexp) || [];\n        let pos_parts = pos_usage.match(part_regexp) || [];\n        assert(opt_parts.join(' ') === opt_usage);\n        assert(pos_parts.join(' ') === pos_usage);\n\n        // helper for wrapping lines\n        let get_lines = (parts, indent, prefix = undefined) => {\n          let lines = [];\n          let line = [];\n          let line_len;\n          if (prefix !== undefined) {\n            line_len = prefix.length - 1;\n          } else {\n            line_len = indent.length - 1;\n          }\n          for (let part of parts) {\n            if (line_len + 1 + part.length > text_width && line) {\n              lines.push(indent + line.join(' '));\n              line = [];\n              line_len = indent.length - 1;\n            }\n            line.push(part);\n            line_len += part.length + 1;\n          }\n          if (line.length) {\n            lines.push(indent + line.join(' '));\n          }\n          if (prefix !== undefined) {\n            lines[0] = lines[0].slice(indent.length);\n          }\n          return lines;\n        };\n        let lines;\n\n        // if prog is short, follow it with optionals or positionals\n        if (prefix.length + prog.length <= 0.75 * text_width) {\n          let indent = ' '.repeat(prefix.length + prog.length + 1);\n          if (opt_parts.length) {\n            lines = get_lines([prog].concat(opt_parts), indent, prefix);\n            lines = lines.concat(get_lines(pos_parts, indent));\n          } else if (pos_parts.length) {\n            lines = get_lines([prog].concat(pos_parts), indent, prefix);\n          } else {\n            lines = [prog];\n          }\n\n          // if prog is long, put it on its own line\n        } else {\n          let indent = ' '.repeat(prefix.length);\n          let parts = [].concat(opt_parts).concat(pos_parts);\n          lines = get_lines(parts, indent);\n          if (lines.length > 1) {\n            lines = [];\n            lines = lines.concat(get_lines(opt_parts, indent));\n            lines = lines.concat(get_lines(pos_parts, indent));\n          }\n          lines = [prog].concat(lines);\n        }\n\n        // join lines into usage\n        usage = lines.join('\\n');\n      }\n    }\n\n    // prefix with 'usage:'\n    return sub('%s%s\\n\\n', prefix, usage);\n  }\n  _format_actions_usage(actions, groups) {\n    // find group indices and identify actions in groups\n    let group_actions = new Set();\n    let inserts = {};\n    for (let group of groups) {\n      let start = actions.indexOf(group._group_actions[0]);\n      if (start === -1) {\n        continue;\n      } else {\n        let end = start + group._group_actions.length;\n        if (_array_equal(actions.slice(start, end), group._group_actions)) {\n          for (let action of group._group_actions) {\n            group_actions.add(action);\n          }\n          if (!group.required) {\n            if (start in inserts) {\n              inserts[start] += ' [';\n            } else {\n              inserts[start] = '[';\n            }\n            if (end in inserts) {\n              inserts[end] += ']';\n            } else {\n              inserts[end] = ']';\n            }\n          } else {\n            if (start in inserts) {\n              inserts[start] += ' (';\n            } else {\n              inserts[start] = '(';\n            }\n            if (end in inserts) {\n              inserts[end] += ')';\n            } else {\n              inserts[end] = ')';\n            }\n          }\n          for (let i of range(start + 1, end)) {\n            inserts[i] = '|';\n          }\n        }\n      }\n    }\n\n    // collect all actions format strings\n    let parts = [];\n    for (let [i, action] of Object.entries(actions)) {\n      // suppressed arguments are marked with None\n      // remove | separators for suppressed arguments\n      if (action.help === SUPPRESS) {\n        parts.push(undefined);\n        if (inserts[+i] === '|') {\n          delete inserts[+i];\n        } else if (inserts[+i + 1] === '|') {\n          delete inserts[+i + 1];\n        }\n\n        // produce all arg strings\n      } else if (!action.option_strings.length) {\n        let default_value = this._get_default_metavar_for_positional(action);\n        let part = this._format_args(action, default_value);\n\n        // if it's in a group, strip the outer []\n        if (group_actions.has(action)) {\n          if (part[0] === '[' && part[part.length - 1] === ']') {\n            part = part.slice(1, -1);\n          }\n        }\n\n        // add the action string to the list\n        parts.push(part);\n\n        // produce the first way to invoke the option in brackets\n      } else {\n        let option_string = action.option_strings[0];\n        let part;\n\n        // if the Optional doesn't take a value, format is:\n        //    -s or --long\n        if (action.nargs === 0) {\n          part = action.format_usage();\n\n          // if the Optional takes a value, format is:\n          //    -s ARGS or --long ARGS\n        } else {\n          let default_value = this._get_default_metavar_for_optional(action);\n          let args_string = this._format_args(action, default_value);\n          part = sub('%s %s', option_string, args_string);\n        }\n\n        // make it look optional if it's not required or in a group\n        if (!action.required && !group_actions.has(action)) {\n          part = sub('[%s]', part);\n        }\n\n        // add the action string to the list\n        parts.push(part);\n      }\n    }\n\n    // insert things at the necessary indices\n    for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {\n      parts.splice(+i, 0, inserts[+i]);\n    }\n\n    // join all the action items with spaces\n    let text = parts.filter(Boolean).join(' ');\n\n    // clean up separators for mutually exclusive groups\n    text = text.replace(/([\\[(]) /g, '$1');\n    text = text.replace(/ ([\\])])/g, '$1');\n    text = text.replace(/[\\[(] *[\\])]/g, '');\n    text = text.replace(/\\(([^|]*)\\)/g, '$1', text);\n    text = text.trim();\n\n    // return the text\n    return text;\n  }\n  _format_text(text) {\n    if (text.includes('%(prog)')) {\n      text = sub(text, {\n        prog: this._prog\n      });\n    }\n    let text_width = Math.max(this._width - this._current_indent, 11);\n    let indent = ' '.repeat(this._current_indent);\n    return this._fill_text(text, text_width, indent) + '\\n\\n';\n  }\n  _format_action(action) {\n    // determine the required width and the entry label\n    let help_position = Math.min(this._action_max_length + 2, this._max_help_position);\n    let help_width = Math.max(this._width - help_position, 11);\n    let action_width = help_position - this._current_indent - 2;\n    let action_header = this._format_action_invocation(action);\n    let indent_first;\n\n    // no help; start on same line and add a final newline\n    if (!action.help) {\n      let tup = [this._current_indent, '', action_header];\n      action_header = sub('%*s%s\\n', ...tup);\n\n      // short action name; start on the same line and pad two spaces\n    } else if (action_header.length <= action_width) {\n      let tup = [this._current_indent, '', action_width, action_header];\n      action_header = sub('%*s%-*s  ', ...tup);\n      indent_first = 0;\n\n      // long action name; start on the next line\n    } else {\n      let tup = [this._current_indent, '', action_header];\n      action_header = sub('%*s%s\\n', ...tup);\n      indent_first = help_position;\n    }\n\n    // collect the pieces of the action help\n    let parts = [action_header];\n\n    // if there was help for the action, add lines of help text\n    if (action.help) {\n      let help_text = this._expand_help(action);\n      let help_lines = this._split_lines(help_text, help_width);\n      parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]));\n      for (let line of help_lines.slice(1)) {\n        parts.push(sub('%*s%s\\n', help_position, '', line));\n      }\n\n      // or add a newline if the description doesn't end with one\n    } else if (!action_header.endsWith('\\n')) {\n      parts.push('\\n');\n    }\n\n    // if there are any sub-actions, add their help as well\n    for (let subaction of this._iter_indented_subactions(action)) {\n      parts.push(this._format_action(subaction));\n    }\n\n    // return a single string\n    return this._join_parts(parts);\n  }\n  _format_action_invocation(action) {\n    if (!action.option_strings.length) {\n      let default_value = this._get_default_metavar_for_positional(action);\n      let metavar = this._metavar_formatter(action, default_value)(1)[0];\n      return metavar;\n    } else {\n      let parts = [];\n\n      // if the Optional doesn't take a value, format is:\n      //    -s, --long\n      if (action.nargs === 0) {\n        parts = parts.concat(action.option_strings);\n\n        // if the Optional takes a value, format is:\n        //    -s ARGS, --long ARGS\n      } else {\n        let default_value = this._get_default_metavar_for_optional(action);\n        let args_string = this._format_args(action, default_value);\n        for (let option_string of action.option_strings) {\n          parts.push(sub('%s %s', option_string, args_string));\n        }\n      }\n      return parts.join(', ');\n    }\n  }\n  _metavar_formatter(action, default_metavar) {\n    let result;\n    if (action.metavar !== undefined) {\n      result = action.metavar;\n    } else if (action.choices !== undefined) {\n      let choice_strs = _choices_to_array(action.choices).map(String);\n      result = sub('{%s}', choice_strs.join(','));\n    } else {\n      result = default_metavar;\n    }\n    function format(tuple_size) {\n      if (Array.isArray(result)) {\n        return result;\n      } else {\n        return Array(tuple_size).fill(result);\n      }\n    }\n    return format;\n  }\n  _format_args(action, default_metavar) {\n    let get_metavar = this._metavar_formatter(action, default_metavar);\n    let result;\n    if (action.nargs === undefined) {\n      result = sub('%s', ...get_metavar(1));\n    } else if (action.nargs === OPTIONAL) {\n      result = sub('[%s]', ...get_metavar(1));\n    } else if (action.nargs === ZERO_OR_MORE) {\n      let metavar = get_metavar(1);\n      if (metavar.length === 2) {\n        result = sub('[%s [%s ...]]', ...metavar);\n      } else {\n        result = sub('[%s ...]', ...metavar);\n      }\n    } else if (action.nargs === ONE_OR_MORE) {\n      result = sub('%s [%s ...]', ...get_metavar(2));\n    } else if (action.nargs === REMAINDER) {\n      result = '...';\n    } else if (action.nargs === PARSER) {\n      result = sub('%s ...', ...get_metavar(1));\n    } else if (action.nargs === SUPPRESS) {\n      result = '';\n    } else {\n      let formats;\n      try {\n        formats = range(action.nargs).map(() => '%s');\n      } catch (err) {\n        throw new TypeError('invalid nargs value');\n      }\n      result = sub(formats.join(' '), ...get_metavar(action.nargs));\n    }\n    return result;\n  }\n  _expand_help(action) {\n    let params = Object.assign({\n      prog: this._prog\n    }, action);\n    for (let name of Object.keys(params)) {\n      if (params[name] === SUPPRESS) {\n        delete params[name];\n      }\n    }\n    for (let name of Object.keys(params)) {\n      if (params[name] && params[name].name) {\n        params[name] = params[name].name;\n      }\n    }\n    if (params.choices !== undefined) {\n      let choices_str = _choices_to_array(params.choices).map(String).join(', ');\n      params.choices = choices_str;\n    }\n    // LEGACY (v1 compatibility): camelcase\n    for (let key of Object.keys(params)) {\n      let old_name = _to_legacy_name(key);\n      if (old_name !== key) {\n        params[old_name] = params[key];\n      }\n    }\n    // end\n    return sub(this._get_help_string(action), params);\n  }\n  *_iter_indented_subactions(action) {\n    if (typeof action._get_subactions === 'function') {\n      this._indent();\n      yield* action._get_subactions();\n      this._dedent();\n    }\n  }\n  _split_lines(text, width) {\n    text = text.replace(this._whitespace_matcher, ' ').trim();\n    // The textwrap module is used only for formatting help.\n    // Delay its import for speeding up the common usage of argparse.\n    let textwrap = require('./lib/textwrap');\n    return textwrap.wrap(text, {\n      width\n    });\n  }\n  _fill_text(text, width, indent) {\n    text = text.replace(this._whitespace_matcher, ' ').trim();\n    let textwrap = require('./lib/textwrap');\n    return textwrap.fill(text, {\n      width,\n      initial_indent: indent,\n      subsequent_indent: indent\n    });\n  }\n  _get_help_string(action) {\n    return action.help;\n  }\n  _get_default_metavar_for_optional(action) {\n    return action.dest.toUpperCase();\n  }\n  _get_default_metavar_for_positional(action) {\n    return action.dest;\n  }\n}));\nHelpFormatter.prototype._Section = _callable(class _Section {\n  constructor(formatter, parent, heading = undefined) {\n    this.formatter = formatter;\n    this.parent = parent;\n    this.heading = heading;\n    this.items = [];\n  }\n  format_help() {\n    // format the indented section\n    if (this.parent !== undefined) {\n      this.formatter._indent();\n    }\n    let item_help = this.formatter._join_parts(this.items.map(([func, args]) => func.apply(null, args)));\n    if (this.parent !== undefined) {\n      this.formatter._dedent();\n    }\n\n    // return nothing if the section was empty\n    if (!item_help) {\n      return '';\n    }\n\n    // add the heading if the section was non-empty\n    let heading;\n    if (this.heading !== SUPPRESS && this.heading !== undefined) {\n      let current_indent = this.formatter._current_indent;\n      heading = sub('%*s%s:\\n', current_indent, '', this.heading);\n    } else {\n      heading = '';\n    }\n\n    // join the section-initial newline, the heading and the help\n    return this.formatter._join_parts(['\\n', heading, item_help, '\\n']);\n  }\n});\nconst RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which retains any formatting in descriptions.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n\n  _fill_text(text, width, indent) {\n    return splitlines(text, true).map(line => indent + line).join('');\n  }\n}));\nconst RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {\n  /*\n   *  Help message formatter which retains formatting of all help text.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n\n  _split_lines(text /*, width*/) {\n    return splitlines(text);\n  }\n}));\nconst ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which adds default values to argument help.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n\n  _get_help_string(action) {\n    let help = action.help;\n    // LEGACY (v1 compatibility): additional check for defaultValue needed\n    if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n      if (action.default !== SUPPRESS) {\n        let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE];\n        if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n          help += ' (default: %(default)s)';\n        }\n      }\n    }\n    return help;\n  }\n}));\nconst MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which uses the argument 'type' as the default\n   *  metavar value (instead of the argument 'dest')\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n\n  _get_default_metavar_for_optional(action) {\n    return typeof action.type === 'function' ? action.type.name : action.type;\n  }\n  _get_default_metavar_for_positional(action) {\n    return typeof action.type === 'function' ? action.type.name : action.type;\n  }\n}));\n\n// =====================\n// Options and Arguments\n// =====================\nfunction _get_action_name(argument) {\n  if (argument === undefined) {\n    return undefined;\n  } else if (argument.option_strings.length) {\n    return argument.option_strings.join('/');\n  } else if (![undefined, SUPPRESS].includes(argument.metavar)) {\n    return argument.metavar;\n  } else if (![undefined, SUPPRESS].includes(argument.dest)) {\n    return argument.dest;\n  } else {\n    return undefined;\n  }\n}\nconst ArgumentError = _callable(class ArgumentError extends Error {\n  /*\n   *  An error from creating or using an argument (optional or positional).\n   *\n   *  The string value of this exception is the message, augmented with\n   *  information about the argument that caused it.\n   */\n\n  constructor(argument, message) {\n    super();\n    this.name = 'ArgumentError';\n    this._argument_name = _get_action_name(argument);\n    this._message = message;\n    this.message = this.str();\n  }\n  str() {\n    let format;\n    if (this._argument_name === undefined) {\n      format = '%(message)s';\n    } else {\n      format = 'argument %(argument_name)s: %(message)s';\n    }\n    return sub(format, {\n      message: this._message,\n      argument_name: this._argument_name\n    });\n  }\n});\nconst ArgumentTypeError = _callable(class ArgumentTypeError extends Error {\n  /*\n   * An error from trying to convert a command line string to a type.\n   */\n\n  constructor(message) {\n    super(message);\n    this.name = 'ArgumentTypeError';\n  }\n});\n\n// ==============\n// Action classes\n// ==============\nconst Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {\n  /*\n   *  Information about how to convert command line strings to Python objects.\n   *\n   *  Action objects are used by an ArgumentParser to represent the information\n   *  needed to parse a single argument from one or more strings from the\n   *  command line. The keyword arguments to the Action constructor are also\n   *  all attributes of Action instances.\n   *\n   *  Keyword Arguments:\n   *\n   *      - option_strings -- A list of command-line option strings which\n   *          should be associated with this action.\n   *\n   *      - dest -- The name of the attribute to hold the created object(s)\n   *\n   *      - nargs -- The number of command-line arguments that should be\n   *          consumed. By default, one argument will be consumed and a single\n   *          value will be produced.  Other values include:\n   *              - N (an integer) consumes N arguments (and produces a list)\n   *              - '?' consumes zero or one arguments\n   *              - '*' consumes zero or more arguments (and produces a list)\n   *              - '+' consumes one or more arguments (and produces a list)\n   *          Note that the difference between the default and nargs=1 is that\n   *          with the default, a single value will be produced, while with\n   *          nargs=1, a list containing a single value will be produced.\n   *\n   *      - const -- The value to be produced if the option is specified and the\n   *          option uses an action that takes no values.\n   *\n   *      - default -- The value to be produced if the option is not specified.\n   *\n   *      - type -- A callable that accepts a single string argument, and\n   *          returns the converted value.  The standard Python types str, int,\n   *          float, and complex are useful examples of such callables.  If None,\n   *          str is used.\n   *\n   *      - choices -- A container of values that should be allowed. If not None,\n   *          after a command-line argument has been converted to the appropriate\n   *          type, an exception will be raised if it is not a member of this\n   *          collection.\n   *\n   *      - required -- True if the action must always be specified at the\n   *          command line. This is only meaningful for optional command-line\n   *          arguments.\n   *\n   *      - help -- The help string describing the argument.\n   *\n   *      - metavar -- The name to be used for the option's argument with the\n   *          help string. If None, the 'dest' value will be used as the name.\n   */\n\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    // when this class is called as a function, redirect it to .call() method of itself\n    super('return arguments.callee.call.apply(arguments.callee, arguments)');\n    this.option_strings = option_strings;\n    this.dest = dest;\n    this.nargs = nargs;\n    this.const = const_value;\n    this.default = default_value;\n    this.type = type;\n    this.choices = choices;\n    this.required = required;\n    this.help = help;\n    this.metavar = metavar;\n  }\n  _get_kwargs() {\n    let names = ['option_strings', 'dest', 'nargs', 'const', 'default', 'type', 'choices', 'help', 'metavar'];\n    return names.map(name => [name, getattr(this, name)]);\n  }\n  format_usage() {\n    return this.option_strings[0];\n  }\n  call( /*parser, namespace, values, option_string = undefined*/\n  ) {\n    throw new Error('.call() not defined');\n  }\n}));\nconst BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    let _option_strings = [];\n    for (let option_string of option_strings) {\n      _option_strings.push(option_string);\n      if (option_string.startsWith('--')) {\n        option_string = '--no-' + option_string.slice(2);\n        _option_strings.push(option_string);\n      }\n    }\n    if (help !== undefined && default_value !== undefined) {\n      help += ` (default: ${default_value})`;\n    }\n    super({\n      option_strings: _option_strings,\n      dest,\n      nargs: 0,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n  call(parser, namespace, values, option_string = undefined) {\n    if (this.option_strings.includes(option_string)) {\n      setattr(namespace, this.dest, !option_string.startsWith('--no-'));\n    }\n  }\n  format_usage() {\n    return this.option_strings.join(' | ');\n  }\n}));\nconst _StoreAction = _callable(class _StoreAction extends Action {\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    if (nargs === 0) {\n      throw new TypeError('nargs for store actions must be != 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store const may be more appropriate');\n    }\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n    super({\n      option_strings,\n      dest,\n      nargs,\n      const: const_value,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n  call(parser, namespace, values /*, option_string = undefined*/) {\n    setattr(namespace, this.dest, values);\n  }\n});\nconst _StoreConstAction = _callable(class _StoreConstAction extends Action {\n  constructor() {\n    let [option_strings, dest, const_value, default_value, required, help\n    //, metavar\n    ] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      const: no_default,\n      default: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required,\n      help\n    });\n  }\n  call(parser, namespace /*, values, option_string = undefined*/) {\n    setattr(namespace, this.dest, this.const);\n  }\n});\nconst _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: false,\n      required: false,\n      help: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      const: true,\n      default: default_value,\n      required,\n      help\n    });\n  }\n});\nconst _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: true,\n      required: false,\n      help: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      const: false,\n      default: default_value,\n      required,\n      help\n    });\n  }\n});\nconst _AppendAction = _callable(class _AppendAction extends Action {\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    if (nargs === 0) {\n      throw new TypeError('nargs for append actions must be != 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append const action may be more appropriate');\n    }\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n    super({\n      option_strings,\n      dest,\n      nargs,\n      const: const_value,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n  call(parser, namespace, values /*, option_string = undefined*/) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items.push(values);\n    setattr(namespace, this.dest, items);\n  }\n});\nconst _AppendConstAction = _callable(class _AppendConstAction extends Action {\n  constructor() {\n    let [option_strings, dest, const_value, default_value, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      const: no_default,\n      default: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required,\n      help,\n      metavar\n    });\n  }\n  call(parser, namespace /*, values, option_string = undefined*/) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items.push(this.const);\n    setattr(namespace, this.dest, items);\n  }\n});\nconst _CountAction = _callable(class _CountAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: undefined,\n      required: false,\n      help: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      default: default_value,\n      required,\n      help\n    });\n  }\n  call(parser, namespace /*, values, option_string = undefined*/) {\n    let count = getattr(namespace, this.dest, undefined);\n    if (count === undefined) {\n      count = 0;\n    }\n    setattr(namespace, this.dest, count + 1);\n  }\n});\nconst _HelpAction = _callable(class _HelpAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: SUPPRESS,\n      default: SUPPRESS,\n      help: undefined\n    });\n    super({\n      option_strings,\n      dest,\n      default: default_value,\n      nargs: 0,\n      help\n    });\n  }\n  call(parser /*, namespace, values, option_string = undefined*/) {\n    parser.print_help();\n    parser.exit();\n  }\n});\nconst _VersionAction = _callable(class _VersionAction extends Action {\n  constructor() {\n    let [option_strings, version, dest, default_value, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      version: undefined,\n      dest: SUPPRESS,\n      default: SUPPRESS,\n      help: \"show program's version number and exit\"\n    });\n    super({\n      option_strings,\n      dest,\n      default: default_value,\n      nargs: 0,\n      help\n    });\n    this.version = version;\n  }\n  call(parser /*, namespace, values, option_string = undefined*/) {\n    let version = this.version;\n    if (version === undefined) {\n      version = parser.version;\n    }\n    let formatter = parser._get_formatter();\n    formatter.add_text(version);\n    parser._print_message(formatter.format_help(), process.stdout);\n    parser.exit();\n  }\n});\nconst _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {\n  constructor() {\n    let [option_strings, prog, parser_class, dest, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      prog: no_default,\n      parser_class: no_default,\n      dest: SUPPRESS,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n    let name_parser_map = {};\n    super({\n      option_strings,\n      dest,\n      nargs: PARSER,\n      choices: name_parser_map,\n      required,\n      help,\n      metavar\n    });\n    this._prog_prefix = prog;\n    this._parser_class = parser_class;\n    this._name_parser_map = name_parser_map;\n    this._choices_actions = [];\n  }\n  add_parser() {\n    let [name, kwargs] = _parse_opts(arguments, {\n      name: no_default,\n      '**kwargs': no_default\n    });\n\n    // set prog from the existing prefix\n    if (kwargs.prog === undefined) {\n      kwargs.prog = sub('%s %s', this._prog_prefix, name);\n    }\n    let aliases = getattr(kwargs, 'aliases', []);\n    delete kwargs.aliases;\n\n    // create a pseudo-action to hold the choice help\n    if ('help' in kwargs) {\n      let help = kwargs.help;\n      delete kwargs.help;\n      let choice_action = this._ChoicesPseudoAction(name, aliases, help);\n      this._choices_actions.push(choice_action);\n    }\n\n    // create the parser and add it to the map\n    let parser = new this._parser_class(kwargs);\n    this._name_parser_map[name] = parser;\n\n    // make parser available under aliases also\n    for (let alias of aliases) {\n      this._name_parser_map[alias] = parser;\n    }\n    return parser;\n  }\n  _get_subactions() {\n    return this._choices_actions;\n  }\n  call(parser, namespace, values /*, option_string = undefined*/) {\n    let parser_name = values[0];\n    let arg_strings = values.slice(1);\n\n    // set the parser name if requested\n    if (this.dest !== SUPPRESS) {\n      setattr(namespace, this.dest, parser_name);\n    }\n\n    // select the parser\n    if (hasattr(this._name_parser_map, parser_name)) {\n      parser = this._name_parser_map[parser_name];\n    } else {\n      let args = {\n        parser_name,\n        choices: this._name_parser_map.join(', ')\n      };\n      let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args);\n      throw new ArgumentError(this, msg);\n    }\n\n    // parse all the remaining options into the namespace\n    // store any unrecognized options on the object, so that the top\n    // level parser can decide what to do with them\n\n    // In case this subparser defines new defaults, we parse them\n    // in a new namespace object and then update the original\n    // namespace for the relevant parts.\n    let subnamespace;\n    [subnamespace, arg_strings] = parser.parse_known_args(arg_strings, undefined);\n    for (let [key, value] of Object.entries(subnamespace)) {\n      setattr(namespace, key, value);\n    }\n    if (arg_strings.length) {\n      setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, []);\n      getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings);\n    }\n  }\n}));\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {\n  constructor(name, aliases, help) {\n    let metavar = name,\n      dest = name;\n    if (aliases.length) {\n      metavar += sub(' (%s)', aliases.join(', '));\n    }\n    super({\n      option_strings: [],\n      dest,\n      help,\n      metavar\n    });\n  }\n});\nconst _ExtendAction = _callable(class _ExtendAction extends _AppendAction {\n  call(parser, namespace, values /*, option_string = undefined*/) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items = items.concat(values);\n    setattr(namespace, this.dest, items);\n  }\n});\n\n// ==============\n// Type classes\n// ==============\nconst FileType = _callable(class FileType extends Function {\n  /*\n   *  Factory for creating file object types\n   *\n   *  Instances of FileType are typically passed as type= arguments to the\n   *  ArgumentParser add_argument() method.\n   *\n   *  Keyword Arguments:\n   *      - mode -- A string indicating how the file is to be opened. Accepts the\n   *          same values as the builtin open() function.\n   *      - bufsize -- The file's desired buffer size. Accepts the same values as\n   *          the builtin open() function.\n   *      - encoding -- The file's encoding. Accepts the same values as the\n   *          builtin open() function.\n   *      - errors -- A string indicating how encoding and decoding errors are to\n   *          be handled. Accepts the same value as the builtin open() function.\n   */\n\n  constructor() {\n    let [flags, encoding, mode, autoClose, emitClose, start, end, highWaterMark, fs] = _parse_opts(arguments, {\n      flags: 'r',\n      encoding: undefined,\n      mode: undefined,\n      // 0o666\n      autoClose: undefined,\n      // true\n      emitClose: undefined,\n      // false\n      start: undefined,\n      // 0\n      end: undefined,\n      // Infinity\n      highWaterMark: undefined,\n      // 64 * 1024\n      fs: undefined\n    });\n\n    // when this class is called as a function, redirect it to .call() method of itself\n    super('return arguments.callee.call.apply(arguments.callee, arguments)');\n    Object.defineProperty(this, 'name', {\n      get() {\n        return sub('FileType(%r)', flags);\n      }\n    });\n    this._flags = flags;\n    this._options = {};\n    if (encoding !== undefined) this._options.encoding = encoding;\n    if (mode !== undefined) this._options.mode = mode;\n    if (autoClose !== undefined) this._options.autoClose = autoClose;\n    if (emitClose !== undefined) this._options.emitClose = emitClose;\n    if (start !== undefined) this._options.start = start;\n    if (end !== undefined) this._options.end = end;\n    if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark;\n    if (fs !== undefined) this._options.fs = fs;\n  }\n  call(string) {\n    // the special argument \"-\" means sys.std{in,out}\n    if (string === '-') {\n      if (this._flags.includes('r')) {\n        return process.stdin;\n      } else if (this._flags.includes('w')) {\n        return process.stdout;\n      } else {\n        let msg = sub('argument \"-\" with mode %r', this._flags);\n        throw new TypeError(msg);\n      }\n    }\n\n    // all other arguments are used as file names\n    let fd;\n    try {\n      fd = fs.openSync(string, this._flags, this._options.mode);\n    } catch (e) {\n      let args = {\n        filename: string,\n        error: e.message\n      };\n      let message = \"can't open '%(filename)s': %(error)s\";\n      throw new ArgumentTypeError(sub(message, args));\n    }\n    let options = Object.assign({\n      fd,\n      flags: this._flags\n    }, this._options);\n    if (this._flags.includes('r')) {\n      return fs.createReadStream(undefined, options);\n    } else if (this._flags.includes('w')) {\n      return fs.createWriteStream(undefined, options);\n    } else {\n      let msg = sub('argument \"%s\" with mode %r', string, this._flags);\n      throw new TypeError(msg);\n    }\n  }\n  [util.inspect.custom]() {\n    let args = [this._flags];\n    let kwargs = Object.entries(this._options).map(([k, v]) => {\n      if (k === 'mode') v = {\n        value: v,\n        [util.inspect.custom]() {\n          return '0o' + this.value.toString(8);\n        }\n      };\n      return [k, v];\n    });\n    let args_str = [].concat(args.filter(arg => arg !== -1).map(repr)).concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined).map(([kw, arg]) => sub('%s=%r', kw, arg))).join(', ');\n    return sub('%s(%s)', this.constructor.name, args_str);\n  }\n  toString() {\n    return this[util.inspect.custom]();\n  }\n});\n\n// ===========================\n// Optional and Positional Parsing\n// ===========================\nconst Namespace = _callable(class Namespace extends _AttributeHolder() {\n  /*\n   *  Simple object for storing attributes.\n   *\n   *  Implements equality by attribute names and values, and provides a simple\n   *  string representation.\n   */\n\n  constructor(options = {}) {\n    super();\n    Object.assign(this, options);\n  }\n});\n\n// unset string tag to mimic plain object\nNamespace.prototype[Symbol.toStringTag] = undefined;\nconst _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {\n  constructor() {\n    let [description, prefix_chars, argument_default, conflict_handler] = _parse_opts(arguments, {\n      description: no_default,\n      prefix_chars: no_default,\n      argument_default: no_default,\n      conflict_handler: no_default\n    });\n    this.description = description;\n    this.argument_default = argument_default;\n    this.prefix_chars = prefix_chars;\n    this.conflict_handler = conflict_handler;\n\n    // set up registries\n    this._registries = {};\n\n    // register actions\n    this.register('action', undefined, _StoreAction);\n    this.register('action', 'store', _StoreAction);\n    this.register('action', 'store_const', _StoreConstAction);\n    this.register('action', 'store_true', _StoreTrueAction);\n    this.register('action', 'store_false', _StoreFalseAction);\n    this.register('action', 'append', _AppendAction);\n    this.register('action', 'append_const', _AppendConstAction);\n    this.register('action', 'count', _CountAction);\n    this.register('action', 'help', _HelpAction);\n    this.register('action', 'version', _VersionAction);\n    this.register('action', 'parsers', _SubParsersAction);\n    this.register('action', 'extend', _ExtendAction)\n    // LEGACY (v1 compatibility): camelcase variants\n    ;\n    ['storeConst', 'storeTrue', 'storeFalse', 'appendConst'].forEach(old_name => {\n      let new_name = _to_new_name(old_name);\n      this.register('action', old_name, util.deprecate(this._registry_get('action', new_name), sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)));\n    });\n    // end\n\n    // raise an exception if the conflict handler is invalid\n    this._get_handler();\n\n    // action storage\n    this._actions = [];\n    this._option_string_actions = {};\n\n    // groups\n    this._action_groups = [];\n    this._mutually_exclusive_groups = [];\n\n    // defaults storage\n    this._defaults = {};\n\n    // determines whether an \"option\" looks like a negative number\n    this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/;\n\n    // whether or not there are any optionals that look like negative\n    // numbers -- uses a list so it can be shared and edited\n    this._has_negative_number_optionals = [];\n  }\n\n  // ====================\n  // Registration methods\n  // ====================\n  register(registry_name, value, object) {\n    let registry = setdefault(this._registries, registry_name, {});\n    registry[value] = object;\n  }\n  _registry_get(registry_name, value, default_value = undefined) {\n    return getattr(this._registries[registry_name], value, default_value);\n  }\n\n  // ==================================\n  // Namespace default accessor methods\n  // ==================================\n  set_defaults(kwargs) {\n    Object.assign(this._defaults, kwargs);\n\n    // if these defaults match any existing arguments, replace\n    // the previous default on the object with the new one\n    for (let action of this._actions) {\n      if (action.dest in kwargs) {\n        action.default = kwargs[action.dest];\n      }\n    }\n  }\n  get_default(dest) {\n    for (let action of this._actions) {\n      if (action.dest === dest && action.default !== undefined) {\n        return action.default;\n      }\n    }\n    return this._defaults[dest];\n  }\n\n  // =======================\n  // Adding argument actions\n  // =======================\n  add_argument() {\n    /*\n     *  add_argument(dest, ..., name=value, ...)\n     *  add_argument(option_string, option_string, ..., name=value, ...)\n     */\n    let [args, kwargs] = _parse_opts(arguments, {\n      '*args': no_default,\n      '**kwargs': no_default\n    });\n    // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })\n    if (args.length === 1 && Array.isArray(args[0])) {\n      args = args[0];\n      deprecate('argument-array', sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n        args: args.map(repr).join(', ')\n      }));\n    }\n    // end\n\n    // if no positional args are supplied or only one is supplied and\n    // it doesn't look like an option string, parse a positional\n    // argument\n    let chars = this.prefix_chars;\n    if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n      if (args.length && 'dest' in kwargs) {\n        throw new TypeError('dest supplied twice for positional argument');\n      }\n      kwargs = this._get_positional_kwargs(...args, kwargs);\n\n      // otherwise, we're adding an optional argument\n    } else {\n      kwargs = this._get_optional_kwargs(...args, kwargs);\n    }\n\n    // if no default was supplied, use the parser-level default\n    if (!('default' in kwargs)) {\n      let dest = kwargs.dest;\n      if (dest in this._defaults) {\n        kwargs.default = this._defaults[dest];\n      } else if (this.argument_default !== undefined) {\n        kwargs.default = this.argument_default;\n      }\n    }\n\n    // create the action object, and add it to the parser\n    let action_class = this._pop_action_class(kwargs);\n    if (typeof action_class !== 'function') {\n      throw new TypeError(sub('unknown action \"%s\"', action_class));\n    }\n    // eslint-disable-next-line new-cap\n    let action = new action_class(kwargs);\n\n    // raise an error if the action type is not callable\n    let type_func = this._registry_get('type', action.type, action.type);\n    if (typeof type_func !== 'function') {\n      throw new TypeError(sub('%r is not callable', type_func));\n    }\n    if (type_func === FileType) {\n      throw new TypeError(sub('%r is a FileType class object, instance of it' + ' must be passed', type_func));\n    }\n\n    // raise an error if the metavar does not match the type\n    if ('_get_formatter' in this) {\n      try {\n        this._get_formatter()._format_args(action, undefined);\n      } catch (err) {\n        // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same\n        if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n          throw new TypeError('length of metavar tuple does not match nargs');\n        } else {\n          throw err;\n        }\n      }\n    }\n    return this._add_action(action);\n  }\n  add_argument_group() {\n    let group = _ArgumentGroup(this, ...arguments);\n    this._action_groups.push(group);\n    return group;\n  }\n  add_mutually_exclusive_group() {\n    // eslint-disable-next-line no-use-before-define\n    let group = _MutuallyExclusiveGroup(this, ...arguments);\n    this._mutually_exclusive_groups.push(group);\n    return group;\n  }\n  _add_action(action) {\n    // resolve any conflicts\n    this._check_conflict(action);\n\n    // add to actions list\n    this._actions.push(action);\n    action.container = this;\n\n    // index the action by any option strings it has\n    for (let option_string of action.option_strings) {\n      this._option_string_actions[option_string] = action;\n    }\n\n    // set the flag if any option strings look like negative numbers\n    for (let option_string of action.option_strings) {\n      if (this._negative_number_matcher.test(option_string)) {\n        if (!this._has_negative_number_optionals.length) {\n          this._has_negative_number_optionals.push(true);\n        }\n      }\n    }\n\n    // return the created action\n    return action;\n  }\n  _remove_action(action) {\n    _array_remove(this._actions, action);\n  }\n  _add_container_actions(container) {\n    // collect groups by titles\n    let title_group_map = {};\n    for (let group of this._action_groups) {\n      if (group.title in title_group_map) {\n        let msg = 'cannot merge actions - two groups are named %r';\n        throw new TypeError(sub(msg, group.title));\n      }\n      title_group_map[group.title] = group;\n    }\n\n    // map each action to its group\n    let group_map = new Map();\n    for (let group of container._action_groups) {\n      // if a group with the title exists, use that, otherwise\n      // create a new group matching the container's group\n      if (!(group.title in title_group_map)) {\n        title_group_map[group.title] = this.add_argument_group({\n          title: group.title,\n          description: group.description,\n          conflict_handler: group.conflict_handler\n        });\n      }\n\n      // map the actions to their new group\n      for (let action of group._group_actions) {\n        group_map.set(action, title_group_map[group.title]);\n      }\n    }\n\n    // add container's mutually exclusive groups\n    // NOTE: if add_mutually_exclusive_group ever gains title= and\n    // description= then this code will need to be expanded as above\n    for (let group of container._mutually_exclusive_groups) {\n      let mutex_group = this.add_mutually_exclusive_group({\n        required: group.required\n      });\n\n      // map the actions to their new mutex group\n      for (let action of group._group_actions) {\n        group_map.set(action, mutex_group);\n      }\n    }\n\n    // add all actions to this container or their group\n    for (let action of container._actions) {\n      group_map.get(action)._add_action(action);\n    }\n  }\n  _get_positional_kwargs() {\n    let [dest, kwargs] = _parse_opts(arguments, {\n      dest: no_default,\n      '**kwargs': no_default\n    });\n\n    // make sure required is not specified\n    if ('required' in kwargs) {\n      let msg = \"'required' is an invalid argument for positionals\";\n      throw new TypeError(msg);\n    }\n\n    // mark positional arguments as required if at least one is\n    // always required\n    if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n      kwargs.required = true;\n    }\n    if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n      kwargs.required = true;\n    }\n\n    // return the keyword arguments with no option strings\n    return Object.assign(kwargs, {\n      dest,\n      option_strings: []\n    });\n  }\n  _get_optional_kwargs() {\n    let [args, kwargs] = _parse_opts(arguments, {\n      '*args': no_default,\n      '**kwargs': no_default\n    });\n\n    // determine short and long option strings\n    let option_strings = [];\n    let long_option_strings = [];\n    let option_string;\n    for (option_string of args) {\n      // error on strings that don't start with an appropriate prefix\n      if (!this.prefix_chars.includes(option_string[0])) {\n        let args = {\n          option: option_string,\n          prefix_chars: this.prefix_chars\n        };\n        let msg = 'invalid option string %(option)r: ' + 'must start with a character %(prefix_chars)r';\n        throw new TypeError(sub(msg, args));\n      }\n\n      // strings starting with two prefix characters are long options\n      option_strings.push(option_string);\n      if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n        long_option_strings.push(option_string);\n      }\n    }\n\n    // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n    let dest = kwargs.dest;\n    delete kwargs.dest;\n    if (dest === undefined) {\n      let dest_option_string;\n      if (long_option_strings.length) {\n        dest_option_string = long_option_strings[0];\n      } else {\n        dest_option_string = option_strings[0];\n      }\n      dest = _string_lstrip(dest_option_string, this.prefix_chars);\n      if (!dest) {\n        let msg = 'dest= is required for options like %r';\n        throw new TypeError(sub(msg, option_string));\n      }\n      dest = dest.replace(/-/g, '_');\n    }\n\n    // return the updated keyword arguments\n    return Object.assign(kwargs, {\n      dest,\n      option_strings\n    });\n  }\n  _pop_action_class(kwargs, default_value = undefined) {\n    let action = getattr(kwargs, 'action', default_value);\n    delete kwargs.action;\n    return this._registry_get('action', action, action);\n  }\n  _get_handler() {\n    // determine function from conflict handler string\n    let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler);\n    if (typeof this[handler_func_name] === 'function') {\n      return this[handler_func_name];\n    } else {\n      let msg = 'invalid conflict_resolution value: %r';\n      throw new TypeError(sub(msg, this.conflict_handler));\n    }\n  }\n  _check_conflict(action) {\n    // find all options that conflict with this option\n    let confl_optionals = [];\n    for (let option_string of action.option_strings) {\n      if (hasattr(this._option_string_actions, option_string)) {\n        let confl_optional = this._option_string_actions[option_string];\n        confl_optionals.push([option_string, confl_optional]);\n      }\n    }\n\n    // resolve any conflicts\n    if (confl_optionals.length) {\n      let conflict_handler = this._get_handler();\n      conflict_handler.call(this, action, confl_optionals);\n    }\n  }\n  _handle_conflict_error(action, conflicting_actions) {\n    let message = conflicting_actions.length === 1 ? 'conflicting option string: %s' : 'conflicting option strings: %s';\n    let conflict_string = conflicting_actions.map(([option_string /*, action*/]) => option_string).join(', ');\n    throw new ArgumentError(action, sub(message, conflict_string));\n  }\n  _handle_conflict_resolve(action, conflicting_actions) {\n    // remove all conflicting options\n    for (let [option_string, action] of conflicting_actions) {\n      // remove the conflicting option\n      _array_remove(action.option_strings, option_string);\n      delete this._option_string_actions[option_string];\n\n      // if the option now has no option string, remove it from the\n      // container holding it\n      if (!action.option_strings.length) {\n        action.container._remove_action(action);\n      }\n    }\n  }\n}));\nconst _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {\n  constructor() {\n    let [container, title, description, kwargs] = _parse_opts(arguments, {\n      container: no_default,\n      title: undefined,\n      description: undefined,\n      '**kwargs': no_default\n    });\n\n    // add any missing keyword arguments by checking the container\n    setdefault(kwargs, 'conflict_handler', container.conflict_handler);\n    setdefault(kwargs, 'prefix_chars', container.prefix_chars);\n    setdefault(kwargs, 'argument_default', container.argument_default);\n    super(Object.assign({\n      description\n    }, kwargs));\n\n    // group attributes\n    this.title = title;\n    this._group_actions = [];\n\n    // share most attributes with the container\n    this._registries = container._registries;\n    this._actions = container._actions;\n    this._option_string_actions = container._option_string_actions;\n    this._defaults = container._defaults;\n    this._has_negative_number_optionals = container._has_negative_number_optionals;\n    this._mutually_exclusive_groups = container._mutually_exclusive_groups;\n  }\n  _add_action(action) {\n    action = super._add_action(action);\n    this._group_actions.push(action);\n    return action;\n  }\n  _remove_action(action) {\n    super._remove_action(action);\n    _array_remove(this._group_actions, action);\n  }\n});\nconst _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {\n  constructor() {\n    let [container, required] = _parse_opts(arguments, {\n      container: no_default,\n      required: false\n    });\n    super(container);\n    this.required = required;\n    this._container = container;\n  }\n  _add_action(action) {\n    if (action.required) {\n      let msg = 'mutually exclusive arguments must be optional';\n      throw new TypeError(msg);\n    }\n    action = this._container._add_action(action);\n    this._group_actions.push(action);\n    return action;\n  }\n  _remove_action(action) {\n    this._container._remove_action(action);\n    _array_remove(this._group_actions, action);\n  }\n});\nconst ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {\n  /*\n   *  Object for parsing command line strings into Python objects.\n   *\n   *  Keyword Arguments:\n   *      - prog -- The name of the program (default: sys.argv[0])\n   *      - usage -- A usage message (default: auto-generated from arguments)\n   *      - description -- A description of what the program does\n   *      - epilog -- Text following the argument descriptions\n   *      - parents -- Parsers whose arguments should be copied into this one\n   *      - formatter_class -- HelpFormatter class for printing help messages\n   *      - prefix_chars -- Characters that prefix optional arguments\n   *      - fromfile_prefix_chars -- Characters that prefix files containing\n   *          additional arguments\n   *      - argument_default -- The default value for all arguments\n   *      - conflict_handler -- String indicating how to handle conflicts\n   *      - add_help -- Add a -h/-help option\n   *      - allow_abbrev -- Allow long options to be abbreviated unambiguously\n   *      - exit_on_error -- Determines whether or not ArgumentParser exits with\n   *          error info when an error occurs\n   */\n\n  constructor() {\n    let [prog, usage, description, epilog, parents, formatter_class, prefix_chars, fromfile_prefix_chars, argument_default, conflict_handler, add_help, allow_abbrev, exit_on_error, debug,\n    // LEGACY (v1 compatibility), debug mode\n    version // LEGACY (v1 compatibility), version\n    ] = _parse_opts(arguments, {\n      prog: undefined,\n      usage: undefined,\n      description: undefined,\n      epilog: undefined,\n      parents: [],\n      formatter_class: HelpFormatter,\n      prefix_chars: '-',\n      fromfile_prefix_chars: undefined,\n      argument_default: undefined,\n      conflict_handler: 'error',\n      add_help: true,\n      allow_abbrev: true,\n      exit_on_error: true,\n      debug: undefined,\n      // LEGACY (v1 compatibility), debug mode\n      version: undefined // LEGACY (v1 compatibility), version\n    });\n\n    // LEGACY (v1 compatibility)\n    if (debug !== undefined) {\n      deprecate('debug', 'The \"debug\" argument to ArgumentParser is deprecated. Please ' + 'override ArgumentParser.exit function instead.');\n    }\n    if (version !== undefined) {\n      deprecate('version', 'The \"version\" argument to ArgumentParser is deprecated. Please use ' + \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\");\n    }\n    // end\n\n    super({\n      description,\n      prefix_chars,\n      argument_default,\n      conflict_handler\n    });\n\n    // default setting for prog\n    if (prog === undefined) {\n      prog = path.basename(get_argv()[0] || '');\n    }\n    this.prog = prog;\n    this.usage = usage;\n    this.epilog = epilog;\n    this.formatter_class = formatter_class;\n    this.fromfile_prefix_chars = fromfile_prefix_chars;\n    this.add_help = add_help;\n    this.allow_abbrev = allow_abbrev;\n    this.exit_on_error = exit_on_error;\n    // LEGACY (v1 compatibility), debug mode\n    this.debug = debug;\n    // end\n\n    this._positionals = this.add_argument_group('positional arguments');\n    this._optionals = this.add_argument_group('optional arguments');\n    this._subparsers = undefined;\n\n    // register types\n    function identity(string) {\n      return string;\n    }\n    this.register('type', undefined, identity);\n    this.register('type', null, identity);\n    this.register('type', 'auto', identity);\n    this.register('type', 'int', function (x) {\n      let result = Number(x);\n      if (!Number.isInteger(result)) {\n        throw new TypeError(sub('could not convert string to int: %r', x));\n      }\n      return result;\n    });\n    this.register('type', 'float', function (x) {\n      let result = Number(x);\n      if (isNaN(result)) {\n        throw new TypeError(sub('could not convert string to float: %r', x));\n      }\n      return result;\n    });\n    this.register('type', 'str', String);\n    // LEGACY (v1 compatibility): custom types\n    this.register('type', 'string', util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}'));\n    // end\n\n    // add help argument if necessary\n    // (using explicit default to override global argument_default)\n    let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0];\n    if (this.add_help) {\n      this.add_argument(default_prefix + 'h', default_prefix.repeat(2) + 'help', {\n        action: 'help',\n        default: SUPPRESS,\n        help: 'show this help message and exit'\n      });\n    }\n    // LEGACY (v1 compatibility), version\n    if (version) {\n      this.add_argument(default_prefix + 'v', default_prefix.repeat(2) + 'version', {\n        action: 'version',\n        default: SUPPRESS,\n        version: this.version,\n        help: \"show program's version number and exit\"\n      });\n    }\n    // end\n\n    // add parent arguments and defaults\n    for (let parent of parents) {\n      this._add_container_actions(parent);\n      Object.assign(this._defaults, parent._defaults);\n    }\n  }\n\n  // =======================\n  // Pretty __repr__ methods\n  // =======================\n  _get_kwargs() {\n    let names = ['prog', 'usage', 'description', 'formatter_class', 'conflict_handler', 'add_help'];\n    return names.map(name => [name, getattr(this, name)]);\n  }\n\n  // ==================================\n  // Optional/Positional adding methods\n  // ==================================\n  add_subparsers() {\n    let [kwargs] = _parse_opts(arguments, {\n      '**kwargs': no_default\n    });\n    if (this._subparsers !== undefined) {\n      this.error('cannot have multiple subparser arguments');\n    }\n\n    // add the parser class to the arguments if it's not present\n    setdefault(kwargs, 'parser_class', this.constructor);\n    if ('title' in kwargs || 'description' in kwargs) {\n      let title = getattr(kwargs, 'title', 'subcommands');\n      let description = getattr(kwargs, 'description', undefined);\n      delete kwargs.title;\n      delete kwargs.description;\n      this._subparsers = this.add_argument_group(title, description);\n    } else {\n      this._subparsers = this._positionals;\n    }\n\n    // prog defaults to the usage message of this parser, skipping\n    // optional arguments and with no \"usage:\" prefix\n    if (kwargs.prog === undefined) {\n      let formatter = this._get_formatter();\n      let positionals = this._get_positional_actions();\n      let groups = this._mutually_exclusive_groups;\n      formatter.add_usage(this.usage, positionals, groups, '');\n      kwargs.prog = formatter.format_help().trim();\n    }\n\n    // create the parsers action and add it to the positionals list\n    let parsers_class = this._pop_action_class(kwargs, 'parsers');\n    // eslint-disable-next-line new-cap\n    let action = new parsers_class(Object.assign({\n      option_strings: []\n    }, kwargs));\n    this._subparsers._add_action(action);\n\n    // return the created parsers action\n    return action;\n  }\n  _add_action(action) {\n    if (action.option_strings.length) {\n      this._optionals._add_action(action);\n    } else {\n      this._positionals._add_action(action);\n    }\n    return action;\n  }\n  _get_optional_actions() {\n    return this._actions.filter(action => action.option_strings.length);\n  }\n  _get_positional_actions() {\n    return this._actions.filter(action => !action.option_strings.length);\n  }\n\n  // =====================================\n  // Command line argument parsing methods\n  // =====================================\n  parse_args(args = undefined, namespace = undefined) {\n    let argv;\n    [args, argv] = this.parse_known_args(args, namespace);\n    if (argv && argv.length > 0) {\n      let msg = 'unrecognized arguments: %s';\n      this.error(sub(msg, argv.join(' ')));\n    }\n    return args;\n  }\n  parse_known_args(args = undefined, namespace = undefined) {\n    if (args === undefined) {\n      args = get_argv().slice(1);\n    }\n\n    // default Namespace built from parser defaults\n    if (namespace === undefined) {\n      namespace = new Namespace();\n    }\n\n    // add any action defaults that aren't present\n    for (let action of this._actions) {\n      if (action.dest !== SUPPRESS) {\n        if (!hasattr(namespace, action.dest)) {\n          if (action.default !== SUPPRESS) {\n            setattr(namespace, action.dest, action.default);\n          }\n        }\n      }\n    }\n\n    // add any parser defaults that aren't present\n    for (let dest of Object.keys(this._defaults)) {\n      if (!hasattr(namespace, dest)) {\n        setattr(namespace, dest, this._defaults[dest]);\n      }\n    }\n\n    // parse the arguments and exit if there are any errors\n    if (this.exit_on_error) {\n      try {\n        [namespace, args] = this._parse_known_args(args, namespace);\n      } catch (err) {\n        if (err instanceof ArgumentError) {\n          this.error(err.message);\n        } else {\n          throw err;\n        }\n      }\n    } else {\n      [namespace, args] = this._parse_known_args(args, namespace);\n    }\n    if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n      args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR));\n      delattr(namespace, _UNRECOGNIZED_ARGS_ATTR);\n    }\n    return [namespace, args];\n  }\n  _parse_known_args(arg_strings, namespace) {\n    // replace arg strings that are file references\n    if (this.fromfile_prefix_chars !== undefined) {\n      arg_strings = this._read_args_from_files(arg_strings);\n    }\n\n    // map all mutually exclusive arguments to the other arguments\n    // they can't occur with\n    let action_conflicts = new Map();\n    for (let mutex_group of this._mutually_exclusive_groups) {\n      let group_actions = mutex_group._group_actions;\n      for (let [i, mutex_action] of Object.entries(mutex_group._group_actions)) {\n        let conflicts = action_conflicts.get(mutex_action) || [];\n        conflicts = conflicts.concat(group_actions.slice(0, +i));\n        conflicts = conflicts.concat(group_actions.slice(+i + 1));\n        action_conflicts.set(mutex_action, conflicts);\n      }\n    }\n\n    // find all option indices, and determine the arg_string_pattern\n    // which has an 'O' if there is an option at an index,\n    // an 'A' if there is an argument, or a '-' if there is a '--'\n    let option_string_indices = {};\n    let arg_string_pattern_parts = [];\n    let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]();\n    for (let [i, arg_string] of arg_strings_iter) {\n      // all args after -- are non-options\n      if (arg_string === '--') {\n        arg_string_pattern_parts.push('-');\n        for ([i, arg_string] of arg_strings_iter) {\n          arg_string_pattern_parts.push('A');\n        }\n\n        // otherwise, add the arg to the arg strings\n        // and note the index if it was an option\n      } else {\n        let option_tuple = this._parse_optional(arg_string);\n        let pattern;\n        if (option_tuple === undefined) {\n          pattern = 'A';\n        } else {\n          option_string_indices[i] = option_tuple;\n          pattern = 'O';\n        }\n        arg_string_pattern_parts.push(pattern);\n      }\n    }\n\n    // join the pieces together to form the pattern\n    let arg_strings_pattern = arg_string_pattern_parts.join('');\n\n    // converts arg strings to the appropriate and then takes the action\n    let seen_actions = new Set();\n    let seen_non_default_actions = new Set();\n    let extras;\n    let take_action = (action, argument_strings, option_string = undefined) => {\n      seen_actions.add(action);\n      let argument_values = this._get_values(action, argument_strings);\n\n      // error if this argument is not allowed with other previously\n      // seen arguments, assuming that actions that use the default\n      // value don't really count as \"present\"\n      if (argument_values !== action.default) {\n        seen_non_default_actions.add(action);\n        for (let conflict_action of action_conflicts.get(action) || []) {\n          if (seen_non_default_actions.has(conflict_action)) {\n            let msg = 'not allowed with argument %s';\n            let action_name = _get_action_name(conflict_action);\n            throw new ArgumentError(action, sub(msg, action_name));\n          }\n        }\n      }\n\n      // take the action if we didn't receive a SUPPRESS value\n      // (e.g. from a default)\n      if (argument_values !== SUPPRESS) {\n        action(this, namespace, argument_values, option_string);\n      }\n    };\n\n    // function to convert arg_strings into an optional action\n    let consume_optional = start_index => {\n      // get the optional identified at this index\n      let option_tuple = option_string_indices[start_index];\n      let [action, option_string, explicit_arg] = option_tuple;\n\n      // identify additional optionals in the same arg string\n      // (e.g. -xyz is the same as -x -y -z if no args are required)\n      let action_tuples = [];\n      let stop;\n      for (;;) {\n        // if we found no optional action, skip it\n        if (action === undefined) {\n          extras.push(arg_strings[start_index]);\n          return start_index + 1;\n        }\n\n        // if there is an explicit argument, try to match the\n        // optional's string arguments to only this\n        if (explicit_arg !== undefined) {\n          let arg_count = this._match_argument(action, 'A');\n\n          // if the action is a single-dash option and takes no\n          // arguments, try to parse more single-dash options out\n          // of the tail of the option string\n          let chars = this.prefix_chars;\n          if (arg_count === 0 && !chars.includes(option_string[1])) {\n            action_tuples.push([action, [], option_string]);\n            let char = option_string[0];\n            option_string = char + explicit_arg[0];\n            let new_explicit_arg = explicit_arg.slice(1) || undefined;\n            let optionals_map = this._option_string_actions;\n            if (hasattr(optionals_map, option_string)) {\n              action = optionals_map[option_string];\n              explicit_arg = new_explicit_arg;\n            } else {\n              let msg = 'ignored explicit argument %r';\n              throw new ArgumentError(action, sub(msg, explicit_arg));\n            }\n\n            // if the action expect exactly one argument, we've\n            // successfully matched the option; exit the loop\n          } else if (arg_count === 1) {\n            stop = start_index + 1;\n            let args = [explicit_arg];\n            action_tuples.push([action, args, option_string]);\n            break;\n\n            // error if a double-dash option did not use the\n            // explicit argument\n          } else {\n            let msg = 'ignored explicit argument %r';\n            throw new ArgumentError(action, sub(msg, explicit_arg));\n          }\n\n          // if there is no explicit argument, try to match the\n          // optional's string arguments with the following strings\n          // if successful, exit the loop\n        } else {\n          let start = start_index + 1;\n          let selected_patterns = arg_strings_pattern.slice(start);\n          let arg_count = this._match_argument(action, selected_patterns);\n          stop = start + arg_count;\n          let args = arg_strings.slice(start, stop);\n          action_tuples.push([action, args, option_string]);\n          break;\n        }\n      }\n\n      // add the Optional to the list and return the index at which\n      // the Optional's string args stopped\n      assert(action_tuples.length);\n      for (let [action, args, option_string] of action_tuples) {\n        take_action(action, args, option_string);\n      }\n      return stop;\n    };\n\n    // the list of Positionals left to be parsed; this is modified\n    // by consume_positionals()\n    let positionals = this._get_positional_actions();\n\n    // function to convert arg_strings into positional actions\n    let consume_positionals = start_index => {\n      // match as many Positionals as possible\n      let selected_pattern = arg_strings_pattern.slice(start_index);\n      let arg_counts = this._match_arguments_partial(positionals, selected_pattern);\n\n      // slice off the appropriate arg strings for each Positional\n      // and add the Positional and its args to the list\n      for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {\n        let action = positionals[i];\n        let arg_count = arg_counts[i];\n        let args = arg_strings.slice(start_index, start_index + arg_count);\n        start_index += arg_count;\n        take_action(action, args);\n      }\n\n      // slice off the Positionals that we just parsed and return the\n      // index at which the Positionals' string args stopped\n      positionals = positionals.slice(arg_counts.length);\n      return start_index;\n    };\n\n    // consume Positionals and Optionals alternately, until we have\n    // passed the last option string\n    extras = [];\n    let start_index = 0;\n    let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number));\n    while (start_index <= max_option_string_index) {\n      // consume any Positionals preceding the next option\n      let next_option_string_index = Math.min(\n      // eslint-disable-next-line no-loop-func\n      ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index));\n      if (start_index !== next_option_string_index) {\n        let positionals_end_index = consume_positionals(start_index);\n\n        // only try to parse the next optional if we didn't consume\n        // the option string during the positionals parsing\n        if (positionals_end_index > start_index) {\n          start_index = positionals_end_index;\n          continue;\n        } else {\n          start_index = positionals_end_index;\n        }\n      }\n\n      // if we consumed all the positionals we could and we're not\n      // at the index of an option string, there were extra arguments\n      if (!(start_index in option_string_indices)) {\n        let strings = arg_strings.slice(start_index, next_option_string_index);\n        extras = extras.concat(strings);\n        start_index = next_option_string_index;\n      }\n\n      // consume the next optional and any arguments for it\n      start_index = consume_optional(start_index);\n    }\n\n    // consume any positionals following the last Optional\n    let stop_index = consume_positionals(start_index);\n\n    // if we didn't consume all the argument strings, there were extras\n    extras = extras.concat(arg_strings.slice(stop_index));\n\n    // make sure all required actions were present and also convert\n    // action defaults which were not given as arguments\n    let required_actions = [];\n    for (let action of this._actions) {\n      if (!seen_actions.has(action)) {\n        if (action.required) {\n          required_actions.push(_get_action_name(action));\n        } else {\n          // Convert action default now instead of doing it before\n          // parsing arguments to avoid calling convert functions\n          // twice (which may fail) if the argument was given, but\n          // only if it was defined already in the namespace\n          if (action.default !== undefined && typeof action.default === 'string' && hasattr(namespace, action.dest) && action.default === getattr(namespace, action.dest)) {\n            setattr(namespace, action.dest, this._get_value(action, action.default));\n          }\n        }\n      }\n    }\n    if (required_actions.length) {\n      this.error(sub('the following arguments are required: %s', required_actions.join(', ')));\n    }\n\n    // make sure all required groups had one option present\n    for (let group of this._mutually_exclusive_groups) {\n      if (group.required) {\n        let no_actions_used = true;\n        for (let action of group._group_actions) {\n          if (seen_non_default_actions.has(action)) {\n            no_actions_used = false;\n            break;\n          }\n        }\n\n        // if no actions were used, report the error\n        if (no_actions_used) {\n          let names = group._group_actions.filter(action => action.help !== SUPPRESS).map(action => _get_action_name(action));\n          let msg = 'one of the arguments %s is required';\n          this.error(sub(msg, names.join(' ')));\n        }\n      }\n    }\n\n    // return the updated namespace and the extra arguments\n    return [namespace, extras];\n  }\n  _read_args_from_files(arg_strings) {\n    // expand arguments referencing files\n    let new_arg_strings = [];\n    for (let arg_string of arg_strings) {\n      // for regular arguments, just add them back into the list\n      if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n        new_arg_strings.push(arg_string);\n\n        // replace arguments referencing files with the file content\n      } else {\n        try {\n          let args_file = fs.readFileSync(arg_string.slice(1), 'utf8');\n          let arg_strings = [];\n          for (let arg_line of splitlines(args_file)) {\n            for (let arg of this.convert_arg_line_to_args(arg_line)) {\n              arg_strings.push(arg);\n            }\n          }\n          arg_strings = this._read_args_from_files(arg_strings);\n          new_arg_strings = new_arg_strings.concat(arg_strings);\n        } catch (err) {\n          this.error(err.message);\n        }\n      }\n    }\n\n    // return the modified argument list\n    return new_arg_strings;\n  }\n  convert_arg_line_to_args(arg_line) {\n    return [arg_line];\n  }\n  _match_argument(action, arg_strings_pattern) {\n    // match the pattern for this action to the arg strings\n    let nargs_pattern = this._get_nargs_pattern(action);\n    let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern));\n\n    // raise an exception if we weren't able to find a match\n    if (match === null) {\n      let nargs_errors = {\n        undefined: 'expected one argument',\n        [OPTIONAL]: 'expected at most one argument',\n        [ONE_OR_MORE]: 'expected at least one argument'\n      };\n      let msg = nargs_errors[action.nargs];\n      if (msg === undefined) {\n        msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs);\n      }\n      throw new ArgumentError(action, msg);\n    }\n\n    // return the number of arguments matched\n    return match[1].length;\n  }\n  _match_arguments_partial(actions, arg_strings_pattern) {\n    // progressively shorten the actions list by slicing off the\n    // final actions until we find a match\n    let result = [];\n    for (let i of range(actions.length, 0, -1)) {\n      let actions_slice = actions.slice(0, i);\n      let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('');\n      let match = arg_strings_pattern.match(new RegExp('^' + pattern));\n      if (match !== null) {\n        result = result.concat(match.slice(1).map(string => string.length));\n        break;\n      }\n    }\n\n    // return the list of arg string counts\n    return result;\n  }\n  _parse_optional(arg_string) {\n    // if it's an empty string, it was meant to be a positional\n    if (!arg_string) {\n      return undefined;\n    }\n\n    // if it doesn't start with a prefix, it was meant to be positional\n    if (!this.prefix_chars.includes(arg_string[0])) {\n      return undefined;\n    }\n\n    // if the option string is present in the parser, return the action\n    if (arg_string in this._option_string_actions) {\n      let action = this._option_string_actions[arg_string];\n      return [action, arg_string, undefined];\n    }\n\n    // if it's just a single character, it was meant to be positional\n    if (arg_string.length === 1) {\n      return undefined;\n    }\n\n    // if the option string before the \"=\" is present, return the action\n    if (arg_string.includes('=')) {\n      let [option_string, explicit_arg] = _string_split(arg_string, '=', 1);\n      if (option_string in this._option_string_actions) {\n        let action = this._option_string_actions[option_string];\n        return [action, option_string, explicit_arg];\n      }\n    }\n\n    // search through all possible prefixes of the option string\n    // and all actions in the parser for possible interpretations\n    let option_tuples = this._get_option_tuples(arg_string);\n\n    // if multiple actions match, the option string was ambiguous\n    if (option_tuples.length > 1) {\n      let options = option_tuples.map(([/*action*/, option_string /*, explicit_arg*/]) => option_string).join(', ');\n      let args = {\n        option: arg_string,\n        matches: options\n      };\n      let msg = 'ambiguous option: %(option)s could match %(matches)s';\n      this.error(sub(msg, args));\n\n      // if exactly one action matched, this segmentation is good,\n      // so return the parsed action\n    } else if (option_tuples.length === 1) {\n      let [option_tuple] = option_tuples;\n      return option_tuple;\n    }\n\n    // if it was not found as an option, but it looks like a negative\n    // number, it was meant to be positional\n    // unless there are negative-number-like options\n    if (this._negative_number_matcher.test(arg_string)) {\n      if (!this._has_negative_number_optionals.length) {\n        return undefined;\n      }\n    }\n\n    // if it contains a space, it was meant to be a positional\n    if (arg_string.includes(' ')) {\n      return undefined;\n    }\n\n    // it was meant to be an optional but there is no such option\n    // in this parser (though it might be a valid option in a subparser)\n    return [undefined, arg_string, undefined];\n  }\n  _get_option_tuples(option_string) {\n    let result = [];\n\n    // option strings starting with two prefix characters are only\n    // split at the '='\n    let chars = this.prefix_chars;\n    if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n      if (this.allow_abbrev) {\n        let option_prefix, explicit_arg;\n        if (option_string.includes('=')) {\n          [option_prefix, explicit_arg] = _string_split(option_string, '=', 1);\n        } else {\n          option_prefix = option_string;\n          explicit_arg = undefined;\n        }\n        for (let option_string of Object.keys(this._option_string_actions)) {\n          if (option_string.startsWith(option_prefix)) {\n            let action = this._option_string_actions[option_string];\n            let tup = [action, option_string, explicit_arg];\n            result.push(tup);\n          }\n        }\n      }\n\n      // single character options can be concatenated with their arguments\n      // but multiple character options always have to have their argument\n      // separate\n    } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n      let option_prefix = option_string;\n      let explicit_arg = undefined;\n      let short_option_prefix = option_string.slice(0, 2);\n      let short_explicit_arg = option_string.slice(2);\n      for (let option_string of Object.keys(this._option_string_actions)) {\n        if (option_string === short_option_prefix) {\n          let action = this._option_string_actions[option_string];\n          let tup = [action, option_string, short_explicit_arg];\n          result.push(tup);\n        } else if (option_string.startsWith(option_prefix)) {\n          let action = this._option_string_actions[option_string];\n          let tup = [action, option_string, explicit_arg];\n          result.push(tup);\n        }\n      }\n\n      // shouldn't ever get here\n    } else {\n      this.error(sub('unexpected option string: %s', option_string));\n    }\n\n    // return the collected option tuples\n    return result;\n  }\n  _get_nargs_pattern(action) {\n    // in all examples below, we have to allow for '--' args\n    // which are represented as '-' in the pattern\n    let nargs = action.nargs;\n    let nargs_pattern;\n\n    // the default (None) is assumed to be a single argument\n    if (nargs === undefined) {\n      nargs_pattern = '(-*A-*)';\n\n      // allow zero or one arguments\n    } else if (nargs === OPTIONAL) {\n      nargs_pattern = '(-*A?-*)';\n\n      // allow zero or more arguments\n    } else if (nargs === ZERO_OR_MORE) {\n      nargs_pattern = '(-*[A-]*)';\n\n      // allow one or more arguments\n    } else if (nargs === ONE_OR_MORE) {\n      nargs_pattern = '(-*A[A-]*)';\n\n      // allow any number of options or arguments\n    } else if (nargs === REMAINDER) {\n      nargs_pattern = '([-AO]*)';\n\n      // allow one argument followed by any number of options or arguments\n    } else if (nargs === PARSER) {\n      nargs_pattern = '(-*A[-AO]*)';\n\n      // suppress action, like nargs=0\n    } else if (nargs === SUPPRESS) {\n      nargs_pattern = '(-*-*)';\n\n      // all others should be integers\n    } else {\n      nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'));\n    }\n\n    // if this is an optional action, -- is not allowed\n    if (action.option_strings.length) {\n      nargs_pattern = nargs_pattern.replace(/-\\*/g, '');\n      nargs_pattern = nargs_pattern.replace(/-/g, '');\n    }\n\n    // return the pattern\n    return nargs_pattern;\n  }\n\n  // ========================\n  // Alt command line argument parsing, allowing free intermix\n  // ========================\n\n  parse_intermixed_args(args = undefined, namespace = undefined) {\n    let argv;\n    [args, argv] = this.parse_known_intermixed_args(args, namespace);\n    if (argv.length) {\n      let msg = 'unrecognized arguments: %s';\n      this.error(sub(msg, argv.join(' ')));\n    }\n    return args;\n  }\n  parse_known_intermixed_args(args = undefined, namespace = undefined) {\n    // returns a namespace and list of extras\n    //\n    // positional can be freely intermixed with optionals.  optionals are\n    // first parsed with all positional arguments deactivated.  The 'extras'\n    // are then parsed.  If the parser definition is incompatible with the\n    // intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n    // TypeError is raised.\n    //\n    // positionals are 'deactivated' by setting nargs and default to\n    // SUPPRESS.  This blocks the addition of that positional to the\n    // namespace\n\n    let extras;\n    let positionals = this._get_positional_actions();\n    let a = positionals.filter(action => [PARSER, REMAINDER].includes(action.nargs));\n    if (a.length) {\n      throw new TypeError(sub('parse_intermixed_args: positional arg' + ' with nargs=%s', a[0].nargs));\n    }\n    for (let group of this._mutually_exclusive_groups) {\n      for (let action of group._group_actions) {\n        if (positionals.includes(action)) {\n          throw new TypeError('parse_intermixed_args: positional in' + ' mutuallyExclusiveGroup');\n        }\n      }\n    }\n    let save_usage;\n    try {\n      save_usage = this.usage;\n      let remaining_args;\n      try {\n        if (this.usage === undefined) {\n          // capture the full usage for use in error messages\n          this.usage = this.format_usage().slice(7);\n        }\n        for (let action of positionals) {\n          // deactivate positionals\n          action.save_nargs = action.nargs;\n          // action.nargs = 0\n          action.nargs = SUPPRESS;\n          action.save_default = action.default;\n          action.default = SUPPRESS;\n        }\n        [namespace, remaining_args] = this.parse_known_args(args, namespace);\n        for (let action of positionals) {\n          // remove the empty positional values from namespace\n          let attr = getattr(namespace, action.dest);\n          if (Array.isArray(attr) && attr.length === 0) {\n            // eslint-disable-next-line no-console\n            console.warn(sub('Do not expect %s in %s', action.dest, namespace));\n            delattr(namespace, action.dest);\n          }\n        }\n      } finally {\n        // restore nargs and usage before exiting\n        for (let action of positionals) {\n          action.nargs = action.save_nargs;\n          action.default = action.save_default;\n        }\n      }\n      let optionals = this._get_optional_actions();\n      try {\n        // parse positionals.  optionals aren't normally required, but\n        // they could be, so make sure they aren't.\n        for (let action of optionals) {\n          action.save_required = action.required;\n          action.required = false;\n        }\n        for (let group of this._mutually_exclusive_groups) {\n          group.save_required = group.required;\n          group.required = false;\n        }\n        [namespace, extras] = this.parse_known_args(remaining_args, namespace);\n      } finally {\n        // restore parser values before exiting\n        for (let action of optionals) {\n          action.required = action.save_required;\n        }\n        for (let group of this._mutually_exclusive_groups) {\n          group.required = group.save_required;\n        }\n      }\n    } finally {\n      this.usage = save_usage;\n    }\n    return [namespace, extras];\n  }\n\n  // ========================\n  // Value conversion methods\n  // ========================\n  _get_values(action, arg_strings) {\n    // for everything but PARSER, REMAINDER args, strip out first '--'\n    if (![PARSER, REMAINDER].includes(action.nargs)) {\n      try {\n        _array_remove(arg_strings, '--');\n      } catch (err) {}\n    }\n    let value;\n    // optional argument produces a default when not present\n    if (!arg_strings.length && action.nargs === OPTIONAL) {\n      if (action.option_strings.length) {\n        value = action.const;\n      } else {\n        value = action.default;\n      }\n      if (typeof value === 'string') {\n        value = this._get_value(action, value);\n        this._check_value(action, value);\n      }\n\n      // when nargs='*' on a positional, if there were no command-line\n      // args, use the default if it is anything other than None\n    } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE && !action.option_strings.length) {\n      if (action.default !== undefined) {\n        value = action.default;\n      } else {\n        value = arg_strings;\n      }\n      this._check_value(action, value);\n\n      // single argument or optional argument produces a single value\n    } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n      let arg_string = arg_strings[0];\n      value = this._get_value(action, arg_string);\n      this._check_value(action, value);\n\n      // REMAINDER arguments convert all values, checking none\n    } else if (action.nargs === REMAINDER) {\n      value = arg_strings.map(v => this._get_value(action, v));\n\n      // PARSER arguments convert all values, but check only the first\n    } else if (action.nargs === PARSER) {\n      value = arg_strings.map(v => this._get_value(action, v));\n      this._check_value(action, value[0]);\n\n      // SUPPRESS argument does not put anything in the namespace\n    } else if (action.nargs === SUPPRESS) {\n      value = SUPPRESS;\n\n      // all other types of nargs produce a list\n    } else {\n      value = arg_strings.map(v => this._get_value(action, v));\n      for (let v of value) {\n        this._check_value(action, v);\n      }\n    }\n\n    // return the converted value\n    return value;\n  }\n  _get_value(action, arg_string) {\n    let type_func = this._registry_get('type', action.type, action.type);\n    if (typeof type_func !== 'function') {\n      let msg = '%r is not callable';\n      throw new ArgumentError(action, sub(msg, type_func));\n    }\n\n    // convert the value to the appropriate type\n    let result;\n    try {\n      try {\n        result = type_func(arg_string);\n      } catch (err) {\n        // Dear TC39, why would you ever consider making es6 classes not callable?\n        // We had one universal interface, [[Call]], which worked for anything\n        // (with familiar this-instanceof guard for classes). Now we have two.\n        if (err instanceof TypeError && /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n          // eslint-disable-next-line new-cap\n          result = new type_func(arg_string);\n        } else {\n          throw err;\n        }\n      }\n    } catch (err) {\n      // ArgumentTypeErrors indicate errors\n      if (err instanceof ArgumentTypeError) {\n        //let name = getattr(action.type, 'name', repr(action.type))\n        let msg = err.message;\n        throw new ArgumentError(action, msg);\n\n        // TypeErrors or ValueErrors also indicate errors\n      } else if (err instanceof TypeError) {\n        let name = getattr(action.type, 'name', repr(action.type));\n        let args = {\n          type: name,\n          value: arg_string\n        };\n        let msg = 'invalid %(type)s value: %(value)r';\n        throw new ArgumentError(action, sub(msg, args));\n      } else {\n        throw err;\n      }\n    }\n\n    // return the converted value\n    return result;\n  }\n  _check_value(action, value) {\n    // converted value must be one of the choices (if specified)\n    if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n      let args = {\n        value,\n        choices: _choices_to_array(action.choices).map(repr).join(', ')\n      };\n      let msg = 'invalid choice: %(value)r (choose from %(choices)s)';\n      throw new ArgumentError(action, sub(msg, args));\n    }\n  }\n\n  // =======================\n  // Help-formatting methods\n  // =======================\n  format_usage() {\n    let formatter = this._get_formatter();\n    formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);\n    return formatter.format_help();\n  }\n  format_help() {\n    let formatter = this._get_formatter();\n\n    // usage\n    formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);\n\n    // description\n    formatter.add_text(this.description);\n\n    // positionals, optionals and user-defined groups\n    for (let action_group of this._action_groups) {\n      formatter.start_section(action_group.title);\n      formatter.add_text(action_group.description);\n      formatter.add_arguments(action_group._group_actions);\n      formatter.end_section();\n    }\n\n    // epilog\n    formatter.add_text(this.epilog);\n\n    // determine help from format above\n    return formatter.format_help();\n  }\n  _get_formatter() {\n    // eslint-disable-next-line new-cap\n    return new this.formatter_class({\n      prog: this.prog\n    });\n  }\n\n  // =====================\n  // Help-printing methods\n  // =====================\n  print_usage(file = undefined) {\n    if (file === undefined) file = process.stdout;\n    this._print_message(this.format_usage(), file);\n  }\n  print_help(file = undefined) {\n    if (file === undefined) file = process.stdout;\n    this._print_message(this.format_help(), file);\n  }\n  _print_message(message, file = undefined) {\n    if (message) {\n      if (file === undefined) file = process.stderr;\n      file.write(message);\n    }\n  }\n\n  // ===============\n  // Exiting methods\n  // ===============\n  exit(status = 0, message = undefined) {\n    if (message) {\n      this._print_message(message, process.stderr);\n    }\n    process.exit(status);\n  }\n  error(message) {\n    /*\n     *  error(message: string)\n     *\n     *  Prints a usage message incorporating the message to stderr and\n     *  exits.\n     *\n     *  If you override this in a subclass, it should not return -- it\n     *  should either exit or raise an exception.\n     */\n\n    // LEGACY (v1 compatibility), debug mode\n    if (this.debug === true) throw new Error(message);\n    // end\n    this.print_usage(process.stderr);\n    let args = {\n      prog: this.prog,\n      message: message\n    };\n    this.exit(2, sub('%(prog)s: error: %(message)s\\n', args));\n  }\n}));\nmodule.exports = {\n  ArgumentParser,\n  ArgumentError,\n  ArgumentTypeError,\n  BooleanOptionalAction,\n  FileType,\n  HelpFormatter,\n  ArgumentDefaultsHelpFormatter,\n  RawDescriptionHelpFormatter,\n  RawTextHelpFormatter,\n  MetavarTypeHelpFormatter,\n  Namespace,\n  Action,\n  ONE_OR_MORE,\n  OPTIONAL,\n  PARSER,\n  REMAINDER,\n  SUPPRESS,\n  ZERO_OR_MORE\n};\n\n// LEGACY (v1 compatibility), Const alias\nObject.defineProperty(module.exports, 'Const', {\n  get() {\n    let result = {};\n    Object.entries({\n      ONE_OR_MORE,\n      OPTIONAL,\n      PARSER,\n      REMAINDER,\n      SUPPRESS,\n      ZERO_OR_MORE\n    }).forEach(([n, v]) => {\n      Object.defineProperty(result, n, {\n        get() {\n          deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n));\n          return v;\n        }\n      });\n    });\n    Object.entries({\n      _UNRECOGNIZED_ARGS_ATTR\n    }).forEach(([n, v]) => {\n      Object.defineProperty(result, n, {\n        get() {\n          deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n));\n          return v;\n        }\n      });\n    });\n    return result;\n  },\n  enumerable: false\n});\n// end","map":{"version":3,"names":["SUPPRESS","OPTIONAL","ZERO_OR_MORE","ONE_OR_MORE","PARSER","REMAINDER","_UNRECOGNIZED_ARGS_ATTR","assert","require","util","fs","sub","path","repr","inspect","get_argv","process","argv","slice","get_terminal_size","columns","env","COLUMNS","stdout","hasattr","object","name","Object","prototype","hasOwnProperty","call","getattr","value","setattr","setdefault","delattr","range","from","to","step","arguments","length","TypeError","result","i","push","splitlines","str","keepends","split","parts","pop","_string_lstrip","string","prefix_chars","idx","includes","_string_split","sep","maxsplit","concat","join","_array_equal","array1","array2","_array_remove","array","item","indexOf","splice","_choices_to_array","choices","undefined","Array","isArray","Symbol","iterator","keys","Error","_callable","cls","args","this_class","new","target","Reflect","construct","toStringTag","_alias","constructor","defineProperty","deprecate","enumerable","_camelcase_alias","_class","getOwnPropertyNames","camelcase","replace","s","toUpperCase","_to_legacy_name","key","_to_new_name","c","toLowerCase","no_default","_parse_opts","descriptor","get_name","stack","map","x","match","filter","Boolean","m","fn","shift","kwargs","last_opt","assign","renames","old_name","a","b","missing_positionals","positional_count","def","entries","new_name","k","v","strs","str_joined","_deprecations","id","_AttributeHolder","custom","type_name","arg_strings","star_args","arg","_get_args","_get_kwargs","test","toString","_copy_items","items","HelpFormatter","prog","indent_increment","max_help_position","width","_prog","_indent_increment","_max_help_position","Math","min","max","_width","_current_indent","_level","_action_max_length","_root_section","_Section","_current_section","_whitespace_matcher","_long_break_matcher","_indent","_dedent","_add_item","func","start_section","heading","section","format_help","bind","end_section","parent","add_text","text","_format_text","add_usage","usage","actions","groups","prefix","_format_usage","add_argument","action","help","invocations","_format_action_invocation","subaction","_iter_indented_subactions","invocation_length","invocation","action_length","_format_action","add_arguments","_join_parts","part_strings","part","optionals","positionals","option_strings","action_usage","_format_actions_usage","String","text_width","part_regexp","opt_usage","pos_usage","opt_parts","pos_parts","get_lines","indent","lines","line","line_len","repeat","group_actions","Set","inserts","group","start","_group_actions","end","add","required","default_value","_get_default_metavar_for_positional","_format_args","has","option_string","nargs","format_usage","_get_default_metavar_for_optional","args_string","Number","sort","trim","_fill_text","help_position","help_width","action_width","action_header","indent_first","tup","help_text","_expand_help","help_lines","_split_lines","endsWith","metavar","_metavar_formatter","default_metavar","choice_strs","format","tuple_size","fill","get_metavar","formats","err","params","choices_str","_get_help_string","_get_subactions","textwrap","wrap","initial_indent","subsequent_indent","dest","formatter","item_help","apply","current_indent","RawDescriptionHelpFormatter","RawTextHelpFormatter","ArgumentDefaultsHelpFormatter","default","defaulting_nargs","MetavarTypeHelpFormatter","type","_get_action_name","argument","ArgumentError","message","_argument_name","_message","argument_name","ArgumentTypeError","Action","Function","const_value","const","names","BooleanOptionalAction","_option_strings","startsWith","parser","namespace","values","_StoreAction","_StoreConstAction","_StoreTrueAction","_StoreFalseAction","_AppendAction","_AppendConstAction","_CountAction","count","_HelpAction","print_help","exit","_VersionAction","version","_get_formatter","_print_message","_SubParsersAction","parser_class","name_parser_map","_prog_prefix","_parser_class","_name_parser_map","_choices_actions","add_parser","aliases","choice_action","_ChoicesPseudoAction","alias","parser_name","msg","subnamespace","parse_known_args","_ExtendAction","FileType","flags","encoding","mode","autoClose","emitClose","highWaterMark","get","_flags","_options","stdin","fd","openSync","e","filename","error","options","createReadStream","createWriteStream","args_str","kw","Namespace","_ActionsContainer","description","argument_default","conflict_handler","_registries","register","forEach","_registry_get","_get_handler","_actions","_option_string_actions","_action_groups","_mutually_exclusive_groups","_defaults","_negative_number_matcher","_has_negative_number_optionals","registry_name","registry","set_defaults","get_default","chars","_get_positional_kwargs","_get_optional_kwargs","action_class","_pop_action_class","type_func","_add_action","add_argument_group","_ArgumentGroup","add_mutually_exclusive_group","_MutuallyExclusiveGroup","_check_conflict","container","_remove_action","_add_container_actions","title_group_map","title","group_map","Map","set","mutex_group","long_option_strings","option","dest_option_string","handler_func_name","confl_optionals","confl_optional","_handle_conflict_error","conflicting_actions","conflict_string","_handle_conflict_resolve","_container","ArgumentParser","epilog","parents","formatter_class","fromfile_prefix_chars","add_help","allow_abbrev","exit_on_error","debug","basename","_positionals","_optionals","_subparsers","identity","isInteger","isNaN","default_prefix","add_subparsers","_get_positional_actions","parsers_class","_get_optional_actions","parse_args","_parse_known_args","_read_args_from_files","action_conflicts","mutex_action","conflicts","option_string_indices","arg_string_pattern_parts","arg_strings_iter","arg_string","option_tuple","_parse_optional","pattern","arg_strings_pattern","seen_actions","seen_non_default_actions","extras","take_action","argument_strings","argument_values","_get_values","conflict_action","action_name","consume_optional","start_index","explicit_arg","action_tuples","stop","arg_count","_match_argument","char","new_explicit_arg","optionals_map","selected_patterns","consume_positionals","selected_pattern","arg_counts","_match_arguments_partial","max_option_string_index","next_option_string_index","index","positionals_end_index","strings","stop_index","required_actions","_get_value","no_actions_used","new_arg_strings","args_file","readFileSync","arg_line","convert_arg_line_to_args","nargs_pattern","_get_nargs_pattern","RegExp","nargs_errors","actions_slice","option_tuples","_get_option_tuples","matches","option_prefix","short_option_prefix","short_explicit_arg","parse_intermixed_args","parse_known_intermixed_args","save_usage","remaining_args","save_nargs","save_default","attr","console","warn","save_required","_check_value","action_group","print_usage","file","stderr","write","status","module","exports","n"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/node_modules/argparse/argparse.js"],"sourcesContent":["// Port of python's argparse module, version 3.9.0:\n// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py\n\n'use strict'\n\n// Copyright (C) 2010-2020 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n\n/*\n * Command-line parsing library\n *\n * This module is an optparse-inspired command-line parsing library that:\n *\n *     - handles both optional and positional arguments\n *     - produces highly informative usage messages\n *     - supports parsers that dispatch to sub-parsers\n *\n * The following is a simple usage example that sums integers from the\n * command-line and writes the result to a file::\n *\n *     parser = argparse.ArgumentParser(\n *         description='sum the integers at the command line')\n *     parser.add_argument(\n *         'integers', metavar='int', nargs='+', type=int,\n *         help='an integer to be summed')\n *     parser.add_argument(\n *         '--log', default=sys.stdout, type=argparse.FileType('w'),\n *         help='the file where the sum should be written')\n *     args = parser.parse_args()\n *     args.log.write('%s' % sum(args.integers))\n *     args.log.close()\n *\n * The module contains the following public classes:\n *\n *     - ArgumentParser -- The main entry point for command-line parsing. As the\n *         example above shows, the add_argument() method is used to populate\n *         the parser with actions for optional and positional arguments. Then\n *         the parse_args() method is invoked to convert the args at the\n *         command-line into an object with attributes.\n *\n *     - ArgumentError -- The exception raised by ArgumentParser objects when\n *         there are errors with the parser's actions. Errors raised while\n *         parsing the command-line are caught by ArgumentParser and emitted\n *         as command-line messages.\n *\n *     - FileType -- A factory for defining types of files to be created. As the\n *         example above shows, instances of FileType are typically passed as\n *         the type= argument of add_argument() calls.\n *\n *     - Action -- The base class for parser actions. Typically actions are\n *         selected by passing strings like 'store_true' or 'append_const' to\n *         the action= argument of add_argument(). However, for greater\n *         customization of ArgumentParser actions, subclasses of Action may\n *         be defined and passed as the action= argument.\n *\n *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n *         ArgumentDefaultsHelpFormatter -- Formatter classes which\n *         may be passed as the formatter_class= argument to the\n *         ArgumentParser constructor. HelpFormatter is the default,\n *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n *         not to change the formatting for help text, and\n *         ArgumentDefaultsHelpFormatter adds information about argument defaults\n *         to the help.\n *\n * All other classes in this module are considered implementation details.\n * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only\n * considered public as object names -- the API of the formatter objects is\n * still considered an implementation detail.)\n */\n\nconst SUPPRESS = '==SUPPRESS=='\n\nconst OPTIONAL = '?'\nconst ZERO_OR_MORE = '*'\nconst ONE_OR_MORE = '+'\nconst PARSER = 'A...'\nconst REMAINDER = '...'\nconst _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n\n\n// ==================================\n// Utility functions used for porting\n// ==================================\nconst assert = require('assert')\nconst util = require('util')\nconst fs = require('fs')\nconst sub = require('./lib/sub')\nconst path = require('path')\nconst repr = util.inspect\n\nfunction get_argv() {\n    // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)\n    return process.argv.slice(1)\n}\n\nfunction get_terminal_size() {\n    return {\n        columns: +process.env.COLUMNS || process.stdout.columns || 80\n    }\n}\n\nfunction hasattr(object, name) {\n    return Object.prototype.hasOwnProperty.call(object, name)\n}\n\nfunction getattr(object, name, value) {\n    return hasattr(object, name) ? object[name] : value\n}\n\nfunction setattr(object, name, value) {\n    object[name] = value\n}\n\nfunction setdefault(object, name, value) {\n    if (!hasattr(object, name)) object[name] = value\n    return object[name]\n}\n\nfunction delattr(object, name) {\n    delete object[name]\n}\n\nfunction range(from, to, step=1) {\n    // range(10) is equivalent to range(0, 10)\n    if (arguments.length === 1) [ to, from ] = [ from, 0 ]\n    if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n        throw new TypeError('argument cannot be interpreted as an integer')\n    }\n    if (step === 0) throw new TypeError('range() arg 3 must not be zero')\n\n    let result = []\n    if (step > 0) {\n        for (let i = from; i < to; i += step) result.push(i)\n    } else {\n        for (let i = from; i > to; i += step) result.push(i)\n    }\n    return result\n}\n\nfunction splitlines(str, keepends = false) {\n    let result\n    if (!keepends) {\n        result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/)\n    } else {\n        result = []\n        let parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/)\n        for (let i = 0; i < parts.length; i += 2) {\n            result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''))\n        }\n    }\n    if (!result[result.length - 1]) result.pop()\n    return result\n}\n\nfunction _string_lstrip(string, prefix_chars) {\n    let idx = 0\n    while (idx < string.length && prefix_chars.includes(string[idx])) idx++\n    return idx ? string.slice(idx) : string\n}\n\nfunction _string_split(string, sep, maxsplit) {\n    let result = string.split(sep)\n    if (result.length > maxsplit) {\n        result = result.slice(0, maxsplit).concat([ result.slice(maxsplit).join(sep) ])\n    }\n    return result\n}\n\nfunction _array_equal(array1, array2) {\n    if (array1.length !== array2.length) return false\n    for (let i = 0; i < array1.length; i++) {\n        if (array1[i] !== array2[i]) return false\n    }\n    return true\n}\n\nfunction _array_remove(array, item) {\n    let idx = array.indexOf(item)\n    if (idx === -1) throw new TypeError(sub('%r not in list', item))\n    array.splice(idx, 1)\n}\n\n// normalize choices to array;\n// this isn't required in python because `in` and `map` operators work with anything,\n// but in js dealing with multiple types here is too clunky\nfunction _choices_to_array(choices) {\n    if (choices === undefined) {\n        return []\n    } else if (Array.isArray(choices)) {\n        return choices\n    } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n        return Array.from(choices)\n    } else if (typeof choices === 'object' && choices !== null) {\n        return Object.keys(choices)\n    } else {\n        throw new Error(sub('invalid choices value: %r', choices))\n    }\n}\n\n// decorator that allows a class to be called without new\nfunction _callable(cls) {\n    let result = { // object is needed for inferred class name\n        [cls.name]: function (...args) {\n            let this_class = new.target === result || !new.target\n            return Reflect.construct(cls, args, this_class ? cls : new.target)\n        }\n    }\n    result[cls.name].prototype = cls.prototype\n    // fix default tag for toString, e.g. [object Action] instead of [object Object]\n    cls.prototype[Symbol.toStringTag] = cls.name\n    return result[cls.name]\n}\n\nfunction _alias(object, from, to) {\n    try {\n        let name = object.constructor.name\n        Object.defineProperty(object, from, {\n            value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()',\n                name, from, name, to)),\n            enumerable: false\n        })\n    } catch {}\n}\n\n// decorator that allows snake_case class methods to be called with camelCase and vice versa\nfunction _camelcase_alias(_class) {\n    for (let name of Object.getOwnPropertyNames(_class.prototype)) {\n        let camelcase = name.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n        if (camelcase !== name) _alias(_class.prototype, camelcase, name)\n    }\n    return _class\n}\n\nfunction _to_legacy_name(key) {\n    key = key.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n    if (key === 'default') key = 'defaultValue'\n    if (key === 'const') key = 'constant'\n    return key\n}\n\nfunction _to_new_name(key) {\n    if (key === 'defaultValue') key = 'default'\n    if (key === 'constant') key = 'const'\n    key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase())\n    return key\n}\n\n// parse options\nlet no_default = Symbol('no_default_value')\nfunction _parse_opts(args, descriptor) {\n    function get_name() {\n        let stack = new Error().stack.split('\\n')\n            .map(x => x.match(/^    at (.*) \\(.*\\)$/))\n            .filter(Boolean)\n            .map(m => m[1])\n            .map(fn => fn.match(/[^ .]*$/)[0])\n\n        if (stack.length && stack[0] === get_name.name) stack.shift()\n        if (stack.length && stack[0] === _parse_opts.name) stack.shift()\n        return stack.length ? stack[0] : ''\n    }\n\n    args = Array.from(args)\n    let kwargs = {}\n    let result = []\n    let last_opt = args.length && args[args.length - 1]\n\n    if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) &&\n        (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n        kwargs = Object.assign({}, args.pop())\n    }\n\n    // LEGACY (v1 compatibility): camelcase\n    let renames = []\n    for (let key of Object.keys(descriptor)) {\n        let old_name = _to_legacy_name(key)\n        if (old_name !== key && (old_name in kwargs)) {\n            if (key in kwargs) {\n                // default and defaultValue specified at the same time, happens often in old tests\n                //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n            } else {\n                kwargs[key] = kwargs[old_name]\n            }\n            renames.push([ old_name, key ])\n            delete kwargs[old_name]\n        }\n    }\n    if (renames.length) {\n        let name = get_name()\n        deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n            name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n    }\n    // end\n\n    let missing_positionals = []\n    let positional_count = args.length\n\n    for (let [ key, def ] of Object.entries(descriptor)) {\n        if (key[0] === '*') {\n            if (key.length > 0 && key[1] === '*') {\n                // LEGACY (v1 compatibility): camelcase\n                let renames = []\n                for (let key of Object.keys(kwargs)) {\n                    let new_name = _to_new_name(key)\n                    if (new_name !== key && (key in kwargs)) {\n                        if (new_name in kwargs) {\n                            // default and defaultValue specified at the same time, happens often in old tests\n                            //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))\n                        } else {\n                            kwargs[new_name] = kwargs[key]\n                        }\n                        renames.push([ key, new_name ])\n                        delete kwargs[key]\n                    }\n                }\n                if (renames.length) {\n                    let name = get_name()\n                    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n                        name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n                }\n                // end\n                result.push(kwargs)\n                kwargs = {}\n            } else {\n                result.push(args)\n                args = []\n            }\n        } else if (key in kwargs && args.length > 0) {\n            throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n        } else if (key in kwargs) {\n            result.push(kwargs[key])\n            delete kwargs[key]\n        } else if (args.length > 0) {\n            result.push(args.shift())\n        } else if (def !== no_default) {\n            result.push(def)\n        } else {\n            missing_positionals.push(key)\n        }\n    }\n\n    if (Object.keys(kwargs).length) {\n        throw new TypeError(sub('%s() got an unexpected keyword argument %r',\n            get_name(), Object.keys(kwargs)[0]))\n    }\n\n    if (args.length) {\n        let from = Object.entries(descriptor).filter(([ k, v ]) => k[0] !== '*' && v !== no_default).length\n        let to = Object.entries(descriptor).filter(([ k ]) => k[0] !== '*').length\n        throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given',\n            get_name(),\n            from === to ? sub('from %s to %s', from, to) : to,\n            from === to && to === 1 ? '' : 's',\n            positional_count,\n            positional_count === 1 ? 'was' : 'were'))\n    }\n\n    if (missing_positionals.length) {\n        let strs = missing_positionals.map(repr)\n        if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1]\n        let str_joined = strs.join(strs.length === 2 ? '' : ', ')\n        throw new TypeError(sub('%s() missing %i required positional argument%s: %s',\n            get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined))\n    }\n\n    return result\n}\n\nlet _deprecations = {}\nfunction deprecate(id, string) {\n    _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string)\n    _deprecations[id]()\n}\n\n\n// =============================\n// Utility functions and classes\n// =============================\nfunction _AttributeHolder(cls = Object) {\n    /*\n     *  Abstract base class that provides __repr__.\n     *\n     *  The __repr__ method returns a string in the format::\n     *      ClassName(attr=name, attr=name, ...)\n     *  The attributes are determined either by a class-level attribute,\n     *  '_kwarg_names', or by inspecting the instance __dict__.\n     */\n\n    return class _AttributeHolder extends cls {\n        [util.inspect.custom]() {\n            let type_name = this.constructor.name\n            let arg_strings = []\n            let star_args = {}\n            for (let arg of this._get_args()) {\n                arg_strings.push(repr(arg))\n            }\n            for (let [ name, value ] of this._get_kwargs()) {\n                if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n                    arg_strings.push(sub('%s=%r', name, value))\n                } else {\n                    star_args[name] = value\n                }\n            }\n            if (Object.keys(star_args).length) {\n                arg_strings.push(sub('**%s', repr(star_args)))\n            }\n            return sub('%s(%s)', type_name, arg_strings.join(', '))\n        }\n\n        toString() {\n            return this[util.inspect.custom]()\n        }\n\n        _get_kwargs() {\n            return Object.entries(this)\n        }\n\n        _get_args() {\n            return []\n        }\n    }\n}\n\n\nfunction _copy_items(items) {\n    if (items === undefined) {\n        return []\n    }\n    return items.slice(0)\n}\n\n\n// ===============\n// Formatting Help\n// ===============\nconst HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {\n    /*\n     *  Formatter for generating usage messages and argument help strings.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    constructor() {\n        let [\n            prog,\n            indent_increment,\n            max_help_position,\n            width\n        ] = _parse_opts(arguments, {\n            prog: no_default,\n            indent_increment: 2,\n            max_help_position: 24,\n            width: undefined\n        })\n\n        // default setting for width\n        if (width === undefined) {\n            width = get_terminal_size().columns\n            width -= 2\n        }\n\n        this._prog = prog\n        this._indent_increment = indent_increment\n        this._max_help_position = Math.min(max_help_position,\n                                      Math.max(width - 20, indent_increment * 2))\n        this._width = width\n\n        this._current_indent = 0\n        this._level = 0\n        this._action_max_length = 0\n\n        this._root_section = this._Section(this, undefined)\n        this._current_section = this._root_section\n\n        this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g // equivalent to python /\\s+/ with ASCII flag\n        this._long_break_matcher = /\\n\\n\\n+/g\n    }\n\n    // ===============================\n    // Section and indentation methods\n    // ===============================\n    _indent() {\n        this._current_indent += this._indent_increment\n        this._level += 1\n    }\n\n    _dedent() {\n        this._current_indent -= this._indent_increment\n        assert(this._current_indent >= 0, 'Indent decreased below 0.')\n        this._level -= 1\n    }\n\n    _add_item(func, args) {\n        this._current_section.items.push([ func, args ])\n    }\n\n    // ========================\n    // Message building methods\n    // ========================\n    start_section(heading) {\n        this._indent()\n        let section = this._Section(this, this._current_section, heading)\n        this._add_item(section.format_help.bind(section), [])\n        this._current_section = section\n    }\n\n    end_section() {\n        this._current_section = this._current_section.parent\n        this._dedent()\n    }\n\n    add_text(text) {\n        if (text !== SUPPRESS && text !== undefined) {\n            this._add_item(this._format_text.bind(this), [text])\n        }\n    }\n\n    add_usage(usage, actions, groups, prefix = undefined) {\n        if (usage !== SUPPRESS) {\n            let args = [ usage, actions, groups, prefix ]\n            this._add_item(this._format_usage.bind(this), args)\n        }\n    }\n\n    add_argument(action) {\n        if (action.help !== SUPPRESS) {\n\n            // find all invocations\n            let invocations = [this._format_action_invocation(action)]\n            for (let subaction of this._iter_indented_subactions(action)) {\n                invocations.push(this._format_action_invocation(subaction))\n            }\n\n            // update the maximum item length\n            let invocation_length = Math.max(...invocations.map(invocation => invocation.length))\n            let action_length = invocation_length + this._current_indent\n            this._action_max_length = Math.max(this._action_max_length,\n                                               action_length)\n\n            // add the item to the list\n            this._add_item(this._format_action.bind(this), [action])\n        }\n    }\n\n    add_arguments(actions) {\n        for (let action of actions) {\n            this.add_argument(action)\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_help() {\n        let help = this._root_section.format_help()\n        if (help) {\n            help = help.replace(this._long_break_matcher, '\\n\\n')\n            help = help.replace(/^\\n+|\\n+$/g, '') + '\\n'\n        }\n        return help\n    }\n\n    _join_parts(part_strings) {\n        return part_strings.filter(part => part && part !== SUPPRESS).join('')\n    }\n\n    _format_usage(usage, actions, groups, prefix) {\n        if (prefix === undefined) {\n            prefix = 'usage: '\n        }\n\n        // if usage is specified, use that\n        if (usage !== undefined) {\n            usage = sub(usage, { prog: this._prog })\n\n        // if no optionals or positionals are available, usage is just prog\n        } else if (usage === undefined && !actions.length) {\n            usage = sub('%(prog)s', { prog: this._prog })\n\n        // if optionals and positionals are available, calculate usage\n        } else if (usage === undefined) {\n            let prog = sub('%(prog)s', { prog: this._prog })\n\n            // split optionals from positionals\n            let optionals = []\n            let positionals = []\n            for (let action of actions) {\n                if (action.option_strings.length) {\n                    optionals.push(action)\n                } else {\n                    positionals.push(action)\n                }\n            }\n\n            // build full usage string\n            let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups)\n            usage = [ prog, action_usage ].map(String).join(' ')\n\n            // wrap the usage parts if it's too long\n            let text_width = this._width - this._current_indent\n            if (prefix.length + usage.length > text_width) {\n\n                // break usage into wrappable parts\n                let part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g\n                let opt_usage = this._format_actions_usage(optionals, groups)\n                let pos_usage = this._format_actions_usage(positionals, groups)\n                let opt_parts = opt_usage.match(part_regexp) || []\n                let pos_parts = pos_usage.match(part_regexp) || []\n                assert(opt_parts.join(' ') === opt_usage)\n                assert(pos_parts.join(' ') === pos_usage)\n\n                // helper for wrapping lines\n                let get_lines = (parts, indent, prefix = undefined) => {\n                    let lines = []\n                    let line = []\n                    let line_len\n                    if (prefix !== undefined) {\n                        line_len = prefix.length - 1\n                    } else {\n                        line_len = indent.length - 1\n                    }\n                    for (let part of parts) {\n                        if (line_len + 1 + part.length > text_width && line) {\n                            lines.push(indent + line.join(' '))\n                            line = []\n                            line_len = indent.length - 1\n                        }\n                        line.push(part)\n                        line_len += part.length + 1\n                    }\n                    if (line.length) {\n                        lines.push(indent + line.join(' '))\n                    }\n                    if (prefix !== undefined) {\n                        lines[0] = lines[0].slice(indent.length)\n                    }\n                    return lines\n                }\n\n                let lines\n\n                // if prog is short, follow it with optionals or positionals\n                if (prefix.length + prog.length <= 0.75 * text_width) {\n                    let indent = ' '.repeat(prefix.length + prog.length + 1)\n                    if (opt_parts.length) {\n                        lines = get_lines([prog].concat(opt_parts), indent, prefix)\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    } else if (pos_parts.length) {\n                        lines = get_lines([prog].concat(pos_parts), indent, prefix)\n                    } else {\n                        lines = [prog]\n                    }\n\n                // if prog is long, put it on its own line\n                } else {\n                    let indent = ' '.repeat(prefix.length)\n                    let parts = [].concat(opt_parts).concat(pos_parts)\n                    lines = get_lines(parts, indent)\n                    if (lines.length > 1) {\n                        lines = []\n                        lines = lines.concat(get_lines(opt_parts, indent))\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    }\n                    lines = [prog].concat(lines)\n                }\n\n                // join lines into usage\n                usage = lines.join('\\n')\n            }\n        }\n\n        // prefix with 'usage:'\n        return sub('%s%s\\n\\n', prefix, usage)\n    }\n\n    _format_actions_usage(actions, groups) {\n        // find group indices and identify actions in groups\n        let group_actions = new Set()\n        let inserts = {}\n        for (let group of groups) {\n            let start = actions.indexOf(group._group_actions[0])\n            if (start === -1) {\n                continue\n            } else {\n                let end = start + group._group_actions.length\n                if (_array_equal(actions.slice(start, end), group._group_actions)) {\n                    for (let action of group._group_actions) {\n                        group_actions.add(action)\n                    }\n                    if (!group.required) {\n                        if (start in inserts) {\n                            inserts[start] += ' ['\n                        } else {\n                            inserts[start] = '['\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ']'\n                        } else {\n                            inserts[end] = ']'\n                        }\n                    } else {\n                        if (start in inserts) {\n                            inserts[start] += ' ('\n                        } else {\n                            inserts[start] = '('\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ')'\n                        } else {\n                            inserts[end] = ')'\n                        }\n                    }\n                    for (let i of range(start + 1, end)) {\n                        inserts[i] = '|'\n                    }\n                }\n            }\n        }\n\n        // collect all actions format strings\n        let parts = []\n        for (let [ i, action ] of Object.entries(actions)) {\n\n            // suppressed arguments are marked with None\n            // remove | separators for suppressed arguments\n            if (action.help === SUPPRESS) {\n                parts.push(undefined)\n                if (inserts[+i] === '|') {\n                    delete inserts[+i]\n                } else if (inserts[+i + 1] === '|') {\n                    delete inserts[+i + 1]\n                }\n\n            // produce all arg strings\n            } else if (!action.option_strings.length) {\n                let default_value = this._get_default_metavar_for_positional(action)\n                let part = this._format_args(action, default_value)\n\n                // if it's in a group, strip the outer []\n                if (group_actions.has(action)) {\n                    if (part[0] === '[' && part[part.length - 1] === ']') {\n                        part = part.slice(1, -1)\n                    }\n                }\n\n                // add the action string to the list\n                parts.push(part)\n\n            // produce the first way to invoke the option in brackets\n            } else {\n                let option_string = action.option_strings[0]\n                let part\n\n                // if the Optional doesn't take a value, format is:\n                //    -s or --long\n                if (action.nargs === 0) {\n                    part = action.format_usage()\n\n                // if the Optional takes a value, format is:\n                //    -s ARGS or --long ARGS\n                } else {\n                    let default_value = this._get_default_metavar_for_optional(action)\n                    let args_string = this._format_args(action, default_value)\n                    part = sub('%s %s', option_string, args_string)\n                }\n\n                // make it look optional if it's not required or in a group\n                if (!action.required && !group_actions.has(action)) {\n                    part = sub('[%s]', part)\n                }\n\n                // add the action string to the list\n                parts.push(part)\n            }\n        }\n\n        // insert things at the necessary indices\n        for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {\n            parts.splice(+i, 0, inserts[+i])\n        }\n\n        // join all the action items with spaces\n        let text = parts.filter(Boolean).join(' ')\n\n        // clean up separators for mutually exclusive groups\n        text = text.replace(/([\\[(]) /g, '$1')\n        text = text.replace(/ ([\\])])/g, '$1')\n        text = text.replace(/[\\[(] *[\\])]/g, '')\n        text = text.replace(/\\(([^|]*)\\)/g, '$1', text)\n        text = text.trim()\n\n        // return the text\n        return text\n    }\n\n    _format_text(text) {\n        if (text.includes('%(prog)')) {\n            text = sub(text, { prog: this._prog })\n        }\n        let text_width = Math.max(this._width - this._current_indent, 11)\n        let indent = ' '.repeat(this._current_indent)\n        return this._fill_text(text, text_width, indent) + '\\n\\n'\n    }\n\n    _format_action(action) {\n        // determine the required width and the entry label\n        let help_position = Math.min(this._action_max_length + 2,\n                                     this._max_help_position)\n        let help_width = Math.max(this._width - help_position, 11)\n        let action_width = help_position - this._current_indent - 2\n        let action_header = this._format_action_invocation(action)\n        let indent_first\n\n        // no help; start on same line and add a final newline\n        if (!action.help) {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n\n        // short action name; start on the same line and pad two spaces\n        } else if (action_header.length <= action_width) {\n            let tup = [ this._current_indent, '', action_width, action_header ]\n            action_header = sub('%*s%-*s  ', ...tup)\n            indent_first = 0\n\n        // long action name; start on the next line\n        } else {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n            indent_first = help_position\n        }\n\n        // collect the pieces of the action help\n        let parts = [action_header]\n\n        // if there was help for the action, add lines of help text\n        if (action.help) {\n            let help_text = this._expand_help(action)\n            let help_lines = this._split_lines(help_text, help_width)\n            parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]))\n            for (let line of help_lines.slice(1)) {\n                parts.push(sub('%*s%s\\n', help_position, '', line))\n            }\n\n        // or add a newline if the description doesn't end with one\n        } else if (!action_header.endsWith('\\n')) {\n            parts.push('\\n')\n        }\n\n        // if there are any sub-actions, add their help as well\n        for (let subaction of this._iter_indented_subactions(action)) {\n            parts.push(this._format_action(subaction))\n        }\n\n        // return a single string\n        return this._join_parts(parts)\n    }\n\n    _format_action_invocation(action) {\n        if (!action.option_strings.length) {\n            let default_value = this._get_default_metavar_for_positional(action)\n            let metavar = this._metavar_formatter(action, default_value)(1)[0]\n            return metavar\n\n        } else {\n            let parts = []\n\n            // if the Optional doesn't take a value, format is:\n            //    -s, --long\n            if (action.nargs === 0) {\n                parts = parts.concat(action.option_strings)\n\n            // if the Optional takes a value, format is:\n            //    -s ARGS, --long ARGS\n            } else {\n                let default_value = this._get_default_metavar_for_optional(action)\n                let args_string = this._format_args(action, default_value)\n                for (let option_string of action.option_strings) {\n                    parts.push(sub('%s %s', option_string, args_string))\n                }\n            }\n\n            return parts.join(', ')\n        }\n    }\n\n    _metavar_formatter(action, default_metavar) {\n        let result\n        if (action.metavar !== undefined) {\n            result = action.metavar\n        } else if (action.choices !== undefined) {\n            let choice_strs = _choices_to_array(action.choices).map(String)\n            result = sub('{%s}', choice_strs.join(','))\n        } else {\n            result = default_metavar\n        }\n\n        function format(tuple_size) {\n            if (Array.isArray(result)) {\n                return result\n            } else {\n                return Array(tuple_size).fill(result)\n            }\n        }\n        return format\n    }\n\n    _format_args(action, default_metavar) {\n        let get_metavar = this._metavar_formatter(action, default_metavar)\n        let result\n        if (action.nargs === undefined) {\n            result = sub('%s', ...get_metavar(1))\n        } else if (action.nargs === OPTIONAL) {\n            result = sub('[%s]', ...get_metavar(1))\n        } else if (action.nargs === ZERO_OR_MORE) {\n            let metavar = get_metavar(1)\n            if (metavar.length === 2) {\n                result = sub('[%s [%s ...]]', ...metavar)\n            } else {\n                result = sub('[%s ...]', ...metavar)\n            }\n        } else if (action.nargs === ONE_OR_MORE) {\n            result = sub('%s [%s ...]', ...get_metavar(2))\n        } else if (action.nargs === REMAINDER) {\n            result = '...'\n        } else if (action.nargs === PARSER) {\n            result = sub('%s ...', ...get_metavar(1))\n        } else if (action.nargs === SUPPRESS) {\n            result = ''\n        } else {\n            let formats\n            try {\n                formats = range(action.nargs).map(() => '%s')\n            } catch (err) {\n                throw new TypeError('invalid nargs value')\n            }\n            result = sub(formats.join(' '), ...get_metavar(action.nargs))\n        }\n        return result\n    }\n\n    _expand_help(action) {\n        let params = Object.assign({ prog: this._prog }, action)\n        for (let name of Object.keys(params)) {\n            if (params[name] === SUPPRESS) {\n                delete params[name]\n            }\n        }\n        for (let name of Object.keys(params)) {\n            if (params[name] && params[name].name) {\n                params[name] = params[name].name\n            }\n        }\n        if (params.choices !== undefined) {\n            let choices_str = _choices_to_array(params.choices).map(String).join(', ')\n            params.choices = choices_str\n        }\n        // LEGACY (v1 compatibility): camelcase\n        for (let key of Object.keys(params)) {\n            let old_name = _to_legacy_name(key)\n            if (old_name !== key) {\n                params[old_name] = params[key]\n            }\n        }\n        // end\n        return sub(this._get_help_string(action), params)\n    }\n\n    * _iter_indented_subactions(action) {\n        if (typeof action._get_subactions === 'function') {\n            this._indent()\n            yield* action._get_subactions()\n            this._dedent()\n        }\n    }\n\n    _split_lines(text, width) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        // The textwrap module is used only for formatting help.\n        // Delay its import for speeding up the common usage of argparse.\n        let textwrap = require('./lib/textwrap')\n        return textwrap.wrap(text, { width })\n    }\n\n    _fill_text(text, width, indent) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        let textwrap = require('./lib/textwrap')\n        return textwrap.fill(text, { width,\n                                     initial_indent: indent,\n                                     subsequent_indent: indent })\n    }\n\n    _get_help_string(action) {\n        return action.help\n    }\n\n    _get_default_metavar_for_optional(action) {\n        return action.dest.toUpperCase()\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return action.dest\n    }\n}))\n\nHelpFormatter.prototype._Section = _callable(class _Section {\n\n    constructor(formatter, parent, heading = undefined) {\n        this.formatter = formatter\n        this.parent = parent\n        this.heading = heading\n        this.items = []\n    }\n\n    format_help() {\n        // format the indented section\n        if (this.parent !== undefined) {\n            this.formatter._indent()\n        }\n        let item_help = this.formatter._join_parts(this.items.map(([ func, args ]) => func.apply(null, args)))\n        if (this.parent !== undefined) {\n            this.formatter._dedent()\n        }\n\n        // return nothing if the section was empty\n        if (!item_help) {\n            return ''\n        }\n\n        // add the heading if the section was non-empty\n        let heading\n        if (this.heading !== SUPPRESS && this.heading !== undefined) {\n            let current_indent = this.formatter._current_indent\n            heading = sub('%*s%s:\\n', current_indent, '', this.heading)\n        } else {\n            heading = ''\n        }\n\n        // join the section-initial newline, the heading and the help\n        return this.formatter._join_parts(['\\n', heading, item_help, '\\n'])\n    }\n})\n\n\nconst RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which retains any formatting in descriptions.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _fill_text(text, width, indent) {\n        return splitlines(text, true).map(line => indent + line).join('')\n    }\n}))\n\n\nconst RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {\n    /*\n     *  Help message formatter which retains formatting of all help text.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _split_lines(text/*, width*/) {\n        return splitlines(text)\n    }\n}))\n\n\nconst ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which adds default values to argument help.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_help_string(action) {\n        let help = action.help\n        // LEGACY (v1 compatibility): additional check for defaultValue needed\n        if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n            if (action.default !== SUPPRESS) {\n                let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]\n                if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n                    help += ' (default: %(default)s)'\n                }\n            }\n        }\n        return help\n    }\n}))\n\n\nconst MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which uses the argument 'type' as the default\n     *  metavar value (instead of the argument 'dest')\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_default_metavar_for_optional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n}))\n\n\n// =====================\n// Options and Arguments\n// =====================\nfunction _get_action_name(argument) {\n    if (argument === undefined) {\n        return undefined\n    } else if (argument.option_strings.length) {\n        return argument.option_strings.join('/')\n    } else if (![ undefined, SUPPRESS ].includes(argument.metavar)) {\n        return argument.metavar\n    } else if (![ undefined, SUPPRESS ].includes(argument.dest)) {\n        return argument.dest\n    } else {\n        return undefined\n    }\n}\n\n\nconst ArgumentError = _callable(class ArgumentError extends Error {\n    /*\n     *  An error from creating or using an argument (optional or positional).\n     *\n     *  The string value of this exception is the message, augmented with\n     *  information about the argument that caused it.\n     */\n\n    constructor(argument, message) {\n        super()\n        this.name = 'ArgumentError'\n        this._argument_name = _get_action_name(argument)\n        this._message = message\n        this.message = this.str()\n    }\n\n    str() {\n        let format\n        if (this._argument_name === undefined) {\n            format = '%(message)s'\n        } else {\n            format = 'argument %(argument_name)s: %(message)s'\n        }\n        return sub(format, { message: this._message,\n                             argument_name: this._argument_name })\n    }\n})\n\n\nconst ArgumentTypeError = _callable(class ArgumentTypeError extends Error {\n    /*\n     * An error from trying to convert a command line string to a type.\n     */\n\n    constructor(message) {\n        super(message)\n        this.name = 'ArgumentTypeError'\n    }\n})\n\n\n// ==============\n// Action classes\n// ==============\nconst Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {\n    /*\n     *  Information about how to convert command line strings to Python objects.\n     *\n     *  Action objects are used by an ArgumentParser to represent the information\n     *  needed to parse a single argument from one or more strings from the\n     *  command line. The keyword arguments to the Action constructor are also\n     *  all attributes of Action instances.\n     *\n     *  Keyword Arguments:\n     *\n     *      - option_strings -- A list of command-line option strings which\n     *          should be associated with this action.\n     *\n     *      - dest -- The name of the attribute to hold the created object(s)\n     *\n     *      - nargs -- The number of command-line arguments that should be\n     *          consumed. By default, one argument will be consumed and a single\n     *          value will be produced.  Other values include:\n     *              - N (an integer) consumes N arguments (and produces a list)\n     *              - '?' consumes zero or one arguments\n     *              - '*' consumes zero or more arguments (and produces a list)\n     *              - '+' consumes one or more arguments (and produces a list)\n     *          Note that the difference between the default and nargs=1 is that\n     *          with the default, a single value will be produced, while with\n     *          nargs=1, a list containing a single value will be produced.\n     *\n     *      - const -- The value to be produced if the option is specified and the\n     *          option uses an action that takes no values.\n     *\n     *      - default -- The value to be produced if the option is not specified.\n     *\n     *      - type -- A callable that accepts a single string argument, and\n     *          returns the converted value.  The standard Python types str, int,\n     *          float, and complex are useful examples of such callables.  If None,\n     *          str is used.\n     *\n     *      - choices -- A container of values that should be allowed. If not None,\n     *          after a command-line argument has been converted to the appropriate\n     *          type, an exception will be raised if it is not a member of this\n     *          collection.\n     *\n     *      - required -- True if the action must always be specified at the\n     *          command line. This is only meaningful for optional command-line\n     *          arguments.\n     *\n     *      - help -- The help string describing the argument.\n     *\n     *      - metavar -- The name to be used for the option's argument with the\n     *          help string. If None, the 'dest' value will be used as the name.\n     */\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        this.option_strings = option_strings\n        this.dest = dest\n        this.nargs = nargs\n        this.const = const_value\n        this.default = default_value\n        this.type = type\n        this.choices = choices\n        this.required = required\n        this.help = help\n        this.metavar = metavar\n    }\n\n    _get_kwargs() {\n        let names = [\n            'option_strings',\n            'dest',\n            'nargs',\n            'const',\n            'default',\n            'type',\n            'choices',\n            'help',\n            'metavar'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    format_usage() {\n        return this.option_strings[0]\n    }\n\n    call(/*parser, namespace, values, option_string = undefined*/) {\n        throw new Error('.call() not defined')\n    }\n}))\n\n\nconst BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let _option_strings = []\n        for (let option_string of option_strings) {\n            _option_strings.push(option_string)\n\n            if (option_string.startsWith('--')) {\n                option_string = '--no-' + option_string.slice(2)\n                _option_strings.push(option_string)\n            }\n        }\n\n        if (help !== undefined && default_value !== undefined) {\n            help += ` (default: ${default_value})`\n        }\n\n        super({\n            option_strings: _option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values, option_string = undefined) {\n        if (this.option_strings.includes(option_string)) {\n            setattr(namespace, this.dest, !option_string.startsWith('--no-'))\n        }\n    }\n\n    format_usage() {\n        return this.option_strings.join(' | ')\n    }\n}))\n\n\nconst _StoreAction = _callable(class _StoreAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for store actions must be != 0; if you ' +\n                        'have nothing to store, actions such as store ' +\n                        'true or store const may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        setattr(namespace, this.dest, values)\n    }\n})\n\n\nconst _StoreConstAction = _callable(class _StoreConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help\n            //, metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        setattr(namespace, this.dest, this.const)\n    }\n})\n\n\nconst _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: false,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: true,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: true,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: false,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _AppendAction = _callable(class _AppendAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for append actions must be != 0; if arg ' +\n                        'strings are not supplying the value to append, ' +\n                        'the append const action may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _AppendConstAction = _callable(class _AppendConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(this.const)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _CountAction = _callable(class _CountAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let count = getattr(namespace, this.dest, undefined)\n        if (count === undefined) {\n            count = 0\n        }\n        setattr(namespace, this.dest, count + 1)\n    }\n})\n\n\nconst _HelpAction = _callable(class _HelpAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        parser.print_help()\n        parser.exit()\n    }\n})\n\n\nconst _VersionAction = _callable(class _VersionAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            version,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            version: undefined,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: \"show program's version number and exit\"\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n        this.version = version\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        let version = this.version\n        if (version === undefined) {\n            version = parser.version\n        }\n        let formatter = parser._get_formatter()\n        formatter.add_text(version)\n        parser._print_message(formatter.format_help(), process.stdout)\n        parser.exit()\n    }\n})\n\n\nconst _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            prog,\n            parser_class,\n            dest,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            prog: no_default,\n            parser_class: no_default,\n            dest: SUPPRESS,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let name_parser_map = {}\n\n        super({\n            option_strings,\n            dest,\n            nargs: PARSER,\n            choices: name_parser_map,\n            required,\n            help,\n            metavar\n        })\n\n        this._prog_prefix = prog\n        this._parser_class = parser_class\n        this._name_parser_map = name_parser_map\n        this._choices_actions = []\n    }\n\n    add_parser() {\n        let [\n            name,\n            kwargs\n        ] = _parse_opts(arguments, {\n            name: no_default,\n            '**kwargs': no_default\n        })\n\n        // set prog from the existing prefix\n        if (kwargs.prog === undefined) {\n            kwargs.prog = sub('%s %s', this._prog_prefix, name)\n        }\n\n        let aliases = getattr(kwargs, 'aliases', [])\n        delete kwargs.aliases\n\n        // create a pseudo-action to hold the choice help\n        if ('help' in kwargs) {\n            let help = kwargs.help\n            delete kwargs.help\n            let choice_action = this._ChoicesPseudoAction(name, aliases, help)\n            this._choices_actions.push(choice_action)\n        }\n\n        // create the parser and add it to the map\n        let parser = new this._parser_class(kwargs)\n        this._name_parser_map[name] = parser\n\n        // make parser available under aliases also\n        for (let alias of aliases) {\n            this._name_parser_map[alias] = parser\n        }\n\n        return parser\n    }\n\n    _get_subactions() {\n        return this._choices_actions\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let parser_name = values[0]\n        let arg_strings = values.slice(1)\n\n        // set the parser name if requested\n        if (this.dest !== SUPPRESS) {\n            setattr(namespace, this.dest, parser_name)\n        }\n\n        // select the parser\n        if (hasattr(this._name_parser_map, parser_name)) {\n            parser = this._name_parser_map[parser_name]\n        } else {\n            let args = {parser_name,\n                        choices: this._name_parser_map.join(', ')}\n            let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args)\n            throw new ArgumentError(this, msg)\n        }\n\n        // parse all the remaining options into the namespace\n        // store any unrecognized options on the object, so that the top\n        // level parser can decide what to do with them\n\n        // In case this subparser defines new defaults, we parse them\n        // in a new namespace object and then update the original\n        // namespace for the relevant parts.\n        let subnamespace\n        [ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)\n        for (let [ key, value ] of Object.entries(subnamespace)) {\n            setattr(namespace, key, value)\n        }\n\n        if (arg_strings.length) {\n            setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)\n        }\n    }\n}))\n\n\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {\n    constructor(name, aliases, help) {\n        let metavar = name, dest = name\n        if (aliases.length) {\n            metavar += sub(' (%s)', aliases.join(', '))\n        }\n        super({ option_strings: [], dest, help, metavar })\n    }\n})\n\n\nconst _ExtendAction = _callable(class _ExtendAction extends _AppendAction {\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items = items.concat(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\n// ==============\n// Type classes\n// ==============\nconst FileType = _callable(class FileType extends Function {\n    /*\n     *  Factory for creating file object types\n     *\n     *  Instances of FileType are typically passed as type= arguments to the\n     *  ArgumentParser add_argument() method.\n     *\n     *  Keyword Arguments:\n     *      - mode -- A string indicating how the file is to be opened. Accepts the\n     *          same values as the builtin open() function.\n     *      - bufsize -- The file's desired buffer size. Accepts the same values as\n     *          the builtin open() function.\n     *      - encoding -- The file's encoding. Accepts the same values as the\n     *          builtin open() function.\n     *      - errors -- A string indicating how encoding and decoding errors are to\n     *          be handled. Accepts the same value as the builtin open() function.\n     */\n\n    constructor() {\n        let [\n            flags,\n            encoding,\n            mode,\n            autoClose,\n            emitClose,\n            start,\n            end,\n            highWaterMark,\n            fs\n        ] = _parse_opts(arguments, {\n            flags: 'r',\n            encoding: undefined,\n            mode: undefined, // 0o666\n            autoClose: undefined, // true\n            emitClose: undefined, // false\n            start: undefined, // 0\n            end: undefined, // Infinity\n            highWaterMark: undefined, // 64 * 1024\n            fs: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        Object.defineProperty(this, 'name', {\n            get() {\n                return sub('FileType(%r)', flags)\n            }\n        })\n        this._flags = flags\n        this._options = {}\n        if (encoding !== undefined) this._options.encoding = encoding\n        if (mode !== undefined) this._options.mode = mode\n        if (autoClose !== undefined) this._options.autoClose = autoClose\n        if (emitClose !== undefined) this._options.emitClose = emitClose\n        if (start !== undefined) this._options.start = start\n        if (end !== undefined) this._options.end = end\n        if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark\n        if (fs !== undefined) this._options.fs = fs\n    }\n\n    call(string) {\n        // the special argument \"-\" means sys.std{in,out}\n        if (string === '-') {\n            if (this._flags.includes('r')) {\n                return process.stdin\n            } else if (this._flags.includes('w')) {\n                return process.stdout\n            } else {\n                let msg = sub('argument \"-\" with mode %r', this._flags)\n                throw new TypeError(msg)\n            }\n        }\n\n        // all other arguments are used as file names\n        let fd\n        try {\n            fd = fs.openSync(string, this._flags, this._options.mode)\n        } catch (e) {\n            let args = { filename: string, error: e.message }\n            let message = \"can't open '%(filename)s': %(error)s\"\n            throw new ArgumentTypeError(sub(message, args))\n        }\n\n        let options = Object.assign({ fd, flags: this._flags }, this._options)\n        if (this._flags.includes('r')) {\n            return fs.createReadStream(undefined, options)\n        } else if (this._flags.includes('w')) {\n            return fs.createWriteStream(undefined, options)\n        } else {\n            let msg = sub('argument \"%s\" with mode %r', string, this._flags)\n            throw new TypeError(msg)\n        }\n    }\n\n    [util.inspect.custom]() {\n        let args = [ this._flags ]\n        let kwargs = Object.entries(this._options).map(([ k, v ]) => {\n            if (k === 'mode') v = { value: v, [util.inspect.custom]() { return '0o' + this.value.toString(8) } }\n            return [ k, v ]\n        })\n        let args_str = []\n                .concat(args.filter(arg => arg !== -1).map(repr))\n                .concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined)\n                    .map(([kw, arg]) => sub('%s=%r', kw, arg)))\n                .join(', ')\n        return sub('%s(%s)', this.constructor.name, args_str)\n    }\n\n    toString() {\n        return this[util.inspect.custom]()\n    }\n})\n\n// ===========================\n// Optional and Positional Parsing\n// ===========================\nconst Namespace = _callable(class Namespace extends _AttributeHolder() {\n    /*\n     *  Simple object for storing attributes.\n     *\n     *  Implements equality by attribute names and values, and provides a simple\n     *  string representation.\n     */\n\n    constructor(options = {}) {\n        super()\n        Object.assign(this, options)\n    }\n})\n\n// unset string tag to mimic plain object\nNamespace.prototype[Symbol.toStringTag] = undefined\n\n\nconst _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {\n\n    constructor() {\n        let [\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        ] = _parse_opts(arguments, {\n            description: no_default,\n            prefix_chars: no_default,\n            argument_default: no_default,\n            conflict_handler: no_default\n        })\n\n        this.description = description\n        this.argument_default = argument_default\n        this.prefix_chars = prefix_chars\n        this.conflict_handler = conflict_handler\n\n        // set up registries\n        this._registries = {}\n\n        // register actions\n        this.register('action', undefined, _StoreAction)\n        this.register('action', 'store', _StoreAction)\n        this.register('action', 'store_const', _StoreConstAction)\n        this.register('action', 'store_true', _StoreTrueAction)\n        this.register('action', 'store_false', _StoreFalseAction)\n        this.register('action', 'append', _AppendAction)\n        this.register('action', 'append_const', _AppendConstAction)\n        this.register('action', 'count', _CountAction)\n        this.register('action', 'help', _HelpAction)\n        this.register('action', 'version', _VersionAction)\n        this.register('action', 'parsers', _SubParsersAction)\n        this.register('action', 'extend', _ExtendAction)\n        // LEGACY (v1 compatibility): camelcase variants\n        ;[ 'storeConst', 'storeTrue', 'storeFalse', 'appendConst' ].forEach(old_name => {\n            let new_name = _to_new_name(old_name)\n            this.register('action', old_name, util.deprecate(this._registry_get('action', new_name),\n                sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)))\n        })\n        // end\n\n        // raise an exception if the conflict handler is invalid\n        this._get_handler()\n\n        // action storage\n        this._actions = []\n        this._option_string_actions = {}\n\n        // groups\n        this._action_groups = []\n        this._mutually_exclusive_groups = []\n\n        // defaults storage\n        this._defaults = {}\n\n        // determines whether an \"option\" looks like a negative number\n        this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/\n\n        // whether or not there are any optionals that look like negative\n        // numbers -- uses a list so it can be shared and edited\n        this._has_negative_number_optionals = []\n    }\n\n    // ====================\n    // Registration methods\n    // ====================\n    register(registry_name, value, object) {\n        let registry = setdefault(this._registries, registry_name, {})\n        registry[value] = object\n    }\n\n    _registry_get(registry_name, value, default_value = undefined) {\n        return getattr(this._registries[registry_name], value, default_value)\n    }\n\n    // ==================================\n    // Namespace default accessor methods\n    // ==================================\n    set_defaults(kwargs) {\n        Object.assign(this._defaults, kwargs)\n\n        // if these defaults match any existing arguments, replace\n        // the previous default on the object with the new one\n        for (let action of this._actions) {\n            if (action.dest in kwargs) {\n                action.default = kwargs[action.dest]\n            }\n        }\n    }\n\n    get_default(dest) {\n        for (let action of this._actions) {\n            if (action.dest === dest && action.default !== undefined) {\n                return action.default\n            }\n        }\n        return this._defaults[dest]\n    }\n\n\n    // =======================\n    // Adding argument actions\n    // =======================\n    add_argument() {\n        /*\n         *  add_argument(dest, ..., name=value, ...)\n         *  add_argument(option_string, option_string, ..., name=value, ...)\n         */\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n        // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })\n        if (args.length === 1 && Array.isArray(args[0])) {\n            args = args[0]\n            deprecate('argument-array',\n                sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n                    args: args.map(repr).join(', ')\n                }))\n        }\n        // end\n\n        // if no positional args are supplied or only one is supplied and\n        // it doesn't look like an option string, parse a positional\n        // argument\n        let chars = this.prefix_chars\n        if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n            if (args.length && 'dest' in kwargs) {\n                throw new TypeError('dest supplied twice for positional argument')\n            }\n            kwargs = this._get_positional_kwargs(...args, kwargs)\n\n        // otherwise, we're adding an optional argument\n        } else {\n            kwargs = this._get_optional_kwargs(...args, kwargs)\n        }\n\n        // if no default was supplied, use the parser-level default\n        if (!('default' in kwargs)) {\n            let dest = kwargs.dest\n            if (dest in this._defaults) {\n                kwargs.default = this._defaults[dest]\n            } else if (this.argument_default !== undefined) {\n                kwargs.default = this.argument_default\n            }\n        }\n\n        // create the action object, and add it to the parser\n        let action_class = this._pop_action_class(kwargs)\n        if (typeof action_class !== 'function') {\n            throw new TypeError(sub('unknown action \"%s\"', action_class))\n        }\n        // eslint-disable-next-line new-cap\n        let action = new action_class(kwargs)\n\n        // raise an error if the action type is not callable\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            throw new TypeError(sub('%r is not callable', type_func))\n        }\n\n        if (type_func === FileType) {\n            throw new TypeError(sub('%r is a FileType class object, instance of it' +\n                                    ' must be passed', type_func))\n        }\n\n        // raise an error if the metavar does not match the type\n        if ('_get_formatter' in this) {\n            try {\n                this._get_formatter()._format_args(action, undefined)\n            } catch (err) {\n                // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same\n                if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n                    throw new TypeError('length of metavar tuple does not match nargs')\n                } else {\n                    throw err\n                }\n            }\n        }\n\n        return this._add_action(action)\n    }\n\n    add_argument_group() {\n        let group = _ArgumentGroup(this, ...arguments)\n        this._action_groups.push(group)\n        return group\n    }\n\n    add_mutually_exclusive_group() {\n        // eslint-disable-next-line no-use-before-define\n        let group = _MutuallyExclusiveGroup(this, ...arguments)\n        this._mutually_exclusive_groups.push(group)\n        return group\n    }\n\n    _add_action(action) {\n        // resolve any conflicts\n        this._check_conflict(action)\n\n        // add to actions list\n        this._actions.push(action)\n        action.container = this\n\n        // index the action by any option strings it has\n        for (let option_string of action.option_strings) {\n            this._option_string_actions[option_string] = action\n        }\n\n        // set the flag if any option strings look like negative numbers\n        for (let option_string of action.option_strings) {\n            if (this._negative_number_matcher.test(option_string)) {\n                if (!this._has_negative_number_optionals.length) {\n                    this._has_negative_number_optionals.push(true)\n                }\n            }\n        }\n\n        // return the created action\n        return action\n    }\n\n    _remove_action(action) {\n        _array_remove(this._actions, action)\n    }\n\n    _add_container_actions(container) {\n        // collect groups by titles\n        let title_group_map = {}\n        for (let group of this._action_groups) {\n            if (group.title in title_group_map) {\n                let msg = 'cannot merge actions - two groups are named %r'\n                throw new TypeError(sub(msg, group.title))\n            }\n            title_group_map[group.title] = group\n        }\n\n        // map each action to its group\n        let group_map = new Map()\n        for (let group of container._action_groups) {\n\n            // if a group with the title exists, use that, otherwise\n            // create a new group matching the container's group\n            if (!(group.title in title_group_map)) {\n                title_group_map[group.title] = this.add_argument_group({\n                    title: group.title,\n                    description: group.description,\n                    conflict_handler: group.conflict_handler\n                })\n            }\n\n            // map the actions to their new group\n            for (let action of group._group_actions) {\n                group_map.set(action, title_group_map[group.title])\n            }\n        }\n\n        // add container's mutually exclusive groups\n        // NOTE: if add_mutually_exclusive_group ever gains title= and\n        // description= then this code will need to be expanded as above\n        for (let group of container._mutually_exclusive_groups) {\n            let mutex_group = this.add_mutually_exclusive_group({\n                required: group.required\n            })\n\n            // map the actions to their new mutex group\n            for (let action of group._group_actions) {\n                group_map.set(action, mutex_group)\n            }\n        }\n\n        // add all actions to this container or their group\n        for (let action of container._actions) {\n            group_map.get(action)._add_action(action)\n        }\n    }\n\n    _get_positional_kwargs() {\n        let [\n            dest,\n            kwargs\n        ] = _parse_opts(arguments, {\n            dest: no_default,\n            '**kwargs': no_default\n        })\n\n        // make sure required is not specified\n        if ('required' in kwargs) {\n            let msg = \"'required' is an invalid argument for positionals\"\n            throw new TypeError(msg)\n        }\n\n        // mark positional arguments as required if at least one is\n        // always required\n        if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n            kwargs.required = true\n        }\n        if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n            kwargs.required = true\n        }\n\n        // return the keyword arguments with no option strings\n        return Object.assign(kwargs, { dest, option_strings: [] })\n    }\n\n    _get_optional_kwargs() {\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n\n        // determine short and long option strings\n        let option_strings = []\n        let long_option_strings = []\n        let option_string\n        for (option_string of args) {\n            // error on strings that don't start with an appropriate prefix\n            if (!this.prefix_chars.includes(option_string[0])) {\n                let args = {option: option_string,\n                            prefix_chars: this.prefix_chars}\n                let msg = 'invalid option string %(option)r: ' +\n                          'must start with a character %(prefix_chars)r'\n                throw new TypeError(sub(msg, args))\n            }\n\n            // strings starting with two prefix characters are long options\n            option_strings.push(option_string)\n            if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n                long_option_strings.push(option_string)\n            }\n        }\n\n        // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n        let dest = kwargs.dest\n        delete kwargs.dest\n        if (dest === undefined) {\n            let dest_option_string\n            if (long_option_strings.length) {\n                dest_option_string = long_option_strings[0]\n            } else {\n                dest_option_string = option_strings[0]\n            }\n            dest = _string_lstrip(dest_option_string, this.prefix_chars)\n            if (!dest) {\n                let msg = 'dest= is required for options like %r'\n                throw new TypeError(sub(msg, option_string))\n            }\n            dest = dest.replace(/-/g, '_')\n        }\n\n        // return the updated keyword arguments\n        return Object.assign(kwargs, { dest, option_strings })\n    }\n\n    _pop_action_class(kwargs, default_value = undefined) {\n        let action = getattr(kwargs, 'action', default_value)\n        delete kwargs.action\n        return this._registry_get('action', action, action)\n    }\n\n    _get_handler() {\n        // determine function from conflict handler string\n        let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler)\n        if (typeof this[handler_func_name] === 'function') {\n            return this[handler_func_name]\n        } else {\n            let msg = 'invalid conflict_resolution value: %r'\n            throw new TypeError(sub(msg, this.conflict_handler))\n        }\n    }\n\n    _check_conflict(action) {\n\n        // find all options that conflict with this option\n        let confl_optionals = []\n        for (let option_string of action.option_strings) {\n            if (hasattr(this._option_string_actions, option_string)) {\n                let confl_optional = this._option_string_actions[option_string]\n                confl_optionals.push([ option_string, confl_optional ])\n            }\n        }\n\n        // resolve any conflicts\n        if (confl_optionals.length) {\n            let conflict_handler = this._get_handler()\n            conflict_handler.call(this, action, confl_optionals)\n        }\n    }\n\n    _handle_conflict_error(action, conflicting_actions) {\n        let message = conflicting_actions.length === 1 ?\n            'conflicting option string: %s' :\n            'conflicting option strings: %s'\n        let conflict_string = conflicting_actions.map(([ option_string/*, action*/ ]) => option_string).join(', ')\n        throw new ArgumentError(action, sub(message, conflict_string))\n    }\n\n    _handle_conflict_resolve(action, conflicting_actions) {\n\n        // remove all conflicting options\n        for (let [ option_string, action ] of conflicting_actions) {\n\n            // remove the conflicting option\n            _array_remove(action.option_strings, option_string)\n            delete this._option_string_actions[option_string]\n\n            // if the option now has no option string, remove it from the\n            // container holding it\n            if (!action.option_strings.length) {\n                action.container._remove_action(action)\n            }\n        }\n    }\n}))\n\n\nconst _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {\n\n    constructor() {\n        let [\n            container,\n            title,\n            description,\n            kwargs\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            title: undefined,\n            description: undefined,\n            '**kwargs': no_default\n        })\n\n        // add any missing keyword arguments by checking the container\n        setdefault(kwargs, 'conflict_handler', container.conflict_handler)\n        setdefault(kwargs, 'prefix_chars', container.prefix_chars)\n        setdefault(kwargs, 'argument_default', container.argument_default)\n        super(Object.assign({ description }, kwargs))\n\n        // group attributes\n        this.title = title\n        this._group_actions = []\n\n        // share most attributes with the container\n        this._registries = container._registries\n        this._actions = container._actions\n        this._option_string_actions = container._option_string_actions\n        this._defaults = container._defaults\n        this._has_negative_number_optionals =\n            container._has_negative_number_optionals\n        this._mutually_exclusive_groups = container._mutually_exclusive_groups\n    }\n\n    _add_action(action) {\n        action = super._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        super._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {\n\n    constructor() {\n        let [\n            container,\n            required\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            required: false\n        })\n\n        super(container)\n        this.required = required\n        this._container = container\n    }\n\n    _add_action(action) {\n        if (action.required) {\n            let msg = 'mutually exclusive arguments must be optional'\n            throw new TypeError(msg)\n        }\n        action = this._container._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        this._container._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {\n    /*\n     *  Object for parsing command line strings into Python objects.\n     *\n     *  Keyword Arguments:\n     *      - prog -- The name of the program (default: sys.argv[0])\n     *      - usage -- A usage message (default: auto-generated from arguments)\n     *      - description -- A description of what the program does\n     *      - epilog -- Text following the argument descriptions\n     *      - parents -- Parsers whose arguments should be copied into this one\n     *      - formatter_class -- HelpFormatter class for printing help messages\n     *      - prefix_chars -- Characters that prefix optional arguments\n     *      - fromfile_prefix_chars -- Characters that prefix files containing\n     *          additional arguments\n     *      - argument_default -- The default value for all arguments\n     *      - conflict_handler -- String indicating how to handle conflicts\n     *      - add_help -- Add a -h/-help option\n     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously\n     *      - exit_on_error -- Determines whether or not ArgumentParser exits with\n     *          error info when an error occurs\n     */\n\n    constructor() {\n        let [\n            prog,\n            usage,\n            description,\n            epilog,\n            parents,\n            formatter_class,\n            prefix_chars,\n            fromfile_prefix_chars,\n            argument_default,\n            conflict_handler,\n            add_help,\n            allow_abbrev,\n            exit_on_error,\n            debug, // LEGACY (v1 compatibility), debug mode\n            version // LEGACY (v1 compatibility), version\n        ] = _parse_opts(arguments, {\n            prog: undefined,\n            usage: undefined,\n            description: undefined,\n            epilog: undefined,\n            parents: [],\n            formatter_class: HelpFormatter,\n            prefix_chars: '-',\n            fromfile_prefix_chars: undefined,\n            argument_default: undefined,\n            conflict_handler: 'error',\n            add_help: true,\n            allow_abbrev: true,\n            exit_on_error: true,\n            debug: undefined, // LEGACY (v1 compatibility), debug mode\n            version: undefined // LEGACY (v1 compatibility), version\n        })\n\n        // LEGACY (v1 compatibility)\n        if (debug !== undefined) {\n            deprecate('debug',\n                'The \"debug\" argument to ArgumentParser is deprecated. Please ' +\n                'override ArgumentParser.exit function instead.'\n            )\n        }\n\n        if (version !== undefined) {\n            deprecate('version',\n                'The \"version\" argument to ArgumentParser is deprecated. Please use ' +\n                \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\"\n            )\n        }\n        // end\n\n        super({\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        })\n\n        // default setting for prog\n        if (prog === undefined) {\n            prog = path.basename(get_argv()[0] || '')\n        }\n\n        this.prog = prog\n        this.usage = usage\n        this.epilog = epilog\n        this.formatter_class = formatter_class\n        this.fromfile_prefix_chars = fromfile_prefix_chars\n        this.add_help = add_help\n        this.allow_abbrev = allow_abbrev\n        this.exit_on_error = exit_on_error\n        // LEGACY (v1 compatibility), debug mode\n        this.debug = debug\n        // end\n\n        this._positionals = this.add_argument_group('positional arguments')\n        this._optionals = this.add_argument_group('optional arguments')\n        this._subparsers = undefined\n\n        // register types\n        function identity(string) {\n            return string\n        }\n        this.register('type', undefined, identity)\n        this.register('type', null, identity)\n        this.register('type', 'auto', identity)\n        this.register('type', 'int', function (x) {\n            let result = Number(x)\n            if (!Number.isInteger(result)) {\n                throw new TypeError(sub('could not convert string to int: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'float', function (x) {\n            let result = Number(x)\n            if (isNaN(result)) {\n                throw new TypeError(sub('could not convert string to float: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'str', String)\n        // LEGACY (v1 compatibility): custom types\n        this.register('type', 'string',\n            util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}'))\n        // end\n\n        // add help argument if necessary\n        // (using explicit default to override global argument_default)\n        let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0]\n        if (this.add_help) {\n            this.add_argument(\n                default_prefix + 'h',\n                default_prefix.repeat(2) + 'help',\n                {\n                    action: 'help',\n                    default: SUPPRESS,\n                    help: 'show this help message and exit'\n                }\n            )\n        }\n        // LEGACY (v1 compatibility), version\n        if (version) {\n            this.add_argument(\n                default_prefix + 'v',\n                default_prefix.repeat(2) + 'version',\n                {\n                    action: 'version',\n                    default: SUPPRESS,\n                    version: this.version,\n                    help: \"show program's version number and exit\"\n                }\n            )\n        }\n        // end\n\n        // add parent arguments and defaults\n        for (let parent of parents) {\n            this._add_container_actions(parent)\n            Object.assign(this._defaults, parent._defaults)\n        }\n    }\n\n    // =======================\n    // Pretty __repr__ methods\n    // =======================\n    _get_kwargs() {\n        let names = [\n            'prog',\n            'usage',\n            'description',\n            'formatter_class',\n            'conflict_handler',\n            'add_help'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    // ==================================\n    // Optional/Positional adding methods\n    // ==================================\n    add_subparsers() {\n        let [\n            kwargs\n        ] = _parse_opts(arguments, {\n            '**kwargs': no_default\n        })\n\n        if (this._subparsers !== undefined) {\n            this.error('cannot have multiple subparser arguments')\n        }\n\n        // add the parser class to the arguments if it's not present\n        setdefault(kwargs, 'parser_class', this.constructor)\n\n        if ('title' in kwargs || 'description' in kwargs) {\n            let title = getattr(kwargs, 'title', 'subcommands')\n            let description = getattr(kwargs, 'description', undefined)\n            delete kwargs.title\n            delete kwargs.description\n            this._subparsers = this.add_argument_group(title, description)\n        } else {\n            this._subparsers = this._positionals\n        }\n\n        // prog defaults to the usage message of this parser, skipping\n        // optional arguments and with no \"usage:\" prefix\n        if (kwargs.prog === undefined) {\n            let formatter = this._get_formatter()\n            let positionals = this._get_positional_actions()\n            let groups = this._mutually_exclusive_groups\n            formatter.add_usage(this.usage, positionals, groups, '')\n            kwargs.prog = formatter.format_help().trim()\n        }\n\n        // create the parsers action and add it to the positionals list\n        let parsers_class = this._pop_action_class(kwargs, 'parsers')\n        // eslint-disable-next-line new-cap\n        let action = new parsers_class(Object.assign({ option_strings: [] }, kwargs))\n        this._subparsers._add_action(action)\n\n        // return the created parsers action\n        return action\n    }\n\n    _add_action(action) {\n        if (action.option_strings.length) {\n            this._optionals._add_action(action)\n        } else {\n            this._positionals._add_action(action)\n        }\n        return action\n    }\n\n    _get_optional_actions() {\n        return this._actions.filter(action => action.option_strings.length)\n    }\n\n    _get_positional_actions() {\n        return this._actions.filter(action => !action.option_strings.length)\n    }\n\n    // =====================================\n    // Command line argument parsing methods\n    // =====================================\n    parse_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_args(args, namespace)\n        if (argv && argv.length > 0) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_args(args = undefined, namespace = undefined) {\n        if (args === undefined) {\n            args = get_argv().slice(1)\n        }\n\n        // default Namespace built from parser defaults\n        if (namespace === undefined) {\n            namespace = new Namespace()\n        }\n\n        // add any action defaults that aren't present\n        for (let action of this._actions) {\n            if (action.dest !== SUPPRESS) {\n                if (!hasattr(namespace, action.dest)) {\n                    if (action.default !== SUPPRESS) {\n                        setattr(namespace, action.dest, action.default)\n                    }\n                }\n            }\n        }\n\n        // add any parser defaults that aren't present\n        for (let dest of Object.keys(this._defaults)) {\n            if (!hasattr(namespace, dest)) {\n                setattr(namespace, dest, this._defaults[dest])\n            }\n        }\n\n        // parse the arguments and exit if there are any errors\n        if (this.exit_on_error) {\n            try {\n                [ namespace, args ] = this._parse_known_args(args, namespace)\n            } catch (err) {\n                if (err instanceof ArgumentError) {\n                    this.error(err.message)\n                } else {\n                    throw err\n                }\n            }\n        } else {\n            [ namespace, args ] = this._parse_known_args(args, namespace)\n        }\n\n        if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n            args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))\n            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)\n        }\n\n        return [ namespace, args ]\n    }\n\n    _parse_known_args(arg_strings, namespace) {\n        // replace arg strings that are file references\n        if (this.fromfile_prefix_chars !== undefined) {\n            arg_strings = this._read_args_from_files(arg_strings)\n        }\n\n        // map all mutually exclusive arguments to the other arguments\n        // they can't occur with\n        let action_conflicts = new Map()\n        for (let mutex_group of this._mutually_exclusive_groups) {\n            let group_actions = mutex_group._group_actions\n            for (let [ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {\n                let conflicts = action_conflicts.get(mutex_action) || []\n                conflicts = conflicts.concat(group_actions.slice(0, +i))\n                conflicts = conflicts.concat(group_actions.slice(+i + 1))\n                action_conflicts.set(mutex_action, conflicts)\n            }\n        }\n\n        // find all option indices, and determine the arg_string_pattern\n        // which has an 'O' if there is an option at an index,\n        // an 'A' if there is an argument, or a '-' if there is a '--'\n        let option_string_indices = {}\n        let arg_string_pattern_parts = []\n        let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()\n        for (let [ i, arg_string ] of arg_strings_iter) {\n\n            // all args after -- are non-options\n            if (arg_string === '--') {\n                arg_string_pattern_parts.push('-')\n                for ([ i, arg_string ] of arg_strings_iter) {\n                    arg_string_pattern_parts.push('A')\n                }\n\n            // otherwise, add the arg to the arg strings\n            // and note the index if it was an option\n            } else {\n                let option_tuple = this._parse_optional(arg_string)\n                let pattern\n                if (option_tuple === undefined) {\n                    pattern = 'A'\n                } else {\n                    option_string_indices[i] = option_tuple\n                    pattern = 'O'\n                }\n                arg_string_pattern_parts.push(pattern)\n            }\n        }\n\n        // join the pieces together to form the pattern\n        let arg_strings_pattern = arg_string_pattern_parts.join('')\n\n        // converts arg strings to the appropriate and then takes the action\n        let seen_actions = new Set()\n        let seen_non_default_actions = new Set()\n        let extras\n\n        let take_action = (action, argument_strings, option_string = undefined) => {\n            seen_actions.add(action)\n            let argument_values = this._get_values(action, argument_strings)\n\n            // error if this argument is not allowed with other previously\n            // seen arguments, assuming that actions that use the default\n            // value don't really count as \"present\"\n            if (argument_values !== action.default) {\n                seen_non_default_actions.add(action)\n                for (let conflict_action of action_conflicts.get(action) || []) {\n                    if (seen_non_default_actions.has(conflict_action)) {\n                        let msg = 'not allowed with argument %s'\n                        let action_name = _get_action_name(conflict_action)\n                        throw new ArgumentError(action, sub(msg, action_name))\n                    }\n                }\n            }\n\n            // take the action if we didn't receive a SUPPRESS value\n            // (e.g. from a default)\n            if (argument_values !== SUPPRESS) {\n                action(this, namespace, argument_values, option_string)\n            }\n        }\n\n        // function to convert arg_strings into an optional action\n        let consume_optional = start_index => {\n\n            // get the optional identified at this index\n            let option_tuple = option_string_indices[start_index]\n            let [ action, option_string, explicit_arg ] = option_tuple\n\n            // identify additional optionals in the same arg string\n            // (e.g. -xyz is the same as -x -y -z if no args are required)\n            let action_tuples = []\n            let stop\n            for (;;) {\n\n                // if we found no optional action, skip it\n                if (action === undefined) {\n                    extras.push(arg_strings[start_index])\n                    return start_index + 1\n                }\n\n                // if there is an explicit argument, try to match the\n                // optional's string arguments to only this\n                if (explicit_arg !== undefined) {\n                    let arg_count = this._match_argument(action, 'A')\n\n                    // if the action is a single-dash option and takes no\n                    // arguments, try to parse more single-dash options out\n                    // of the tail of the option string\n                    let chars = this.prefix_chars\n                    if (arg_count === 0 && !chars.includes(option_string[1])) {\n                        action_tuples.push([ action, [], option_string ])\n                        let char = option_string[0]\n                        option_string = char + explicit_arg[0]\n                        let new_explicit_arg = explicit_arg.slice(1) || undefined\n                        let optionals_map = this._option_string_actions\n                        if (hasattr(optionals_map, option_string)) {\n                            action = optionals_map[option_string]\n                            explicit_arg = new_explicit_arg\n                        } else {\n                            let msg = 'ignored explicit argument %r'\n                            throw new ArgumentError(action, sub(msg, explicit_arg))\n                        }\n\n                    // if the action expect exactly one argument, we've\n                    // successfully matched the option; exit the loop\n                    } else if (arg_count === 1) {\n                        stop = start_index + 1\n                        let args = [ explicit_arg ]\n                        action_tuples.push([ action, args, option_string ])\n                        break\n\n                    // error if a double-dash option did not use the\n                    // explicit argument\n                    } else {\n                        let msg = 'ignored explicit argument %r'\n                        throw new ArgumentError(action, sub(msg, explicit_arg))\n                    }\n\n                // if there is no explicit argument, try to match the\n                // optional's string arguments with the following strings\n                // if successful, exit the loop\n                } else {\n                    let start = start_index + 1\n                    let selected_patterns = arg_strings_pattern.slice(start)\n                    let arg_count = this._match_argument(action, selected_patterns)\n                    stop = start + arg_count\n                    let args = arg_strings.slice(start, stop)\n                    action_tuples.push([ action, args, option_string ])\n                    break\n                }\n            }\n\n            // add the Optional to the list and return the index at which\n            // the Optional's string args stopped\n            assert(action_tuples.length)\n            for (let [ action, args, option_string ] of action_tuples) {\n                take_action(action, args, option_string)\n            }\n            return stop\n        }\n\n        // the list of Positionals left to be parsed; this is modified\n        // by consume_positionals()\n        let positionals = this._get_positional_actions()\n\n        // function to convert arg_strings into positional actions\n        let consume_positionals = start_index => {\n            // match as many Positionals as possible\n            let selected_pattern = arg_strings_pattern.slice(start_index)\n            let arg_counts = this._match_arguments_partial(positionals, selected_pattern)\n\n            // slice off the appropriate arg strings for each Positional\n            // and add the Positional and its args to the list\n            for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {\n                let action = positionals[i]\n                let arg_count = arg_counts[i]\n                let args = arg_strings.slice(start_index, start_index + arg_count)\n                start_index += arg_count\n                take_action(action, args)\n            }\n\n            // slice off the Positionals that we just parsed and return the\n            // index at which the Positionals' string args stopped\n            positionals = positionals.slice(arg_counts.length)\n            return start_index\n        }\n\n        // consume Positionals and Optionals alternately, until we have\n        // passed the last option string\n        extras = []\n        let start_index = 0\n        let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number))\n        while (start_index <= max_option_string_index) {\n\n            // consume any Positionals preceding the next option\n            let next_option_string_index = Math.min(\n                // eslint-disable-next-line no-loop-func\n                ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index)\n            )\n            if (start_index !== next_option_string_index) {\n                let positionals_end_index = consume_positionals(start_index)\n\n                // only try to parse the next optional if we didn't consume\n                // the option string during the positionals parsing\n                if (positionals_end_index > start_index) {\n                    start_index = positionals_end_index\n                    continue\n                } else {\n                    start_index = positionals_end_index\n                }\n            }\n\n            // if we consumed all the positionals we could and we're not\n            // at the index of an option string, there were extra arguments\n            if (!(start_index in option_string_indices)) {\n                let strings = arg_strings.slice(start_index, next_option_string_index)\n                extras = extras.concat(strings)\n                start_index = next_option_string_index\n            }\n\n            // consume the next optional and any arguments for it\n            start_index = consume_optional(start_index)\n        }\n\n        // consume any positionals following the last Optional\n        let stop_index = consume_positionals(start_index)\n\n        // if we didn't consume all the argument strings, there were extras\n        extras = extras.concat(arg_strings.slice(stop_index))\n\n        // make sure all required actions were present and also convert\n        // action defaults which were not given as arguments\n        let required_actions = []\n        for (let action of this._actions) {\n            if (!seen_actions.has(action)) {\n                if (action.required) {\n                    required_actions.push(_get_action_name(action))\n                } else {\n                    // Convert action default now instead of doing it before\n                    // parsing arguments to avoid calling convert functions\n                    // twice (which may fail) if the argument was given, but\n                    // only if it was defined already in the namespace\n                    if (action.default !== undefined &&\n                        typeof action.default === 'string' &&\n                        hasattr(namespace, action.dest) &&\n                        action.default === getattr(namespace, action.dest)) {\n                        setattr(namespace, action.dest,\n                                this._get_value(action, action.default))\n                    }\n                }\n            }\n        }\n\n        if (required_actions.length) {\n            this.error(sub('the following arguments are required: %s',\n                       required_actions.join(', ')))\n        }\n\n        // make sure all required groups had one option present\n        for (let group of this._mutually_exclusive_groups) {\n            if (group.required) {\n                let no_actions_used = true\n                for (let action of group._group_actions) {\n                    if (seen_non_default_actions.has(action)) {\n                        no_actions_used = false\n                        break\n                    }\n                }\n\n                // if no actions were used, report the error\n                if (no_actions_used) {\n                    let names = group._group_actions\n                        .filter(action => action.help !== SUPPRESS)\n                        .map(action => _get_action_name(action))\n                    let msg = 'one of the arguments %s is required'\n                    this.error(sub(msg, names.join(' ')))\n                }\n            }\n        }\n\n        // return the updated namespace and the extra arguments\n        return [ namespace, extras ]\n    }\n\n    _read_args_from_files(arg_strings) {\n        // expand arguments referencing files\n        let new_arg_strings = []\n        for (let arg_string of arg_strings) {\n\n            // for regular arguments, just add them back into the list\n            if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n                new_arg_strings.push(arg_string)\n\n            // replace arguments referencing files with the file content\n            } else {\n                try {\n                    let args_file = fs.readFileSync(arg_string.slice(1), 'utf8')\n                    let arg_strings = []\n                    for (let arg_line of splitlines(args_file)) {\n                        for (let arg of this.convert_arg_line_to_args(arg_line)) {\n                            arg_strings.push(arg)\n                        }\n                    }\n                    arg_strings = this._read_args_from_files(arg_strings)\n                    new_arg_strings = new_arg_strings.concat(arg_strings)\n                } catch (err) {\n                    this.error(err.message)\n                }\n            }\n        }\n\n        // return the modified argument list\n        return new_arg_strings\n    }\n\n    convert_arg_line_to_args(arg_line) {\n        return [arg_line]\n    }\n\n    _match_argument(action, arg_strings_pattern) {\n        // match the pattern for this action to the arg strings\n        let nargs_pattern = this._get_nargs_pattern(action)\n        let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern))\n\n        // raise an exception if we weren't able to find a match\n        if (match === null) {\n            let nargs_errors = {\n                undefined: 'expected one argument',\n                [OPTIONAL]: 'expected at most one argument',\n                [ONE_OR_MORE]: 'expected at least one argument'\n            }\n            let msg = nargs_errors[action.nargs]\n            if (msg === undefined) {\n                msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs)\n            }\n            throw new ArgumentError(action, msg)\n        }\n\n        // return the number of arguments matched\n        return match[1].length\n    }\n\n    _match_arguments_partial(actions, arg_strings_pattern) {\n        // progressively shorten the actions list by slicing off the\n        // final actions until we find a match\n        let result = []\n        for (let i of range(actions.length, 0, -1)) {\n            let actions_slice = actions.slice(0, i)\n            let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('')\n            let match = arg_strings_pattern.match(new RegExp('^' + pattern))\n            if (match !== null) {\n                result = result.concat(match.slice(1).map(string => string.length))\n                break\n            }\n        }\n\n        // return the list of arg string counts\n        return result\n    }\n\n    _parse_optional(arg_string) {\n        // if it's an empty string, it was meant to be a positional\n        if (!arg_string) {\n            return undefined\n        }\n\n        // if it doesn't start with a prefix, it was meant to be positional\n        if (!this.prefix_chars.includes(arg_string[0])) {\n            return undefined\n        }\n\n        // if the option string is present in the parser, return the action\n        if (arg_string in this._option_string_actions) {\n            let action = this._option_string_actions[arg_string]\n            return [ action, arg_string, undefined ]\n        }\n\n        // if it's just a single character, it was meant to be positional\n        if (arg_string.length === 1) {\n            return undefined\n        }\n\n        // if the option string before the \"=\" is present, return the action\n        if (arg_string.includes('=')) {\n            let [ option_string, explicit_arg ] = _string_split(arg_string, '=', 1)\n            if (option_string in this._option_string_actions) {\n                let action = this._option_string_actions[option_string]\n                return [ action, option_string, explicit_arg ]\n            }\n        }\n\n        // search through all possible prefixes of the option string\n        // and all actions in the parser for possible interpretations\n        let option_tuples = this._get_option_tuples(arg_string)\n\n        // if multiple actions match, the option string was ambiguous\n        if (option_tuples.length > 1) {\n            let options = option_tuples.map(([ /*action*/, option_string/*, explicit_arg*/ ]) => option_string).join(', ')\n            let args = {option: arg_string, matches: options}\n            let msg = 'ambiguous option: %(option)s could match %(matches)s'\n            this.error(sub(msg, args))\n\n        // if exactly one action matched, this segmentation is good,\n        // so return the parsed action\n        } else if (option_tuples.length === 1) {\n            let [ option_tuple ] = option_tuples\n            return option_tuple\n        }\n\n        // if it was not found as an option, but it looks like a negative\n        // number, it was meant to be positional\n        // unless there are negative-number-like options\n        if (this._negative_number_matcher.test(arg_string)) {\n            if (!this._has_negative_number_optionals.length) {\n                return undefined\n            }\n        }\n\n        // if it contains a space, it was meant to be a positional\n        if (arg_string.includes(' ')) {\n            return undefined\n        }\n\n        // it was meant to be an optional but there is no such option\n        // in this parser (though it might be a valid option in a subparser)\n        return [ undefined, arg_string, undefined ]\n    }\n\n    _get_option_tuples(option_string) {\n        let result = []\n\n        // option strings starting with two prefix characters are only\n        // split at the '='\n        let chars = this.prefix_chars\n        if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n            if (this.allow_abbrev) {\n                let option_prefix, explicit_arg\n                if (option_string.includes('=')) {\n                    [ option_prefix, explicit_arg ] = _string_split(option_string, '=', 1)\n                } else {\n                    option_prefix = option_string\n                    explicit_arg = undefined\n                }\n                for (let option_string of Object.keys(this._option_string_actions)) {\n                    if (option_string.startsWith(option_prefix)) {\n                        let action = this._option_string_actions[option_string]\n                        let tup = [ action, option_string, explicit_arg ]\n                        result.push(tup)\n                    }\n                }\n            }\n\n        // single character options can be concatenated with their arguments\n        // but multiple character options always have to have their argument\n        // separate\n        } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n            let option_prefix = option_string\n            let explicit_arg = undefined\n            let short_option_prefix = option_string.slice(0, 2)\n            let short_explicit_arg = option_string.slice(2)\n\n            for (let option_string of Object.keys(this._option_string_actions)) {\n                if (option_string === short_option_prefix) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, short_explicit_arg ]\n                    result.push(tup)\n                } else if (option_string.startsWith(option_prefix)) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, explicit_arg ]\n                    result.push(tup)\n                }\n            }\n\n        // shouldn't ever get here\n        } else {\n            this.error(sub('unexpected option string: %s', option_string))\n        }\n\n        // return the collected option tuples\n        return result\n    }\n\n    _get_nargs_pattern(action) {\n        // in all examples below, we have to allow for '--' args\n        // which are represented as '-' in the pattern\n        let nargs = action.nargs\n        let nargs_pattern\n\n        // the default (None) is assumed to be a single argument\n        if (nargs === undefined) {\n            nargs_pattern = '(-*A-*)'\n\n        // allow zero or one arguments\n        } else if (nargs === OPTIONAL) {\n            nargs_pattern = '(-*A?-*)'\n\n        // allow zero or more arguments\n        } else if (nargs === ZERO_OR_MORE) {\n            nargs_pattern = '(-*[A-]*)'\n\n        // allow one or more arguments\n        } else if (nargs === ONE_OR_MORE) {\n            nargs_pattern = '(-*A[A-]*)'\n\n        // allow any number of options or arguments\n        } else if (nargs === REMAINDER) {\n            nargs_pattern = '([-AO]*)'\n\n        // allow one argument followed by any number of options or arguments\n        } else if (nargs === PARSER) {\n            nargs_pattern = '(-*A[-AO]*)'\n\n        // suppress action, like nargs=0\n        } else if (nargs === SUPPRESS) {\n            nargs_pattern = '(-*-*)'\n\n        // all others should be integers\n        } else {\n            nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'))\n        }\n\n        // if this is an optional action, -- is not allowed\n        if (action.option_strings.length) {\n            nargs_pattern = nargs_pattern.replace(/-\\*/g, '')\n            nargs_pattern = nargs_pattern.replace(/-/g, '')\n        }\n\n        // return the pattern\n        return nargs_pattern\n    }\n\n    // ========================\n    // Alt command line argument parsing, allowing free intermix\n    // ========================\n\n    parse_intermixed_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_intermixed_args(args, namespace)\n        if (argv.length) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_intermixed_args(args = undefined, namespace = undefined) {\n        // returns a namespace and list of extras\n        //\n        // positional can be freely intermixed with optionals.  optionals are\n        // first parsed with all positional arguments deactivated.  The 'extras'\n        // are then parsed.  If the parser definition is incompatible with the\n        // intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n        // TypeError is raised.\n        //\n        // positionals are 'deactivated' by setting nargs and default to\n        // SUPPRESS.  This blocks the addition of that positional to the\n        // namespace\n\n        let extras\n        let positionals = this._get_positional_actions()\n        let a = positionals.filter(action => [ PARSER, REMAINDER ].includes(action.nargs))\n        if (a.length) {\n            throw new TypeError(sub('parse_intermixed_args: positional arg' +\n                                    ' with nargs=%s', a[0].nargs))\n        }\n\n        for (let group of this._mutually_exclusive_groups) {\n            for (let action of group._group_actions) {\n                if (positionals.includes(action)) {\n                    throw new TypeError('parse_intermixed_args: positional in' +\n                                        ' mutuallyExclusiveGroup')\n                }\n            }\n        }\n\n        let save_usage\n        try {\n            save_usage = this.usage\n            let remaining_args\n            try {\n                if (this.usage === undefined) {\n                    // capture the full usage for use in error messages\n                    this.usage = this.format_usage().slice(7)\n                }\n                for (let action of positionals) {\n                    // deactivate positionals\n                    action.save_nargs = action.nargs\n                    // action.nargs = 0\n                    action.nargs = SUPPRESS\n                    action.save_default = action.default\n                    action.default = SUPPRESS\n                }\n                [ namespace, remaining_args ] = this.parse_known_args(args,\n                                                                      namespace)\n                for (let action of positionals) {\n                    // remove the empty positional values from namespace\n                    let attr = getattr(namespace, action.dest)\n                    if (Array.isArray(attr) && attr.length === 0) {\n                        // eslint-disable-next-line no-console\n                        console.warn(sub('Do not expect %s in %s', action.dest, namespace))\n                        delattr(namespace, action.dest)\n                    }\n                }\n            } finally {\n                // restore nargs and usage before exiting\n                for (let action of positionals) {\n                    action.nargs = action.save_nargs\n                    action.default = action.save_default\n                }\n            }\n            let optionals = this._get_optional_actions()\n            try {\n                // parse positionals.  optionals aren't normally required, but\n                // they could be, so make sure they aren't.\n                for (let action of optionals) {\n                    action.save_required = action.required\n                    action.required = false\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.save_required = group.required\n                    group.required = false\n                }\n                [ namespace, extras ] = this.parse_known_args(remaining_args,\n                                                              namespace)\n            } finally {\n                // restore parser values before exiting\n                for (let action of optionals) {\n                    action.required = action.save_required\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.required = group.save_required\n                }\n            }\n        } finally {\n            this.usage = save_usage\n        }\n        return [ namespace, extras ]\n    }\n\n    // ========================\n    // Value conversion methods\n    // ========================\n    _get_values(action, arg_strings) {\n        // for everything but PARSER, REMAINDER args, strip out first '--'\n        if (![PARSER, REMAINDER].includes(action.nargs)) {\n            try {\n                _array_remove(arg_strings, '--')\n            } catch (err) {}\n        }\n\n        let value\n        // optional argument produces a default when not present\n        if (!arg_strings.length && action.nargs === OPTIONAL) {\n            if (action.option_strings.length) {\n                value = action.const\n            } else {\n                value = action.default\n            }\n            if (typeof value === 'string') {\n                value = this._get_value(action, value)\n                this._check_value(action, value)\n            }\n\n        // when nargs='*' on a positional, if there were no command-line\n        // args, use the default if it is anything other than None\n        } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE &&\n              !action.option_strings.length) {\n            if (action.default !== undefined) {\n                value = action.default\n            } else {\n                value = arg_strings\n            }\n            this._check_value(action, value)\n\n        // single argument or optional argument produces a single value\n        } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n            let arg_string = arg_strings[0]\n            value = this._get_value(action, arg_string)\n            this._check_value(action, value)\n\n        // REMAINDER arguments convert all values, checking none\n        } else if (action.nargs === REMAINDER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n\n        // PARSER arguments convert all values, but check only the first\n        } else if (action.nargs === PARSER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n            this._check_value(action, value[0])\n\n        // SUPPRESS argument does not put anything in the namespace\n        } else if (action.nargs === SUPPRESS) {\n            value = SUPPRESS\n\n        // all other types of nargs produce a list\n        } else {\n            value = arg_strings.map(v => this._get_value(action, v))\n            for (let v of value) {\n                this._check_value(action, v)\n            }\n        }\n\n        // return the converted value\n        return value\n    }\n\n    _get_value(action, arg_string) {\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            let msg = '%r is not callable'\n            throw new ArgumentError(action, sub(msg, type_func))\n        }\n\n        // convert the value to the appropriate type\n        let result\n        try {\n            try {\n                result = type_func(arg_string)\n            } catch (err) {\n                // Dear TC39, why would you ever consider making es6 classes not callable?\n                // We had one universal interface, [[Call]], which worked for anything\n                // (with familiar this-instanceof guard for classes). Now we have two.\n                if (err instanceof TypeError &&\n                    /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n                    // eslint-disable-next-line new-cap\n                    result = new type_func(arg_string)\n                } else {\n                    throw err\n                }\n            }\n\n        } catch (err) {\n            // ArgumentTypeErrors indicate errors\n            if (err instanceof ArgumentTypeError) {\n                //let name = getattr(action.type, 'name', repr(action.type))\n                let msg = err.message\n                throw new ArgumentError(action, msg)\n\n            // TypeErrors or ValueErrors also indicate errors\n            } else if (err instanceof TypeError) {\n                let name = getattr(action.type, 'name', repr(action.type))\n                let args = {type: name, value: arg_string}\n                let msg = 'invalid %(type)s value: %(value)r'\n                throw new ArgumentError(action, sub(msg, args))\n            } else {\n                throw err\n            }\n        }\n\n        // return the converted value\n        return result\n    }\n\n    _check_value(action, value) {\n        // converted value must be one of the choices (if specified)\n        if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n            let args = {value,\n                        choices: _choices_to_array(action.choices).map(repr).join(', ')}\n            let msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n            throw new ArgumentError(action, sub(msg, args))\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_usage() {\n        let formatter = this._get_formatter()\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n        return formatter.format_help()\n    }\n\n    format_help() {\n        let formatter = this._get_formatter()\n\n        // usage\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n\n        // description\n        formatter.add_text(this.description)\n\n        // positionals, optionals and user-defined groups\n        for (let action_group of this._action_groups) {\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n        }\n\n        // epilog\n        formatter.add_text(this.epilog)\n\n        // determine help from format above\n        return formatter.format_help()\n    }\n\n    _get_formatter() {\n        // eslint-disable-next-line new-cap\n        return new this.formatter_class({ prog: this.prog })\n    }\n\n    // =====================\n    // Help-printing methods\n    // =====================\n    print_usage(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_usage(), file)\n    }\n\n    print_help(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_help(), file)\n    }\n\n    _print_message(message, file = undefined) {\n        if (message) {\n            if (file === undefined) file = process.stderr\n            file.write(message)\n        }\n    }\n\n    // ===============\n    // Exiting methods\n    // ===============\n    exit(status = 0, message = undefined) {\n        if (message) {\n            this._print_message(message, process.stderr)\n        }\n        process.exit(status)\n    }\n\n    error(message) {\n        /*\n         *  error(message: string)\n         *\n         *  Prints a usage message incorporating the message to stderr and\n         *  exits.\n         *\n         *  If you override this in a subclass, it should not return -- it\n         *  should either exit or raise an exception.\n         */\n\n        // LEGACY (v1 compatibility), debug mode\n        if (this.debug === true) throw new Error(message)\n        // end\n        this.print_usage(process.stderr)\n        let args = {prog: this.prog, message: message}\n        this.exit(2, sub('%(prog)s: error: %(message)s\\n', args))\n    }\n}))\n\n\nmodule.exports = {\n    ArgumentParser,\n    ArgumentError,\n    ArgumentTypeError,\n    BooleanOptionalAction,\n    FileType,\n    HelpFormatter,\n    ArgumentDefaultsHelpFormatter,\n    RawDescriptionHelpFormatter,\n    RawTextHelpFormatter,\n    MetavarTypeHelpFormatter,\n    Namespace,\n    Action,\n    ONE_OR_MORE,\n    OPTIONAL,\n    PARSER,\n    REMAINDER,\n    SUPPRESS,\n    ZERO_OR_MORE\n}\n\n// LEGACY (v1 compatibility), Const alias\nObject.defineProperty(module.exports, 'Const', {\n    get() {\n        let result = {}\n        Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n))\n                    return v\n                }\n            })\n        })\n        Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n))\n                    return v\n                }\n            })\n        })\n        return result\n    },\n    enumerable: false\n})\n// end\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}