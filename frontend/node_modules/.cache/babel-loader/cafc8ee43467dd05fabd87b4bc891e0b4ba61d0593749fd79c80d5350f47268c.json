{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\nfunction isPureVoid(node) {\n  return core.types.isUnaryExpression(node) && node.operator === \"void\" && core.types.isPureish(node.argument);\n}\nfunction unshiftForXStatementBody(statementPath, newStatements) {\n  statementPath.ensureBlock();\n  const {\n    scope,\n    node\n  } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(name => scope.hasBinding(name));\n  if (hasShadowedBlockScopedBindings) {\n    node.body = core.types.blockStatement([...newStatements, node.body]);\n  } else {\n    node.body.body.unshift(...newStatements);\n  }\n}\nfunction hasArrayRest(pattern) {\n  return pattern.elements.some(elem => core.types.isRestElement(elem));\n}\nfunction hasObjectRest(pattern) {\n  return pattern.properties.some(prop => core.types.isRestElement(prop));\n}\nconst STOP_TRAVERSAL = {};\nconst arrayUnpackVisitor = (node, ancestors, state) => {\n  if (!ancestors.length) {\n    return;\n  }\n  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\nclass DestructuringTransformer {\n  constructor(opts) {\n    this.blockHoist = void 0;\n    this.operator = void 0;\n    this.arrayRefSet = void 0;\n    this.nodes = void 0;\n    this.scope = void 0;\n    this.kind = void 0;\n    this.iterableIsArray = void 0;\n    this.arrayLikeIsIterable = void 0;\n    this.objectRestNoSymbols = void 0;\n    this.useBuiltIns = void 0;\n    this.addHelper = void 0;\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n  getExtendsHelper() {\n    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : this.addHelper(\"extends\");\n  }\n  buildVariableAssignment(id, init) {\n    let op = this.operator;\n    if (core.types.isMemberExpression(id) || core.types.isOptionalMemberExpression(id)) op = \"=\";\n    let node;\n    if (op) {\n      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n    } else {\n      let nodeInit;\n      if ((this.kind === \"const\" || this.kind === \"using\") && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = core.types.cloneNode(init);\n      }\n      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);\n    }\n    node._blockHoist = this.blockHoist;\n    return node;\n  }\n  buildVariableDeclaration(id, init) {\n    const declar = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n  push(id, _init) {\n    const init = core.types.cloneNode(_init);\n    if (core.types.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (core.types.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (core.types.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n  toArray(node, count) {\n    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n  pushAssignmentPattern({\n    left,\n    right\n  }, valueRef) {\n    if (isPureVoid(valueRef)) {\n      this.push(left, right);\n      return;\n    }\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression(\"===\", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));\n    if (core.types.isPattern(left)) {\n      let patternId;\n      let node;\n      if (this.kind === \"const\" || this.kind === \"let\" || this.kind === \"using\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n        node = core.types.expressionStatement(core.types.assignmentExpression(\"=\", core.types.cloneNode(tempId), tempConditional));\n      }\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n  pushObjectProperty(prop, propRef) {\n    if (core.types.isLiteral(prop.key)) prop.computed = true;\n    const pattern = prop.value;\n    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);\n    if (core.types.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n  pushObjectPattern(pattern, objRef) {\n    if (!pattern.properties.length) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), isPureVoid(objRef) ? [] : [objRef])));\n      return;\n    }\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n    if (hasObjectRest(pattern)) {\n      let copiedPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (core.types.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(this.buildVariableDeclaration(name, key));\n          if (!copiedPattern) {\n            copiedPattern = pattern = Object.assign({}, pattern, {\n              properties: pattern.properties.slice()\n            });\n          }\n          copiedPattern.properties[i] = Object.assign({}, prop, {\n            key: name\n          });\n        }\n      }\n    }\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (core.types.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n  canUnpackArrayPattern(pattern, arr) {\n    if (!core.types.isArrayExpression(arr)) return false;\n    if (pattern.elements.length > arr.elements.length) return;\n    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {\n      return false;\n    }\n    for (const elem of pattern.elements) {\n      if (!elem) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n    for (const elem of arr.elements) {\n      if (core.types.isSpreadElement(elem)) return false;\n      if (core.types.isCallExpression(elem)) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n    const bindings = core.types.getBindingIdentifiers(pattern);\n    const state = {\n      deopt: false,\n      bindings\n    };\n    try {\n      core.types.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n    return !state.deopt;\n  }\n  pushUnpackedArrayPattern(pattern, arr) {\n    const holeToUndefined = el => el != null ? el : this.scope.buildUndefinedNode();\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (core.types.isRestElement(elem)) {\n        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));\n      } else {\n        this.push(elem, holeToUndefined(arr.elements[i]));\n      }\n    }\n  }\n  pushArrayPattern(pattern, arrayRef) {\n    if (arrayRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [])));\n      return;\n    }\n    if (!pattern.elements) return;\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      this.pushUnpackedArrayPattern(pattern, arrayRef);\n      return;\n    }\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n    const toArray = this.toArray(arrayRef, count);\n    if (core.types.isIdentifier(toArray)) {\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (!elem) continue;\n      let elemRef;\n      if (core.types.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier(\"slice\")), [core.types.numericLiteral(i)]);\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n  init(pattern, ref) {\n    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n    this.push(pattern, ref);\n    return this.nodes;\n  }\n}\nfunction buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (core.types.isIdentifier(key) && !prop.computed) {\n      keys.push(core.types.stringLiteral(key.name));\n    } else if (core.types.isTemplateLiteral(key)) {\n      keys.push(core.types.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (core.types.isLiteral(key)) {\n      keys.push(core.types.stringLiteral(String(key.value)));\n    } else if (core.types.isPrivateName(key)) ;else {\n      keys.push(core.types.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : addHelper(\"extends\");\n    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(addHelper(\"objectDestructuringEmpty\"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])]);\n  } else {\n    let keyExpression = core.types.arrayExpression(keys);\n    if (!allLiteral) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier(\"map\")), [addHelper(\"toPropertyKey\")]);\n    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\"\n      });\n      keyExpression = core.types.cloneNode(id);\n    }\n    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression]);\n  }\n  return value;\n}\nfunction convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope\n  } = path;\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n    const patternId = declar.init;\n    const pattern = declar.id;\n    const destructuring = new DestructuringTransformer({\n      blockHoist: node._blockHoist,\n      nodes: nodes,\n      scope: scope,\n      kind: node.kind,\n      iterableIsArray,\n      arrayLikeIsIterable,\n      useBuiltIns,\n      objectRestNoSymbols,\n      addHelper\n    });\n    if (core.types.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n      if (+i !== node.declarations.length - 1) {\n        core.types.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));\n    }\n  }\n  let tail = null;\n  let nodesOut = [];\n  for (const node of nodes) {\n    if (core.types.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(node);\n  }\n  if (nodesOut.length === 2 && core.types.isVariableDeclaration(nodesOut[0]) && core.types.isExpressionStatement(nodesOut[1]) && core.types.isCallExpression(nodesOut[1].expression) && nodesOut[0].declarations.length === 1) {\n    const expr = nodesOut[1].expression;\n    expr.arguments = [nodesOut[0].declarations[0].init];\n    nodesOut = [expr];\n  } else {\n    if (core.types.isForStatement(path.parent, {\n      init: node\n    }) && !nodesOut.some(v => core.types.isVariableDeclaration(v))) {\n      for (let i = 0; i < nodesOut.length; i++) {\n        const node = nodesOut[i];\n        if (core.types.isExpressionStatement(node)) {\n          nodesOut[i] = node.expression;\n        }\n      }\n    }\n  }\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\nfunction convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope,\n    parentPath\n  } = path;\n  const nodes = [];\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper\n  });\n  let ref;\n  if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n    nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(ref, node.right)]));\n    if (core.types.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n  destructuring.init(node.left, ref || node.right);\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(core.types.blockStatement([]));\n      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));\n    } else {\n      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));\n    }\n  }\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\nfunction variableDeclarationHasPattern(node) {\n  for (const declar of node.declarations) {\n    if (core.types.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar index = helperPluginUtils.declare((api, options) => {\n  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false\n  } = options;\n  const iterableIsArray = (_ref = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose) != null ? _ref : false;\n  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\")) != null ? _ref2 : false;\n  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));\n        }\n        path.replaceWith(declaration.node);\n        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n        if (core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", left, core.types.cloneNode(temp))));\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n        if (!core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n      AssignmentExpression(path, state) {\n        if (!core.types.isPattern(path.node.left)) return;\n        convertAssignmentExpression(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      },\n      VariableDeclaration(path, state) {\n        const {\n          node,\n          parent\n        } = path;\n        if (core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      }\n    }\n  };\n});\nexports.buildObjectExcludingKeys = buildObjectExcludingKeys;\nexports.default = index;\nexports.unshiftForXStatementBody = unshiftForXStatementBody;","map":{"version":3,"names":["isPureVoid","node","core","types","isUnaryExpression","operator","isPureish","argument","unshiftForXStatementBody","statementPath","newStatements","ensureBlock","scope","bodyScopeBindings","get","bindings","hasShadowedBlockScopedBindings","Object","keys","some","name","hasBinding","body","blockStatement","unshift","hasArrayRest","pattern","elements","elem","isRestElement","hasObjectRest","properties","prop","STOP_TRAVERSAL","arrayUnpackVisitor","ancestors","state","length","isIdentifier","isReferenced","deopt","DestructuringTransformer","constructor","opts","blockHoist","arrayRefSet","nodes","kind","iterableIsArray","arrayLikeIsIterable","objectRestNoSymbols","useBuiltIns","addHelper","Set","getExtendsHelper","memberExpression","identifier","buildVariableAssignment","id","init","op","isMemberExpression","isOptionalMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","nodeInit","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","declar","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","has","left","right","valueRef","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","isPattern","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","value","buildObjectExcludingKeys","slice","pushObjectProperty","propRef","isLiteral","key","computed","callExpression","isStatic","temp","copiedPattern","i","isPure","assign","canUnpackArrayPattern","arr","isArrayExpression","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","holeToUndefined","el","arrayExpression","map","arrayRef","add","elemRef","numericLiteral","ref","memo","maybeGenerateMemoised","excludedKeys","allLiteral","hasTemplateLiteral","stringLiteral","isTemplateLiteral","String","isPrivateName","extendsHelper","objectExpression","sequenceExpression","keyExpression","isProgram","block","programScope","getProgramParent","convertVariableDeclaration","path","nodeKind","nodeLoc","loc","declarations","destructuring","inherits","tail","nodesOut","isVariableDeclaration","isExpressionStatement","expression","expr","arguments","isForStatement","parent","v","replaceWith","replaceWithMultiple","crawl","convertAssignmentExpression","parentPath","isSequenceExpression","isCompletionRecord","isArrowFunctionExpression","returnStatement","variableDeclarationHasPattern","index","helperPluginUtils","declare","api","options","_ref","_api$assumption","_ref2","_options$allowArrayLi","_ref3","_api$assumption2","assertVersion","assumption","loose","allowArrayLike","visitor","ExportNamedDeclaration","declaration","specifiers","getOuterBindingIdentifiers","exportSpecifier","insertAfter","exportNamedDeclaration","ForXStatement","statementBody","CatchClause","param","AssignmentExpression","VariableDeclaration","isForXStatement","container"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-destructuring\\src\\util.ts","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-destructuring\\src\\index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { Scope, NodePath } from \"@babel/traverse\";\nimport type { TraversalAncestors } from \"@babel/types\";\n\nfunction isPureVoid(node: t.Node) {\n  return (\n    t.isUnaryExpression(node) &&\n    node.operator === \"void\" &&\n    t.isPureish(node.argument)\n  );\n}\n\nexport function unshiftForXStatementBody(\n  statementPath: NodePath<t.ForXStatement>,\n  newStatements: t.Statement[],\n) {\n  statementPath.ensureBlock();\n  const { scope, node } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(\n    name => scope.hasBinding(name),\n  );\n\n  if (hasShadowedBlockScopedBindings) {\n    // handle shadowed variables referenced in computed keys:\n    // var a = 0;for (const { #x: x, [a++]: y } of z) { const a = 1; }\n    node.body = t.blockStatement([...newStatements, node.body]);\n  } else {\n    (node.body as t.BlockStatement).body.unshift(...newStatements);\n  }\n}\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasArrayRest(pattern: t.ArrayPattern) {\n  return pattern.elements.some(elem => t.isRestElement(elem));\n}\n\n/**\n * Test if an ObjectPattern's properties contain any RestElements.\n */\n\nfunction hasObjectRest(pattern: t.ObjectPattern) {\n  return pattern.properties.some(prop => t.isRestElement(prop));\n}\n\ninterface UnpackableArrayExpression extends t.ArrayExpression {\n  elements: (null | t.Expression)[];\n}\n\nconst STOP_TRAVERSAL = {};\n\ninterface ArrayUnpackVisitorState {\n  deopt: boolean;\n  bindings: Record<string, t.Identifier>;\n}\n\n// NOTE: This visitor is meant to be used via t.traverse\nconst arrayUnpackVisitor = (\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: ArrayUnpackVisitorState,\n) => {\n  if (!ancestors.length) {\n    // Top-level node: this is the array literal.\n    return;\n  }\n\n  if (\n    t.isIdentifier(node) &&\n    t.isReferenced(node, ancestors[ancestors.length - 1].node) &&\n    state.bindings[node.name]\n  ) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\nexport type DestructuringTransformerNode =\n  | t.VariableDeclaration\n  | t.ExpressionStatement\n  | t.ReturnStatement;\n\ninterface DestructuringTransformerOption {\n  blockHoist?: number;\n  operator?: t.AssignmentExpression[\"operator\"];\n  nodes?: DestructuringTransformerNode[];\n  kind?: t.VariableDeclaration[\"kind\"];\n  scope: Scope;\n  arrayLikeIsIterable: boolean;\n  iterableIsArray: boolean;\n  objectRestNoSymbols: boolean;\n  useBuiltIns: boolean;\n  addHelper: File[\"addHelper\"];\n}\nexport class DestructuringTransformer {\n  private blockHoist: number;\n  private operator: t.AssignmentExpression[\"operator\"];\n  arrayRefSet: Set<string>;\n  private nodes: DestructuringTransformerNode[];\n  private scope: Scope;\n  private kind: t.VariableDeclaration[\"kind\"];\n  private iterableIsArray: boolean;\n  private arrayLikeIsIterable: boolean;\n  private objectRestNoSymbols: boolean;\n  private useBuiltIns: boolean;\n  private addHelper: File[\"addHelper\"];\n  constructor(opts: DestructuringTransformerOption) {\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(\n    id: t.AssignmentExpression[\"left\"],\n    init: t.Expression,\n  ) {\n    let op = this.operator;\n    if (t.isMemberExpression(id) || t.isOptionalMemberExpression(id)) op = \"=\";\n\n    let node: t.ExpressionStatement | t.VariableDeclaration;\n\n    if (op) {\n      node = t.expressionStatement(\n        t.assignmentExpression(\n          op,\n          id,\n          t.cloneNode(init) || this.scope.buildUndefinedNode(),\n        ),\n      );\n    } else {\n      let nodeInit: t.Expression;\n\n      if ((this.kind === \"const\" || this.kind === \"using\") && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = t.cloneNode(init);\n      }\n\n      node = t.variableDeclaration(this.kind, [\n        t.variableDeclarator(id as t.LVal, nodeInit),\n      ]);\n    }\n\n    //@ts-expect-error(todo): document block hoist property\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  }\n\n  buildVariableDeclaration(id: t.Identifier, init: t.Expression) {\n    const declar = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),\n    ]);\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id: t.LVal, _init: t.Expression | null) {\n    const init = t.cloneNode(_init);\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node: t.Expression, count?: boolean | number) {\n    if (\n      this.iterableIsArray ||\n      (t.isIdentifier(node) && this.arrayRefSet.has(node.name))\n    ) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern(\n    { left, right }: t.AssignmentPattern,\n    valueRef: t.Expression | null,\n  ) {\n    // handle array init with void 0. This also happens when\n    // the value was originally a hole.\n    // const [x = 42] = [void 0,];\n    // -> const x = 42;\n    if (isPureVoid(valueRef)) {\n      this.push(left, right);\n      return;\n    }\n\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n    const tempConditional = t.conditionalExpression(\n      t.binaryExpression(\n        \"===\",\n        t.cloneNode(tempId),\n        this.scope.buildUndefinedNode(),\n      ),\n      right,\n      t.cloneNode(tempId),\n    );\n\n    if (t.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (\n        this.kind === \"const\" ||\n        this.kind === \"let\" ||\n        this.kind === \"using\"\n      ) {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n\n        node = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(tempId), tempConditional),\n        );\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(\n    pattern: t.ObjectPattern,\n    objRef: t.Expression,\n    spreadProp: t.RestElement,\n    spreadPropIndex: number,\n  ) {\n    const value = buildObjectExcludingKeys(\n      pattern.properties.slice(0, spreadPropIndex) as t.ObjectProperty[],\n      objRef,\n      this.scope,\n      name => this.addHelper(name),\n      this.objectRestNoSymbols,\n      this.useBuiltIns,\n    );\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop: t.ObjectProperty, propRef: t.Expression) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    const pattern = prop.value as t.LVal;\n    const objRef = t.memberExpression(\n      t.cloneNode(propRef),\n      prop.key,\n      prop.computed,\n    );\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern: t.ObjectPattern, objRef: t.Expression) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(\n            this.addHelper(\"objectDestructuringEmpty\"),\n            isPureVoid(objRef) ? [] : [objRef],\n          ),\n        ),\n      );\n      return;\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    // Replace impure computed key expressions if we have a rest parameter\n    if (hasObjectRest(pattern)) {\n      let copiedPattern: t.ObjectPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (t.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(\n            //@ts-expect-error PrivateName has been handled by destructuring-private\n            this.buildVariableDeclaration(name, key),\n          );\n          if (!copiedPattern) {\n            copiedPattern = pattern = {\n              ...pattern,\n              properties: pattern.properties.slice(),\n            };\n          }\n          copiedPattern.properties[i] = {\n            ...prop,\n            key: name,\n          };\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (t.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: t.Expression,\n  ): arr is UnpackableArrayExpression {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements won't be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (\n      pattern.elements.length < arr.elements.length &&\n      !hasArrayRest(pattern)\n    ) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n\n      // deopt call expressions as they might change values of LHS variables\n      if (t.isCallExpression(elem)) return false;\n\n      // deopt on member expressions as they may be getter/setters and have side-effects\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    const bindings = t.getBindingIdentifiers(pattern);\n    const state: ArrayUnpackVisitorState = { deopt: false, bindings };\n\n    try {\n      t.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: UnpackableArrayExpression,\n  ) {\n    const holeToUndefined = (el: t.Expression) =>\n      el ?? this.scope.buildUndefinedNode();\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(\n          elem.argument,\n          t.arrayExpression(arr.elements.slice(i).map(holeToUndefined)),\n        );\n      } else {\n        this.push(elem, holeToUndefined(arr.elements[i]));\n      }\n    }\n  }\n\n  pushArrayPattern(pattern: t.ArrayPattern, arrayRef: t.Expression | null) {\n    if (arrayRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(this.addHelper(\"objectDestructuringEmpty\"), []),\n        ),\n      );\n      return;\n    }\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that won't be evaluated\n    //\n    // eg: let [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      this.pushUnpackedArrayPattern(pattern, arrayRef);\n      return;\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    const toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      let elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = t.callExpression(\n          t.memberExpression(elemRef, t.identifier(\"slice\")),\n          [t.numericLiteral(i)],\n        );\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern: t.LVal, ref: t.Expression) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, t.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  }\n}\n\ninterface ExcludingKey {\n  key: t.Expression | t.PrivateName;\n  computed: boolean;\n}\n\nexport function buildObjectExcludingKeys<T extends ExcludingKey>(\n  excludedKeys: T[],\n  objRef: t.Expression,\n  scope: Scope,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): t.CallExpression {\n  // get all the keys that appear in this object before the current spread\n\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      keys.push(t.stringLiteral(key.name));\n    } else if (t.isTemplateLiteral(key)) {\n      keys.push(t.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (t.isLiteral(key)) {\n      // @ts-expect-error todo(flow->ts) NullLiteral\n      keys.push(t.stringLiteral(String(key.value)));\n    } else if (t.isPrivateName(key)) {\n      // private key is not enumerable\n    } else {\n      keys.push(t.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : addHelper(\"extends\");\n    value = t.callExpression(extendsHelper, [\n      t.objectExpression([]),\n      t.sequenceExpression([\n        t.callExpression(addHelper(\"objectDestructuringEmpty\"), [\n          t.cloneNode(objRef),\n        ]),\n        t.cloneNode(objRef),\n      ]),\n    ]);\n  } else {\n    let keyExpression: t.Expression = t.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = t.callExpression(\n        t.memberExpression(keyExpression, t.identifier(\"map\")),\n        [addHelper(\"toPropertyKey\")],\n      );\n    } else if (!hasTemplateLiteral && !t.isProgram(scope.block)) {\n      // Hoist definition of excluded keys, so that it's not created each time.\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\",\n      });\n\n      keyExpression = t.cloneNode(id);\n    }\n\n    value = t.callExpression(\n      addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`),\n      [t.cloneNode(objRef), keyExpression],\n    );\n  }\n  return value;\n}\n\nexport function convertVariableDeclaration(\n  path: NodePath<t.VariableDeclaration>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n\n    const patternId = declar.init;\n    const pattern = declar.id;\n\n    const destructuring: DestructuringTransformer =\n      new DestructuringTransformer({\n        // @ts-expect-error(todo): avoid internal properties access\n        blockHoist: node._blockHoist,\n        nodes: nodes,\n        scope: scope,\n        kind: node.kind,\n        iterableIsArray,\n        arrayLikeIsIterable,\n        useBuiltIns,\n        objectRestNoSymbols,\n        addHelper,\n      });\n\n    if (t.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        // we aren't the last declarator so let's just make the\n        // last transformed node inherit from us\n        t.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(\n        t.inherits(\n          destructuring.buildVariableAssignment(pattern, patternId),\n          declar,\n        ),\n      );\n    }\n  }\n\n  let tail: t.VariableDeclaration | null = null;\n  let nodesOut = [];\n  for (const node of nodes) {\n    if (t.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        // Create a single compound declarations\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        // Make sure the original node kind is used for each compound declaration\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    // Propagate the original declaration node's location\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(node);\n  }\n\n  if (\n    nodesOut.length === 2 &&\n    t.isVariableDeclaration(nodesOut[0]) &&\n    t.isExpressionStatement(nodesOut[1]) &&\n    t.isCallExpression(nodesOut[1].expression) &&\n    nodesOut[0].declarations.length === 1\n  ) {\n    // This can only happen when we generate this code:\n    //    var _ref = DESTRUCTURED_VALUE;\n    //     babelHelpers.objectDestructuringEmpty(_ref);\n    // Since pushing those two statements to the for loop .init will require an IIFE,\n    // we can optimize them to\n    //     babelHelpers.objectDestructuringEmpty(DESTRUCTURED_VALUE);\n    const expr = nodesOut[1].expression;\n    expr.arguments = [nodesOut[0].declarations[0].init];\n    nodesOut = [expr];\n  } else {\n    // We must keep nodes all are expressions or statements, so `replaceWithMultiple` can work.\n    if (\n      t.isForStatement(path.parent, { init: node }) &&\n      !nodesOut.some(v => t.isVariableDeclaration(v))\n    ) {\n      for (let i = 0; i < nodesOut.length; i++) {\n        const node: t.Node = nodesOut[i];\n        if (t.isExpressionStatement(node)) {\n          nodesOut[i] = node.expression;\n        }\n      }\n    }\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\n\nexport function convertAssignmentExpression(\n  path: NodePath<t.AssignmentExpression & { left: t.Pattern }>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope, parentPath } = path;\n\n  const nodes: DestructuringTransformerNode[] = [];\n\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper,\n  });\n\n  let ref: t.Identifier | void;\n  if (\n    (!parentPath.isExpressionStatement() &&\n      !parentPath.isSequenceExpression()) ||\n    path.isCompletionRecord()\n  ) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n    nodes.push(\n      t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]),\n    );\n\n    if (t.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(t.blockStatement([]));\n      nodes.push(t.returnStatement(t.cloneNode(ref)));\n    } else {\n      nodes.push(t.expressionStatement(t.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport {\n  DestructuringTransformer,\n  convertVariableDeclaration,\n  convertAssignmentExpression,\n  unshiftForXStatementBody,\n  type DestructuringTransformerNode,\n} from \"./util.ts\";\nexport { buildObjectExcludingKeys, unshiftForXStatementBody } from \"./util.ts\";\nimport type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node: t.VariableDeclaration) {\n  for (const declar of node.declarations) {\n    if (t.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n  useBuiltIns?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { useBuiltIns = false } = options;\n\n  const iterableIsArray =\n    api.assumption(\"iterableIsArray\") ?? options.loose ?? false;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\") ?? false;\n  const objectRestNoSymbols =\n    api.assumption(\"objectRestNoSymbols\") ?? options.loose ?? false;\n\n  return {\n    name: \"transform-destructuring\",\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const statementBody = (path.node.body as t.BlockStatement).body;\n          const nodes = [];\n          // todo: the completion of a for statement can only be observed from\n          // a do block (or eval that we don't support),\n          // but the new do-expression proposal plans to ban iteration ends in the\n          // do block, maybe we can get rid of this\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        const pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [\n          t.variableDeclarator(key, null),\n        ]);\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n\n        destructuring.init(pattern, key);\n\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n\n      CatchClause({ node, scope }) {\n        const pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n\n      AssignmentExpression(path, state) {\n        if (!t.isPattern(path.node.left)) return;\n        convertAssignmentExpression(\n          path as NodePath<t.AssignmentExpression & { left: t.Pattern }>,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n\n      VariableDeclaration(path, state) {\n        const { node, parent } = path;\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}