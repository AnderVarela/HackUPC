{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ClassVisitor_classNode, _ClassVisitor_referencer, _ClassVisitor_emitDecoratorMetadata;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst definition_1 = require(\"../definition\");\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\nconst Visitor_1 = require(\"./Visitor\");\nclass ClassVisitor extends Visitor_1.Visitor {\n  constructor(referencer, node, emitDecoratorMetadata) {\n    super(referencer);\n    _ClassVisitor_classNode.set(this, void 0);\n    _ClassVisitor_referencer.set(this, void 0);\n    _ClassVisitor_emitDecoratorMetadata.set(this, void 0);\n    __classPrivateFieldSet(this, _ClassVisitor_referencer, referencer, \"f\");\n    __classPrivateFieldSet(this, _ClassVisitor_classNode, node, \"f\");\n    __classPrivateFieldSet(this, _ClassVisitor_emitDecoratorMetadata, emitDecoratorMetadata, \"f\");\n  }\n  static visit(referencer, node, emitDecoratorMetadata) {\n    const classVisitor = new ClassVisitor(referencer, node, emitDecoratorMetadata);\n    classVisitor.visitClass(node);\n  }\n  visit(node) {\n    // make sure we only handle the nodes we are designed to handle\n    if (node && node.type in this) {\n      super.visit(node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n    }\n  }\n  ///////////////////\n  // Visit helpers //\n  ///////////////////\n  visitClass(node) {\n    var _a, _b;\n    if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n    (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassScope(node);\n    if (node.id) {\n      // define the class name again inside the new scope\n      // references to the class should not resolve directly to the parent class\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.superClass);\n    // visit the type param declarations\n    this.visitType(node.typeParameters);\n    // then the usages\n    this.visitType(node.superTypeParameters);\n    (_b = node.implements) === null || _b === void 0 ? void 0 : _b.forEach(imp => this.visitType(imp));\n    this.visit(node.body);\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n  visitPropertyDefinition(node) {\n    this.visitPropertyBase(node);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo: Type;\n     * }\n     */\n    this.visitMetadataType(node.typeAnnotation, !!node.decorators);\n  }\n  visitFunctionParameterTypeAnnotation(node, withDecorators) {\n    if ('typeAnnotation' in node) {\n      this.visitMetadataType(node.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {\n      this.visitMetadataType(node.left.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {\n      this.visitFunctionParameterTypeAnnotation(node.parameter, withDecorators);\n    }\n  }\n  visitMethodFunction(node, methodNode) {\n    var _a, _b;\n    if (node.id) {\n      // FunctionExpression with name creates its special scope;\n      // FunctionExpressionNameScope.\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionExpressionNameScope(node);\n    }\n    // Consider this function is in the MethodDefinition.\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionScope(node, true);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo(a: Type) {}\n     *\n     *   @meta     // <--- check this\n     *   foo(): Type {}\n     * }\n     */\n    let withMethodDecorators = !!methodNode.decorators;\n    /**\n     * class A {\n     *   foo(\n     *     @meta    // <--- check this\n     *     a: Type\n     *   ) {}\n     *\n     *   set foo(\n     *     @meta    // <--- EXCEPT this. TS do nothing for this\n     *     a: Type\n     *   ) {}\n     * }\n     */\n    withMethodDecorators = withMethodDecorators || methodNode.kind !== 'set' && node.params.some(param => param.decorators);\n    if (!withMethodDecorators && methodNode.kind === 'set') {\n      const keyName = getLiteralMethodKeyName(methodNode);\n      /**\n       * class A {\n       *   @meta      // <--- check this\n       *   get a() {}\n       *   set ['a'](v: Type) {}\n       * }\n       */\n      if (keyName != null && ((_a = __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").body.body.find(node => node !== methodNode && node.type === types_1.AST_NODE_TYPES.MethodDefinition &&\n      // Node must both be static or not\n      node.static === methodNode.static && getLiteralMethodKeyName(node) === keyName)) === null || _a === void 0 ? void 0 : _a.decorators)) {\n        withMethodDecorators = true;\n      }\n    }\n    /**\n     * @meta      // <--- check this\n     * class A {\n     *   constructor(a: Type) {}\n     * }\n     */\n    if (!withMethodDecorators && methodNode.kind === 'constructor' && __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").decorators) {\n      withMethodDecorators = true;\n    }\n    // Process parameter declarations.\n    for (const param of node.params) {\n      this.visitPattern(param, (pattern, info) => {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").referencingDefaultValue(pattern, info.assignments, null, true);\n      }, {\n        processRightHandNodes: true\n      });\n      this.visitFunctionParameterTypeAnnotation(param, withMethodDecorators);\n      (_b = param.decorators) === null || _b === void 0 ? void 0 : _b.forEach(d => this.visit(d));\n    }\n    this.visitMetadataType(node.returnType, withMethodDecorators);\n    this.visitType(node.typeParameters);\n    // In TypeScript there are a number of function-like constructs which have no body,\n    // so check it exists before traversing\n    if (node.body) {\n      // Skip BlockStatement to prevent creating BlockStatement scope.\n      if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visitChildren(node.body);\n      } else {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.body);\n      }\n    }\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n  visitPropertyBase(node) {\n    var _a;\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n    if (node.value) {\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassFieldInitializerScope(node.value);\n      }\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node.value);\n      }\n    }\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n  visitMethod(node) {\n    var _a;\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n    if (node.value.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n      this.visitMethodFunction(node.value, node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n    }\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n  visitType(node) {\n    if (!node) {\n      return;\n    }\n    TypeVisitor_1.TypeVisitor.visit(__classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\"), node);\n  }\n  visitMetadataType(node, withDecorators) {\n    if (!node) {\n      return;\n    }\n    // emit decorators metadata only work for TSTypeReference in ClassDeclaration\n    if (__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").type === types_1.AST_NODE_TYPES.ClassDeclaration && !__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").declare && node.typeAnnotation.type === types_1.AST_NODE_TYPES.TSTypeReference && __classPrivateFieldGet(this, _ClassVisitor_emitDecoratorMetadata, \"f\")) {\n      let entityName;\n      if (node.typeAnnotation.typeName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n        let iter = node.typeAnnotation.typeName;\n        while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n          iter = iter.left;\n        }\n        entityName = iter.left;\n      } else {\n        entityName = node.typeAnnotation.typeName;\n      }\n      if (withDecorators) {\n        if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {\n          __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().referenceDualValueType(entityName);\n        }\n        if (node.typeAnnotation.typeParameters) {\n          this.visitType(node.typeAnnotation.typeParameters);\n        }\n        // everything is handled now\n        return;\n      }\n    }\n    this.visitType(node);\n  }\n  /////////////////////\n  // Visit selectors //\n  /////////////////////\n  AccessorProperty(node) {\n    this.visitPropertyDefinition(node);\n  }\n  ClassBody(node) {\n    // this is here on purpose so that this visitor explicitly declares visitors\n    // for all nodes it cares about (see the instance visit method above)\n    this.visitChildren(node);\n  }\n  PropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n  MethodDefinition(node) {\n    this.visitMethod(node);\n  }\n  TSAbstractAccessorProperty(node) {\n    this.visitPropertyDefinition(node);\n  }\n  TSAbstractPropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n  TSAbstractMethodDefinition(node) {\n    this.visitPropertyBase(node);\n  }\n  Identifier(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n  }\n  PrivateIdentifier() {\n    // intentionally skip\n  }\n  StaticBlock(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassStaticBlockScope(node);\n    node.body.forEach(b => this.visit(b));\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n}\nexports.ClassVisitor = ClassVisitor;\n_ClassVisitor_classNode = new WeakMap(), _ClassVisitor_referencer = new WeakMap(), _ClassVisitor_emitDecoratorMetadata = new WeakMap();\n/**\n * Only if key is one of [identifier, string, number], ts will combine metadata of accessors .\n * class A {\n *   get a() {}\n *   set ['a'](v: Type) {}\n *\n *   get [1]() {}\n *   set [1](v: Type) {}\n *\n *   // Following won't be combined\n *   get [key]() {}\n *   set [key](v: Type) {}\n *\n *   get [true]() {}\n *   set [true](v: Type) {}\n *\n *   get ['a'+'b']() {}\n *   set ['a'+'b']() {}\n * }\n */\nfunction getLiteralMethodKeyName(node) {\n  if (node.computed && node.key.type === types_1.AST_NODE_TYPES.Literal) {\n    if (typeof node.key.value === 'string' || typeof node.key.value === 'number') {\n      return node.key.value;\n    }\n  } else if (!node.computed && node.key.type === types_1.AST_NODE_TYPES.Identifier) {\n    return node.key.name;\n  }\n  return null;\n}","map":{"version":3,"names":["types_1","require","definition_1","TypeVisitor_1","Visitor_1","ClassVisitor","Visitor","constructor","referencer","node","emitDecoratorMetadata","_ClassVisitor_classNode","set","_ClassVisitor_referencer","_ClassVisitor_emitDecoratorMetadata","__classPrivateFieldSet","visit","classVisitor","visitClass","type","__classPrivateFieldGet","AST_NODE_TYPES","ClassDeclaration","id","currentScope","defineIdentifier","ClassNameDefinition","_a","decorators","forEach","d","scopeManager","nestClassScope","superClass","visitType","typeParameters","superTypeParameters","_b","implements","imp","body","close","visitPropertyDefinition","visitPropertyBase","visitMetadataType","typeAnnotation","visitFunctionParameterTypeAnnotation","withDecorators","AssignmentPattern","left","TSParameterProperty","parameter","visitMethodFunction","methodNode","nestFunctionExpressionNameScope","nestFunctionScope","withMethodDecorators","kind","params","some","param","keyName","getLiteralMethodKeyName","find","MethodDefinition","static","visitPattern","pattern","info","ParameterDefinition","rest","referencingDefaultValue","assignments","processRightHandNodes","returnType","BlockStatement","visitChildren","computed","key","value","PropertyDefinition","AccessorProperty","nestClassFieldInitializerScope","visitMethod","FunctionExpression","TypeVisitor","declare","TSTypeReference","entityName","typeName","TSQualifiedName","iter","Identifier","referenceDualValueType","ClassBody","TSAbstractAccessorProperty","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","PrivateIdentifier","StaticBlock","nestClassStaticBlockScope","b","exports","Literal","name"],"sources":["../../src/referencer/ClassVisitor.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}