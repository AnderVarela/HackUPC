{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst {\n  types: t\n} = _babel.default || _babel;\nclass ImportsCachedInjector {\n  constructor(resolver, getPreferredIndex) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n    this._getPreferredIndex = getPreferredIndex;\n  }\n  storeAnonymous(programPath, url, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url);\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n    this._injectImport(programPath, node, moduleName);\n  }\n  storeNamed(programPath, url, name, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n    const imports = this._ensure(this._imports, programPath, Map);\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n      this._injectImport(programPath, node, moduleName);\n    }\n    return t.identifier(imports.get(key));\n  }\n  _injectImport(programPath, node, moduleName) {\n    var _this$_lastImports$ge;\n    const newIndex = this._getPreferredIndex(moduleName);\n    const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];\n    const isPathStillValid = path => path.node &&\n    // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    path.parent === programPath.node && path.container === programPath.node.body;\n    let last;\n    if (newIndex === Infinity) {\n      // Fast path: we can always just insert at the end if newIndex is `Infinity`\n      if (lastImports.length > 0) {\n        last = lastImports[lastImports.length - 1].path;\n        if (!isPathStillValid(last)) last = undefined;\n      }\n    } else {\n      for (const [i, data] of lastImports.entries()) {\n        const {\n          path,\n          index\n        } = data;\n        if (isPathStillValid(path)) {\n          if (newIndex < index) {\n            const [newPath] = path.insertBefore(node);\n            lastImports.splice(i, 0, {\n              path: newPath,\n              index: newIndex\n            });\n            return;\n          }\n          last = path;\n        }\n      }\n    }\n    if (last) {\n      const [newPath] = last.insertAfter(node);\n      lastImports.push({\n        path: newPath,\n        index: newIndex\n      });\n    } else {\n      const [newPath] = programPath.unshiftContainer(\"body\", node);\n      this._lastImports.set(programPath, [{\n        path: newPath,\n        index: newIndex\n      }]);\n    }\n  }\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n    return collection;\n  }\n  _normalizeKey(programPath, url, name = \"\") {\n    const {\n      sourceType\n    } = programPath.node;\n\n    // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n    return `${name && sourceType}::${url}::${name}`;\n  }\n}\nexports.default = ImportsCachedInjector;","map":{"version":3,"names":["exports","__esModule","default","_babel","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","types","t","ImportsCachedInjector","constructor","resolver","getPreferredIndex","_imports","_anonymousImports","_lastImports","_resolver","_getPreferredIndex","storeAnonymous","programPath","url","moduleName","getVal","_normalizeKey","imports","_ensure","Set","node","sourceType","stringLiteral","add","_injectImport","storeNamed","name","Map","id","identifier","_this$_lastImports$ge","newIndex","lastImports","isPathStillValid","path","parent","container","body","last","Infinity","length","undefined","i","data","entries","index","newPath","insertBefore","splice","insertAfter","push","unshiftContainer","map","Collection","collection"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@babel/helper-define-polyfill-provider/lib/imports-injector.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst {\n  types: t\n} = _babel.default || _babel;\nclass ImportsCachedInjector {\n  constructor(resolver, getPreferredIndex) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n    this._getPreferredIndex = getPreferredIndex;\n  }\n  storeAnonymous(programPath, url, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url);\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n    this._injectImport(programPath, node, moduleName);\n  }\n  storeNamed(programPath, url, name, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n    const imports = this._ensure(this._imports, programPath, Map);\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n      this._injectImport(programPath, node, moduleName);\n    }\n    return t.identifier(imports.get(key));\n  }\n  _injectImport(programPath, node, moduleName) {\n    var _this$_lastImports$ge;\n    const newIndex = this._getPreferredIndex(moduleName);\n    const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];\n    const isPathStillValid = path => path.node &&\n    // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    path.parent === programPath.node && path.container === programPath.node.body;\n    let last;\n    if (newIndex === Infinity) {\n      // Fast path: we can always just insert at the end if newIndex is `Infinity`\n      if (lastImports.length > 0) {\n        last = lastImports[lastImports.length - 1].path;\n        if (!isPathStillValid(last)) last = undefined;\n      }\n    } else {\n      for (const [i, data] of lastImports.entries()) {\n        const {\n          path,\n          index\n        } = data;\n        if (isPathStillValid(path)) {\n          if (newIndex < index) {\n            const [newPath] = path.insertBefore(node);\n            lastImports.splice(i, 0, {\n              path: newPath,\n              index: newIndex\n            });\n            return;\n          }\n          last = path;\n        }\n      }\n    }\n    if (last) {\n      const [newPath] = last.insertAfter(node);\n      lastImports.push({\n        path: newPath,\n        index: newIndex\n      });\n    } else {\n      const [newPath] = programPath.unshiftContainer(\"body\", node);\n      this._lastImports.set(programPath, [{\n        path: newPath,\n        index: newIndex\n      }]);\n    }\n  }\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n    return collection;\n  }\n  _normalizeKey(programPath, url, name = \"\") {\n    const {\n      sourceType\n    } = programPath.node;\n\n    // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n    return `${name && sourceType}::${url}::${name}`;\n  }\n}\nexports.default = ImportsCachedInjector;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}