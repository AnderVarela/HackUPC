{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _esutils = _interopRequireDefault(require(\"esutils\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nvar _default = ({\n  types: t\n}) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  } // Converts a JSXAttribute to the equivalent ObjectExpression property\n\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  } // Convert a JSX attribute name to an Object expression property name\n\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n    if (_esutils.default.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n    return t.stringLiteral(node.name.name);\n  } // Convert a JSX attribute value to a JavaScript expression value\n\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \"); // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n    return value;\n  }\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:\n\n        if (!hasSpread || path.node.attributes.length === 1) return;\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n    }\n  };\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["exports","__esModule","default","_esutils","_interopRequireDefault","require","obj","_default","types","t","convertAttributesAssign","attributes","args","i","current","length","node","isJSXSpreadAttribute","push","objectExpression","argument","name","getAttributeName","value","getAttributeValue","properties","objectProperty","callExpression","memberExpression","identifier","convertAttributeSpread","spreadElement","inherits","isJSXNamespacedName","stringLiteral","namespace","keyword","isIdentifierNameES6","booleanLiteral","isJSXExpressionContainer","expression","isStringLiteral","replace","extra","raw","visitor","JSXOpeningElement","path","state","useSpread","opts","hasSpread","some","attr","jsxSpreadAttribute","map","module"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@babel/preset-modules/lib/plugins/transform-jsx-spread/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _esutils = _interopRequireDefault(require(\"esutils\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nvar _default = ({\n  types: t\n}) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  } // Converts a JSXAttribute to the equivalent ObjectExpression property\n\n\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  } // Convert a JSX attribute name to an Object expression property name\n\n\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n\n    if (_esutils.default.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n\n    return t.stringLiteral(node.name.name);\n  } // Convert a JSX attribute value to a JavaScript expression value\n\n\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \"); // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:\n\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n\n    }\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}