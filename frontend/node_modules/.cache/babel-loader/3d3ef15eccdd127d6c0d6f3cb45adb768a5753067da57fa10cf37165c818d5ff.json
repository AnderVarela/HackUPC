{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst util_1 = require(\"../../compile/util\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst metadata_1 = require(\"./metadata\");\nconst nullable_1 = require(\"./nullable\");\nconst error_1 = require(\"./error\");\nconst def = {\n  keyword: \"values\",\n  schemaType: \"object\",\n  error: (0, error_1.typeError)(\"object\"),\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      it\n    } = cxt;\n    const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());\n    } else {\n      gen.if(cond);\n      gen.assign(valid, validateMap());\n      gen.elseIf((0, codegen_1.not)(valid));\n      cxt.error();\n      gen.endIf();\n    }\n    cxt.ok(valid);\n    function validateMap() {\n      const _valid = gen.name(\"valid\");\n      if (it.allErrors) {\n        const validMap = gen.let(\"valid\", true);\n        validateValues(() => gen.assign(validMap, false));\n        return validMap;\n      }\n      gen.var(_valid, true);\n      validateValues(() => gen.break());\n      return _valid;\n      function validateValues(notValid) {\n        gen.forIn(\"key\", data, key => {\n          cxt.subschema({\n            keyword: \"values\",\n            dataProp: key,\n            dataPropType: util_1.Type.Str\n          }, _valid);\n          gen.if((0, codegen_1.not)(_valid), notValid);\n        });\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["util_1","require","codegen_1","metadata_1","nullable_1","error_1","def","keyword","schemaType","error","typeError","code","cxt","checkMetadata","gen","data","schema","it","valid","cond","checkNullableObject","alwaysValidSchema","if","not","or","assign","validateMap","elseIf","endIf","ok","_valid","name","allErrors","validMap","let","validateValues","var","break","notValid","forIn","key","subschema","dataProp","dataPropType","Type","Str","exports","default"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\values.ts"],"sourcesContent":["import type {CodeKeywordDefinition, SchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema, Type} from \"../../compile/util\"\nimport {not, or, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeError, _JTDTypeError} from \"./error\"\n\nexport type JTDValuesError = _JTDTypeError<\"values\", \"object\", SchemaObject>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"values\",\n  schemaType: \"object\",\n  error: typeError(\"object\"),\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, it} = cxt\n    const [valid, cond] = checkNullableObject(cxt, data)\n    if (alwaysValidSchema(it, schema)) {\n      gen.if(not(or(cond, valid)), () => cxt.error())\n    } else {\n      gen.if(cond)\n      gen.assign(valid, validateMap())\n      gen.elseIf(not(valid))\n      cxt.error()\n      gen.endIf()\n    }\n    cxt.ok(valid)\n\n    function validateMap(): Name | boolean {\n      const _valid = gen.name(\"valid\")\n      if (it.allErrors) {\n        const validMap = gen.let(\"valid\", true)\n        validateValues(() => gen.assign(validMap, false))\n        return validMap\n      }\n      gen.var(_valid, true)\n      validateValues(() => gen.break())\n      return _valid\n\n      function validateValues(notValid: () => void): void {\n        gen.forIn(\"key\", data, (key) => {\n          cxt.subschema(\n            {\n              keyword: \"values\",\n              dataProp: key,\n              dataPropType: Type.Str,\n            },\n            _valid\n          )\n          gen.if(not(_valid), notValid)\n        })\n      }\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;AAEA,MAAAA,MAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,UAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,OAAA,GAAAJ,OAAA;AAIA,MAAMK,GAAG,GAA0B;EACjCC,OAAO,EAAE,QAAQ;EACjBC,UAAU,EAAE,QAAQ;EACpBC,KAAK,EAAE,IAAAJ,OAAA,CAAAK,SAAS,EAAC,QAAQ,CAAC;EAC1BC,IAAIA,CAACC,GAAe;IAClB,IAAAT,UAAA,CAAAU,aAAa,EAACD,GAAG,CAAC;IAClB,MAAM;MAACE,GAAG;MAAEC,IAAI;MAAEC,MAAM;MAAEC;IAAE,CAAC,GAAGL,GAAG;IACnC,MAAM,CAACM,KAAK,EAAEC,IAAI,CAAC,GAAG,IAAAf,UAAA,CAAAgB,mBAAmB,EAACR,GAAG,EAAEG,IAAI,CAAC;IACpD,IAAI,IAAAf,MAAA,CAAAqB,iBAAiB,EAACJ,EAAE,EAAED,MAAM,CAAC,EAAE;MACjCF,GAAG,CAACQ,EAAE,CAAC,IAAApB,SAAA,CAAAqB,GAAG,EAAC,IAAArB,SAAA,CAAAsB,EAAE,EAACL,IAAI,EAAED,KAAK,CAAC,CAAC,EAAE,MAAMN,GAAG,CAACH,KAAK,EAAE,CAAC;IACjD,CAAC,MAAM;MACLK,GAAG,CAACQ,EAAE,CAACH,IAAI,CAAC;MACZL,GAAG,CAACW,MAAM,CAACP,KAAK,EAAEQ,WAAW,EAAE,CAAC;MAChCZ,GAAG,CAACa,MAAM,CAAC,IAAAzB,SAAA,CAAAqB,GAAG,EAACL,KAAK,CAAC,CAAC;MACtBN,GAAG,CAACH,KAAK,EAAE;MACXK,GAAG,CAACc,KAAK,EAAE;IACb;IACAhB,GAAG,CAACiB,EAAE,CAACX,KAAK,CAAC;IAEb,SAASQ,WAAWA,CAAA;MAClB,MAAMI,MAAM,GAAGhB,GAAG,CAACiB,IAAI,CAAC,OAAO,CAAC;MAChC,IAAId,EAAE,CAACe,SAAS,EAAE;QAChB,MAAMC,QAAQ,GAAGnB,GAAG,CAACoB,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC;QACvCC,cAAc,CAAC,MAAMrB,GAAG,CAACW,MAAM,CAACQ,QAAQ,EAAE,KAAK,CAAC,CAAC;QACjD,OAAOA,QAAQ;MACjB;MACAnB,GAAG,CAACsB,GAAG,CAACN,MAAM,EAAE,IAAI,CAAC;MACrBK,cAAc,CAAC,MAAMrB,GAAG,CAACuB,KAAK,EAAE,CAAC;MACjC,OAAOP,MAAM;MAEb,SAASK,cAAcA,CAACG,QAAoB;QAC1CxB,GAAG,CAACyB,KAAK,CAAC,KAAK,EAAExB,IAAI,EAAGyB,GAAG,IAAI;UAC7B5B,GAAG,CAAC6B,SAAS,CACX;YACElC,OAAO,EAAE,QAAQ;YACjBmC,QAAQ,EAAEF,GAAG;YACbG,YAAY,EAAE3C,MAAA,CAAA4C,IAAI,CAACC;WACpB,EACDf,MAAM,CACP;UACDhB,GAAG,CAACQ,EAAE,CAAC,IAAApB,SAAA,CAAAqB,GAAG,EAACO,MAAM,CAAC,EAAEQ,QAAQ,CAAC;QAC/B,CAAC,CAAC;MACJ;IACF;EACF;CACD;AAEDQ,OAAA,CAAAC,OAAA,GAAezC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}