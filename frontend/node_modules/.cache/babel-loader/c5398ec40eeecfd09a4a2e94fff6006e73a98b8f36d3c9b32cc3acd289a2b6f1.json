{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateProperties = exports.error = void 0;\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst metadata_1 = require(\"./metadata\");\nconst nullable_1 = require(\"./nullable\");\nconst error_1 = require(\"./error\");\nvar PropError;\n(function (PropError) {\n  PropError[\"Additional\"] = \"additional\";\n  PropError[\"Missing\"] = \"missing\";\n})(PropError || (PropError = {}));\nexports.error = {\n  message: cxt => {\n    const {\n      params\n    } = cxt;\n    return params.propError ? params.propError === PropError.Additional ? \"must NOT have additional properties\" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, \"object\");\n  },\n  params: cxt => {\n    const {\n      params\n    } = cxt;\n    return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, \"object\");\n  }\n};\nconst def = {\n  keyword: \"properties\",\n  schemaType: \"object\",\n  error: exports.error,\n  code: validateProperties\n};\n// const error: KeywordErrorDefinition = {\n//   message: \"should NOT have additional properties\",\n//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n// }\nfunction validateProperties(cxt) {\n  (0, metadata_1.checkMetadata)(cxt);\n  const {\n    gen,\n    data,\n    parentSchema,\n    it\n  } = cxt;\n  const {\n    additionalProperties,\n    nullable\n  } = parentSchema;\n  if (it.jtdDiscriminator && nullable) throw new Error(\"JTD: nullable inside discriminator mapping\");\n  if (commonProperties()) {\n    throw new Error(\"JTD: properties and optionalProperties have common members\");\n  }\n  const [allProps, properties] = schemaProperties(\"properties\");\n  const [allOptProps, optProperties] = schemaProperties(\"optionalProperties\");\n  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {\n    return;\n  }\n  const [valid, cond] = it.jtdDiscriminator === undefined ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let(\"valid\", false), true];\n  gen.if(cond, () => gen.assign(valid, true).block(() => {\n    validateProps(properties, \"properties\", true);\n    validateProps(optProperties, \"optionalProperties\");\n    if (!additionalProperties) validateAdditional();\n  }));\n  cxt.pass(valid);\n  function commonProperties() {\n    const props = parentSchema.properties;\n    const optProps = parentSchema.optionalProperties;\n    if (!(props && optProps)) return false;\n    for (const p in props) {\n      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true;\n    }\n    return false;\n  }\n  function schemaProperties(keyword) {\n    const schema = parentSchema[keyword];\n    const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];\n    if (it.jtdDiscriminator && allPs.some(p => p === it.jtdDiscriminator)) {\n      throw new Error(`JTD: discriminator tag used in ${keyword}`);\n    }\n    const ps = allPs.filter(p => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n    return [allPs, ps];\n  }\n  function validateProps(props, keyword, required) {\n    const _valid = gen.var(\"valid\");\n    for (const prop of props) {\n      gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));\n      cxt.ok(_valid);\n    }\n    function missingProperty(prop) {\n      if (required) {\n        gen.assign(_valid, false);\n        cxt.error(false, {\n          propError: PropError.Missing,\n          missingProperty: prop\n        }, {\n          schemaPath: prop\n        });\n      } else {\n        gen.assign(_valid, true);\n      }\n    }\n  }\n  function applyPropertySchema(prop, keyword, _valid) {\n    cxt.subschema({\n      keyword,\n      schemaProp: prop,\n      dataProp: prop\n    }, _valid);\n  }\n  function validateAdditional() {\n    gen.forIn(\"key\", data, key => {\n      const addProp = isAdditional(key, allProps, \"properties\", it.jtdDiscriminator);\n      const addOptProp = isAdditional(key, allOptProps, \"optionalProperties\");\n      const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);\n      gen.if(extra, () => {\n        if (it.opts.removeAdditional) {\n          gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n        } else {\n          cxt.error(false, {\n            propError: PropError.Additional,\n            additionalProperty: key\n          }, {\n            instancePath: key,\n            parentSchema: true\n          });\n          if (!it.opts.allErrors) gen.break();\n        }\n      });\n    });\n  }\n  function isAdditional(key, props, keyword, jtdDiscriminator) {\n    let additional;\n    if (props.length > 8) {\n      // TODO maybe an option instead of hard-coded 8?\n      const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);\n      additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));\n      if (jtdDiscriminator !== undefined) {\n        additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);\n      }\n    } else if (props.length || jtdDiscriminator !== undefined) {\n      const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);\n      additional = (0, codegen_1.and)(...ps.map(p => (0, codegen_1._)`${key} !== ${p}`));\n    } else {\n      additional = true;\n    }\n    return additional;\n  }\n}\nexports.validateProperties = validateProperties;\nexports.default = def;","map":{"version":3,"names":["code_1","require","util_1","codegen_1","metadata_1","nullable_1","error_1","PropError","exports","error","message","cxt","params","propError","Additional","missingProperty","typeErrorMessage","_","additionalProperty","typeErrorParams","def","keyword","schemaType","code","validateProperties","checkMetadata","gen","data","parentSchema","it","additionalProperties","nullable","jtdDiscriminator","Error","commonProperties","allProps","properties","schemaProperties","allOptProps","optProperties","length","valid","cond","undefined","checkNullableObject","let","if","assign","block","validateProps","validateAdditional","pass","props","optProps","optionalProperties","p","Object","prototype","hasOwnProperty","call","schema","allPs","allSchemaProperties","some","ps","filter","alwaysValidSchema","required","_valid","var","prop","propertyInData","opts","ownProperties","applyPropertySchema","ok","Missing","schemaPath","subschema","schemaProp","dataProp","forIn","key","addProp","isAdditional","addOptProp","extra","and","removeAdditional","instancePath","allErrors","break","additional","propsSchema","schemaRefOrVal","not","isOwnProperty","concat","map","default"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\properties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties, isOwnProperty} from \"../code\"\nimport {alwaysValidSchema, schemaRefOrVal} from \"../../compile/util\"\nimport {_, and, not, Code, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\n\nenum PropError {\n  Additional = \"additional\",\n  Missing = \"missing\",\n}\n\ntype PropKeyword = \"properties\" | \"optionalProperties\"\n\ntype PropSchema = {[P in string]?: SchemaObject}\n\nexport type JTDPropertiesError =\n  | _JTDTypeError<PropKeyword, \"object\", PropSchema>\n  | ErrorObject<PropKeyword, {error: PropError.Additional; additionalProperty: string}, PropSchema>\n  | ErrorObject<PropKeyword, {error: PropError.Missing; missingProperty: string}, PropSchema>\n\nexport const error: KeywordErrorDefinition = {\n  message: (cxt) => {\n    const {params} = cxt\n    return params.propError\n      ? params.propError === PropError.Additional\n        ? \"must NOT have additional properties\"\n        : `must have property '${params.missingProperty}'`\n      : typeErrorMessage(cxt, \"object\")\n  },\n  params: (cxt) => {\n    const {params} = cxt\n    return params.propError\n      ? params.propError === PropError.Additional\n        ? _`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`\n        : _`{error: ${params.propError}, missingProperty: ${params.missingProperty}}`\n      : typeErrorParams(cxt, \"object\")\n  },\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  schemaType: \"object\",\n  error,\n  code: validateProperties,\n}\n\n// const error: KeywordErrorDefinition = {\n//   message: \"should NOT have additional properties\",\n//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n// }\n\nexport function validateProperties(cxt: KeywordCxt): void {\n  checkMetadata(cxt)\n  const {gen, data, parentSchema, it} = cxt\n  const {additionalProperties, nullable} = parentSchema\n  if (it.jtdDiscriminator && nullable) throw new Error(\"JTD: nullable inside discriminator mapping\")\n  if (commonProperties()) {\n    throw new Error(\"JTD: properties and optionalProperties have common members\")\n  }\n  const [allProps, properties] = schemaProperties(\"properties\")\n  const [allOptProps, optProperties] = schemaProperties(\"optionalProperties\")\n  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {\n    return\n  }\n\n  const [valid, cond] =\n    it.jtdDiscriminator === undefined\n      ? checkNullableObject(cxt, data)\n      : [gen.let(\"valid\", false), true]\n  gen.if(cond, () =>\n    gen.assign(valid, true).block(() => {\n      validateProps(properties, \"properties\", true)\n      validateProps(optProperties, \"optionalProperties\")\n      if (!additionalProperties) validateAdditional()\n    })\n  )\n  cxt.pass(valid)\n\n  function commonProperties(): boolean {\n    const props = parentSchema.properties as Record<string, any> | undefined\n    const optProps = parentSchema.optionalProperties as Record<string, any> | undefined\n    if (!(props && optProps)) return false\n    for (const p in props) {\n      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true\n    }\n    return false\n  }\n\n  function schemaProperties(keyword: string): [string[], string[]] {\n    const schema = parentSchema[keyword]\n    const allPs = schema ? allSchemaProperties(schema) : []\n    if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {\n      throw new Error(`JTD: discriminator tag used in ${keyword}`)\n    }\n    const ps = allPs.filter((p) => !alwaysValidSchema(it, schema[p]))\n    return [allPs, ps]\n  }\n\n  function validateProps(props: string[], keyword: string, required?: boolean): void {\n    const _valid = gen.var(\"valid\")\n    for (const prop of props) {\n      gen.if(\n        propertyInData(gen, data, prop, it.opts.ownProperties),\n        () => applyPropertySchema(prop, keyword, _valid),\n        () => missingProperty(prop)\n      )\n      cxt.ok(_valid)\n    }\n\n    function missingProperty(prop: string): void {\n      if (required) {\n        gen.assign(_valid, false)\n        cxt.error(false, {propError: PropError.Missing, missingProperty: prop}, {schemaPath: prop})\n      } else {\n        gen.assign(_valid, true)\n      }\n    }\n  }\n\n  function applyPropertySchema(prop: string, keyword: string, _valid: Name): void {\n    cxt.subschema(\n      {\n        keyword,\n        schemaProp: prop,\n        dataProp: prop,\n      },\n      _valid\n    )\n  }\n\n  function validateAdditional(): void {\n    gen.forIn(\"key\", data, (key: Name) => {\n      const addProp = isAdditional(key, allProps, \"properties\", it.jtdDiscriminator)\n      const addOptProp = isAdditional(key, allOptProps, \"optionalProperties\")\n      const extra =\n        addProp === true ? addOptProp : addOptProp === true ? addProp : and(addProp, addOptProp)\n      gen.if(extra, () => {\n        if (it.opts.removeAdditional) {\n          gen.code(_`delete ${data}[${key}]`)\n        } else {\n          cxt.error(\n            false,\n            {propError: PropError.Additional, additionalProperty: key},\n            {instancePath: key, parentSchema: true}\n          )\n          if (!it.opts.allErrors) gen.break()\n        }\n      })\n    })\n  }\n\n  function isAdditional(\n    key: Name,\n    props: string[],\n    keyword: string,\n    jtdDiscriminator?: string\n  ): Code | true {\n    let additional: Code | boolean\n    if (props.length > 8) {\n      // TODO maybe an option instead of hard-coded 8?\n      const propsSchema = schemaRefOrVal(it, parentSchema[keyword], keyword)\n      additional = not(isOwnProperty(gen, propsSchema as Code, key))\n      if (jtdDiscriminator !== undefined) {\n        additional = and(additional, _`${key} !== ${jtdDiscriminator}`)\n      }\n    } else if (props.length || jtdDiscriminator !== undefined) {\n      const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props)\n      additional = and(...ps.map((p) => _`${key} !== ${p}`))\n    } else {\n      additional = true\n    }\n    return additional\n  }\n}\n\nexport default def\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}