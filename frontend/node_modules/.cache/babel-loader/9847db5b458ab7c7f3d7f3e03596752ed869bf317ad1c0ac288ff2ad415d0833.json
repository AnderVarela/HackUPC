{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isUnsafeAssignment = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils_1 = require(\"tsutils\");\nconst predicates_1 = require(\"./predicates\");\n/**\n * Does a simple check to see if there is an any being assigned to a non-any type.\n *\n * This also checks generic positions to ensure there's no unsafe sub-assignments.\n * Note: in the case of generic positions, it makes the assumption that the two types are the same.\n *\n * @example See tests for examples\n *\n * @returns false if it's safe, or an object with the two types if it's unsafe\n */\nfunction isUnsafeAssignment(type, receiver, checker, senderNode) {\n  var _a, _b;\n  if ((0, predicates_1.isTypeAnyType)(type)) {\n    // Allow assignment of any ==> unknown.\n    if ((0, predicates_1.isTypeUnknownType)(receiver)) {\n      return false;\n    }\n    if (!(0, predicates_1.isTypeAnyType)(receiver)) {\n      return {\n        sender: type,\n        receiver\n      };\n    }\n  }\n  if ((0, tsutils_1.isTypeReference)(type) && (0, tsutils_1.isTypeReference)(receiver)) {\n    // TODO - figure out how to handle cases like this,\n    // where the types are assignable, but not the same type\n    /*\n    function foo(): ReadonlySet<number> { return new Set<any>(); }\n         // and\n         type Test<T> = { prop: T }\n    type Test2 = { prop: string }\n    declare const a: Test<any>;\n    const b: Test2 = a;\n    */\n    if (type.target !== receiver.target) {\n      // if the type references are different, assume safe, as we won't know how to compare the two types\n      // the generic positions might not be equivalent for both types\n      return false;\n    }\n    if ((senderNode === null || senderNode === void 0 ? void 0 : senderNode.type) === utils_1.AST_NODE_TYPES.NewExpression && senderNode.callee.type === utils_1.AST_NODE_TYPES.Identifier && senderNode.callee.name === 'Map' && senderNode.arguments.length === 0 && senderNode.typeParameters == null) {\n      // special case to handle `new Map()`\n      // unfortunately Map's default empty constructor is typed to return `Map<any, any>` :(\n      // https://github.com/typescript-eslint/typescript-eslint/issues/2109#issuecomment-634144396\n      return false;\n    }\n    const typeArguments = (_a = type.typeArguments) !== null && _a !== void 0 ? _a : [];\n    const receiverTypeArguments = (_b = receiver.typeArguments) !== null && _b !== void 0 ? _b : [];\n    for (let i = 0; i < typeArguments.length; i += 1) {\n      const arg = typeArguments[i];\n      const receiverArg = receiverTypeArguments[i];\n      const unsafe = isUnsafeAssignment(arg, receiverArg, checker, senderNode);\n      if (unsafe) {\n        return {\n          sender: type,\n          receiver\n        };\n      }\n    }\n    return false;\n  }\n  return false;\n}\nexports.isUnsafeAssignment = isUnsafeAssignment;","map":{"version":3,"names":["utils_1","require","tsutils_1","predicates_1","isUnsafeAssignment","type","receiver","checker","senderNode","isTypeAnyType","isTypeUnknownType","sender","isTypeReference","target","AST_NODE_TYPES","NewExpression","callee","Identifier","name","arguments","length","typeParameters","typeArguments","_a","receiverTypeArguments","_b","i","arg","receiverArg","unsafe","exports"],"sources":["../src/isUnsafeAssignment.ts"],"sourcesContent":[null],"mappings":";;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AAGA,MAAAE,YAAA,GAAAF,OAAA;AAEA;;;;;;;;;;AAUA,SAAgBG,kBAAkBA,CAChCC,IAAa,EACbC,QAAiB,EACjBC,OAAuB,EACvBC,UAAgC;;EAEhC,IAAI,IAAAL,YAAA,CAAAM,aAAa,EAACJ,IAAI,CAAC,EAAE;IACvB;IACA,IAAI,IAAAF,YAAA,CAAAO,iBAAiB,EAACJ,QAAQ,CAAC,EAAE;MAC/B,OAAO,KAAK;;IAGd,IAAI,CAAC,IAAAH,YAAA,CAAAM,aAAa,EAACH,QAAQ,CAAC,EAAE;MAC5B,OAAO;QAAEK,MAAM,EAAEN,IAAI;QAAEC;MAAQ,CAAE;;;EAIrC,IAAI,IAAAJ,SAAA,CAAAU,eAAe,EAACP,IAAI,CAAC,IAAI,IAAAH,SAAA,CAAAU,eAAe,EAACN,QAAQ,CAAC,EAAE;IACtD;IACA;IACA;;;;;;;;IAWA,IAAID,IAAI,CAACQ,MAAM,KAAKP,QAAQ,CAACO,MAAM,EAAE;MACnC;MACA;MACA,OAAO,KAAK;;IAGd,IACE,CAAAL,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEH,IAAI,MAAKL,OAAA,CAAAc,cAAc,CAACC,aAAa,IACjDP,UAAU,CAACQ,MAAM,CAACX,IAAI,KAAKL,OAAA,CAAAc,cAAc,CAACG,UAAU,IACpDT,UAAU,CAACQ,MAAM,CAACE,IAAI,KAAK,KAAK,IAChCV,UAAU,CAACW,SAAS,CAACC,MAAM,KAAK,CAAC,IACjCZ,UAAU,CAACa,cAAc,IAAI,IAAI,EACjC;MACA;MACA;MACA;MACA,OAAO,KAAK;;IAGd,MAAMC,aAAa,GAAG,CAAAC,EAAA,GAAAlB,IAAI,CAACiB,aAAa,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;IAC9C,MAAMC,qBAAqB,GAAG,CAAAC,EAAA,GAAAnB,QAAQ,CAACgB,aAAa,cAAAG,EAAA,cAAAA,EAAA,GAAI,EAAE;IAE1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,aAAa,CAACF,MAAM,EAAEM,CAAC,IAAI,CAAC,EAAE;MAChD,MAAMC,GAAG,GAAGL,aAAa,CAACI,CAAC,CAAC;MAC5B,MAAME,WAAW,GAAGJ,qBAAqB,CAACE,CAAC,CAAC;MAE5C,MAAMG,MAAM,GAAGzB,kBAAkB,CAACuB,GAAG,EAAEC,WAAW,EAAErB,OAAO,EAAEC,UAAU,CAAC;MACxE,IAAIqB,MAAM,EAAE;QACV,OAAO;UAAElB,MAAM,EAAEN,IAAI;UAAEC;QAAQ,CAAE;;;IAIrC,OAAO,KAAK;;EAGd,OAAO,KAAK;AACd;AAnEAwB,OAAA,CAAA1B,kBAAA,GAAAA,kBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}