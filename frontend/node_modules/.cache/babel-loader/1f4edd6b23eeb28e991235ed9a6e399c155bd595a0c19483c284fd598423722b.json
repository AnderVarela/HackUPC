{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PredefinedFormatToCheckFunction = void 0;\nconst enums_1 = require(\"./enums\");\n/*\nThese format functions are taken from `tslint-consistent-codestyle/naming-convention`:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/rules/namingConventionRule.ts#L603-L645\n\nThe license for the code can be viewed here:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/LICENSE\n*/\n/*\nWhy not regex here? Because it's actually really, really difficult to create a regex to handle\nall of the unicode cases, and we have many non-english users that use non-english characters.\nhttps://gist.github.com/mathiasbynens/6334847\n*/\nfunction isPascalCase(name) {\n  return name.length === 0 || name[0] === name[0].toUpperCase() && !name.includes('_');\n}\nfunction isStrictPascalCase(name) {\n  return name.length === 0 || name[0] === name[0].toUpperCase() && hasStrictCamelHumps(name, true);\n}\nfunction isCamelCase(name) {\n  return name.length === 0 || name[0] === name[0].toLowerCase() && !name.includes('_');\n}\nfunction isStrictCamelCase(name) {\n  return name.length === 0 || name[0] === name[0].toLowerCase() && hasStrictCamelHumps(name, false);\n}\nfunction hasStrictCamelHumps(name, isUpper) {\n  function isUppercaseChar(char) {\n    return char === char.toUpperCase() && char !== char.toLowerCase();\n  }\n  if (name.startsWith('_')) {\n    return false;\n  }\n  for (let i = 1; i < name.length; ++i) {\n    if (name[i] === '_') {\n      return false;\n    }\n    if (isUpper === isUppercaseChar(name[i])) {\n      if (isUpper) {\n        return false;\n      }\n    } else {\n      isUpper = !isUpper;\n    }\n  }\n  return true;\n}\nfunction isSnakeCase(name) {\n  return name.length === 0 || name === name.toLowerCase() && validateUnderscores(name);\n}\nfunction isUpperCase(name) {\n  return name.length === 0 || name === name.toUpperCase() && validateUnderscores(name);\n}\n/** Check for leading trailing and adjacent underscores */\nfunction validateUnderscores(name) {\n  if (name.startsWith('_')) {\n    return false;\n  }\n  let wasUnderscore = false;\n  for (let i = 1; i < name.length; ++i) {\n    if (name[i] === '_') {\n      if (wasUnderscore) {\n        return false;\n      }\n      wasUnderscore = true;\n    } else {\n      wasUnderscore = false;\n    }\n  }\n  return !wasUnderscore;\n}\nconst PredefinedFormatToCheckFunction = {\n  [enums_1.PredefinedFormats.PascalCase]: isPascalCase,\n  [enums_1.PredefinedFormats.StrictPascalCase]: isStrictPascalCase,\n  [enums_1.PredefinedFormats.camelCase]: isCamelCase,\n  [enums_1.PredefinedFormats.strictCamelCase]: isStrictCamelCase,\n  [enums_1.PredefinedFormats.UPPER_CASE]: isUpperCase,\n  [enums_1.PredefinedFormats.snake_case]: isSnakeCase\n};\nexports.PredefinedFormatToCheckFunction = PredefinedFormatToCheckFunction;","map":{"version":3,"names":["enums_1","require","isPascalCase","name","length","toUpperCase","includes","isStrictPascalCase","hasStrictCamelHumps","isCamelCase","toLowerCase","isStrictCamelCase","isUpper","isUppercaseChar","char","startsWith","i","isSnakeCase","validateUnderscores","isUpperCase","wasUnderscore","PredefinedFormatToCheckFunction","PredefinedFormats","PascalCase","StrictPascalCase","camelCase","strictCamelCase","UPPER_CASE","snake_case","exports"],"sources":["../../../src/rules/naming-convention-utils/format.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}