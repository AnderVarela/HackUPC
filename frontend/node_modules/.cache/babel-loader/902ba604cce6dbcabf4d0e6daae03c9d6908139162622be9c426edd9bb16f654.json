{"ast":null,"code":"const flagSymbol = Symbol('arg flag');\nclass ArgError extends Error {\n  constructor(msg, code) {\n    super(msg);\n    this.name = 'ArgError';\n    this.code = code;\n    Object.setPrototypeOf(this, ArgError.prototype);\n  }\n}\nfunction arg(opts, {\n  argv = process.argv.slice(2),\n  permissive = false,\n  stopAtPositional = false\n} = {}) {\n  if (!opts) {\n    throw new ArgError('argument specification object is required', 'ARG_CONFIG_NO_SPEC');\n  }\n  const result = {\n    _: []\n  };\n  const aliases = {};\n  const handlers = {};\n  for (const key of Object.keys(opts)) {\n    if (!key) {\n      throw new ArgError('argument key cannot be an empty string', 'ARG_CONFIG_EMPTY_KEY');\n    }\n    if (key[0] !== '-') {\n      throw new ArgError(`argument key must start with '-' but found: '${key}'`, 'ARG_CONFIG_NONOPT_KEY');\n    }\n    if (key.length === 1) {\n      throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, 'ARG_CONFIG_NONAME_KEY');\n    }\n    if (typeof opts[key] === 'string') {\n      aliases[key] = opts[key];\n      continue;\n    }\n    let type = opts[key];\n    let isFlag = false;\n    if (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n      const [fn] = type;\n      type = (value, name, prev = []) => {\n        prev.push(fn(value, name, prev[prev.length - 1]));\n        return prev;\n      };\n      isFlag = fn === Boolean || fn[flagSymbol] === true;\n    } else if (typeof type === 'function') {\n      isFlag = type === Boolean || type[flagSymbol] === true;\n    } else {\n      throw new ArgError(`type missing or not a function or valid array type: ${key}`, 'ARG_CONFIG_VAD_TYPE');\n    }\n    if (key[1] !== '-' && key.length > 2) {\n      throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, 'ARG_CONFIG_SHORTOPT_TOOLONG');\n    }\n    handlers[key] = [type, isFlag];\n  }\n  for (let i = 0, len = argv.length; i < len; i++) {\n    const wholeArg = argv[i];\n    if (stopAtPositional && result._.length > 0) {\n      result._ = result._.concat(argv.slice(i));\n      break;\n    }\n    if (wholeArg === '--') {\n      result._ = result._.concat(argv.slice(i + 1));\n      break;\n    }\n    if (wholeArg.length > 1 && wholeArg[0] === '-') {\n      /* eslint-disable operator-linebreak */\n      const separatedArguments = wholeArg[1] === '-' || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split('').map(a => `-${a}`);\n      /* eslint-enable operator-linebreak */\n\n      for (let j = 0; j < separatedArguments.length; j++) {\n        const arg = separatedArguments[j];\n        const [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n        let argName = originalArgName;\n        while (argName in aliases) {\n          argName = aliases[argName];\n        }\n        if (!(argName in handlers)) {\n          if (permissive) {\n            result._.push(arg);\n            continue;\n          } else {\n            throw new ArgError(`unknown or unexpected option: ${originalArgName}`, 'ARG_UNKNOWN_OPTION');\n          }\n        }\n        const [type, isFlag] = handlers[argName];\n        if (!isFlag && j + 1 < separatedArguments.length) {\n          throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, 'ARG_MISSING_REQUIRED_SHORTARG');\n        }\n        if (isFlag) {\n          result[argName] = type(true, argName, result[argName]);\n        } else if (argStr === undefined) {\n          if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === '-' && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number ||\n          // eslint-disable-next-line no-undef\n          typeof BigInt !== 'undefined' && type === BigInt))) {\n            const extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n            throw new ArgError(`option requires argument: ${originalArgName}${extended}`, 'ARG_MISSING_REQUIRED_LONGARG');\n          }\n          result[argName] = type(argv[i + 1], argName, result[argName]);\n          ++i;\n        } else {\n          result[argName] = type(argStr, argName, result[argName]);\n        }\n      }\n    } else {\n      result._.push(wholeArg);\n    }\n  }\n  return result;\n}\narg.flag = fn => {\n  fn[flagSymbol] = true;\n  return fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\n// Expose error class\narg.ArgError = ArgError;\nmodule.exports = arg;","map":{"version":3,"names":["flagSymbol","Symbol","ArgError","Error","constructor","msg","code","name","Object","setPrototypeOf","prototype","arg","opts","argv","process","slice","permissive","stopAtPositional","result","_","aliases","handlers","key","keys","length","type","isFlag","Array","isArray","fn","value","prev","push","Boolean","i","len","wholeArg","concat","separatedArguments","split","map","a","j","originalArgName","argStr","undefined","argName","match","Number","BigInt","extended","flag","COUNT","v","existingCount","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/arg/index.js"],"sourcesContent":["const flagSymbol = Symbol('arg flag');\n\nclass ArgError extends Error {\n\tconstructor(msg, code) {\n\t\tsuper(msg);\n\t\tthis.name = 'ArgError';\n\t\tthis.code = code;\n\n\t\tObject.setPrototypeOf(this, ArgError.prototype);\n\t}\n}\n\nfunction arg(\n\topts,\n\t{\n\t\targv = process.argv.slice(2),\n\t\tpermissive = false,\n\t\tstopAtPositional = false\n\t} = {}\n) {\n\tif (!opts) {\n\t\tthrow new ArgError(\n\t\t\t'argument specification object is required',\n\t\t\t'ARG_CONFIG_NO_SPEC'\n\t\t);\n\t}\n\n\tconst result = { _: [] };\n\n\tconst aliases = {};\n\tconst handlers = {};\n\n\tfor (const key of Object.keys(opts)) {\n\t\tif (!key) {\n\t\t\tthrow new ArgError(\n\t\t\t\t'argument key cannot be an empty string',\n\t\t\t\t'ARG_CONFIG_EMPTY_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key[0] !== '-') {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must start with '-' but found: '${key}'`,\n\t\t\t\t'ARG_CONFIG_NONOPT_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`argument key must have a name; singular '-' keys are not allowed: ${key}`,\n\t\t\t\t'ARG_CONFIG_NONAME_KEY'\n\t\t\t);\n\t\t}\n\n\t\tif (typeof opts[key] === 'string') {\n\t\t\taliases[key] = opts[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet type = opts[key];\n\t\tlet isFlag = false;\n\n\t\tif (\n\t\t\tArray.isArray(type) &&\n\t\t\ttype.length === 1 &&\n\t\t\ttypeof type[0] === 'function'\n\t\t) {\n\t\t\tconst [fn] = type;\n\t\t\ttype = (value, name, prev = []) => {\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\n\t\t} else if (typeof type === 'function') {\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\n\t\t} else {\n\t\t\tthrow new ArgError(\n\t\t\t\t`type missing or not a function or valid array type: ${key}`,\n\t\t\t\t'ARG_CONFIG_VAD_TYPE'\n\t\t\t);\n\t\t}\n\n\t\tif (key[1] !== '-' && key.length > 2) {\n\t\t\tthrow new ArgError(\n\t\t\t\t`short argument keys (with a single hyphen) must have only one character: ${key}`,\n\t\t\t\t'ARG_CONFIG_SHORTOPT_TOOLONG'\n\t\t\t);\n\t\t}\n\n\t\thandlers[key] = [type, isFlag];\n\t}\n\n\tfor (let i = 0, len = argv.length; i < len; i++) {\n\t\tconst wholeArg = argv[i];\n\n\t\tif (stopAtPositional && result._.length > 0) {\n\t\t\tresult._ = result._.concat(argv.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg === '--') {\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\n\t\t\t/* eslint-disable operator-linebreak */\n\t\t\tconst separatedArguments =\n\t\t\t\twholeArg[1] === '-' || wholeArg.length === 2\n\t\t\t\t\t? [wholeArg]\n\t\t\t\t\t: wholeArg\n\t\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t\t.split('')\n\t\t\t\t\t\t\t.map((a) => `-${a}`);\n\t\t\t/* eslint-enable operator-linebreak */\n\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\n\t\t\t\tconst arg = separatedArguments[j];\n\t\t\t\tconst [originalArgName, argStr] =\n\t\t\t\t\targ[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n\n\t\t\t\tlet argName = originalArgName;\n\t\t\t\twhile (argName in aliases) {\n\t\t\t\t\targName = aliases[argName];\n\t\t\t\t}\n\n\t\t\t\tif (!(argName in handlers)) {\n\t\t\t\t\tif (permissive) {\n\t\t\t\t\t\tresult._.push(arg);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`unknown or unexpected option: ${originalArgName}`,\n\t\t\t\t\t\t\t'ARG_UNKNOWN_OPTION'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst [type, isFlag] = handlers[argName];\n\n\t\t\t\tif (!isFlag && j + 1 < separatedArguments.length) {\n\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t`option requires argument (but was followed by another short argument): ${originalArgName}`,\n\t\t\t\t\t\t'ARG_MISSING_REQUIRED_SHORTARG'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (isFlag) {\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\n\t\t\t\t} else if (argStr === undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\targv.length < i + 2 ||\n\t\t\t\t\t\t(argv[i + 1].length > 1 &&\n\t\t\t\t\t\t\targv[i + 1][0] === '-' &&\n\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\n\t\t\t\t\t\t\t\t(type === Number ||\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt))\n\t\t\t\t\t\t\t))\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst extended =\n\t\t\t\t\t\t\toriginalArgName === argName ? '' : ` (alias for ${argName})`;\n\t\t\t\t\t\tthrow new ArgError(\n\t\t\t\t\t\t\t`option requires argument: ${originalArgName}${extended}`,\n\t\t\t\t\t\t\t'ARG_MISSING_REQUIRED_LONGARG'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\n\t\t\t\t\t++i;\n\t\t\t\t} else {\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult._.push(wholeArg);\n\t\t}\n\t}\n\n\treturn result;\n}\n\narg.flag = (fn) => {\n\tfn[flagSymbol] = true;\n\treturn fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\n// Expose error class\narg.ArgError = ArgError;\n\nmodule.exports = arg;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}