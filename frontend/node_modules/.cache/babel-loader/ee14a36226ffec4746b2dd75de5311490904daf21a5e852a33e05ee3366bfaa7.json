{"ast":null,"code":"'use strict';\n\nvar getFieldAsFn = require('./get-field-as-fn');\n\n/**\n * Create a decoder for input sources using the given codec hash\n * @this {object} A loader or compilation\n * @param {Array.<object>} codecs A list of codecs, each with a `decode` function\n * @param {boolean} mustDecode Return an error for a source that is not decoded\n * @returns {function(string):string|Error} A decode function that returns an absolute path or else an Error\n */\nfunction decodeSourcesWith(codecs, mustDecode) {\n  /* jshint validthis:true */\n  var context = this;\n\n  // get a list of valid decoders\n  var candidates = [].concat(codecs).reduce(reduceValidDecoder.bind(null, codecs), []);\n\n  /**\n   * Attempt to decode the given source path using the previously supplied codecs\n   * @param {string} inputSource A source path from a source map\n   * @returns {Error|string|undefined} An absolute path if decoded else an error if encountered else undefined\n   */\n  return function decode(inputSource) {\n    // attempt all candidates until a match\n    for (var i = 0, decoded = null; i < candidates.length && !decoded; i++) {\n      // call the decoder\n      try {\n        decoded = candidates[i].decode.call(context, inputSource);\n      } catch (exception) {\n        return getNamedError(exception);\n      }\n\n      // match implies a return value\n      if (decoded) {\n        // abstract sources cannot be decoded, only validated\n        if (candidates[i].abstract) {\n          return undefined;\n        }\n        // non-string implies error\n        if (typeof decoded !== 'string') {\n          return getNamedError('Decoder returned a truthy value but it is not a string:\\n' + decoded);\n        }\n        // otherwise success\n        else {\n          return decoded;\n        }\n      }\n    }\n\n    // default is undefined or error\n    return mustDecode ? new Error('No viable decoder for source: ' + inputSource) : undefined;\n    function getNamedError(details) {\n      var name = candidates[i].name || '(unnamed)',\n        message = ['Decoding with codec: ' + name, 'Incoming source: ' + inputSource, details && (details.stack ? details.stack : details)].filter(Boolean).join('\\n');\n      return new Error(message);\n    }\n  };\n}\nmodule.exports = decodeSourcesWith;\nfunction reduceValidDecoder(reduced, codec) {\n  var decoder = getFieldAsFn('decode')(codec);\n  return decoder ? reduced.concat(codec) : reduced;\n}","map":{"version":3,"names":["getFieldAsFn","require","decodeSourcesWith","codecs","mustDecode","context","candidates","concat","reduce","reduceValidDecoder","bind","decode","inputSource","i","decoded","length","call","exception","getNamedError","abstract","undefined","Error","details","name","message","stack","filter","Boolean","join","module","exports","reduced","codec","decoder"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/adjust-sourcemap-loader/lib/process/decode-sources-with.js"],"sourcesContent":["'use strict';\n\nvar getFieldAsFn = require('./get-field-as-fn');\n\n/**\n * Create a decoder for input sources using the given codec hash\n * @this {object} A loader or compilation\n * @param {Array.<object>} codecs A list of codecs, each with a `decode` function\n * @param {boolean} mustDecode Return an error for a source that is not decoded\n * @returns {function(string):string|Error} A decode function that returns an absolute path or else an Error\n */\nfunction decodeSourcesWith(codecs, mustDecode) {\n  /* jshint validthis:true */\n  var context = this;\n\n  // get a list of valid decoders\n  var candidates = [].concat(codecs)\n    .reduce(reduceValidDecoder.bind(null, codecs), []);\n\n  /**\n   * Attempt to decode the given source path using the previously supplied codecs\n   * @param {string} inputSource A source path from a source map\n   * @returns {Error|string|undefined} An absolute path if decoded else an error if encountered else undefined\n   */\n  return function decode(inputSource) {\n\n    // attempt all candidates until a match\n    for (var i = 0, decoded = null; i < candidates.length && !decoded; i++) {\n\n      // call the decoder\n      try {\n        decoded = candidates[i].decode.call(context, inputSource);\n      }\n      catch (exception) {\n        return getNamedError(exception);\n      }\n\n      // match implies a return value\n      if (decoded) {\n\n        // abstract sources cannot be decoded, only validated\n        if (candidates[i].abstract) {\n          return undefined;\n        }\n        // non-string implies error\n        if (typeof decoded !== 'string') {\n          return getNamedError('Decoder returned a truthy value but it is not a string:\\n' + decoded);\n        }\n        // otherwise success\n        else {\n          return decoded;\n        }\n      }\n    }\n\n    // default is undefined or error\n    return mustDecode ? new Error('No viable decoder for source: ' + inputSource) : undefined;\n\n    function getNamedError(details) {\n      var name    = candidates[i].name || '(unnamed)',\n          message = [\n            'Decoding with codec: ' + name,\n            'Incoming source: ' + inputSource,\n            details && (details.stack ? details.stack : details)\n          ]\n            .filter(Boolean)\n            .join('\\n');\n      return new Error(message);\n    }\n  };\n}\n\nmodule.exports = decodeSourcesWith;\n\nfunction reduceValidDecoder(reduced, codec) {\n  var decoder = getFieldAsFn('decode')(codec);\n  return decoder ? reduced.concat(codec) : reduced;\n}"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,mBAAmB,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,UAAU,EAAE;EAC7C;EACA,IAAIC,OAAO,GAAG,IAAI;;EAElB;EACA,IAAIC,UAAU,GAAG,EAAE,CAACC,MAAM,CAACJ,MAAM,CAAC,CAC/BK,MAAM,CAACC,kBAAkB,CAACC,IAAI,CAAC,IAAI,EAAEP,MAAM,CAAC,EAAE,EAAE,CAAC;;EAEpD;AACF;AACA;AACA;AACA;EACE,OAAO,SAASQ,MAAMA,CAACC,WAAW,EAAE;IAElC;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,OAAO,GAAG,IAAI,EAAED,CAAC,GAAGP,UAAU,CAACS,MAAM,IAAI,CAACD,OAAO,EAAED,CAAC,EAAE,EAAE;MAEtE;MACA,IAAI;QACFC,OAAO,GAAGR,UAAU,CAACO,CAAC,CAAC,CAACF,MAAM,CAACK,IAAI,CAACX,OAAO,EAAEO,WAAW,CAAC;MAC3D,CAAC,CACD,OAAOK,SAAS,EAAE;QAChB,OAAOC,aAAa,CAACD,SAAS,CAAC;MACjC;;MAEA;MACA,IAAIH,OAAO,EAAE;QAEX;QACA,IAAIR,UAAU,CAACO,CAAC,CAAC,CAACM,QAAQ,EAAE;UAC1B,OAAOC,SAAS;QAClB;QACA;QACA,IAAI,OAAON,OAAO,KAAK,QAAQ,EAAE;UAC/B,OAAOI,aAAa,CAAC,2DAA2D,GAAGJ,OAAO,CAAC;QAC7F;QACA;QAAA,KACK;UACH,OAAOA,OAAO;QAChB;MACF;IACF;;IAEA;IACA,OAAOV,UAAU,GAAG,IAAIiB,KAAK,CAAC,gCAAgC,GAAGT,WAAW,CAAC,GAAGQ,SAAS;IAEzF,SAASF,aAAaA,CAACI,OAAO,EAAE;MAC9B,IAAIC,IAAI,GAAMjB,UAAU,CAACO,CAAC,CAAC,CAACU,IAAI,IAAI,WAAW;QAC3CC,OAAO,GAAG,CACR,uBAAuB,GAAGD,IAAI,EAC9B,mBAAmB,GAAGX,WAAW,EACjCU,OAAO,KAAKA,OAAO,CAACG,KAAK,GAAGH,OAAO,CAACG,KAAK,GAAGH,OAAO,CAAC,CACrD,CACEI,MAAM,CAACC,OAAO,CAAC,CACfC,IAAI,CAAC,IAAI,CAAC;MACjB,OAAO,IAAIP,KAAK,CAACG,OAAO,CAAC;IAC3B;EACF,CAAC;AACH;AAEAK,MAAM,CAACC,OAAO,GAAG5B,iBAAiB;AAElC,SAASO,kBAAkBA,CAACsB,OAAO,EAAEC,KAAK,EAAE;EAC1C,IAAIC,OAAO,GAAGjC,YAAY,CAAC,QAAQ,CAAC,CAACgC,KAAK,CAAC;EAC3C,OAAOC,OAAO,GAAGF,OAAO,CAACxB,MAAM,CAACyB,KAAK,CAAC,GAAGD,OAAO;AAClD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}