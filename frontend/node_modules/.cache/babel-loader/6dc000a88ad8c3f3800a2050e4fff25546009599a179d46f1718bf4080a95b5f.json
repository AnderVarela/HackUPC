{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContextualType = void 0;\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\n/**\n * Returns the contextual type of a given node.\n * Contextual type is the type of the target the node is going into.\n * i.e. the type of a called function's parameter, or the defined type of a variable declaration\n */\nfunction getContextualType(checker, node) {\n  const parent = node.parent;\n  if (!parent) {\n    return;\n  }\n  if ((0, tsutils_1.isCallExpression)(parent) || (0, tsutils_1.isNewExpression)(parent)) {\n    if (node === parent.expression) {\n      // is the callee, so has no contextual type\n      return;\n    }\n  } else if ((0, tsutils_1.isVariableDeclaration)(parent) || (0, tsutils_1.isPropertyDeclaration)(parent) || (0, tsutils_1.isParameterDeclaration)(parent)) {\n    return parent.type ? checker.getTypeFromTypeNode(parent.type) : undefined;\n  } else if ((0, tsutils_1.isJsxExpression)(parent)) {\n    return checker.getContextualType(parent);\n  } else if ((0, tsutils_1.isPropertyAssignment)(parent) && (0, tsutils_1.isIdentifier)(node)) {\n    return checker.getContextualType(node);\n  } else if ((0, tsutils_1.isBinaryExpression)(parent) && parent.operatorToken.kind === ts.SyntaxKind.EqualsToken && parent.right === node) {\n    // is RHS of assignment\n    return checker.getTypeAtLocation(parent.left);\n  } else if (![ts.SyntaxKind.TemplateSpan, ts.SyntaxKind.JsxExpression].includes(parent.kind)) {\n    // parent is not something we know we can get the contextual type of\n    return;\n  }\n  // TODO - support return statement checking\n  return checker.getContextualType(node);\n}\nexports.getContextualType = getContextualType;","map":{"version":3,"names":["tsutils_1","require","ts","__importStar","getContextualType","checker","node","parent","isCallExpression","isNewExpression","expression","isVariableDeclaration","isPropertyDeclaration","isParameterDeclaration","type","getTypeFromTypeNode","undefined","isJsxExpression","isPropertyAssignment","isIdentifier","isBinaryExpression","operatorToken","kind","SyntaxKind","EqualsToken","right","getTypeAtLocation","left","TemplateSpan","JsxExpression","includes","exports"],"sources":["../src/getContextualType.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAWA,MAAAC,EAAA,GAAAC,YAAA,CAAAF,OAAA;AAEA;;;;;AAKA,SAAgBG,iBAAiBA,CAC/BC,OAAuB,EACvBC,IAAmB;EAEnB,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAAM;EAC1B,IAAI,CAACA,MAAM,EAAE;IACX;;EAGF,IAAI,IAAAP,SAAA,CAAAQ,gBAAgB,EAACD,MAAM,CAAC,IAAI,IAAAP,SAAA,CAAAS,eAAe,EAACF,MAAM,CAAC,EAAE;IACvD,IAAID,IAAI,KAAKC,MAAM,CAACG,UAAU,EAAE;MAC9B;MACA;;GAEH,MAAM,IACL,IAAAV,SAAA,CAAAW,qBAAqB,EAACJ,MAAM,CAAC,IAC7B,IAAAP,SAAA,CAAAY,qBAAqB,EAACL,MAAM,CAAC,IAC7B,IAAAP,SAAA,CAAAa,sBAAsB,EAACN,MAAM,CAAC,EAC9B;IACA,OAAOA,MAAM,CAACO,IAAI,GAAGT,OAAO,CAACU,mBAAmB,CAACR,MAAM,CAACO,IAAI,CAAC,GAAGE,SAAS;GAC1E,MAAM,IAAI,IAAAhB,SAAA,CAAAiB,eAAe,EAACV,MAAM,CAAC,EAAE;IAClC,OAAOF,OAAO,CAACD,iBAAiB,CAACG,MAAM,CAAC;GACzC,MAAM,IAAI,IAAAP,SAAA,CAAAkB,oBAAoB,EAACX,MAAM,CAAC,IAAI,IAAAP,SAAA,CAAAmB,YAAY,EAACb,IAAI,CAAC,EAAE;IAC7D,OAAOD,OAAO,CAACD,iBAAiB,CAACE,IAAI,CAAC;GACvC,MAAM,IACL,IAAAN,SAAA,CAAAoB,kBAAkB,EAACb,MAAM,CAAC,IAC1BA,MAAM,CAACc,aAAa,CAACC,IAAI,KAAKpB,EAAE,CAACqB,UAAU,CAACC,WAAW,IACvDjB,MAAM,CAACkB,KAAK,KAAKnB,IAAI,EACrB;IACA;IACA,OAAOD,OAAO,CAACqB,iBAAiB,CAACnB,MAAM,CAACoB,IAAI,CAAC;GAC9C,MAAM,IACL,CAAC,CAACzB,EAAE,CAACqB,UAAU,CAACK,YAAY,EAAE1B,EAAE,CAACqB,UAAU,CAACM,aAAa,CAAC,CAACC,QAAQ,CACjEvB,MAAM,CAACe,IAAI,CACZ,EACD;IACA;IACA;;EAEF;EAEA,OAAOjB,OAAO,CAACD,iBAAiB,CAACE,IAAI,CAAC;AACxC;AA1CAyB,OAAA,CAAA3B,iBAAA,GAAAA,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}