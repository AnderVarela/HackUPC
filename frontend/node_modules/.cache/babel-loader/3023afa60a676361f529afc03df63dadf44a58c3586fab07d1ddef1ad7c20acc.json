{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\nfunction _fs() {\n  const data = require(\"fs\");\n  _fs = function () {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  const data = require(\"debug\");\n  _debug = function () {\n    return data;\n  };\n  return data;\n}\nfunction _t() {\n  const data = require(\"@babel/types\");\n  _t = function () {\n    return data;\n  };\n  return data;\n}\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n  _convertSourceMap = function () {\n    return data;\n  };\n  return data;\n}\nvar _file = require(\"./file/file.js\");\nvar _index = require(\"../parser/index.js\");\nvar _cloneDeep = require(\"./util/clone-deep.js\");\nconst {\n  file,\n  traverseFast\n} = _t();\nconst debug = _debug()(\"babel:transform:file\");\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\nfunction* normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n    if (options.cloneInputAst) {\n      ast = (0, _cloneDeep.default)(ast);\n    }\n  } else {\n    ast = yield* (0, _index.default)(pluginPasses, options, code);\n  }\n  let inputMap = null;\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n    }\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().fromComment(\"//\" + lastComment);\n        } catch (err) {\n          {\n            debug(\"discarding unknown inline input sourcemap\");\n          }\n        }\n      }\n    }\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);\n          const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]), \"utf8\");\n          inputMap = _convertSourceMap().fromJSON(inputMapContent);\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n  return new _file.default(options, {\n    code,\n    ast: ast,\n    inputMap\n  });\n}\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(({\n      value\n    }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n      return true;\n    });\n  }\n  return [comments, lastComment];\n}\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}\n0 && 0;","map":{"version":3,"names":["_fs","data","require","_path","_debug","_t","_convertSourceMap","_file","_index","_cloneDeep","file","traverseFast","debug","INLINE_SOURCEMAP_REGEX","EXTERNAL_SOURCEMAP_REGEX","normalizeFile","pluginPasses","options","code","ast","type","Error","cloneInputAst","default","inputMap","inputSourceMap","fromObject","lastComment","extractComments","fromComment","err","filename","match","exec","inputMapContent","readFileSync","resolve","dirname","fromJSON","extractCommentsFromList","regex","comments","filter","value","test","node","leadingComments","innerComments","trailingComments"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\core\\src\\transformation\\normalize-file.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport buildDebug from \"debug\";\nimport type { Handler } from \"gensync\";\nimport { file, traverseFast } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { PluginPasses } from \"../config/index.ts\";\nimport convertSourceMap from \"convert-source-map\";\nimport type { SourceMapConverter as Converter } from \"convert-source-map\";\nimport File from \"./file/file.ts\";\nimport parser from \"../parser/index.ts\";\nimport cloneDeep from \"./util/clone-deep.ts\";\n\nconst debug = buildDebug(\"babel:transform:file\");\n\n// These regexps are copied from the convert-source-map package,\n// but without // or /* at the beginning of the comment.\n\nconst INLINE_SOURCEMAP_REGEX =\n  /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX =\n  /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nexport type NormalizedFile = {\n  code: string;\n  ast: t.File;\n  inputMap: Converter | null;\n};\n\nexport default function* normalizeFile(\n  pluginPasses: PluginPasses,\n  options: { [key: string]: any },\n  code: string,\n  ast?: t.File | t.Program | null,\n): Handler<File> {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    if (options.cloneInputAst) {\n      ast = cloneDeep(ast);\n    }\n  } else {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    ast = yield* parser(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n  if (options.inputSourceMap !== false) {\n    // If an explicit object is passed in, it overrides the processing of\n    // source maps that may be in the file itself.\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = convertSourceMap.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n      if (lastComment) {\n        try {\n          inputMap = convertSourceMap.fromComment(\"//\" + lastComment);\n        } catch (err) {\n          if (process.env.BABEL_8_BREAKING) {\n            console.warn(\n              \"discarding unknown inline input sourcemap\",\n              options.filename,\n              err,\n            );\n          } else {\n            debug(\"discarding unknown inline input sourcemap\");\n          }\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          // when `lastComment` is non-null, EXTERNAL_SOURCEMAP_REGEX must have matches\n          const match: [string, string] = EXTERNAL_SOURCEMAP_REGEX.exec(\n            lastComment,\n          ) as any;\n          const inputMapContent = fs.readFileSync(\n            path.resolve(path.dirname(options.filename), match[1]),\n            \"utf8\",\n          );\n          inputMap = convertSourceMap.fromJSON(inputMapContent);\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new File(options, {\n    code,\n    ast: ast as t.File,\n    inputMap,\n  });\n}\n\nfunction extractCommentsFromList(\n  regex: RegExp,\n  comments: t.Comment[],\n  lastComment: string | null,\n): [t.Comment[], string | null] {\n  if (comments) {\n    comments = comments.filter(({ value }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n      return true;\n    });\n  }\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex: RegExp, ast: t.Node) {\n  let lastComment: string = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.leadingComments,\n      lastComment,\n    );\n    [node.innerComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.innerComments,\n      lastComment,\n    );\n    [node.trailingComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.trailingComments,\n      lastComment,\n    );\n  });\n  return lastComment;\n}\n"],"mappings":";;;;;;AAAA,SAAAA,IAAA;EAAA,MAAAC,IAAA,GAAAC,OAAA;EAAAF,GAAA,YAAAA,CAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AACA,SAAAE,MAAA;EAAA,MAAAF,IAAA,GAAAC,OAAA;EAAAC,KAAA,YAAAA,CAAA;IAAA,OAAAF,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AACA,SAAAG,OAAA;EAAA,MAAAH,IAAA,GAAAC,OAAA;EAAAE,MAAA,YAAAA,CAAA;IAAA,OAAAH,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAEA,SAAAI,GAAA;EAAA,MAAAJ,IAAA,GAAAC,OAAA;EAAAG,EAAA,YAAAA,CAAA;IAAA,OAAAJ,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAGA,SAAAK,kBAAA;EAAA,MAAAL,IAAA,GAAAC,OAAA;EAAAI,iBAAA,YAAAA,CAAA;IAAA,OAAAL,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAEA,IAAAM,KAAA,GAAAL,OAAA;AACA,IAAAM,MAAA,GAAAN,OAAA;AACA,IAAAO,UAAA,GAAAP,OAAA;AAA6C;EAPpCQ,IAAI;EAAEC;AAAY,IAAAN,EAAA;AAS3B,MAAMO,KAAK,GAAGR,MAAA,CAAS,CAAC,CAAC,sBAAsB,CAAC;AAKhD,MAAMS,sBAAsB,GAC1B,8FAA8F;AAChG,MAAMC,wBAAwB,GAC5B,gDAAgD;AAQnC,UAAUC,aAAaA,CACpCC,YAA0B,EAC1BC,OAA+B,EAC/BC,IAAY,EACZC,GAA+B,EAChB;EACfD,IAAI,GAAI,GAAEA,IAAI,IAAI,EAAG,EAAC;EAEtB,IAAIC,GAAG,EAAE;IACP,IAAIA,GAAG,CAACC,IAAI,KAAK,SAAS,EAAE;MAC1BD,GAAG,GAAGT,IAAI,CAACS,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;IACzB,CAAC,MAAM,IAAIA,GAAG,CAACC,IAAI,KAAK,MAAM,EAAE;MAC9B,MAAM,IAAIC,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IAEA,IAAIJ,OAAO,CAACK,aAAa,EAAE;MACzBH,GAAG,GAAG,IAAAV,UAAA,CAAAc,OAAS,EAACJ,GAAG,CAAC;IACtB;EACF,CAAC,MAAM;IAELA,GAAG,GAAG,OAAO,IAAAX,MAAA,CAAAe,OAAM,EAACP,YAAY,EAAEC,OAAO,EAAEC,IAAI,CAAC;EAClD;EAEA,IAAIM,QAAQ,GAAG,IAAI;EACnB,IAAIP,OAAO,CAACQ,cAAc,KAAK,KAAK,EAAE;IAGpC,IAAI,OAAOR,OAAO,CAACQ,cAAc,KAAK,QAAQ,EAAE;MAC9CD,QAAQ,GAAGlB,iBAAA,CAAe,CAAC,CAACoB,UAAU,CAACT,OAAO,CAACQ,cAAc,CAAC;IAChE;IAEA,IAAI,CAACD,QAAQ,EAAE;MACb,MAAMG,WAAW,GAAGC,eAAe,CAACf,sBAAsB,EAAEM,GAAG,CAAC;MAChE,IAAIQ,WAAW,EAAE;QACf,IAAI;UACFH,QAAQ,GAAGlB,iBAAA,CAAe,CAAC,CAACuB,WAAW,CAAC,IAAI,GAAGF,WAAW,CAAC;QAC7D,CAAC,CAAC,OAAOG,GAAG,EAAE;UAOL;YACLlB,KAAK,CAAC,2CAA2C,CAAC;UACpD;QACF;MACF;IACF;IAEA,IAAI,CAACY,QAAQ,EAAE;MACb,MAAMG,WAAW,GAAGC,eAAe,CAACd,wBAAwB,EAAEK,GAAG,CAAC;MAClE,IAAI,OAAOF,OAAO,CAACc,QAAQ,KAAK,QAAQ,IAAIJ,WAAW,EAAE;QACvD,IAAI;UAEF,MAAMK,KAAuB,GAAGlB,wBAAwB,CAACmB,IAAI,CAC3DN,WACF,CAAQ;UACR,MAAMO,eAAe,GAAGlC,GAAA,CAAC,CAAC,CAACmC,YAAY,CACrChC,KAAA,CAAG,CAAC,CAACiC,OAAO,CAACjC,KAAA,CAAG,CAAC,CAACkC,OAAO,CAACpB,OAAO,CAACc,QAAQ,CAAC,EAAEC,KAAK,CAAC,CAAC,CAAC,CAAC,EACtD,MACF,CAAC;UACDR,QAAQ,GAAGlB,iBAAA,CAAe,CAAC,CAACgC,QAAQ,CAACJ,eAAe,CAAC;QACvD,CAAC,CAAC,OAAOJ,GAAG,EAAE;UACZlB,KAAK,CAAC,yCAAyC,EAAEkB,GAAG,CAAC;QACvD;MACF,CAAC,MAAM,IAAIH,WAAW,EAAE;QACtBf,KAAK,CAAC,6CAA6C,CAAC;MACtD;IACF;EACF;EAEA,OAAO,IAAIL,KAAA,CAAAgB,OAAI,CAACN,OAAO,EAAE;IACvBC,IAAI;IACJC,GAAG,EAAEA,GAAa;IAClBK;EACF,CAAC,CAAC;AACJ;AAEA,SAASe,uBAAuBA,CAC9BC,KAAa,EACbC,QAAqB,EACrBd,WAA0B,EACI;EAC9B,IAAIc,QAAQ,EAAE;IACZA,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC;MAAEC;IAAM,CAAC,KAAK;MACxC,IAAIH,KAAK,CAACI,IAAI,CAACD,KAAK,CAAC,EAAE;QACrBhB,WAAW,GAAGgB,KAAK;QACnB,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC,CAAC;EACJ;EACA,OAAO,CAACF,QAAQ,EAAEd,WAAW,CAAC;AAChC;AAEA,SAASC,eAAeA,CAACY,KAAa,EAAErB,GAAW,EAAE;EACnD,IAAIQ,WAAmB,GAAG,IAAI;EAC9BhB,YAAY,CAACQ,GAAG,EAAE0B,IAAI,IAAI;IACxB,CAACA,IAAI,CAACC,eAAe,EAAEnB,WAAW,CAAC,GAAGY,uBAAuB,CAC3DC,KAAK,EACLK,IAAI,CAACC,eAAe,EACpBnB,WACF,CAAC;IACD,CAACkB,IAAI,CAACE,aAAa,EAAEpB,WAAW,CAAC,GAAGY,uBAAuB,CACzDC,KAAK,EACLK,IAAI,CAACE,aAAa,EAClBpB,WACF,CAAC;IACD,CAACkB,IAAI,CAACG,gBAAgB,EAAErB,WAAW,CAAC,GAAGY,uBAAuB,CAC5DC,KAAK,EACLK,IAAI,CAACG,gBAAgB,EACrBrB,WACF,CAAC;EACH,CAAC,CAAC;EACF,OAAOA,WAAW;AACpB;AAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}