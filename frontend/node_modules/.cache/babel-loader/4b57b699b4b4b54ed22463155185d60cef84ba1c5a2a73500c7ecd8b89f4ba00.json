{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nvar _core = require(\"@babel/core\");\nconst buildWrapper = _core.template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\nconst buildAnonymousWrapper = _core.template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\nfunction injectWrapper(path, wrapper) {\n  const {\n    body,\n    directives\n  } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path.pushContainer(\"body\", wrapper)[0].get(\"expression\");\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    importInterop,\n    noInterop\n  } = options;\n  const constantReexports = (_api$assumption = api.assumption(\"constantReexports\")) != null ? _api$assumption : options.loose;\n  const enumerableModuleMeta = (_api$assumption2 = api.assumption(\"enumerableModuleMeta\")) != null ? _api$assumption2 : options.loose;\n  return {\n    name: \"transform-modules-amd\",\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n    visitor: {\n      [\"CallExpression\" + (api.types.importExpression ? \"|ImportExpression\" : \"\")](path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (path.isCallExpression() && !path.get(\"callee\").isImport()) return;\n        let {\n          requireId,\n          resolveId,\n          rejectId\n        } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n        let result = _core.types.identifier(\"imported\");\n        if (!noInterop) {\n          result = (0, _helperModuleTransforms.wrapInterop)(this.file.path, result, \"namespace\");\n        }\n        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, false, specifier => _core.template.expression.ast`\n              new Promise((${resolveId}, ${rejectId}) =>\n                ${requireId}(\n                  [${specifier}],\n                  imported => ${_core.types.cloneNode(resolveId)}(${result}),\n                  ${_core.types.cloneNode(rejectId)}\n                )\n              )\n            `));\n      },\n      Program: {\n        exit(path, {\n          requireId\n        }) {\n          if (!(0, _helperModuleTransforms.isModule)(path)) {\n            if (requireId) {\n              injectWrapper(path, buildAnonymousWrapper({\n                REQUIRE: _core.types.cloneNode(requireId)\n              }));\n            }\n            return;\n          }\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(_core.types.stringLiteral(\"require\"));\n            importNames.push(_core.types.cloneNode(requireId));\n          }\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          const {\n            meta,\n            headers\n          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {\n            enumerableModuleMeta,\n            constantReexports,\n            strict,\n            strictMode,\n            allowTopLevelThis,\n            importInterop,\n            noInterop,\n            filename: this.file.opts.filename\n          });\n          if ((0, _helperModuleTransforms.hasExports)(meta)) {\n            amdArgs.push(_core.types.stringLiteral(\"exports\"));\n            importNames.push(_core.types.identifier(meta.exportName));\n          }\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(_core.types.stringLiteral(source));\n            importNames.push(_core.types.identifier(metadata.name));\n            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {\n              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);\n              if (interop) {\n                const header = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(metadata.name), interop));\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));\n          }\n          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);\n          path.unshiftContainer(\"body\", headers);\n          injectWrapper(path, buildWrapper({\n            MODULE_NAME: moduleName,\n            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),\n            IMPORT_NAMES: importNames\n          }));\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperModuleTransforms","_core","buildWrapper","template","statement","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdFactoryCall","pushContainer","get","amdFactoryCallArgs","amdFactory","length","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","allowTopLevelThis","strict","strictMode","importInterop","noInterop","constantReexports","assumption","loose","enumerableModuleMeta","name","pre","file","set","visitor","types","importExpression","state","has","isCallExpression","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","identifier","wrapInterop","replaceWith","buildDynamicImport","specifier","expression","ast","cloneNode","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","filename","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-modules-amd\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  buildDynamicImport,\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t, type PluginPass } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildWrapper = template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\n\nconst buildAnonymousWrapper = template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(\n  path: NodePath<t.Program>,\n  wrapper: t.ExpressionStatement,\n) {\n  const { body, directives } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path\n    .pushContainer(\"body\", wrapper)[0]\n    .get(\"expression\") as NodePath<t.CallExpression>;\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = (\n    amdFactoryCallArgs[\n      amdFactoryCallArgs.length - 1\n    ] as NodePath<t.FunctionExpression>\n  ).get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\ntype State = {\n  requireId?: t.Identifier;\n  resolveId?: t.Identifier;\n  rejectId?: t.Identifier;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } =\n    options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      [\"CallExpression\" +\n        (api.types.importExpression ? \"|ImportExpression\" : \"\")](\n        this: State & PluginPass,\n        path: NodePath<t.CallExpression | t.ImportExpression>,\n        state: State,\n      ) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (path.isCallExpression() && !path.get(\"callee\").isImport()) return;\n\n        let { requireId, resolveId, rejectId } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result: t.Node = t.identifier(\"imported\");\n        if (!noInterop) {\n          result = wrapInterop(this.file.path, result, \"namespace\");\n        }\n\n        path.replaceWith(\n          buildDynamicImport(\n            path.node,\n            false,\n            false,\n            specifier => template.expression.ast`\n              new Promise((${resolveId}, ${rejectId}) =>\n                ${requireId}(\n                  [${specifier}],\n                  imported => ${t.cloneNode(resolveId)}(${result}),\n                  ${t.cloneNode(rejectId)}\n                )\n              )\n            `,\n          ),\n        );\n      },\n      Program: {\n        exit(path, { requireId }) {\n          if (!isModule(path)) {\n            if (requireId) {\n              injectWrapper(\n                path,\n                buildAnonymousWrapper({\n                  REQUIRE: t.cloneNode(requireId),\n                }) as t.ExpressionStatement,\n              );\n            }\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(t.stringLiteral(\"require\"));\n            importNames.push(t.cloneNode(requireId));\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              enumerableModuleMeta,\n              constantReexports,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              importInterop,\n              noInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          injectWrapper(\n            path,\n            buildWrapper({\n              MODULE_NAME: moduleName,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              IMPORT_NAMES: importNames,\n            }) as t.ExpressionStatement,\n          );\n        },\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}