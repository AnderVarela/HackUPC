{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n  _chalk = function () {\n    return data;\n  };\n  return data;\n}\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n  _exit = function () {\n    return data;\n  };\n  return data;\n}\nfunction _reporters() {\n  const data = require('@jest/reporters');\n  _reporters = function () {\n    return data;\n  };\n  return data;\n}\nfunction _testResult() {\n  const data = require('@jest/test-result');\n  _testResult = function () {\n    return data;\n  };\n  return data;\n}\nfunction _transform() {\n  const data = require('@jest/transform');\n  _transform = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n  _jestMessageUtil = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n  _jestSnapshot = function () {\n    return data;\n  };\n  return data;\n}\nfunction _jestUtil() {\n  const data = require('jest-util');\n  _jestUtil = function () {\n    return data;\n  };\n  return data;\n}\nvar _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));\nvar _testSchedulerHelper = require('./testSchedulerHelper');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nasync function createTestScheduler(globalConfig, options, context) {\n  const scheduler = new TestScheduler(globalConfig, options, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n    _defineProperty(this, '_globalConfig', void 0);\n    _defineProperty(this, '_options', void 0);\n    _defineProperty(this, '_context', void 0);\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n  }\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(this._dispatcher);\n    const timings = [];\n    const contexts = new Set();\n    tests.forEach(test => {\n      contexts.add(test.context);\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000);\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, this._globalConfig);\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n      if (testResult.leaks) {\n        const message = _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') + 'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' + '\\n' + 'There is a number of things that can leak memory:\\n' + '  - Async operations that have not finished (e.g. fs.readFile).\\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' + '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n      return this._bailIfNeeded(contexts, aggregatedResults, watcher);\n    };\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n      const testResult = (0, _testResult().buildFailureTestResult)(test.path, error);\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, this._globalConfig, test.path);\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(test, testResult, aggregatedResults);\n    };\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(Array.from(contexts).map(async context => [context, await _jestSnapshot().default.buildSnapshotResolver(context.config)]));\n      contextsWithSnapshotResolvers.forEach(([context, snapshotResolver]) => {\n        const status = _jestSnapshot().default.cleanup(context.hasteFS, this._globalConfig.updateSnapshot, snapshotResolver, context.config.testPathIgnorePatterns);\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));\n    };\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(Array.from(contexts).map(async context => {\n      const {\n        config\n      } = context;\n      if (!testRunners[config.runner]) {\n        var _this$_context, _this$_context2;\n        const transformer = await (0, _transform().createScriptTransformer)(config);\n        const Runner = await transformer.requireAndTranspileModule(config.runner);\n        const runner = new Runner(this._globalConfig, {\n          changedFiles: (_this$_context = this._context) === null || _this$_context === void 0 ? void 0 : _this$_context.changedFiles,\n          sourcesRelatedToTestsInChangedFiles: (_this$_context2 = this._context) === null || _this$_context2 === void 0 ? void 0 : _this$_context2.sourcesRelatedToTestsInChangedFiles\n        });\n        testRunners[config.runner] = runner;\n        contextsByTestRunner.set(runner, context);\n      }\n    }));\n    const testsByRunner = this._partitionTests(testRunners, tests);\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n          /**\n           * Test runners with event emitters are still not supported\n           * for third party test runners.\n           */\n\n          if (testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__) {\n            const unsubscribes = [testRunner.on('test-file-start', ([test]) => onTestFileStart(test)), testRunner.on('test-file-success', ([test, testResult]) => onResult(test, testResult)), testRunner.on('test-file-failure', ([test, error]) => onFailure(test, error)), testRunner.on('test-case-result', ([testPath, testCaseResult]) => {\n              const test = {\n                context,\n                path: testPath\n              };\n              this._dispatcher.onTestCaseResult(test, testCaseResult);\n            })];\n            await testRunner.runTests(tests, watcher, undefined, undefined, undefined, testRunnerOptions);\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(tests, watcher, onTestFileStart, onResult, onFailure, testRunnerOptions);\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n    const anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);\n    const anyReporterErrors = this._dispatcher.hasErrors();\n    aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);\n    return aggregatedResults;\n  }\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n  _shouldAddDefaultReporters(reporters) {\n    return !reporters || !!reporters.find(reporter => this._getReporterProps(reporter).path === 'default');\n  }\n  async _setupReporters() {\n    const {\n      collectCoverage,\n      notify,\n      reporters\n    } = this._globalConfig;\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n    if (!isDefault && collectCoverage) {\n      var _this$_context3, _this$_context4;\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: (_this$_context3 = this._context) === null || _this$_context3 === void 0 ? void 0 : _this$_context3.changedFiles,\n        sourcesRelatedToTestsInChangedFiles: (_this$_context4 = this._context) === null || _this$_context4 === void 0 ? void 0 : _this$_context4.sourcesRelatedToTestsInChangedFiles\n      }));\n    }\n    if (notify) {\n      this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._options.startRun, this._context));\n    }\n    if (reporters && Array.isArray(reporters)) {\n      await this._addCustomReporters(reporters);\n    }\n  }\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(this._globalConfig.verbose ? new (_reporters().VerboseReporter)(this._globalConfig) : new (_reporters().DefaultReporter)(this._globalConfig));\n    if (collectCoverage) {\n      var _this$_context5, _this$_context6;\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: (_this$_context5 = this._context) === null || _this$_context5 === void 0 ? void 0 : _this$_context5.changedFiles,\n        sourcesRelatedToTestsInChangedFiles: (_this$_context6 = this._context) === null || _this$_context6 === void 0 ? void 0 : _this$_context6.sourcesRelatedToTestsInChangedFiles\n      }));\n    }\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n  async _addCustomReporters(reporters) {\n    for (const reporter of reporters) {\n      const {\n        options,\n        path\n      } = this._getReporterProps(reporter);\n      if (path === 'default') continue;\n      try {\n        const Reporter = await (0, _jestUtil().requireOrImportModule)(path, true);\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        error.message = 'An error occurred while adding the reporter at path \"' + _chalk().default.bold(path) + '\".' + error.message;\n        throw error;\n      }\n    }\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const [path, options] = reporter;\n      return {\n        options,\n        path\n      };\n    }\n    throw new Error('Reporter should be either a string or an array');\n  }\n  async _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n      try {\n        await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n}\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n  const max = Math.max(...timings);\n  return timings.length <= workers ? max : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","createTestScheduler","_chalk","data","_interopRequireDefault","require","_exit","_reporters","_testResult","_transform","_jestMessageUtil","_jestSnapshot","_jestUtil","_ReporterDispatcher","_testSchedulerHelper","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","globalConfig","options","context","scheduler","TestScheduler","_setupReporters","constructor","_dispatcher","_globalConfig","_options","_context","addReporter","reporter","register","removeReporter","ReporterClass","unregister","scheduleTests","tests","watcher","onTestFileStart","bind","timings","contexts","Set","forEach","test","add","duration","push","aggregatedResults","createAggregatedResults","length","estimatedTime","Math","ceil","getEstimatedTime","maxWorkers","runInBand","shouldRunInBand","onResult","testResult","isInterrupted","Promise","resolve","testResults","message","onFailure","stack","Error","leaks","red","bold","addResult","onTestFileResult","_bailIfNeeded","error","buildFailureTestResult","path","failureMessage","formatExecError","testExecError","config","updateSnapshotState","contextsWithSnapshotResolvers","all","Array","from","map","buildSnapshotResolver","snapshotResolver","status","cleanup","hasteFS","updateSnapshot","testPathIgnorePatterns","snapshot","filesRemoved","filesRemovedList","concat","updateAll","didUpdate","failure","unchecked","unmatched","onRunStart","showStatus","testRunners","create","contextsByTestRunner","WeakMap","runner","_this$_context","_this$_context2","transformer","createScriptTransformer","Runner","requireAndTranspileModule","changedFiles","sourcesRelatedToTestsInChangedFiles","set","testsByRunner","_partitionTests","keys","testRunner","get","invariant","testRunnerOptions","serial","Boolean","isSerial","__PRIVATE_UNSTABLE_API_supportsEventEmitters__","unsubscribes","on","testPath","testCaseResult","onTestCaseResult","runTests","undefined","sub","wasInterrupted","onRunComplete","anyTestFailures","numFailedTests","numRuntimeErrorTestSuites","anyReporterErrors","hasErrors","success","reduce","testRuns","assign","_shouldAddDefaultReporters","reporters","find","_getReporterProps","collectCoverage","notify","isDefault","_setupDefaultReporters","_this$_context3","_this$_context4","CoverageReporter","NotifyReporter","startRun","isArray","_addCustomReporters","verbose","VerboseReporter","DefaultReporter","_this$_context5","_this$_context6","SummaryReporter","Reporter","requireOrImportModule","bail","isWatchMode","setState","interrupted","exitCode","testFailureExitCode","condition","numTotalTestSuites","result","makeEmptyAggregatedTestResult","startTime","Date","now","workers","max","sum","time"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@jest/core/build/TestScheduler.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTestScheduler = createTestScheduler;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(\n  require('./ReporterDispatcher')\n);\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nasync function createTestScheduler(globalConfig, options, context) {\n  const scheduler = new TestScheduler(globalConfig, options, context);\n  await scheduler._setupReporters();\n  return scheduler;\n}\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  async scheduleTests(tests, watcher) {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(\n      this._dispatcher\n    );\n\n    const timings = [];\n    const contexts = new Set();\n    tests.forEach(test => {\n      contexts.add(test.context);\n\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    });\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(\n      getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000\n    );\n    const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(\n      tests,\n      timings,\n      this._globalConfig\n    );\n\n    const onResult = async (test, testResult) => {\n      if (watcher.isInterrupted()) {\n        return Promise.resolve();\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      } // Throws when the context is leaked after executing a test.\n\n      if (testResult.leaks) {\n        const message =\n          _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') +\n          'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' +\n          '\\n' +\n          'There is a number of things that can leak memory:\\n' +\n          '  - Async operations that have not finished (e.g. fs.readFile).\\n' +\n          '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' +\n          '  - Keeping references to the global scope.';\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack\n        });\n      }\n\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n      return this._bailIfNeeded(contexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test, error) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      const testResult = (0, _testResult().buildFailureTestResult)(\n        test.path,\n        error\n      );\n      testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(\n        testResult.testExecError,\n        test.context.config,\n        this._globalConfig,\n        test.path\n      );\n      (0, _testResult().addResult)(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults\n      );\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(\n        Array.from(contexts).map(async context => [\n          context,\n          await _jestSnapshot().default.buildSnapshotResolver(context.config)\n        ])\n      );\n      contextsWithSnapshotResolvers.forEach(([context, snapshotResolver]) => {\n        const status = _jestSnapshot().default.cleanup(\n          context.hasteFS,\n          this._globalConfig.updateSnapshot,\n          snapshotResolver,\n          context.config.testPathIgnorePatterns\n        );\n\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = (\n          aggregatedResults.snapshot.filesRemovedList || []\n        ).concat(status.filesRemovedList);\n      });\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(\n        !updateAll &&\n        (aggregatedResults.snapshot.unchecked ||\n          aggregatedResults.snapshot.unmatched ||\n          aggregatedResults.snapshot.filesRemoved)\n      );\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand\n    });\n    const testRunners = Object.create(null);\n    const contextsByTestRunner = new WeakMap();\n    await Promise.all(\n      Array.from(contexts).map(async context => {\n        const {config} = context;\n\n        if (!testRunners[config.runner]) {\n          var _this$_context, _this$_context2;\n\n          const transformer = await (0, _transform().createScriptTransformer)(\n            config\n          );\n          const Runner = await transformer.requireAndTranspileModule(\n            config.runner\n          );\n          const runner = new Runner(this._globalConfig, {\n            changedFiles:\n              (_this$_context = this._context) === null ||\n              _this$_context === void 0\n                ? void 0\n                : _this$_context.changedFiles,\n            sourcesRelatedToTestsInChangedFiles:\n              (_this$_context2 = this._context) === null ||\n              _this$_context2 === void 0\n                ? void 0\n                : _this$_context2.sourcesRelatedToTestsInChangedFiles\n          });\n          testRunners[config.runner] = runner;\n          contextsByTestRunner.set(runner, context);\n        }\n      })\n    );\n\n    const testsByRunner = this._partitionTests(testRunners, tests);\n\n    if (testsByRunner) {\n      try {\n        for (const runner of Object.keys(testRunners)) {\n          const testRunner = testRunners[runner];\n          const context = contextsByTestRunner.get(testRunner);\n          invariant(context);\n          const tests = testsByRunner[runner];\n          const testRunnerOptions = {\n            serial: runInBand || Boolean(testRunner.isSerial)\n          };\n          /**\n           * Test runners with event emitters are still not supported\n           * for third party test runners.\n           */\n\n          if (testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__) {\n            const unsubscribes = [\n              testRunner.on('test-file-start', ([test]) =>\n                onTestFileStart(test)\n              ),\n              testRunner.on('test-file-success', ([test, testResult]) =>\n                onResult(test, testResult)\n              ),\n              testRunner.on('test-file-failure', ([test, error]) =>\n                onFailure(test, error)\n              ),\n              testRunner.on(\n                'test-case-result',\n                ([testPath, testCaseResult]) => {\n                  const test = {\n                    context,\n                    path: testPath\n                  };\n\n                  this._dispatcher.onTestCaseResult(test, testCaseResult);\n                }\n              )\n            ];\n            await testRunner.runTests(\n              tests,\n              watcher,\n              undefined,\n              undefined,\n              undefined,\n              testRunnerOptions\n            );\n            unsubscribes.forEach(sub => sub());\n          } else {\n            await testRunner.runTests(\n              tests,\n              watcher,\n              onTestFileStart,\n              onResult,\n              onFailure,\n              testRunnerOptions\n            );\n          }\n        }\n      } catch (error) {\n        if (!watcher.isInterrupted()) {\n          throw error;\n        }\n      }\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n    const anyTestFailures = !(\n      aggregatedResults.numFailedTests === 0 &&\n      aggregatedResults.numRuntimeErrorTestSuites === 0\n    );\n\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(\n      anyTestFailures ||\n      aggregatedResults.snapshot.failure ||\n      anyReporterErrors\n    );\n    return aggregatedResults;\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return (\n      !reporters ||\n      !!reporters.find(\n        reporter => this._getReporterProps(reporter).path === 'default'\n      )\n    );\n  }\n\n  async _setupReporters() {\n    const {collectCoverage, notify, reporters} = this._globalConfig;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      var _this$_context3, _this$_context4;\n\n      this.addReporter(\n        new (_reporters().CoverageReporter)(this._globalConfig, {\n          changedFiles:\n            (_this$_context3 = this._context) === null ||\n            _this$_context3 === void 0\n              ? void 0\n              : _this$_context3.changedFiles,\n          sourcesRelatedToTestsInChangedFiles:\n            (_this$_context4 = this._context) === null ||\n            _this$_context4 === void 0\n              ? void 0\n              : _this$_context4.sourcesRelatedToTestsInChangedFiles\n        })\n      );\n    }\n\n    if (notify) {\n      this.addReporter(\n        new (_reporters().NotifyReporter)(\n          this._globalConfig,\n          this._options.startRun,\n          this._context\n        )\n      );\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      await this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(\n      this._globalConfig.verbose\n        ? new (_reporters().VerboseReporter)(this._globalConfig)\n        : new (_reporters().DefaultReporter)(this._globalConfig)\n    );\n\n    if (collectCoverage) {\n      var _this$_context5, _this$_context6;\n\n      this.addReporter(\n        new (_reporters().CoverageReporter)(this._globalConfig, {\n          changedFiles:\n            (_this$_context5 = this._context) === null ||\n            _this$_context5 === void 0\n              ? void 0\n              : _this$_context5.changedFiles,\n          sourcesRelatedToTestsInChangedFiles:\n            (_this$_context6 = this._context) === null ||\n            _this$_context6 === void 0\n              ? void 0\n              : _this$_context6.sourcesRelatedToTestsInChangedFiles\n        })\n      );\n    }\n\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n\n  async _addCustomReporters(reporters) {\n    for (const reporter of reporters) {\n      const {options, path} = this._getReporterProps(reporter);\n\n      if (path === 'default') continue;\n\n      try {\n        const Reporter = await (0, _jestUtil().requireOrImportModule)(\n          path,\n          true\n        );\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        error.message =\n          'An error occurred while adding the reporter at path \"' +\n          _chalk().default.bold(path) +\n          '\".' +\n          error.message;\n        throw error;\n      }\n    }\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const [path, options] = reporter;\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  async _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (\n      this._globalConfig.bail !== 0 &&\n      aggregatedResults.numFailedTests >= this._globalConfig.bail\n    ) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({\n          interrupted: true\n        });\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        (0, _exit().default)(exitCode);\n      }\n    }\n  }\n}\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers\n    ? max\n    : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}