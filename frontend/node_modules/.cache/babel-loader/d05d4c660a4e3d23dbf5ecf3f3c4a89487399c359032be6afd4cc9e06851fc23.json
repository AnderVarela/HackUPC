{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst types_1 = require(\"./types\");\nconst __1 = require(\"..\");\nconst codegen_1 = require(\"../codegen\");\nconst ref_error_1 = require(\"../ref_error\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst ref_1 = require(\"../../vocabularies/jtd/ref\");\nconst type_1 = require(\"../../vocabularies/jtd/type\");\nconst parseJson_1 = require(\"../../runtime/parseJson\");\nconst util_1 = require(\"../util\");\nconst timestamp_1 = require(\"../../runtime/timestamp\");\nconst genParse = {\n  elements: parseElements,\n  values: parseValues,\n  discriminator: parseDiscriminator,\n  properties: parseProperties,\n  optionalProperties: parseProperties,\n  enum: parseEnum,\n  type: parseType,\n  ref: parseRef\n};\nfunction compileParser(sch, definitions) {\n  const _sch = __1.getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  const parseName = gen.scopeName(\"parse\");\n  const cxt = {\n    self: this,\n    gen,\n    schema: sch.schema,\n    schemaEnv: sch,\n    definitions,\n    data: names_1.default.data,\n    parseName,\n    char: gen.name(\"c\")\n  };\n  let sourceCode;\n  try {\n    this._compilations.add(sch);\n    sch.parseName = parseName;\n    parserFunction(cxt);\n    gen.optimize(this.opts.code.optimize);\n    const parseFuncCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;\n    const makeParse = new Function(`${names_1.default.scope}`, sourceCode);\n    const parse = makeParse(this.scope.get());\n    this.scope.value(parseName, {\n      ref: parse\n    });\n    sch.parse = parse;\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling parser, function code:\", sourceCode);\n    delete sch.parse;\n    delete sch.parseName;\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n  return sch;\n}\nexports.default = compileParser;\nconst undef = (0, codegen_1._)`undefined`;\nfunction parserFunction(cxt) {\n  const {\n    gen,\n    parseName,\n    char\n  } = cxt;\n  gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {\n    gen.let(names_1.default.data);\n    gen.let(char);\n    gen.assign((0, codegen_1._)`${parseName}.message`, undef);\n    gen.assign((0, codegen_1._)`${parseName}.position`, undef);\n    gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);\n    gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);\n    parseCode(cxt);\n    skipWhitespace(cxt);\n    gen.if(names_1.default.jsonPart, () => {\n      gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);\n      gen.return(names_1.default.data);\n    });\n    gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));\n    jsonSyntaxError(cxt);\n  });\n}\nfunction parseCode(cxt) {\n  let form;\n  for (const key of types_1.jtdForms) {\n    if (key in cxt.schema) {\n      form = key;\n      break;\n    }\n  }\n  if (form) parseNullable(cxt, genParse[form]);else parseEmpty(cxt);\n}\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));\nfunction parseNullable(cxt, parseForm) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  if (!schema.nullable) return parseForm(cxt);\n  tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null));\n}\nfunction parseElements(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  parseToken(cxt, \"[\");\n  const ix = gen.let(\"i\", 0);\n  gen.assign(data, (0, codegen_1._)`[]`);\n  parseItems(cxt, \"]\", () => {\n    const el = gen.let(\"el\");\n    parseCode({\n      ...cxt,\n      schema: schema.elements,\n      data: el\n    });\n    gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);\n  });\n}\nfunction parseValues(cxt) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values));\n}\nfunction parseItems(cxt, endToken, block) {\n  tryParseItems(cxt, endToken, block);\n  parseToken(cxt, endToken);\n}\nfunction tryParseItems(cxt, endToken, block) {\n  const {\n    gen\n  } = cxt;\n  gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n    block();\n    tryParseToken(cxt, \",\", () => gen.break(), hasItem);\n  });\n  function hasItem() {\n    tryParseToken(cxt, endToken, () => {}, jsonSyntaxError);\n  }\n}\nfunction parseKeyValue(cxt, schema) {\n  const {\n    gen\n  } = cxt;\n  const key = gen.let(\"key\");\n  parseString({\n    ...cxt,\n    data: key\n  });\n  parseToken(cxt, \":\");\n  parsePropertyValue(cxt, key, schema);\n}\nfunction parseDiscriminator(cxt) {\n  const {\n    gen,\n    data,\n    schema\n  } = cxt;\n  const {\n    discriminator,\n    mapping\n  } = schema;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  const startPos = gen.const(\"pos\", names_1.default.jsonPos);\n  const value = gen.let(\"value\");\n  const tag = gen.let(\"tag\");\n  tryParseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\");\n    parseString({\n      ...cxt,\n      data: key\n    });\n    parseToken(cxt, \":\");\n    gen.if((0, codegen_1._)`${key} === ${discriminator}`, () => {\n      parseString({\n        ...cxt,\n        data: tag\n      });\n      gen.assign((0, codegen_1._)`${data}[${key}]`, tag);\n      gen.break();\n    }, () => parseEmpty({\n      ...cxt,\n      data: value\n    }) // can be discarded/skipped\n    );\n  });\n  gen.assign(names_1.default.jsonPos, startPos);\n  gen.if((0, codegen_1._)`${tag} === undefined`);\n  parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);\n  for (const tagValue in mapping) {\n    gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n    parseSchemaProperties({\n      ...cxt,\n      schema: mapping[tagValue]\n    }, discriminator);\n  }\n  gen.else();\n  parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);\n  gen.endIf();\n}\nfunction parseProperties(cxt) {\n  const {\n    gen,\n    data\n  } = cxt;\n  parseToken(cxt, \"{\");\n  gen.assign(data, (0, codegen_1._)`{}`);\n  parseSchemaProperties(cxt);\n}\nfunction parseSchemaProperties(cxt, discriminator) {\n  const {\n    gen,\n    schema,\n    data\n  } = cxt;\n  const {\n    properties,\n    optionalProperties,\n    additionalProperties\n  } = schema;\n  parseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\");\n    parseString({\n      ...cxt,\n      data: key\n    });\n    parseToken(cxt, \":\");\n    gen.if(false);\n    parseDefinedProperty(cxt, key, properties);\n    parseDefinedProperty(cxt, key, optionalProperties);\n    if (discriminator) {\n      gen.elseIf((0, codegen_1._)`${key} === ${discriminator}`);\n      const tag = gen.let(\"tag\");\n      parseString({\n        ...cxt,\n        data: tag\n      }); // can be discarded, it is already assigned\n    }\n    gen.else();\n    if (additionalProperties) {\n      parseEmpty({\n        ...cxt,\n        data: (0, codegen_1._)`${data}[${key}]`\n      });\n    } else {\n      parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);\n    }\n    gen.endIf();\n  });\n  if (properties) {\n    const hasProp = (0, code_1.hasPropFunc)(gen);\n    const allProps = (0, codegen_1.and)(...Object.keys(properties).map(p => (0, codegen_1._)`${hasProp}.call(${data}, ${p})`));\n    gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));\n  }\n}\nfunction parseDefinedProperty(cxt, key, schemas = {}) {\n  const {\n    gen\n  } = cxt;\n  for (const prop in schemas) {\n    gen.elseIf((0, codegen_1._)`${key} === ${prop}`);\n    parsePropertyValue(cxt, key, schemas[prop]);\n  }\n}\nfunction parsePropertyValue(cxt, key, schema) {\n  parseCode({\n    ...cxt,\n    schema,\n    data: (0, codegen_1._)`${cxt.data}[${key}]`\n  });\n}\nfunction parseType(cxt) {\n  const {\n    gen,\n    schema,\n    data,\n    self\n  } = cxt;\n  switch (schema.type) {\n    case \"boolean\":\n      parseBoolean(cxt);\n      break;\n    case \"string\":\n      parseString(cxt);\n      break;\n    case \"timestamp\":\n      {\n        parseString(cxt);\n        const vts = (0, util_1.useFunc)(gen, timestamp_1.default);\n        const {\n          allowDate,\n          parseDate\n        } = self.opts;\n        const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;\n        const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;\n        gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));\n        break;\n      }\n    case \"float32\":\n    case \"float64\":\n      parseNumber(cxt);\n      break;\n    default:\n      {\n        const t = schema.type;\n        if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n          parseNumber(cxt, 16); // 2 ** 53 - max safe integer\n          if (t === \"uint32\") {\n            gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));\n          }\n        } else {\n          const [min, max, maxDigits] = type_1.intRange[t];\n          parseNumber(cxt, maxDigits);\n          gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));\n        }\n      }\n  }\n}\nfunction parseString(cxt) {\n  parseToken(cxt, '\"');\n  parseWith(cxt, parseJson_1.parseJsonString);\n}\nfunction parseEnum(cxt) {\n  const {\n    gen,\n    data,\n    schema\n  } = cxt;\n  const enumSch = schema.enum;\n  parseToken(cxt, '\"');\n  // TODO loopEnum\n  gen.if(false);\n  for (const value of enumSch) {\n    const valueStr = JSON.stringify(value).slice(1); // remove starting quote\n    gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);\n    gen.assign(data, (0, codegen_1.str)`${value}`);\n    gen.add(names_1.default.jsonPos, valueStr.length);\n  }\n  gen.else();\n  jsonSyntaxError(cxt);\n  gen.endIf();\n}\nfunction parseNumber(cxt, maxDigits) {\n  const {\n    gen\n  } = cxt;\n  skipWhitespace(cxt);\n  gen.if((0, codegen_1._)`\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));\n}\nfunction parseBooleanToken(bool, fail) {\n  return cxt => {\n    const {\n      gen,\n      data\n    } = cxt;\n    tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));\n  };\n}\nfunction parseRef(cxt) {\n  const {\n    gen,\n    self,\n    definitions,\n    schema,\n    schemaEnv\n  } = cxt;\n  const {\n    ref\n  } = schema;\n  const refSchema = definitions[ref];\n  if (!refSchema) throw new ref_error_1.default(self.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n  if (!(0, ref_1.hasRef)(refSchema)) return parseCode({\n    ...cxt,\n    schema: refSchema\n  });\n  const {\n    root\n  } = schemaEnv;\n  const sch = compileParser.call(self, new __1.SchemaEnv({\n    schema: refSchema,\n    root\n  }), definitions);\n  partialParse(cxt, getParser(gen, sch), true);\n}\nfunction getParser(gen, sch) {\n  return sch.parse ? gen.scopeValue(\"parse\", {\n    ref: sch.parse\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.parse`;\n}\nfunction parseEmpty(cxt) {\n  parseWith(cxt, parseJson_1.parseJson);\n}\nfunction parseWith(cxt, parseFunc, args) {\n  partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);\n}\nfunction partialParse(cxt, parseFunc, args) {\n  const {\n    gen,\n    data\n  } = cxt;\n  gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);\n  gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);\n  gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));\n}\nfunction parseToken(cxt, tok) {\n  tryParseToken(cxt, tok, jsonSyntaxError);\n}\nfunction tryParseToken(cxt, tok, fail, success) {\n  const {\n    gen\n  } = cxt;\n  const n = tok.length;\n  skipWhitespace(cxt);\n  gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {\n    gen.add(names_1.default.jsonPos, n);\n    success === null || success === void 0 ? void 0 : success(cxt);\n  }, () => fail(cxt));\n}\nfunction skipWhitespace({\n  gen,\n  char: c\n}) {\n  gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${names_1.default.jsonPos}++;`);\n}\nfunction jsonSlice(len) {\n  return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;\n}\nfunction jsonSyntaxError(cxt) {\n  parsingError(cxt, (0, codegen_1._)`\"unexpected token \" + ${names_1.default.json}[${names_1.default.jsonPos}]`);\n}\nfunction parsingError({\n  gen,\n  parseName\n}, msg) {\n  gen.assign((0, codegen_1._)`${parseName}.message`, msg);\n  gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);\n  gen.return(undef);\n}","map":{"version":3,"names":["types_1","require","__1","codegen_1","ref_error_1","names_1","code_1","ref_1","type_1","parseJson_1","util_1","timestamp_1","genParse","elements","parseElements","values","parseValues","discriminator","parseDiscriminator","properties","parseProperties","optionalProperties","enum","parseEnum","type","parseType","ref","parseRef","compileParser","sch","definitions","_sch","getCompilingSchema","call","es5","lines","opts","code","ownProperties","gen","CodeGen","scope","parseName","scopeName","cxt","self","schema","schemaEnv","data","default","char","name","sourceCode","_compilations","add","parserFunction","optimize","parseFuncCode","toString","scopeRefs","makeParse","Function","parse","get","value","e","logger","error","delete","exports","undef","_","func","json","jsonPos","jsonPart","let","assign","const","jsonLen","parseCode","skipWhitespace","if","return","jsonSyntaxError","form","key","jtdForms","parseNullable","parseEmpty","parseBoolean","parseBooleanToken","parseForm","nullable","tryParseToken","parseToken","ix","parseItems","el","parseKeyValue","endToken","block","tryParseItems","for","jsonSlice","break","hasItem","parseString","parsePropertyValue","mapping","startPos","tag","parsingError","str","tagValue","elseIf","parseSchemaProperties","else","endIf","additionalProperties","parseDefinedProperty","hasProp","hasPropFunc","allProps","and","Object","keys","map","p","not","schemas","prop","vts","useFunc","allowDate","parseDate","notValid","fail","or","parseNumber","t","int32range","min","max","maxDigits","intRange","parseWith","parseJsonString","enumSch","valueStr","JSON","stringify","slice","length","parseJsonNumber","bool","refSchema","uriResolver","hasRef","root","SchemaEnv","partialParse","getParser","scopeValue","parseJson","parseFunc","args","nil","tok","success","n","c","len","msg"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\compile\\jtd\\parse.ts"],"sourcesContent":["import type Ajv from \"../../core\"\nimport type {SchemaObject} from \"../../types\"\nimport {jtdForms, JTDForm, SchemaObjectMap} from \"./types\"\nimport {SchemaEnv, getCompilingSchema} from \"..\"\nimport {_, str, and, or, nil, not, CodeGen, Code, Name, SafeExpr} from \"../codegen\"\nimport MissingRefError from \"../ref_error\"\nimport N from \"../names\"\nimport {hasPropFunc} from \"../../vocabularies/code\"\nimport {hasRef} from \"../../vocabularies/jtd/ref\"\nimport {intRange, IntType} from \"../../vocabularies/jtd/type\"\nimport {parseJson, parseJsonNumber, parseJsonString} from \"../../runtime/parseJson\"\nimport {useFunc} from \"../util\"\nimport validTimestamp from \"../../runtime/timestamp\"\n\ntype GenParse = (cxt: ParseCxt) => void\n\nconst genParse: {[F in JTDForm]: GenParse} = {\n  elements: parseElements,\n  values: parseValues,\n  discriminator: parseDiscriminator,\n  properties: parseProperties,\n  optionalProperties: parseProperties,\n  enum: parseEnum,\n  type: parseType,\n  ref: parseRef,\n}\n\ninterface ParseCxt {\n  readonly gen: CodeGen\n  readonly self: Ajv // current Ajv instance\n  readonly schemaEnv: SchemaEnv\n  readonly definitions: SchemaObjectMap\n  schema: SchemaObject\n  data: Code\n  parseName: Name\n  char: Name\n}\n\nexport default function compileParser(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const parseName = gen.scopeName(\"parse\")\n  const cxt: ParseCxt = {\n    self: this,\n    gen,\n    schema: sch.schema as SchemaObject,\n    schemaEnv: sch,\n    definitions,\n    data: N.data,\n    parseName,\n    char: gen.name(\"c\"),\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    sch.parseName = parseName\n    parserFunction(cxt)\n    gen.optimize(this.opts.code.optimize)\n    const parseFuncCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${parseFuncCode}`\n    const makeParse = new Function(`${N.scope}`, sourceCode)\n    const parse: (json: string) => unknown = makeParse(this.scope.get())\n    this.scope.value(parseName, {ref: parse})\n    sch.parse = parse\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling parser, function code:\", sourceCode)\n    delete sch.parse\n    delete sch.parseName\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n  return sch\n}\n\nconst undef = _`undefined`\n\nfunction parserFunction(cxt: ParseCxt): void {\n  const {gen, parseName, char} = cxt\n  gen.func(parseName, _`${N.json}, ${N.jsonPos}, ${N.jsonPart}`, false, () => {\n    gen.let(N.data)\n    gen.let(char)\n    gen.assign(_`${parseName}.message`, undef)\n    gen.assign(_`${parseName}.position`, undef)\n    gen.assign(N.jsonPos, _`${N.jsonPos} || 0`)\n    gen.const(N.jsonLen, _`${N.json}.length`)\n    parseCode(cxt)\n    skipWhitespace(cxt)\n    gen.if(N.jsonPart, () => {\n      gen.assign(_`${parseName}.position`, N.jsonPos)\n      gen.return(N.data)\n    })\n    gen.if(_`${N.jsonPos} === ${N.jsonLen}`, () => gen.return(N.data))\n    jsonSyntaxError(cxt)\n  })\n}\n\nfunction parseCode(cxt: ParseCxt): void {\n  let form: JTDForm | undefined\n  for (const key of jtdForms) {\n    if (key in cxt.schema) {\n      form = key\n      break\n    }\n  }\n  if (form) parseNullable(cxt, genParse[form])\n  else parseEmpty(cxt)\n}\n\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError))\n\nfunction parseNullable(cxt: ParseCxt, parseForm: GenParse): void {\n  const {gen, schema, data} = cxt\n  if (!schema.nullable) return parseForm(cxt)\n  tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null))\n}\n\nfunction parseElements(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"[\")\n  const ix = gen.let(\"i\", 0)\n  gen.assign(data, _`[]`)\n  parseItems(cxt, \"]\", () => {\n    const el = gen.let(\"el\")\n    parseCode({...cxt, schema: schema.elements, data: el})\n    gen.assign(_`${data}[${ix}++]`, el)\n  })\n}\n\nfunction parseValues(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values))\n}\n\nfunction parseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  tryParseItems(cxt, endToken, block)\n  parseToken(cxt, endToken)\n}\n\nfunction tryParseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  const {gen} = cxt\n  gen.for(_`;${N.jsonPos}<${N.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n    block()\n    tryParseToken(cxt, \",\", () => gen.break(), hasItem)\n  })\n\n  function hasItem(): void {\n    tryParseToken(cxt, endToken, () => {}, jsonSyntaxError)\n  }\n}\n\nfunction parseKeyValue(cxt: ParseCxt, schema: SchemaObject): void {\n  const {gen} = cxt\n  const key = gen.let(\"key\")\n  parseString({...cxt, data: key})\n  parseToken(cxt, \":\")\n  parsePropertyValue(cxt, key, schema)\n}\n\nfunction parseDiscriminator(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const {discriminator, mapping} = schema\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  const startPos = gen.const(\"pos\", N.jsonPos)\n  const value = gen.let(\"value\")\n  const tag = gen.let(\"tag\")\n  tryParseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(\n      _`${key} === ${discriminator}`,\n      () => {\n        parseString({...cxt, data: tag})\n        gen.assign(_`${data}[${key}]`, tag)\n        gen.break()\n      },\n      () => parseEmpty({...cxt, data: value}) // can be discarded/skipped\n    )\n  })\n  gen.assign(N.jsonPos, startPos)\n  gen.if(_`${tag} === undefined`)\n  parsingError(cxt, str`discriminator tag not found`)\n  for (const tagValue in mapping) {\n    gen.elseIf(_`${tag} === ${tagValue}`)\n    parseSchemaProperties({...cxt, schema: mapping[tagValue]}, discriminator)\n  }\n  gen.else()\n  parsingError(cxt, str`discriminator value not in schema`)\n  gen.endIf()\n}\n\nfunction parseProperties(cxt: ParseCxt): void {\n  const {gen, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseSchemaProperties(cxt)\n}\n\nfunction parseSchemaProperties(cxt: ParseCxt, discriminator?: string): void {\n  const {gen, schema, data} = cxt\n  const {properties, optionalProperties, additionalProperties} = schema\n  parseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(false)\n    parseDefinedProperty(cxt, key, properties)\n    parseDefinedProperty(cxt, key, optionalProperties)\n    if (discriminator) {\n      gen.elseIf(_`${key} === ${discriminator}`)\n      const tag = gen.let(\"tag\")\n      parseString({...cxt, data: tag}) // can be discarded, it is already assigned\n    }\n    gen.else()\n    if (additionalProperties) {\n      parseEmpty({...cxt, data: _`${data}[${key}]`})\n    } else {\n      parsingError(cxt, str`property ${key} not allowed`)\n    }\n    gen.endIf()\n  })\n  if (properties) {\n    const hasProp = hasPropFunc(gen)\n    const allProps: Code = and(\n      ...Object.keys(properties).map((p): Code => _`${hasProp}.call(${data}, ${p})`)\n    )\n    gen.if(not(allProps), () => parsingError(cxt, str`missing required properties`))\n  }\n}\n\nfunction parseDefinedProperty(cxt: ParseCxt, key: Name, schemas: SchemaObjectMap = {}): void {\n  const {gen} = cxt\n  for (const prop in schemas) {\n    gen.elseIf(_`${key} === ${prop}`)\n    parsePropertyValue(cxt, key, schemas[prop] as SchemaObject)\n  }\n}\n\nfunction parsePropertyValue(cxt: ParseCxt, key: Name, schema: SchemaObject): void {\n  parseCode({...cxt, schema, data: _`${cxt.data}[${key}]`})\n}\n\nfunction parseType(cxt: ParseCxt): void {\n  const {gen, schema, data, self} = cxt\n  switch (schema.type) {\n    case \"boolean\":\n      parseBoolean(cxt)\n      break\n    case \"string\":\n      parseString(cxt)\n      break\n    case \"timestamp\": {\n      parseString(cxt)\n      const vts = useFunc(gen, validTimestamp)\n      const {allowDate, parseDate} = self.opts\n      const notValid = allowDate ? _`!${vts}(${data}, true)` : _`!${vts}(${data})`\n      const fail: Code = parseDate\n        ? or(notValid, _`(${data} = new Date(${data}), false)`, _`isNaN(${data}.valueOf())`)\n        : notValid\n      gen.if(fail, () => parsingError(cxt, str`invalid timestamp`))\n      break\n    }\n    case \"float32\":\n    case \"float64\":\n      parseNumber(cxt)\n      break\n    default: {\n      const t = schema.type as IntType\n      if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n        parseNumber(cxt, 16) // 2 ** 53 - max safe integer\n        if (t === \"uint32\") {\n          gen.if(_`${data} < 0`, () => parsingError(cxt, str`integer out of range`))\n        }\n      } else {\n        const [min, max, maxDigits] = intRange[t]\n        parseNumber(cxt, maxDigits)\n        gen.if(_`${data} < ${min} || ${data} > ${max}`, () =>\n          parsingError(cxt, str`integer out of range`)\n        )\n      }\n    }\n  }\n}\n\nfunction parseString(cxt: ParseCxt): void {\n  parseToken(cxt, '\"')\n  parseWith(cxt, parseJsonString)\n}\n\nfunction parseEnum(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const enumSch = schema.enum\n  parseToken(cxt, '\"')\n  // TODO loopEnum\n  gen.if(false)\n  for (const value of enumSch) {\n    const valueStr = JSON.stringify(value).slice(1) // remove starting quote\n    gen.elseIf(_`${jsonSlice(valueStr.length)} === ${valueStr}`)\n    gen.assign(data, str`${value}`)\n    gen.add(N.jsonPos, valueStr.length)\n  }\n  gen.else()\n  jsonSyntaxError(cxt)\n  gen.endIf()\n}\n\nfunction parseNumber(cxt: ParseCxt, maxDigits?: number): void {\n  const {gen} = cxt\n  skipWhitespace(cxt)\n  gen.if(\n    _`\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`,\n    () => jsonSyntaxError(cxt),\n    () => parseWith(cxt, parseJsonNumber, maxDigits)\n  )\n}\n\nfunction parseBooleanToken(bool: boolean, fail: GenParse): GenParse {\n  return (cxt) => {\n    const {gen, data} = cxt\n    tryParseToken(\n      cxt,\n      `${bool}`,\n      () => fail(cxt),\n      () => gen.assign(data, bool)\n    )\n  }\n}\n\nfunction parseRef(cxt: ParseCxt): void {\n  const {gen, self, definitions, schema, schemaEnv} = cxt\n  const {ref} = schema\n  const refSchema = definitions[ref]\n  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n  if (!hasRef(refSchema)) return parseCode({...cxt, schema: refSchema})\n  const {root} = schemaEnv\n  const sch = compileParser.call(self, new SchemaEnv({schema: refSchema, root}), definitions)\n  partialParse(cxt, getParser(gen, sch), true)\n}\n\nfunction getParser(gen: CodeGen, sch: SchemaEnv): Code {\n  return sch.parse\n    ? gen.scopeValue(\"parse\", {ref: sch.parse})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.parse`\n}\n\nfunction parseEmpty(cxt: ParseCxt): void {\n  parseWith(cxt, parseJson)\n}\n\nfunction parseWith(cxt: ParseCxt, parseFunc: {code: string}, args?: SafeExpr): void {\n  partialParse(cxt, useFunc(cxt.gen, parseFunc), args)\n}\n\nfunction partialParse(cxt: ParseCxt, parseFunc: Name, args?: SafeExpr): void {\n  const {gen, data} = cxt\n  gen.assign(data, _`${parseFunc}(${N.json}, ${N.jsonPos}${args ? _`, ${args}` : nil})`)\n  gen.assign(N.jsonPos, _`${parseFunc}.position`)\n  gen.if(_`${data} === undefined`, () => parsingError(cxt, _`${parseFunc}.message`))\n}\n\nfunction parseToken(cxt: ParseCxt, tok: string): void {\n  tryParseToken(cxt, tok, jsonSyntaxError)\n}\n\nfunction tryParseToken(cxt: ParseCxt, tok: string, fail: GenParse, success?: GenParse): void {\n  const {gen} = cxt\n  const n = tok.length\n  skipWhitespace(cxt)\n  gen.if(\n    _`${jsonSlice(n)} === ${tok}`,\n    () => {\n      gen.add(N.jsonPos, n)\n      success?.(cxt)\n    },\n    () => fail(cxt)\n  )\n}\n\nfunction skipWhitespace({gen, char: c}: ParseCxt): void {\n  gen.code(\n    _`while((${c}=${N.json}[${N.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${N.jsonPos}++;`\n  )\n}\n\nfunction jsonSlice(len: number | Name): Code {\n  return len === 1\n    ? _`${N.json}[${N.jsonPos}]`\n    : _`${N.json}.slice(${N.jsonPos}, ${N.jsonPos}+${len})`\n}\n\nfunction jsonSyntaxError(cxt: ParseCxt): void {\n  parsingError(cxt, _`\"unexpected token \" + ${N.json}[${N.jsonPos}]`)\n}\n\nfunction parsingError({gen, parseName}: ParseCxt, msg: Code): void {\n  gen.assign(_`${parseName}.message`, msg)\n  gen.assign(_`${parseName}.position`, N.jsonPos)\n  gen.return(undef)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}