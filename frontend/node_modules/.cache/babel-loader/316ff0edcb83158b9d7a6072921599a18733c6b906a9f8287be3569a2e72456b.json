{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = autoInject;\nvar _auto = require('./auto.js');\nvar _auto2 = _interopRequireDefault(_auto);\nvar _wrapAsync = require('./internal/wrapAsync.js');\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nfunction stripComments(string) {\n  let stripped = '';\n  let index = 0;\n  let endBlockComment = string.indexOf('*/');\n  while (index < string.length) {\n    if (string[index] === '/' && string[index + 1] === '/') {\n      // inline comment\n      let endIndex = string.indexOf('\\n', index);\n      index = endIndex === -1 ? string.length : endIndex;\n    } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n      // block comment\n      let endIndex = string.indexOf('*/', index);\n      if (endIndex !== -1) {\n        index = endIndex + 2;\n        endBlockComment = string.indexOf('*/', index);\n      } else {\n        stripped += string[index];\n        index++;\n      }\n    } else {\n      stripped += string[index];\n      index++;\n    }\n  }\n  return stripped;\n}\nfunction parseParams(func) {\n  const src = stripComments(func.toString());\n  let match = src.match(FN_ARGS);\n  if (!match) {\n    match = src.match(ARROW_FN_ARGS);\n  }\n  if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n  let [, args] = match;\n  return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n  var newTasks = {};\n  Object.keys(tasks).forEach(key => {\n    var taskFn = tasks[key];\n    var params;\n    var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);\n    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n    if (Array.isArray(taskFn)) {\n      params = [...taskFn];\n      taskFn = params.pop();\n      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n    } else if (hasNoDeps) {\n      // no dependencies, use the function as-is\n      newTasks[key] = taskFn;\n    } else {\n      params = parseParams(taskFn);\n      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n        throw new Error(\"autoInject task functions require explicit parameters.\");\n      }\n\n      // remove callback param\n      if (!fnIsAsync) params.pop();\n      newTasks[key] = params.concat(newTask);\n    }\n    function newTask(results, taskCb) {\n      var newArgs = params.map(name => results[name]);\n      newArgs.push(taskCb);\n      (0, _wrapAsync2.default)(taskFn)(...newArgs);\n    }\n  });\n  return (0, _auto2.default)(newTasks, callback);\n}\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","autoInject","_auto","require","_auto2","_interopRequireDefault","_wrapAsync","_wrapAsync2","obj","__esModule","FN_ARGS","ARROW_FN_ARGS","FN_ARG_SPLIT","FN_ARG","stripComments","string","stripped","index","endBlockComment","indexOf","length","endIndex","parseParams","func","src","toString","match","Error","args","replace","split","map","arg","trim","tasks","callback","newTasks","keys","forEach","key","taskFn","params","fnIsAsync","isAsync","hasNoDeps","Array","isArray","pop","concat","newTask","results","taskCb","newArgs","name","push","module"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/async/autoInject.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = autoInject;\n\nvar _auto = require('./auto.js');\n\nvar _auto2 = _interopRequireDefault(_auto);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\n\nfunction stripComments(string) {\n    let stripped = '';\n    let index = 0;\n    let endBlockComment = string.indexOf('*/');\n    while (index < string.length) {\n        if (string[index] === '/' && string[index + 1] === '/') {\n            // inline comment\n            let endIndex = string.indexOf('\\n', index);\n            index = endIndex === -1 ? string.length : endIndex;\n        } else if (endBlockComment !== -1 && string[index] === '/' && string[index + 1] === '*') {\n            // block comment\n            let endIndex = string.indexOf('*/', index);\n            if (endIndex !== -1) {\n                index = endIndex + 2;\n                endBlockComment = string.indexOf('*/', index);\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        } else {\n            stripped += string[index];\n            index++;\n        }\n    }\n    return stripped;\n}\n\nfunction parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src);\n    let [, args] = match;\n    return args.replace(/\\s/g, '').split(FN_ARG_SPLIT).map(arg => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    Object.keys(tasks).forEach(key => {\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (Array.isArray(taskFn)) {\n            params = [...taskFn];\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = params.map(name => results[name]);\n            newArgs.push(taskCb);\n            (0, _wrapAsync2.default)(taskFn)(...newArgs);\n        }\n    });\n\n    return (0, _auto2.default)(newTasks, callback);\n}\nmodule.exports = exports.default;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,UAAU;AAE5B,IAAIC,KAAK,GAAGC,OAAO,CAAC,WAAW,CAAC;AAEhC,IAAIC,MAAM,GAAGC,sBAAsB,CAACH,KAAK,CAAC;AAE1C,IAAII,UAAU,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAEnD,IAAII,WAAW,GAAGF,sBAAsB,CAACC,UAAU,CAAC;AAEpD,SAASD,sBAAsBA,CAACG,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAER,OAAO,EAAEQ;EAAI,CAAC;AAAE;AAE9F,IAAIE,OAAO,GAAG,+DAA+D;AAC7E,IAAIC,aAAa,GAAG,6CAA6C;AACjE,IAAIC,YAAY,GAAG,GAAG;AACtB,IAAIC,MAAM,GAAG,cAAc;AAE3B,SAASC,aAAaA,CAACC,MAAM,EAAE;EAC3B,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,eAAe,GAAGH,MAAM,CAACI,OAAO,CAAC,IAAI,CAAC;EAC1C,OAAOF,KAAK,GAAGF,MAAM,CAACK,MAAM,EAAE;IAC1B,IAAIL,MAAM,CAACE,KAAK,CAAC,KAAK,GAAG,IAAIF,MAAM,CAACE,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MACpD;MACA,IAAII,QAAQ,GAAGN,MAAM,CAACI,OAAO,CAAC,IAAI,EAAEF,KAAK,CAAC;MAC1CA,KAAK,GAAGI,QAAQ,KAAK,CAAC,CAAC,GAAGN,MAAM,CAACK,MAAM,GAAGC,QAAQ;IACtD,CAAC,MAAM,IAAIH,eAAe,KAAK,CAAC,CAAC,IAAIH,MAAM,CAACE,KAAK,CAAC,KAAK,GAAG,IAAIF,MAAM,CAACE,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MACrF;MACA,IAAII,QAAQ,GAAGN,MAAM,CAACI,OAAO,CAAC,IAAI,EAAEF,KAAK,CAAC;MAC1C,IAAII,QAAQ,KAAK,CAAC,CAAC,EAAE;QACjBJ,KAAK,GAAGI,QAAQ,GAAG,CAAC;QACpBH,eAAe,GAAGH,MAAM,CAACI,OAAO,CAAC,IAAI,EAAEF,KAAK,CAAC;MACjD,CAAC,MAAM;QACHD,QAAQ,IAAID,MAAM,CAACE,KAAK,CAAC;QACzBA,KAAK,EAAE;MACX;IACJ,CAAC,MAAM;MACHD,QAAQ,IAAID,MAAM,CAACE,KAAK,CAAC;MACzBA,KAAK,EAAE;IACX;EACJ;EACA,OAAOD,QAAQ;AACnB;AAEA,SAASM,WAAWA,CAACC,IAAI,EAAE;EACvB,MAAMC,GAAG,GAAGV,aAAa,CAACS,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;EAC1C,IAAIC,KAAK,GAAGF,GAAG,CAACE,KAAK,CAAChB,OAAO,CAAC;EAC9B,IAAI,CAACgB,KAAK,EAAE;IACRA,KAAK,GAAGF,GAAG,CAACE,KAAK,CAACf,aAAa,CAAC;EACpC;EACA,IAAI,CAACe,KAAK,EAAE,MAAM,IAAIC,KAAK,CAAC,+CAA+C,GAAGH,GAAG,CAAC;EAClF,IAAI,GAAGI,IAAI,CAAC,GAAGF,KAAK;EACpB,OAAOE,IAAI,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,KAAK,CAAClB,YAAY,CAAC,CAACmB,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACH,OAAO,CAAChB,MAAM,EAAE,EAAE,CAAC,CAACoB,IAAI,CAAC,CAAC,CAAC;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShC,UAAUA,CAACiC,KAAK,EAAEC,QAAQ,EAAE;EACjC,IAAIC,QAAQ,GAAG,CAAC,CAAC;EAEjBxC,MAAM,CAACyC,IAAI,CAACH,KAAK,CAAC,CAACI,OAAO,CAACC,GAAG,IAAI;IAC9B,IAAIC,MAAM,GAAGN,KAAK,CAACK,GAAG,CAAC;IACvB,IAAIE,MAAM;IACV,IAAIC,SAAS,GAAG,CAAC,CAAC,EAAEpC,UAAU,CAACqC,OAAO,EAAEH,MAAM,CAAC;IAC/C,IAAII,SAAS,GAAG,CAACF,SAAS,IAAIF,MAAM,CAACpB,MAAM,KAAK,CAAC,IAAIsB,SAAS,IAAIF,MAAM,CAACpB,MAAM,KAAK,CAAC;IAErF,IAAIyB,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,EAAE;MACvBC,MAAM,GAAG,CAAC,GAAGD,MAAM,CAAC;MACpBA,MAAM,GAAGC,MAAM,CAACM,GAAG,CAAC,CAAC;MAErBX,QAAQ,CAACG,GAAG,CAAC,GAAGE,MAAM,CAACO,MAAM,CAACP,MAAM,CAACrB,MAAM,GAAG,CAAC,GAAG6B,OAAO,GAAGT,MAAM,CAAC;IACvE,CAAC,MAAM,IAAII,SAAS,EAAE;MAClB;MACAR,QAAQ,CAACG,GAAG,CAAC,GAAGC,MAAM;IAC1B,CAAC,MAAM;MACHC,MAAM,GAAGnB,WAAW,CAACkB,MAAM,CAAC;MAC5B,IAAIA,MAAM,CAACpB,MAAM,KAAK,CAAC,IAAI,CAACsB,SAAS,IAAID,MAAM,CAACrB,MAAM,KAAK,CAAC,EAAE;QAC1D,MAAM,IAAIO,KAAK,CAAC,wDAAwD,CAAC;MAC7E;;MAEA;MACA,IAAI,CAACe,SAAS,EAAED,MAAM,CAACM,GAAG,CAAC,CAAC;MAE5BX,QAAQ,CAACG,GAAG,CAAC,GAAGE,MAAM,CAACO,MAAM,CAACC,OAAO,CAAC;IAC1C;IAEA,SAASA,OAAOA,CAACC,OAAO,EAAEC,MAAM,EAAE;MAC9B,IAAIC,OAAO,GAAGX,MAAM,CAACV,GAAG,CAACsB,IAAI,IAAIH,OAAO,CAACG,IAAI,CAAC,CAAC;MAC/CD,OAAO,CAACE,IAAI,CAACH,MAAM,CAAC;MACpB,CAAC,CAAC,EAAE5C,WAAW,CAACP,OAAO,EAAEwC,MAAM,CAAC,CAAC,GAAGY,OAAO,CAAC;IAChD;EACJ,CAAC,CAAC;EAEF,OAAO,CAAC,CAAC,EAAEhD,MAAM,CAACJ,OAAO,EAAEoC,QAAQ,EAAED,QAAQ,CAAC;AAClD;AACAoB,MAAM,CAACzD,OAAO,GAAGA,OAAO,CAACE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}