{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst tsutils_1 = require(\"tsutils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst getOperatorPrecedence_1 = require(\"../util/getOperatorPrecedence\");\nexports.default = util.createRule({\n  name: 'return-await',\n  meta: {\n    docs: {\n      description: 'Enforce consistent returning of awaited values',\n      recommended: false,\n      requiresTypeChecking: true,\n      extendsBaseRule: 'no-return-await'\n    },\n    fixable: 'code',\n    hasSuggestions: true,\n    type: 'problem',\n    messages: {\n      nonPromiseAwait: 'Returning an awaited value that is not a promise is not allowed.',\n      disallowedPromiseAwait: 'Returning an awaited promise is not allowed in this context.',\n      requiredPromiseAwait: 'Returning an awaited promise is required in this context.'\n    },\n    schema: [{\n      enum: ['in-try-catch', 'always', 'never']\n    }]\n  },\n  defaultOptions: ['in-try-catch'],\n  create(context, [option]) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    const scopeInfoStack = [];\n    function enterFunction(node) {\n      scopeInfoStack.push({\n        hasAsync: node.async,\n        owningFunc: node\n      });\n    }\n    function exitFunction() {\n      scopeInfoStack.pop();\n    }\n    function inTry(node) {\n      let ancestor = node.parent;\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor)) {\n          return true;\n        }\n        ancestor = ancestor.parent;\n      }\n      return false;\n    }\n    function inCatch(node) {\n      let ancestor = node.parent;\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isCatchClause(ancestor)) {\n          return true;\n        }\n        ancestor = ancestor.parent;\n      }\n      return false;\n    }\n    function isReturnPromiseInFinally(node) {\n      let ancestor = node.parent;\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor.parent) && ts.isBlock(ancestor) && ancestor.parent.end === ancestor.end) {\n          return true;\n        }\n        ancestor = ancestor.parent;\n      }\n      return false;\n    }\n    function hasFinallyBlock(node) {\n      let ancestor = node.parent;\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor)) {\n          return !!ancestor.finallyBlock;\n        }\n        ancestor = ancestor.parent;\n      }\n      return false;\n    }\n    // function findTokensToRemove()\n    function removeAwait(fixer, node) {\n      // Should always be an await node; but let's be safe.\n      /* istanbul ignore if */\n      if (!util.isAwaitExpression(node)) {\n        return null;\n      }\n      const awaitToken = sourceCode.getFirstToken(node, util.isAwaitKeyword);\n      // Should always be the case; but let's be safe.\n      /* istanbul ignore if */\n      if (!awaitToken) {\n        return null;\n      }\n      const startAt = awaitToken.range[0];\n      let endAt = awaitToken.range[1];\n      // Also remove any extraneous whitespace after `await`, if there is any.\n      const nextToken = sourceCode.getTokenAfter(awaitToken, {\n        includeComments: true\n      });\n      if (nextToken) {\n        endAt = nextToken.range[0];\n      }\n      return fixer.removeRange([startAt, endAt]);\n    }\n    function insertAwait(fixer, node, isHighPrecendence) {\n      if (isHighPrecendence) {\n        return fixer.insertTextBefore(node, 'await ');\n      } else {\n        return [fixer.insertTextBefore(node, 'await ('), fixer.insertTextAfter(node, ')')];\n      }\n    }\n    function isHigherPrecedenceThanAwait(node) {\n      const operator = (0, tsutils_1.isBinaryExpression)(node) ? node.operatorToken.kind : ts.SyntaxKind.Unknown;\n      const nodePrecedence = (0, getOperatorPrecedence_1.getOperatorPrecedence)(node.kind, operator);\n      const awaitPrecedence = (0, getOperatorPrecedence_1.getOperatorPrecedence)(ts.SyntaxKind.AwaitExpression, ts.SyntaxKind.Unknown);\n      return nodePrecedence > awaitPrecedence;\n    }\n    function test(node, expression) {\n      let child;\n      const isAwait = ts.isAwaitExpression(expression);\n      if (isAwait) {\n        child = expression.getChildAt(1);\n      } else {\n        child = expression;\n      }\n      const type = checker.getTypeAtLocation(child);\n      const isThenable = tsutils.isThenableType(checker, expression, type);\n      if (!isAwait && !isThenable) {\n        return;\n      }\n      if (isAwait && !isThenable) {\n        // any/unknown could be thenable; do not auto-fix\n        const useAutoFix = !(util.isTypeAnyType(type) || util.isTypeUnknownType(type));\n        const fix = fixer => removeAwait(fixer, node);\n        context.report(Object.assign({\n          messageId: 'nonPromiseAwait',\n          node\n        }, useAutoFix ? {\n          fix\n        } : {\n          suggest: [{\n            messageId: 'nonPromiseAwait',\n            fix\n          }]\n        }));\n        return;\n      }\n      if (option === 'always') {\n        if (!isAwait && isThenable) {\n          context.report({\n            messageId: 'requiredPromiseAwait',\n            node,\n            fix: fixer => insertAwait(fixer, node, isHigherPrecedenceThanAwait(expression))\n          });\n        }\n        return;\n      }\n      if (option === 'never') {\n        if (isAwait) {\n          context.report({\n            messageId: 'disallowedPromiseAwait',\n            node,\n            fix: fixer => removeAwait(fixer, node)\n          });\n        }\n        return;\n      }\n      if (option === 'in-try-catch') {\n        const isInTryCatch = inTry(expression) || inCatch(expression);\n        if (isAwait && !isInTryCatch) {\n          context.report({\n            messageId: 'disallowedPromiseAwait',\n            node,\n            fix: fixer => removeAwait(fixer, node)\n          });\n        } else if (!isAwait && isInTryCatch) {\n          if (inCatch(expression) && !hasFinallyBlock(expression)) {\n            return;\n          }\n          if (isReturnPromiseInFinally(expression)) {\n            return;\n          }\n          context.report({\n            messageId: 'requiredPromiseAwait',\n            node,\n            fix: fixer => insertAwait(fixer, node, isHigherPrecedenceThanAwait(expression))\n          });\n        }\n        return;\n      }\n    }\n    function findPossiblyReturnedNodes(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        return [...findPossiblyReturnedNodes(node.alternate), ...findPossiblyReturnedNodes(node.consequent)];\n      }\n      return [node];\n    }\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction,\n      'FunctionDeclaration:exit': exitFunction,\n      'FunctionExpression:exit': exitFunction,\n      'ArrowFunctionExpression:exit': exitFunction,\n      // executes after less specific handler, so exitFunction is called\n      'ArrowFunctionExpression[async = true]:exit'(node) {\n        if (node.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n          findPossiblyReturnedNodes(node.body).forEach(node => {\n            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n            test(node, tsNode);\n          });\n        }\n      },\n      ReturnStatement(node) {\n        const scopeInfo = scopeInfoStack[scopeInfoStack.length - 1];\n        if (!(scopeInfo === null || scopeInfo === void 0 ? void 0 : scopeInfo.hasAsync) || !node.argument) {\n          return;\n        }\n        findPossiblyReturnedNodes(node.argument).forEach(node => {\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n          test(node, tsNode);\n        });\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","tsutils_1","ts","util","getOperatorPrecedence_1","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","extendsBaseRule","fixable","hasSuggestions","type","messages","nonPromiseAwait","disallowedPromiseAwait","requiredPromiseAwait","schema","enum","defaultOptions","create","context","option","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","scopeInfoStack","enterFunction","node","push","hasAsync","async","owningFunc","exitFunction","pop","inTry","ancestor","parent","isFunctionLike","isTryStatement","inCatch","isCatchClause","isReturnPromiseInFinally","isBlock","end","hasFinallyBlock","finallyBlock","removeAwait","fixer","isAwaitExpression","awaitToken","getFirstToken","isAwaitKeyword","startAt","range","endAt","nextToken","getTokenAfter","includeComments","removeRange","insertAwait","isHighPrecendence","insertTextBefore","insertTextAfter","isHigherPrecedenceThanAwait","operator","isBinaryExpression","operatorToken","kind","SyntaxKind","Unknown","nodePrecedence","getOperatorPrecedence","awaitPrecedence","AwaitExpression","test","expression","child","isAwait","getChildAt","getTypeAtLocation","isThenable","isThenableType","useAutoFix","isTypeAnyType","isTypeUnknownType","fix","report","Object","assign","messageId","suggest","isInTryCatch","findPossiblyReturnedNodes","AST_NODE_TYPES","ConditionalExpression","alternate","consequent","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ArrowFunctionExpression[async = true]:exit","body","BlockStatement","forEach","tsNode","esTreeNodeToTSNodeMap","get","ReturnStatement","scopeInfo","length","argument"],"sources":["../../src/rules/return-await.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}