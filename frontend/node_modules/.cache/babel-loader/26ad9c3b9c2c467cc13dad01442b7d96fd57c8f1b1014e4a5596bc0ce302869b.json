{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = auto;\nvar _once = require('./internal/once.js');\nvar _once2 = _interopRequireDefault(_once);\nvar _onlyOnce = require('./internal/onlyOnce.js');\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\nvar _wrapAsync = require('./internal/wrapAsync.js');\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\nvar _promiseCallback = require('./internal/promiseCallback.js');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n  if (typeof concurrency !== 'number') {\n    // concurrency is optional, shift the args.\n    callback = concurrency;\n    concurrency = null;\n  }\n  callback = (0, _once2.default)(callback || (0, _promiseCallback.promiseCallback)());\n  var numTasks = Object.keys(tasks).length;\n  if (!numTasks) {\n    return callback(null);\n  }\n  if (!concurrency) {\n    concurrency = numTasks;\n  }\n  var results = {};\n  var runningTasks = 0;\n  var canceled = false;\n  var hasError = false;\n  var listeners = Object.create(null);\n  var readyTasks = [];\n\n  // for cycle detection:\n  var readyToCheck = []; // tasks that have been identified as reachable\n  // without the possibility of returning to an ancestor task\n  var uncheckedDependencies = {};\n  Object.keys(tasks).forEach(key => {\n    var task = tasks[key];\n    if (!Array.isArray(task)) {\n      // no dependencies\n      enqueueTask(key, [task]);\n      readyToCheck.push(key);\n      return;\n    }\n    var dependencies = task.slice(0, task.length - 1);\n    var remainingDependencies = dependencies.length;\n    if (remainingDependencies === 0) {\n      enqueueTask(key, task);\n      readyToCheck.push(key);\n      return;\n    }\n    uncheckedDependencies[key] = remainingDependencies;\n    dependencies.forEach(dependencyName => {\n      if (!tasks[dependencyName]) {\n        throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n      }\n      addListener(dependencyName, () => {\n        remainingDependencies--;\n        if (remainingDependencies === 0) {\n          enqueueTask(key, task);\n        }\n      });\n    });\n  });\n  checkForDeadlocks();\n  processQueue();\n  function enqueueTask(key, task) {\n    readyTasks.push(() => runTask(key, task));\n  }\n  function processQueue() {\n    if (canceled) return;\n    if (readyTasks.length === 0 && runningTasks === 0) {\n      return callback(null, results);\n    }\n    while (readyTasks.length && runningTasks < concurrency) {\n      var run = readyTasks.shift();\n      run();\n    }\n  }\n  function addListener(taskName, fn) {\n    var taskListeners = listeners[taskName];\n    if (!taskListeners) {\n      taskListeners = listeners[taskName] = [];\n    }\n    taskListeners.push(fn);\n  }\n  function taskComplete(taskName) {\n    var taskListeners = listeners[taskName] || [];\n    taskListeners.forEach(fn => fn());\n    processQueue();\n  }\n  function runTask(key, task) {\n    if (hasError) return;\n    var taskCallback = (0, _onlyOnce2.default)((err, ...result) => {\n      runningTasks--;\n      if (err === false) {\n        canceled = true;\n        return;\n      }\n      if (result.length < 2) {\n        [result] = result;\n      }\n      if (err) {\n        var safeResults = {};\n        Object.keys(results).forEach(rkey => {\n          safeResults[rkey] = results[rkey];\n        });\n        safeResults[key] = result;\n        hasError = true;\n        listeners = Object.create(null);\n        if (canceled) return;\n        callback(err, safeResults);\n      } else {\n        results[key] = result;\n        taskComplete(key);\n      }\n    });\n    runningTasks++;\n    var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);\n    if (task.length > 1) {\n      taskFn(results, taskCallback);\n    } else {\n      taskFn(taskCallback);\n    }\n  }\n  function checkForDeadlocks() {\n    // Kahn's algorithm\n    // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n    // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n    var currentTask;\n    var counter = 0;\n    while (readyToCheck.length) {\n      currentTask = readyToCheck.pop();\n      counter++;\n      getDependents(currentTask).forEach(dependent => {\n        if (--uncheckedDependencies[dependent] === 0) {\n          readyToCheck.push(dependent);\n        }\n      });\n    }\n    if (counter !== numTasks) {\n      throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n    }\n  }\n  function getDependents(taskName) {\n    var result = [];\n    Object.keys(tasks).forEach(key => {\n      const task = tasks[key];\n      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n        result.push(key);\n      }\n    });\n    return result;\n  }\n  return callback[_promiseCallback.PROMISE_SYMBOL];\n}\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","auto","_once","require","_once2","_interopRequireDefault","_onlyOnce","_onlyOnce2","_wrapAsync","_wrapAsync2","_promiseCallback","obj","__esModule","tasks","concurrency","callback","promiseCallback","numTasks","keys","length","results","runningTasks","canceled","hasError","listeners","create","readyTasks","readyToCheck","uncheckedDependencies","forEach","key","task","Array","isArray","enqueueTask","push","dependencies","slice","remainingDependencies","dependencyName","Error","join","addListener","checkForDeadlocks","processQueue","runTask","run","shift","taskName","fn","taskListeners","taskComplete","taskCallback","err","result","safeResults","rkey","taskFn","currentTask","counter","pop","getDependents","dependent","indexOf","PROMISE_SYMBOL","module"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/async/auto.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = auto;\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = (0, _once2.default)(callback || (0, _promiseCallback.promiseCallback)());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    Object.keys(tasks).forEach(key => {\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        dependencies.forEach(dependencyName => {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, () => {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(() => runTask(key, task));\n    }\n\n    function processQueue() {\n        if (canceled) return;\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach(fn => fn());\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = (0, _onlyOnce2.default)((err, ...result) => {\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return;\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach(rkey => {\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return;\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach(dependent => {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach(key => {\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\nmodule.exports = exports.default;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,IAAI;AAEtB,IAAIC,KAAK,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAEzC,IAAIC,MAAM,GAAGC,sBAAsB,CAACH,KAAK,CAAC;AAE1C,IAAII,SAAS,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AAEjD,IAAII,UAAU,GAAGF,sBAAsB,CAACC,SAAS,CAAC;AAElD,IAAIE,UAAU,GAAGL,OAAO,CAAC,yBAAyB,CAAC;AAEnD,IAAIM,WAAW,GAAGJ,sBAAsB,CAACG,UAAU,CAAC;AAEpD,IAAIE,gBAAgB,GAAGP,OAAO,CAAC,+BAA+B,CAAC;AAE/D,SAASE,sBAAsBA,CAACM,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAEX,OAAO,EAAEW;EAAI,CAAC;AAAE;;AAE9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}