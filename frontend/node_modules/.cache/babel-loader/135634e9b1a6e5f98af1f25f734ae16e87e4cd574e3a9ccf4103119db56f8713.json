{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst literalToPrimitiveTypeFlags = {\n  [ts.TypeFlags.BigIntLiteral]: ts.TypeFlags.BigInt,\n  [ts.TypeFlags.BooleanLiteral]: ts.TypeFlags.Boolean,\n  [ts.TypeFlags.NumberLiteral]: ts.TypeFlags.Number,\n  [ts.TypeFlags.StringLiteral]: ts.TypeFlags.String,\n  [ts.TypeFlags.TemplateLiteral]: ts.TypeFlags.String\n};\nconst literalTypeFlags = [ts.TypeFlags.BigIntLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.NumberLiteral, ts.TypeFlags.StringLiteral, ts.TypeFlags.TemplateLiteral];\nconst primitiveTypeFlags = [ts.TypeFlags.BigInt, ts.TypeFlags.Boolean, ts.TypeFlags.Number, ts.TypeFlags.String];\nconst primitiveTypeFlagNames = {\n  [ts.TypeFlags.BigInt]: 'bigint',\n  [ts.TypeFlags.Boolean]: 'boolean',\n  [ts.TypeFlags.Number]: 'number',\n  [ts.TypeFlags.String]: 'string'\n};\nconst primitiveTypeFlagTypes = {\n  bigint: ts.TypeFlags.BigIntLiteral,\n  boolean: ts.TypeFlags.BooleanLiteral,\n  number: ts.TypeFlags.NumberLiteral,\n  string: ts.TypeFlags.StringLiteral\n};\nconst keywordNodeTypesToTsTypes = new Map([[utils_1.TSESTree.AST_NODE_TYPES.TSAnyKeyword, ts.TypeFlags.Any], [utils_1.TSESTree.AST_NODE_TYPES.TSBigIntKeyword, ts.TypeFlags.BigInt], [utils_1.TSESTree.AST_NODE_TYPES.TSBooleanKeyword, ts.TypeFlags.Boolean], [utils_1.TSESTree.AST_NODE_TYPES.TSNeverKeyword, ts.TypeFlags.Never], [utils_1.TSESTree.AST_NODE_TYPES.TSUnknownKeyword, ts.TypeFlags.Unknown], [utils_1.TSESTree.AST_NODE_TYPES.TSNumberKeyword, ts.TypeFlags.Number], [utils_1.TSESTree.AST_NODE_TYPES.TSStringKeyword, ts.TypeFlags.String]]);\nfunction addToMapGroup(map, key, value) {\n  const existing = map.get(key);\n  if (existing) {\n    existing.push(value);\n  } else {\n    map.set(key, [value]);\n  }\n}\nfunction describeLiteralType(type) {\n  if (type.isStringLiteral()) {\n    return JSON.stringify(type.value);\n  }\n  if (util.isTypeBigIntLiteralType(type)) {\n    return `${type.value.negative ? '-' : ''}${type.value.base10Value}n`;\n  }\n  if (type.isLiteral()) {\n    return type.value.toString();\n  }\n  if (util.isTypeAnyType(type)) {\n    return 'any';\n  }\n  if (util.isTypeNeverType(type)) {\n    return 'never';\n  }\n  if (util.isTypeUnknownType(type)) {\n    return 'unknown';\n  }\n  if (util.isTypeTemplateLiteralType(type)) {\n    return 'template literal type';\n  }\n  if (tsutils.isBooleanLiteralType(type, true)) {\n    return 'true';\n  }\n  if (tsutils.isBooleanLiteralType(type, false)) {\n    return 'false';\n  }\n  return 'literal type';\n}\nfunction describeLiteralTypeNode(typeNode) {\n  switch (typeNode.type) {\n    case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n      return 'any';\n    case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n      return 'boolean';\n    case utils_1.AST_NODE_TYPES.TSNeverKeyword:\n      return 'never';\n    case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n      return 'number';\n    case utils_1.AST_NODE_TYPES.TSStringKeyword:\n      return 'string';\n    case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n      return 'unknown';\n    case utils_1.AST_NODE_TYPES.TSLiteralType:\n      switch (typeNode.literal.type) {\n        case utils_1.TSESTree.AST_NODE_TYPES.Literal:\n          switch (typeof typeNode.literal.value) {\n            case 'bigint':\n              return `${typeNode.literal.value < 0 ? '-' : ''}${typeNode.literal.value}n`;\n            case 'string':\n              return JSON.stringify(typeNode.literal.value);\n            default:\n              return `${typeNode.literal.value}`;\n          }\n        case utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral:\n          return 'template literal type';\n      }\n  }\n  return 'literal type';\n}\nfunction isNodeInsideReturnType(node) {\n  var _a;\n  return !!(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSTypeAnnotation && node.parent.parent && (util.isFunctionType(node.parent.parent) || util.isFunction(node.parent.parent)));\n}\n/**\n * @remarks TypeScript stores boolean types as the union false | true, always.\n */\nfunction unionTypePartsUnlessBoolean(type) {\n  return type.isUnion() && type.types.length === 2 && tsutils.isBooleanLiteralType(type.types[0], false) && tsutils.isBooleanLiteralType(type.types[1], true) ? [type] : tsutils.unionTypeParts(type);\n}\nexports.default = util.createRule({\n  name: 'no-redundant-type-constituents',\n  meta: {\n    docs: {\n      description: 'Disallow members of unions and intersections that do nothing or override type information',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      literalOverridden: `{{literal}} is overridden by {{primitive}} in this union type.`,\n      primitiveOverridden: `{{primitive}} is overridden by the {{literal}} in this intersection type.`,\n      overridden: `'{{typeName}}' is overridden by other types in this {{container}} type.`,\n      overrides: `'{{typeName}}' overrides all other types in this {{container}} type.`\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const typesCache = new Map();\n    function getTypeNodeTypePartFlags(typeNode) {\n      const keywordTypeFlags = keywordNodeTypesToTsTypes.get(typeNode.type);\n      if (keywordTypeFlags) {\n        return [{\n          typeFlags: keywordTypeFlags,\n          typeName: describeLiteralTypeNode(typeNode)\n        }];\n      }\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSLiteralType && typeNode.literal.type === utils_1.AST_NODE_TYPES.Literal) {\n        return [{\n          typeFlags: primitiveTypeFlagTypes[typeof typeNode.literal.value],\n          typeName: describeLiteralTypeNode(typeNode)\n        }];\n      }\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n        return typeNode.types.flatMap(getTypeNodeTypePartFlags);\n      }\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(typeNode);\n      const checker = parserServices.program.getTypeChecker();\n      const nodeType = checker.getTypeAtLocation(tsNode);\n      const typeParts = unionTypePartsUnlessBoolean(nodeType);\n      return typeParts.map(typePart => ({\n        typeFlags: typePart.flags,\n        typeName: describeLiteralType(typePart)\n      }));\n    }\n    function getTypeNodeTypePartFlagsCached(typeNode) {\n      const existing = typesCache.get(typeNode);\n      if (existing) {\n        return existing;\n      }\n      const created = getTypeNodeTypePartFlags(typeNode);\n      typesCache.set(typeNode, created);\n      return created;\n    }\n    return {\n      'TSIntersectionType:exit'(node) {\n        const seenLiteralTypes = new Map();\n        const seenPrimitiveTypes = new Map();\n        function checkIntersectionBottomAndTopTypes({\n          typeFlags,\n          typeName\n        }, typeNode) {\n          for (const [messageId, checkFlag] of [['overrides', ts.TypeFlags.Any], ['overrides', ts.TypeFlags.Never], ['overridden', ts.TypeFlags.Unknown]]) {\n            if (typeFlags === checkFlag) {\n              context.report({\n                data: {\n                  container: 'intersection',\n                  typeName\n                },\n                messageId,\n                node: typeNode\n              });\n              return true;\n            }\n          }\n          return false;\n        }\n        for (const typeNode of node.types) {\n          const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);\n          for (const typePart of typePartFlags) {\n            if (checkIntersectionBottomAndTopTypes(typePart, typeNode)) {\n              continue;\n            }\n            for (const literalTypeFlag of literalTypeFlags) {\n              if (typePart.typeFlags === literalTypeFlag) {\n                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], typePart.typeName);\n                break;\n              }\n            }\n            for (const primitiveTypeFlag of primitiveTypeFlags) {\n              if (typePart.typeFlags === primitiveTypeFlag) {\n                addToMapGroup(seenPrimitiveTypes, primitiveTypeFlag, typeNode);\n              }\n            }\n          }\n        }\n        // For each primitive type of all the seen primitive types,\n        // if there was a literal type seen that overrides it,\n        // report each of the primitive type's type nodes\n        for (const [primitiveTypeFlag, typeNodes] of seenPrimitiveTypes) {\n          const matchedLiteralTypes = seenLiteralTypes.get(primitiveTypeFlag);\n          if (matchedLiteralTypes) {\n            for (const typeNode of typeNodes) {\n              context.report({\n                data: {\n                  literal: matchedLiteralTypes.join(' | '),\n                  primitive: primitiveTypeFlagNames[primitiveTypeFlag]\n                },\n                messageId: 'primitiveOverridden',\n                node: typeNode\n              });\n            }\n          }\n        }\n      },\n      'TSUnionType:exit'(node) {\n        const seenLiteralTypes = new Map();\n        const seenPrimitiveTypes = new Set();\n        function checkUnionBottomAndTopTypes({\n          typeFlags,\n          typeName\n        }, typeNode) {\n          for (const checkFlag of [ts.TypeFlags.Any, ts.TypeFlags.Unknown]) {\n            if (typeFlags === checkFlag) {\n              context.report({\n                data: {\n                  container: 'union',\n                  typeName\n                },\n                messageId: 'overrides',\n                node: typeNode\n              });\n              return true;\n            }\n          }\n          if (typeFlags === ts.TypeFlags.Never && !isNodeInsideReturnType(node)) {\n            context.report({\n              data: {\n                container: 'union',\n                typeName: 'never'\n              },\n              messageId: 'overridden',\n              node: typeNode\n            });\n            return true;\n          }\n          return false;\n        }\n        for (const typeNode of node.types) {\n          const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);\n          for (const typePart of typePartFlags) {\n            if (checkUnionBottomAndTopTypes(typePart, typeNode)) {\n              continue;\n            }\n            for (const literalTypeFlag of literalTypeFlags) {\n              if (typePart.typeFlags === literalTypeFlag) {\n                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], {\n                  literalValue: typePart.typeName,\n                  typeNode\n                });\n                break;\n              }\n            }\n            for (const primitiveTypeFlag of primitiveTypeFlags) {\n              if ((typePart.typeFlags & primitiveTypeFlag) !== 0) {\n                seenPrimitiveTypes.add(primitiveTypeFlag);\n              }\n            }\n          }\n        }\n        const overriddenTypeNodes = new Map();\n        // For each primitive type of all the seen literal types,\n        // if there was a primitive type seen that overrides it,\n        // upsert the literal text and primitive type under the backing type node\n        for (const [primitiveTypeFlag, typeNodesWithText] of seenLiteralTypes) {\n          if (seenPrimitiveTypes.has(primitiveTypeFlag)) {\n            for (const {\n              literalValue,\n              typeNode\n            } of typeNodesWithText) {\n              addToMapGroup(overriddenTypeNodes, typeNode, {\n                literalValue,\n                primitiveTypeFlag\n              });\n            }\n          }\n        }\n        // For each type node that had at least one overridden literal,\n        // group those literals by their primitive type,\n        // then report each primitive type with all its literals\n        for (const [typeNode, typeFlagsWithText] of overriddenTypeNodes) {\n          const grouped = util.arrayGroupByToMap(typeFlagsWithText, pair => pair.primitiveTypeFlag);\n          for (const [primitiveTypeFlag, pairs] of grouped) {\n            context.report({\n              data: {\n                literal: pairs.map(pair => pair.literalValue).join(' | '),\n                primitive: primitiveTypeFlagNames[primitiveTypeFlag]\n              },\n              messageId: 'literalOverridden',\n              node: typeNode\n            });\n          }\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","literalToPrimitiveTypeFlags","TypeFlags","BigIntLiteral","BigInt","BooleanLiteral","Boolean","NumberLiteral","Number","StringLiteral","String","TemplateLiteral","literalTypeFlags","primitiveTypeFlags","primitiveTypeFlagNames","primitiveTypeFlagTypes","bigint","boolean","number","string","keywordNodeTypesToTsTypes","Map","TSESTree","AST_NODE_TYPES","TSAnyKeyword","Any","TSBigIntKeyword","TSBooleanKeyword","TSNeverKeyword","Never","TSUnknownKeyword","Unknown","TSNumberKeyword","TSStringKeyword","addToMapGroup","map","key","value","existing","get","push","set","describeLiteralType","type","isStringLiteral","JSON","stringify","isTypeBigIntLiteralType","negative","base10Value","isLiteral","toString","isTypeAnyType","isTypeNeverType","isTypeUnknownType","isTypeTemplateLiteralType","isBooleanLiteralType","describeLiteralTypeNode","typeNode","TSLiteralType","literal","Literal","isNodeInsideReturnType","node","_a","parent","TSTypeAnnotation","isFunctionType","isFunction","unionTypePartsUnlessBoolean","isUnion","types","length","unionTypeParts","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","literalOverridden","primitiveOverridden","overridden","overrides","schema","defaultOptions","create","context","parserServices","getParserServices","typesCache","getTypeNodeTypePartFlags","keywordTypeFlags","typeFlags","typeName","TSUnionType","flatMap","tsNode","esTreeNodeToTSNodeMap","checker","program","getTypeChecker","nodeType","getTypeAtLocation","typeParts","typePart","flags","getTypeNodeTypePartFlagsCached","created","TSIntersectionType:exit","seenLiteralTypes","seenPrimitiveTypes","checkIntersectionBottomAndTopTypes","messageId","checkFlag","report","data","container","typePartFlags","literalTypeFlag","primitiveTypeFlag","typeNodes","matchedLiteralTypes","join","primitive","TSUnionType:exit","Set","checkUnionBottomAndTopTypes","literalValue","add","overriddenTypeNodes","typeNodesWithText","has","typeFlagsWithText","grouped","arrayGroupByToMap","pair","pairs"],"sources":["../../src/rules/no-redundant-type-constituents.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAC,YAAA,CAAAF,OAAA;AACA,MAAAG,EAAA,GAAAD,YAAA,CAAAF,OAAA;AAEA,MAAAI,IAAA,GAAAF,YAAA,CAAAF,OAAA;AAEA,MAAMK,2BAA2B,GAAG;EAClC,CAACF,EAAE,CAACG,SAAS,CAACC,aAAa,GAAGJ,EAAE,CAACG,SAAS,CAACE,MAAM;EACjD,CAACL,EAAE,CAACG,SAAS,CAACG,cAAc,GAAGN,EAAE,CAACG,SAAS,CAACI,OAAO;EACnD,CAACP,EAAE,CAACG,SAAS,CAACK,aAAa,GAAGR,EAAE,CAACG,SAAS,CAACM,MAAM;EACjD,CAACT,EAAE,CAACG,SAAS,CAACO,aAAa,GAAGV,EAAE,CAACG,SAAS,CAACQ,MAAM;EACjD,CAACX,EAAE,CAACG,SAAS,CAACS,eAAe,GAAGZ,EAAE,CAACG,SAAS,CAACQ;CACrC;AAEV,MAAME,gBAAgB,GAAG,CACvBb,EAAE,CAACG,SAAS,CAACC,aAAa,EAC1BJ,EAAE,CAACG,SAAS,CAACG,cAAc,EAC3BN,EAAE,CAACG,SAAS,CAACK,aAAa,EAC1BR,EAAE,CAACG,SAAS,CAACO,aAAa,EAC1BV,EAAE,CAACG,SAAS,CAACS,eAAe,CACpB;AAEV,MAAME,kBAAkB,GAAG,CACzBd,EAAE,CAACG,SAAS,CAACE,MAAM,EACnBL,EAAE,CAACG,SAAS,CAACI,OAAO,EACpBP,EAAE,CAACG,SAAS,CAACM,MAAM,EACnBT,EAAE,CAACG,SAAS,CAACQ,MAAM,CACX;AAEV,MAAMI,sBAAsB,GAAG;EAC7B,CAACf,EAAE,CAACG,SAAS,CAACE,MAAM,GAAG,QAAQ;EAC/B,CAACL,EAAE,CAACG,SAAS,CAACI,OAAO,GAAG,SAAS;EACjC,CAACP,EAAE,CAACG,SAAS,CAACM,MAAM,GAAG,QAAQ;EAC/B,CAACT,EAAE,CAACG,SAAS,CAACQ,MAAM,GAAG;CACf;AAEV,MAAMK,sBAAsB,GAAG;EAC7BC,MAAM,EAAEjB,EAAE,CAACG,SAAS,CAACC,aAAa;EAClCc,OAAO,EAAElB,EAAE,CAACG,SAAS,CAACG,cAAc;EACpCa,MAAM,EAAEnB,EAAE,CAACG,SAAS,CAACK,aAAa;EAClCY,MAAM,EAAEpB,EAAE,CAACG,SAAS,CAACO;CACb;AAEV,MAAMW,yBAAyB,GAAG,IAAIC,GAAG,CAAC,CACxC,CAAC1B,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACC,YAAY,EAAEzB,EAAE,CAACG,SAAS,CAACuB,GAAG,CAAC,EACxD,CAAC9B,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACG,eAAe,EAAE3B,EAAE,CAACG,SAAS,CAACE,MAAM,CAAC,EAC9D,CAACT,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACI,gBAAgB,EAAE5B,EAAE,CAACG,SAAS,CAACI,OAAO,CAAC,EAChE,CAACX,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACK,cAAc,EAAE7B,EAAE,CAACG,SAAS,CAAC2B,KAAK,CAAC,EAC5D,CAAClC,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACO,gBAAgB,EAAE/B,EAAE,CAACG,SAAS,CAAC6B,OAAO,CAAC,EAChE,CAACpC,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACS,eAAe,EAAEjC,EAAE,CAACG,SAAS,CAACM,MAAM,CAAC,EAC9D,CAACb,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACU,eAAe,EAAElC,EAAE,CAACG,SAAS,CAACQ,MAAM,CAAC,CAC/D,CAAC;AAcF,SAASwB,aAAaA,CACpBC,GAAsB,EACtBC,GAAQ,EACRC,KAAY;EAEZ,MAAMC,QAAQ,GAAGH,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;EAE7B,IAAIE,QAAQ,EAAE;IACZA,QAAQ,CAACE,IAAI,CAACH,KAAK,CAAC;GACrB,MAAM;IACLF,GAAG,CAACM,GAAG,CAACL,GAAG,EAAE,CAACC,KAAK,CAAC,CAAC;;AAEzB;AAEA,SAASK,mBAAmBA,CAACC,IAAa;EACxC,IAAIA,IAAI,CAACC,eAAe,EAAE,EAAE;IAC1B,OAAOC,IAAI,CAACC,SAAS,CAACH,IAAI,CAACN,KAAK,CAAC;;EAGnC,IAAIrC,IAAI,CAAC+C,uBAAuB,CAACJ,IAAI,CAAC,EAAE;IACtC,OAAO,GAAGA,IAAI,CAACN,KAAK,CAACW,QAAQ,GAAG,GAAG,GAAG,EAAE,GAAGL,IAAI,CAACN,KAAK,CAACY,WAAW,GAAG;;EAGtE,IAAIN,IAAI,CAACO,SAAS,EAAE,EAAE;IACpB,OAAOP,IAAI,CAACN,KAAK,CAACc,QAAQ,EAAE;;EAG9B,IAAInD,IAAI,CAACoD,aAAa,CAACT,IAAI,CAAC,EAAE;IAC5B,OAAO,KAAK;;EAGd,IAAI3C,IAAI,CAACqD,eAAe,CAACV,IAAI,CAAC,EAAE;IAC9B,OAAO,OAAO;;EAGhB,IAAI3C,IAAI,CAACsD,iBAAiB,CAACX,IAAI,CAAC,EAAE;IAChC,OAAO,SAAS;;EAGlB,IAAI3C,IAAI,CAACuD,yBAAyB,CAACZ,IAAI,CAAC,EAAE;IACxC,OAAO,uBAAuB;;EAGhC,IAAI9C,OAAO,CAAC2D,oBAAoB,CAACb,IAAI,EAAE,IAAI,CAAC,EAAE;IAC5C,OAAO,MAAM;;EAGf,IAAI9C,OAAO,CAAC2D,oBAAoB,CAACb,IAAI,EAAE,KAAK,CAAC,EAAE;IAC7C,OAAO,OAAO;;EAGhB,OAAO,cAAc;AACvB;AAEA,SAASc,uBAAuBA,CAACC,QAA2B;EAC1D,QAAQA,QAAQ,CAACf,IAAI;IACnB,KAAKhD,OAAA,CAAA4B,cAAc,CAACC,YAAY;MAC9B,OAAO,KAAK;IACd,KAAK7B,OAAA,CAAA4B,cAAc,CAACI,gBAAgB;MAClC,OAAO,SAAS;IAClB,KAAKhC,OAAA,CAAA4B,cAAc,CAACK,cAAc;MAChC,OAAO,OAAO;IAChB,KAAKjC,OAAA,CAAA4B,cAAc,CAACS,eAAe;MACjC,OAAO,QAAQ;IACjB,KAAKrC,OAAA,CAAA4B,cAAc,CAACU,eAAe;MACjC,OAAO,QAAQ;IACjB,KAAKtC,OAAA,CAAA4B,cAAc,CAACO,gBAAgB;MAClC,OAAO,SAAS;IAClB,KAAKnC,OAAA,CAAA4B,cAAc,CAACoC,aAAa;MAC/B,QAAQD,QAAQ,CAACE,OAAO,CAACjB,IAAI;QAC3B,KAAKhD,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACsC,OAAO;UAClC,QAAQ,OAAOH,QAAQ,CAACE,OAAO,CAACvB,KAAK;YACnC,KAAK,QAAQ;cACX,OAAO,GAAGqB,QAAQ,CAACE,OAAO,CAACvB,KAAK,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAC7CqB,QAAQ,CAACE,OAAO,CAACvB,KACnB,GAAG;YACL,KAAK,QAAQ;cACX,OAAOQ,IAAI,CAACC,SAAS,CAACY,QAAQ,CAACE,OAAO,CAACvB,KAAK,CAAC;YAC/C;cACE,OAAO,GAAGqB,QAAQ,CAACE,OAAO,CAACvB,KAAK,EAAE;;QAExC,KAAK1C,OAAA,CAAA2B,QAAQ,CAACC,cAAc,CAACZ,eAAe;UAC1C,OAAO,uBAAuB;;;EAItC,OAAO,cAAc;AACvB;AAEA,SAASmD,sBAAsBA,CAACC,IAA0B;;EACxD,OAAO,CAAC,EACN,EAAAC,EAAA,GAAAD,IAAI,CAACE,MAAM,cAAAD,EAAA,uBAAAA,EAAA,CAAErB,IAAI,MAAKhD,OAAA,CAAA4B,cAAc,CAAC2C,gBAAgB,IACrDH,IAAI,CAACE,MAAM,CAACA,MAAM,KACjBjE,IAAI,CAACmE,cAAc,CAACJ,IAAI,CAACE,MAAM,CAACA,MAAM,CAAC,IACtCjE,IAAI,CAACoE,UAAU,CAACL,IAAI,CAACE,MAAM,CAACA,MAAM,CAAC,CAAC,CACvC;AACH;AAEA;;;AAGA,SAASI,2BAA2BA,CAAC1B,IAAa;EAChD,OAAOA,IAAI,CAAC2B,OAAO,EAAE,IACnB3B,IAAI,CAAC4B,KAAK,CAACC,MAAM,KAAK,CAAC,IACvB3E,OAAO,CAAC2D,oBAAoB,CAACb,IAAI,CAAC4B,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,IAClD1E,OAAO,CAAC2D,oBAAoB,CAACb,IAAI,CAAC4B,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAC/C,CAAC5B,IAAI,CAAC,GACN9C,OAAO,CAAC4E,cAAc,CAAC9B,IAAI,CAAC;AAClC;AAEA+B,OAAA,CAAAC,OAAA,GAAe3E,IAAI,CAAC4E,UAAU,CAAC;EAC7BC,IAAI,EAAE,gCAAgC;EACtCC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EACT,2FAA2F;MAC7FC,WAAW,EAAE,KAAK;MAClBC,oBAAoB,EAAE;KACvB;IACDC,QAAQ,EAAE;MACRC,iBAAiB,EAAE,gEAAgE;MACnFC,mBAAmB,EAAE,2EAA2E;MAChGC,UAAU,EAAE,yEAAyE;MACrFC,SAAS,EAAE;KACZ;IACDC,MAAM,EAAE,EAAE;IACV7C,IAAI,EAAE;GACP;EACD8C,cAAc,EAAE,EAAE;EAClBC,MAAMA,CAACC,OAAO;IACZ,MAAMC,cAAc,GAAG5F,IAAI,CAAC6F,iBAAiB,CAACF,OAAO,CAAC;IACtD,MAAMG,UAAU,GAAG,IAAIzE,GAAG,EAA0C;IAEpE,SAAS0E,wBAAwBA,CAC/BrC,QAA2B;MAE3B,MAAMsC,gBAAgB,GAAG5E,yBAAyB,CAACmB,GAAG,CAACmB,QAAQ,CAACf,IAAI,CAAC;MACrE,IAAIqD,gBAAgB,EAAE;QACpB,OAAO,CACL;UACEC,SAAS,EAAED,gBAAgB;UAC3BE,QAAQ,EAAEzC,uBAAuB,CAACC,QAAQ;SAC3C,CACF;;MAGH,IACEA,QAAQ,CAACf,IAAI,KAAKhD,OAAA,CAAA4B,cAAc,CAACoC,aAAa,IAC9CD,QAAQ,CAACE,OAAO,CAACjB,IAAI,KAAKhD,OAAA,CAAA4B,cAAc,CAACsC,OAAO,EAChD;QACA,OAAO,CACL;UACEoC,SAAS,EACPlF,sBAAsB,CACpB,OAAO2C,QAAQ,CAACE,OAAO,CACpBvB,KAA4C,CAChD;UACH6D,QAAQ,EAAEzC,uBAAuB,CAACC,QAAQ;SAC3C,CACF;;MAGH,IAAIA,QAAQ,CAACf,IAAI,KAAKhD,OAAA,CAAA4B,cAAc,CAAC4E,WAAW,EAAE;QAChD,OAAOzC,QAAQ,CAACa,KAAK,CAAC6B,OAAO,CAACL,wBAAwB,CAAC;;MAGzD,MAAMM,MAAM,GAAGT,cAAc,CAACU,qBAAqB,CAAC/D,GAAG,CAACmB,QAAQ,CAAC;MACjE,MAAM6C,OAAO,GAAGX,cAAc,CAACY,OAAO,CAACC,cAAc,EAAE;MACvD,MAAMC,QAAQ,GAAGH,OAAO,CAACI,iBAAiB,CAACN,MAAM,CAAC;MAClD,MAAMO,SAAS,GAAGvC,2BAA2B,CAACqC,QAAQ,CAAC;MAEvD,OAAOE,SAAS,CAACzE,GAAG,CAAC0E,QAAQ,KAAK;QAChCZ,SAAS,EAAEY,QAAQ,CAACC,KAAK;QACzBZ,QAAQ,EAAExD,mBAAmB,CAACmE,QAAQ;OACvC,CAAC,CAAC;IACL;IAEA,SAASE,8BAA8BA,CACrCrD,QAA2B;MAE3B,MAAMpB,QAAQ,GAAGwD,UAAU,CAACvD,GAAG,CAACmB,QAAQ,CAAC;MACzC,IAAIpB,QAAQ,EAAE;QACZ,OAAOA,QAAQ;;MAGjB,MAAM0E,OAAO,GAAGjB,wBAAwB,CAACrC,QAAQ,CAAC;MAClDoC,UAAU,CAACrD,GAAG,CAACiB,QAAQ,EAAEsD,OAAO,CAAC;MACjC,OAAOA,OAAO;IAChB;IAEA,OAAO;MACL,yBAAyBC,CAAClD,IAAiC;QACzD,MAAMmD,gBAAgB,GAAG,IAAI7F,GAAG,EAA+B;QAC/D,MAAM8F,kBAAkB,GAAG,IAAI9F,GAAG,EAG/B;QAEH,SAAS+F,kCAAkCA,CACzC;UAAEnB,SAAS;UAAEC;QAAQ,CAAqB,EAC1CxC,QAA2B;UAE3B,KAAK,MAAM,CAAC2D,SAAS,EAAEC,SAAS,CAAC,IAAI,CACnC,CAAC,WAAW,EAAEvH,EAAE,CAACG,SAAS,CAACuB,GAAG,CAAC,EAC/B,CAAC,WAAW,EAAE1B,EAAE,CAACG,SAAS,CAAC2B,KAAK,CAAC,EACjC,CAAC,YAAY,EAAE9B,EAAE,CAACG,SAAS,CAAC6B,OAAO,CAAC,CAC5B,EAAE;YACV,IAAIkE,SAAS,KAAKqB,SAAS,EAAE;cAC3B3B,OAAO,CAAC4B,MAAM,CAAC;gBACbC,IAAI,EAAE;kBACJC,SAAS,EAAE,cAAc;kBACzBvB;iBACD;gBACDmB,SAAS;gBACTtD,IAAI,EAAEL;eACP,CAAC;cACF,OAAO,IAAI;;;UAIf,OAAO,KAAK;QACd;QAEA,KAAK,MAAMA,QAAQ,IAAIK,IAAI,CAACQ,KAAK,EAAE;UACjC,MAAMmD,aAAa,GAAGX,8BAA8B,CAACrD,QAAQ,CAAC;UAE9D,KAAK,MAAMmD,QAAQ,IAAIa,aAAa,EAAE;YACpC,IAAIN,kCAAkC,CAACP,QAAQ,EAAEnD,QAAQ,CAAC,EAAE;cAC1D;;YAGF,KAAK,MAAMiE,eAAe,IAAI/G,gBAAgB,EAAE;cAC9C,IAAIiG,QAAQ,CAACZ,SAAS,KAAK0B,eAAe,EAAE;gBAC1CzF,aAAa,CACXgF,gBAAgB,EAChBjH,2BAA2B,CAAC0H,eAAe,CAAC,EAC5Cd,QAAQ,CAACX,QAAQ,CAClB;gBACD;;;YAIJ,KAAK,MAAM0B,iBAAiB,IAAI/G,kBAAkB,EAAE;cAClD,IAAIgG,QAAQ,CAACZ,SAAS,KAAK2B,iBAAiB,EAAE;gBAC5C1F,aAAa,CAACiF,kBAAkB,EAAES,iBAAiB,EAAElE,QAAQ,CAAC;;;;;QAMtE;QACA;QACA;QACA,KAAK,MAAM,CAACkE,iBAAiB,EAAEC,SAAS,CAAC,IAAIV,kBAAkB,EAAE;UAC/D,MAAMW,mBAAmB,GAAGZ,gBAAgB,CAAC3E,GAAG,CAACqF,iBAAiB,CAAC;UACnE,IAAIE,mBAAmB,EAAE;YACvB,KAAK,MAAMpE,QAAQ,IAAImE,SAAS,EAAE;cAChClC,OAAO,CAAC4B,MAAM,CAAC;gBACbC,IAAI,EAAE;kBACJ5D,OAAO,EAAEkE,mBAAmB,CAACC,IAAI,CAAC,KAAK,CAAC;kBACxCC,SAAS,EAAElH,sBAAsB,CAAC8G,iBAAiB;iBACpD;gBACDP,SAAS,EAAE,qBAAqB;gBAChCtD,IAAI,EAAEL;eACP,CAAC;;;;MAIV,CAAC;MACD,kBAAkBuE,CAAClE,IAA0B;QAC3C,MAAMmD,gBAAgB,GAAG,IAAI7F,GAAG,EAG7B;QACH,MAAM8F,kBAAkB,GAAG,IAAIe,GAAG,EAAqB;QAEvD,SAASC,2BAA2BA,CAClC;UAAElC,SAAS;UAAEC;QAAQ,CAAqB,EAC1CxC,QAA2B;UAE3B,KAAK,MAAM4D,SAAS,IAAI,CACtBvH,EAAE,CAACG,SAAS,CAACuB,GAAG,EAChB1B,EAAE,CAACG,SAAS,CAAC6B,OAAO,CACZ,EAAE;YACV,IAAIkE,SAAS,KAAKqB,SAAS,EAAE;cAC3B3B,OAAO,CAAC4B,MAAM,CAAC;gBACbC,IAAI,EAAE;kBACJC,SAAS,EAAE,OAAO;kBAClBvB;iBACD;gBACDmB,SAAS,EAAE,WAAW;gBACtBtD,IAAI,EAAEL;eACP,CAAC;cACF,OAAO,IAAI;;;UAIf,IACEuC,SAAS,KAAKlG,EAAE,CAACG,SAAS,CAAC2B,KAAK,IAChC,CAACiC,sBAAsB,CAACC,IAAI,CAAC,EAC7B;YACA4B,OAAO,CAAC4B,MAAM,CAAC;cACbC,IAAI,EAAE;gBACJC,SAAS,EAAE,OAAO;gBAClBvB,QAAQ,EAAE;eACX;cACDmB,SAAS,EAAE,YAAY;cACvBtD,IAAI,EAAEL;aACP,CAAC;YACF,OAAO,IAAI;;UAGb,OAAO,KAAK;QACd;QAEA,KAAK,MAAMA,QAAQ,IAAIK,IAAI,CAACQ,KAAK,EAAE;UACjC,MAAMmD,aAAa,GAAGX,8BAA8B,CAACrD,QAAQ,CAAC;UAE9D,KAAK,MAAMmD,QAAQ,IAAIa,aAAa,EAAE;YACpC,IAAIS,2BAA2B,CAACtB,QAAQ,EAAEnD,QAAQ,CAAC,EAAE;cACnD;;YAGF,KAAK,MAAMiE,eAAe,IAAI/G,gBAAgB,EAAE;cAC9C,IAAIiG,QAAQ,CAACZ,SAAS,KAAK0B,eAAe,EAAE;gBAC1CzF,aAAa,CACXgF,gBAAgB,EAChBjH,2BAA2B,CAAC0H,eAAe,CAAC,EAC5C;kBACES,YAAY,EAAEvB,QAAQ,CAACX,QAAQ;kBAC/BxC;iBACD,CACF;gBACD;;;YAIJ,KAAK,MAAMkE,iBAAiB,IAAI/G,kBAAkB,EAAE;cAClD,IAAI,CAACgG,QAAQ,CAACZ,SAAS,GAAG2B,iBAAiB,MAAM,CAAC,EAAE;gBAClDT,kBAAkB,CAACkB,GAAG,CAACT,iBAAiB,CAAC;;;;;QAWjD,MAAMU,mBAAmB,GAAG,IAAIjH,GAAG,EAGhC;QAEH;QACA;QACA;QACA,KAAK,MAAM,CAACuG,iBAAiB,EAAEW,iBAAiB,CAAC,IAAIrB,gBAAgB,EAAE;UACrE,IAAIC,kBAAkB,CAACqB,GAAG,CAACZ,iBAAiB,CAAC,EAAE;YAC7C,KAAK,MAAM;cAAEQ,YAAY;cAAE1E;YAAQ,CAAE,IAAI6E,iBAAiB,EAAE;cAC1DrG,aAAa,CAACoG,mBAAmB,EAAE5E,QAAQ,EAAE;gBAC3C0E,YAAY;gBACZR;eACD,CAAC;;;;QAKR;QACA;QACA;QACA,KAAK,MAAM,CAAClE,QAAQ,EAAE+E,iBAAiB,CAAC,IAAIH,mBAAmB,EAAE;UAC/D,MAAMI,OAAO,GAAG1I,IAAI,CAAC2I,iBAAiB,CACpCF,iBAAiB,EACjBG,IAAI,IAAIA,IAAI,CAAChB,iBAAiB,CAC/B;UAED,KAAK,MAAM,CAACA,iBAAiB,EAAEiB,KAAK,CAAC,IAAIH,OAAO,EAAE;YAChD/C,OAAO,CAAC4B,MAAM,CAAC;cACbC,IAAI,EAAE;gBACJ5D,OAAO,EAAEiF,KAAK,CAAC1G,GAAG,CAACyG,IAAI,IAAIA,IAAI,CAACR,YAAY,CAAC,CAACL,IAAI,CAAC,KAAK,CAAC;gBACzDC,SAAS,EAAElH,sBAAsB,CAAC8G,iBAAiB;eACpD;cACDP,SAAS,EAAE,mBAAmB;cAC9BtD,IAAI,EAAEL;aACP,CAAC;;;MAGR;KACD;EACH;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}