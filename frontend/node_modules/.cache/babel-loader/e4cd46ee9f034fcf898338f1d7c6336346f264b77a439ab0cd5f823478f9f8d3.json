{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nfunction isRemoved(path) {\n  if (path.removed) return true;\n  if (!path.parentPath) return false;\n  if (path.listKey) {\n    var _path$parentPath$node;\n    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;\n  } else {\n    if (path.parentPath.node[path.key] !== path.node) return true;\n  }\n  return isRemoved(path.parentPath);\n}\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n  function handleReferencedIdentifier(path) {\n    const {\n      node: {\n        name\n      },\n      scope\n    } = path;\n    if (scope.getBindingIdentifier(name)) return;\n    callProvider({\n      kind: \"global\",\n      name\n    }, path);\n  }\n  function analyzeMemberExpression(path) {\n    const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n    return {\n      key,\n      handleAsMemberExpression: !!key && key !== \"prototype\"\n    };\n  }\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        parentPath\n      } = path;\n      if (parentPath.isMemberExpression({\n        object: path.node\n      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {\n        return;\n      }\n      handleReferencedIdentifier(path);\n    },\n    MemberExpression(path) {\n      const {\n        key,\n        handleAsMemberExpression\n      } = analyzeMemberExpression(path);\n      if (!handleAsMemberExpression) return;\n      const object = path.get(\"object\");\n      let objectIsGlobalIdentifier = object.isIdentifier();\n      if (objectIsGlobalIdentifier) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding) {\n          if (binding.path.isImportNamespaceSpecifier()) return;\n          objectIsGlobalIdentifier = false;\n        }\n      }\n      const source = (0, _utils.resolveSource)(object);\n      let skipObject = property(source.id, key, source.placement, path);\n      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));\n      if (!skipObject) handleReferencedIdentifier(object);\n    },\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj;\n\n      // const { keys, values } = Object\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\");\n        // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\");\n        // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n  };\n};\nexports.default = _default;","map":{"version":3,"names":["exports","__esModule","default","_utils","require","isRemoved","path","removed","parentPath","listKey","_path$parentPath$node","node","includes","key","_default","callProvider","property","object","placement","kind","handleReferencedIdentifier","name","scope","getBindingIdentifier","analyzeMemberExpression","resolveKey","get","computed","handleAsMemberExpression","ReferencedIdentifier","isMemberExpression","MemberExpression","objectIsGlobalIdentifier","isIdentifier","binding","getBinding","isImportNamespaceSpecifier","source","resolveSource","skipObject","id","shouldSkip","ObjectPattern","parent","obj","isVariableDeclarator","isAssignmentExpression","isFunction","grand","isCallExpression","isNewExpression","callee","prop","isObjectProperty","BinaryExpression","operator"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/usage.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nfunction isRemoved(path) {\n  if (path.removed) return true;\n  if (!path.parentPath) return false;\n  if (path.listKey) {\n    var _path$parentPath$node;\n    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;\n  } else {\n    if (path.parentPath.node[path.key] !== path.node) return true;\n  }\n  return isRemoved(path.parentPath);\n}\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n  function handleReferencedIdentifier(path) {\n    const {\n      node: {\n        name\n      },\n      scope\n    } = path;\n    if (scope.getBindingIdentifier(name)) return;\n    callProvider({\n      kind: \"global\",\n      name\n    }, path);\n  }\n  function analyzeMemberExpression(path) {\n    const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n    return {\n      key,\n      handleAsMemberExpression: !!key && key !== \"prototype\"\n    };\n  }\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        parentPath\n      } = path;\n      if (parentPath.isMemberExpression({\n        object: path.node\n      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {\n        return;\n      }\n      handleReferencedIdentifier(path);\n    },\n    MemberExpression(path) {\n      const {\n        key,\n        handleAsMemberExpression\n      } = analyzeMemberExpression(path);\n      if (!handleAsMemberExpression) return;\n      const object = path.get(\"object\");\n      let objectIsGlobalIdentifier = object.isIdentifier();\n      if (objectIsGlobalIdentifier) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding) {\n          if (binding.path.isImportNamespaceSpecifier()) return;\n          objectIsGlobalIdentifier = false;\n        }\n      }\n      const source = (0, _utils.resolveSource)(object);\n      let skipObject = property(source.id, key, source.placement, path);\n      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));\n      if (!skipObject) handleReferencedIdentifier(object);\n    },\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj;\n\n      // const { keys, values } = Object\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\");\n        // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\");\n        // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n  };\n};\nexports.default = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}