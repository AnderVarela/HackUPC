{"ast":null,"code":"var definitions = {};\nfunction defineType(typeName, metadata) {\n  definitions[typeName] = metadata;\n}\ndefineType(\"Module\", {\n  spec: {\n    wasm: \"https://webassembly.github.io/spec/core/binary/modules.html#binary-module\",\n    wat: \"https://webassembly.github.io/spec/core/text/modules.html#text-module\"\n  },\n  doc: \"A module consists of a sequence of sections (termed fields in the text format).\",\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    fields: {\n      array: true,\n      type: \"Node\"\n    },\n    metadata: {\n      optional: true,\n      type: \"ModuleMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    sections: {\n      array: true,\n      type: \"SectionMetadata\"\n    },\n    functionNames: {\n      optional: true,\n      array: true,\n      type: \"FunctionNameMetadata\"\n    },\n    localNames: {\n      optional: true,\n      array: true,\n      type: \"ModuleMetadata\"\n    },\n    producers: {\n      optional: true,\n      array: true,\n      type: \"ProducersSectionMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FunctionNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    index: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"LocalNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    localIndex: {\n      type: \"number\"\n    },\n    functionIndex: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"BinaryModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    blob: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"QuoteModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    string: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"SectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    section: {\n      type: \"SectionName\"\n    },\n    startOffset: {\n      type: \"number\"\n    },\n    size: {\n      type: \"NumberLiteral\"\n    },\n    vectorOfSize: {\n      comment: \"Size of the vector in the section (if any)\",\n      type: \"NumberLiteral\"\n    }\n  }\n});\ndefineType(\"ProducersSectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    producers: {\n      array: true,\n      type: \"ProducerMetadata\"\n    }\n  }\n});\ndefineType(\"ProducerMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    language: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    processedBy: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    sdk: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    }\n  }\n});\ndefineType(\"ProducerMetadataVersionedName\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    version: {\n      type: \"string\"\n    }\n  }\n});\n/*\nInstructions\n*/\n\ndefineType(\"LoopInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"loop\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    resulttype: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\ndefineType(\"Instr\", {\n  unionType: [\"Node\", \"Expression\", \"Instruction\"],\n  fields: {\n    id: {\n      type: \"string\"\n    },\n    object: {\n      optional: true,\n      type: \"Valtype\"\n    },\n    args: {\n      array: true,\n      type: \"Expression\"\n    },\n    namedArgs: {\n      optional: true,\n      type: \"Object\"\n    }\n  }\n});\ndefineType(\"IfInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"if\"\n    },\n    testLabel: {\n      comment: \"only for WAST\",\n      type: \"Identifier\"\n    },\n    test: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    consequent: {\n      array: true,\n      type: \"Instruction\"\n    },\n    alternate: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\n/* \nConcrete value types\n*/\n\ndefineType(\"StringLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"NumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"LongNumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"LongNumber\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FloatLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    nan: {\n      optional: true,\n      type: \"boolean\"\n    },\n    inf: {\n      optional: true,\n      type: \"boolean\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Elem\", {\n  unionType: [\"Node\"],\n  fields: {\n    table: {\n      type: \"Index\"\n    },\n    offset: {\n      array: true,\n      type: \"Instruction\"\n    },\n    funcs: {\n      array: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"IndexInFuncSection\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ValtypeLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    name: {\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"TypeInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"Index\"\n    },\n    functype: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"Start\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"GlobalType\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    valtype: {\n      type: \"Valtype\"\n    },\n    mutability: {\n      type: \"Mutability\"\n    }\n  }\n});\ndefineType(\"LeadingComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Data\", {\n  unionType: [\"Node\"],\n  fields: {\n    memoryIndex: {\n      type: \"Memidx\"\n    },\n    offset: {\n      type: \"Instruction\"\n    },\n    init: {\n      type: \"ByteArray\"\n    }\n  }\n});\ndefineType(\"Global\", {\n  unionType: [\"Node\"],\n  fields: {\n    globalType: {\n      type: \"GlobalType\"\n    },\n    init: {\n      array: true,\n      type: \"Instruction\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    }\n  }\n});\ndefineType(\"Table\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    elementType: {\n      type: \"TableElementType\"\n    },\n    limits: {\n      assertNodeType: true,\n      type: \"Limit\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    elements: {\n      array: true,\n      optional: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"Memory\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    limits: {\n      type: \"Limit\"\n    },\n    id: {\n      maybe: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"FuncImportDescr\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    id: {\n      type: \"Identifier\"\n    },\n    signature: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"ModuleImport\", {\n  unionType: [\"Node\"],\n  fields: {\n    module: {\n      type: \"string\"\n    },\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ImportDescr\"\n    }\n  }\n});\ndefineType(\"ModuleExportDescr\", {\n  unionType: [\"Node\"],\n  fields: {\n    exportType: {\n      type: \"ExportDescrType\"\n    },\n    id: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ModuleExport\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ModuleExportDescr\"\n    }\n  }\n});\ndefineType(\"Limit\", {\n  unionType: [\"Node\"],\n  fields: {\n    min: {\n      type: \"number\"\n    },\n    max: {\n      optional: true,\n      type: \"number\"\n    },\n    // Threads proposal, shared memory\n    shared: {\n      optional: true,\n      type: \"boolean\"\n    }\n  }\n});\ndefineType(\"Signature\", {\n  unionType: [\"Node\"],\n  fields: {\n    params: {\n      array: true,\n      type: \"FuncParam\"\n    },\n    results: {\n      array: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"Program\", {\n  unionType: [\"Node\"],\n  fields: {\n    body: {\n      array: true,\n      type: \"Node\"\n    }\n  }\n});\ndefineType(\"Identifier\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    raw: {\n      optional: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"block\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"CallInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call\"\n    },\n    index: {\n      type: \"Index\"\n    },\n    instrArgs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    },\n    numeric: {\n      type: \"Index\",\n      optional: true\n    }\n  }\n});\ndefineType(\"CallIndirectInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call_indirect\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    intrs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    }\n  }\n});\ndefineType(\"ByteArray\", {\n  unionType: [\"Node\"],\n  fields: {\n    values: {\n      array: true,\n      type: \"Byte\"\n    }\n  }\n});\ndefineType(\"Func\", {\n  unionType: [\"Node\", \"Block\"],\n  fields: {\n    name: {\n      maybe: true,\n      type: \"Index\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    body: {\n      array: true,\n      type: \"Instruction\"\n    },\n    isExternal: {\n      comment: \"means that it has been imported from the outside js\",\n      optional: true,\n      type: \"boolean\"\n    },\n    metadata: {\n      optional: true,\n      type: \"FuncMetadata\"\n    }\n  }\n});\n/**\n * Intrinsics\n */\n\ndefineType(\"InternalBrUnless\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalGoto\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalCallExtern\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n}); // function bodies are terminated by an `end` instruction but are missing a\n// return instruction\n//\n// Since we can't inject a new instruction we are injecting a new instruction.\n\ndefineType(\"InternalEndAndReturn\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {}\n});\nmodule.exports = definitions;","map":{"version":3,"names":["definitions","defineType","typeName","metadata","spec","wasm","wat","doc","unionType","fields","id","maybe","type","array","optional","sections","functionNames","localNames","producers","value","index","localIndex","functionIndex","blob","string","section","startOffset","size","vectorOfSize","comment","language","processedBy","sdk","name","version","constant","label","resulttype","instr","object","args","namedArgs","testLabel","test","result","consequent","alternate","raw","nan","inf","table","offset","funcs","functype","valtype","mutability","memoryIndex","init","globalType","elementType","limits","assertNodeType","elements","signature","module","descr","exportType","min","max","shared","params","results","body","instrArgs","numeric","intrs","values","isExternal","target","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/esm/definitions.js"],"sourcesContent":["var definitions = {};\n\nfunction defineType(typeName, metadata) {\n  definitions[typeName] = metadata;\n}\n\ndefineType(\"Module\", {\n  spec: {\n    wasm: \"https://webassembly.github.io/spec/core/binary/modules.html#binary-module\",\n    wat: \"https://webassembly.github.io/spec/core/text/modules.html#text-module\"\n  },\n  doc: \"A module consists of a sequence of sections (termed fields in the text format).\",\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    fields: {\n      array: true,\n      type: \"Node\"\n    },\n    metadata: {\n      optional: true,\n      type: \"ModuleMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    sections: {\n      array: true,\n      type: \"SectionMetadata\"\n    },\n    functionNames: {\n      optional: true,\n      array: true,\n      type: \"FunctionNameMetadata\"\n    },\n    localNames: {\n      optional: true,\n      array: true,\n      type: \"ModuleMetadata\"\n    },\n    producers: {\n      optional: true,\n      array: true,\n      type: \"ProducersSectionMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FunctionNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    index: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"LocalNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    localIndex: {\n      type: \"number\"\n    },\n    functionIndex: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"BinaryModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    blob: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"QuoteModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    string: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"SectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    section: {\n      type: \"SectionName\"\n    },\n    startOffset: {\n      type: \"number\"\n    },\n    size: {\n      type: \"NumberLiteral\"\n    },\n    vectorOfSize: {\n      comment: \"Size of the vector in the section (if any)\",\n      type: \"NumberLiteral\"\n    }\n  }\n});\ndefineType(\"ProducersSectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    producers: {\n      array: true,\n      type: \"ProducerMetadata\"\n    }\n  }\n});\ndefineType(\"ProducerMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    language: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    processedBy: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    sdk: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    }\n  }\n});\ndefineType(\"ProducerMetadataVersionedName\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    version: {\n      type: \"string\"\n    }\n  }\n});\n/*\nInstructions\n*/\n\ndefineType(\"LoopInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"loop\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    resulttype: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\ndefineType(\"Instr\", {\n  unionType: [\"Node\", \"Expression\", \"Instruction\"],\n  fields: {\n    id: {\n      type: \"string\"\n    },\n    object: {\n      optional: true,\n      type: \"Valtype\"\n    },\n    args: {\n      array: true,\n      type: \"Expression\"\n    },\n    namedArgs: {\n      optional: true,\n      type: \"Object\"\n    }\n  }\n});\ndefineType(\"IfInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"if\"\n    },\n    testLabel: {\n      comment: \"only for WAST\",\n      type: \"Identifier\"\n    },\n    test: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    consequent: {\n      array: true,\n      type: \"Instruction\"\n    },\n    alternate: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\n/* \nConcrete value types\n*/\n\ndefineType(\"StringLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"NumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"LongNumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"LongNumber\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FloatLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    nan: {\n      optional: true,\n      type: \"boolean\"\n    },\n    inf: {\n      optional: true,\n      type: \"boolean\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Elem\", {\n  unionType: [\"Node\"],\n  fields: {\n    table: {\n      type: \"Index\"\n    },\n    offset: {\n      array: true,\n      type: \"Instruction\"\n    },\n    funcs: {\n      array: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"IndexInFuncSection\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ValtypeLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    name: {\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"TypeInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"Index\"\n    },\n    functype: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"Start\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"GlobalType\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    valtype: {\n      type: \"Valtype\"\n    },\n    mutability: {\n      type: \"Mutability\"\n    }\n  }\n});\ndefineType(\"LeadingComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Data\", {\n  unionType: [\"Node\"],\n  fields: {\n    memoryIndex: {\n      type: \"Memidx\"\n    },\n    offset: {\n      type: \"Instruction\"\n    },\n    init: {\n      type: \"ByteArray\"\n    }\n  }\n});\ndefineType(\"Global\", {\n  unionType: [\"Node\"],\n  fields: {\n    globalType: {\n      type: \"GlobalType\"\n    },\n    init: {\n      array: true,\n      type: \"Instruction\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    }\n  }\n});\ndefineType(\"Table\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    elementType: {\n      type: \"TableElementType\"\n    },\n    limits: {\n      assertNodeType: true,\n      type: \"Limit\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    elements: {\n      array: true,\n      optional: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"Memory\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    limits: {\n      type: \"Limit\"\n    },\n    id: {\n      maybe: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"FuncImportDescr\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    id: {\n      type: \"Identifier\"\n    },\n    signature: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"ModuleImport\", {\n  unionType: [\"Node\"],\n  fields: {\n    module: {\n      type: \"string\"\n    },\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ImportDescr\"\n    }\n  }\n});\ndefineType(\"ModuleExportDescr\", {\n  unionType: [\"Node\"],\n  fields: {\n    exportType: {\n      type: \"ExportDescrType\"\n    },\n    id: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ModuleExport\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ModuleExportDescr\"\n    }\n  }\n});\ndefineType(\"Limit\", {\n  unionType: [\"Node\"],\n  fields: {\n    min: {\n      type: \"number\"\n    },\n    max: {\n      optional: true,\n      type: \"number\"\n    },\n    // Threads proposal, shared memory\n    shared: {\n      optional: true,\n      type: \"boolean\"\n    }\n  }\n});\ndefineType(\"Signature\", {\n  unionType: [\"Node\"],\n  fields: {\n    params: {\n      array: true,\n      type: \"FuncParam\"\n    },\n    results: {\n      array: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"Program\", {\n  unionType: [\"Node\"],\n  fields: {\n    body: {\n      array: true,\n      type: \"Node\"\n    }\n  }\n});\ndefineType(\"Identifier\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    raw: {\n      optional: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"block\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"CallInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call\"\n    },\n    index: {\n      type: \"Index\"\n    },\n    instrArgs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    },\n    numeric: {\n      type: \"Index\",\n      optional: true\n    }\n  }\n});\ndefineType(\"CallIndirectInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call_indirect\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    intrs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    }\n  }\n});\ndefineType(\"ByteArray\", {\n  unionType: [\"Node\"],\n  fields: {\n    values: {\n      array: true,\n      type: \"Byte\"\n    }\n  }\n});\ndefineType(\"Func\", {\n  unionType: [\"Node\", \"Block\"],\n  fields: {\n    name: {\n      maybe: true,\n      type: \"Index\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    body: {\n      array: true,\n      type: \"Instruction\"\n    },\n    isExternal: {\n      comment: \"means that it has been imported from the outside js\",\n      optional: true,\n      type: \"boolean\"\n    },\n    metadata: {\n      optional: true,\n      type: \"FuncMetadata\"\n    }\n  }\n});\n/**\n * Intrinsics\n */\n\ndefineType(\"InternalBrUnless\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalGoto\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalCallExtern\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n}); // function bodies are terminated by an `end` instruction but are missing a\n// return instruction\n//\n// Since we can't inject a new instruction we are injecting a new instruction.\n\ndefineType(\"InternalEndAndReturn\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {}\n});\nmodule.exports = definitions;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}