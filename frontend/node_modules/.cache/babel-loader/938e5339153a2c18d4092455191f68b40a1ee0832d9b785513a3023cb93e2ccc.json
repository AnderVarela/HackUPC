{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\types\\json-schema.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-interface */\ntype StrictNullChecksWrapper<Name extends string, Type> = undefined extends null\n  ? `strictNullChecks must be true in tsconfig to use ${Name}`\n  : Type\n\ntype UnionToIntersection<U> = (U extends any ? (_: U) => void : never) extends (_: infer I) => void\n  ? I\n  : never\n\nexport type SomeJSONSchema = UncheckedJSONSchemaType<Known, true>\n\ntype UncheckedPartialSchema<T> = Partial<UncheckedJSONSchemaType<T, true>>\n\nexport type PartialSchema<T> = StrictNullChecksWrapper<\"PartialSchema\", UncheckedPartialSchema<T>>\n\ntype JSONType<T extends string, IsPartial extends boolean> = IsPartial extends true\n  ? T | undefined\n  : T\n\ninterface NumberKeywords {\n  minimum?: number\n  maximum?: number\n  exclusiveMinimum?: number\n  exclusiveMaximum?: number\n  multipleOf?: number\n  format?: string\n}\n\ninterface StringKeywords {\n  minLength?: number\n  maxLength?: number\n  pattern?: string\n  format?: string\n}\n\ntype UncheckedJSONSchemaType<T, IsPartial extends boolean> = (\n  | // these two unions allow arbitrary unions of types\n  {\n      anyOf: readonly UncheckedJSONSchemaType<T, IsPartial>[]\n    }\n  | {\n      oneOf: readonly UncheckedJSONSchemaType<T, IsPartial>[]\n    }\n  // this union allows for { type: (primitive)[] } style schemas\n  | ({\n      type: readonly (T extends number\n        ? JSONType<\"number\" | \"integer\", IsPartial>\n        : T extends string\n        ? JSONType<\"string\", IsPartial>\n        : T extends boolean\n        ? JSONType<\"boolean\", IsPartial>\n        : never)[]\n    } & UnionToIntersection<\n      T extends number\n        ? NumberKeywords\n        : T extends string\n        ? StringKeywords\n        : T extends boolean\n        ? // eslint-disable-next-line @typescript-eslint/ban-types\n          {}\n        : never\n    >)\n  // this covers \"normal\" types; it's last so typescript looks to it first for errors\n  | ((T extends number\n      ? {\n          type: JSONType<\"number\" | \"integer\", IsPartial>\n        } & NumberKeywords\n      : T extends string\n      ? {\n          type: JSONType<\"string\", IsPartial>\n        } & StringKeywords\n      : T extends boolean\n      ? {\n          type: JSONType<\"boolean\", IsPartial>\n        }\n      : T extends readonly [any, ...any[]]\n      ? {\n          // JSON AnySchema for tuple\n          type: JSONType<\"array\", IsPartial>\n          items: {\n            readonly [K in keyof T]-?: UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>\n          } & {length: T[\"length\"]}\n          minItems: T[\"length\"]\n        } & ({maxItems: T[\"length\"]} | {additionalItems: false})\n      : T extends readonly any[]\n      ? {\n          type: JSONType<\"array\", IsPartial>\n          items: UncheckedJSONSchemaType<T[0], false>\n          contains?: UncheckedPartialSchema<T[0]>\n          minItems?: number\n          maxItems?: number\n          minContains?: number\n          maxContains?: number\n          uniqueItems?: true\n          additionalItems?: never\n        }\n      : T extends Record<string, any>\n      ? {\n          // JSON AnySchema for records and dictionaries\n          // \"required\" is not optional because it is often forgotten\n          // \"properties\" are optional for more concise dictionary schemas\n          // \"patternProperties\" and can be only used with interfaces that have string index\n          type: JSONType<\"object\", IsPartial>\n          additionalProperties?: boolean | UncheckedJSONSchemaType<T[string], false>\n          unevaluatedProperties?: boolean | UncheckedJSONSchemaType<T[string], false>\n          properties?: IsPartial extends true\n            ? Partial<UncheckedPropertiesSchema<T>>\n            : UncheckedPropertiesSchema<T>\n          patternProperties?: Record<string, UncheckedJSONSchemaType<T[string], false>>\n          propertyNames?: Omit<UncheckedJSONSchemaType<string, false>, \"type\"> & {type?: \"string\"}\n          dependencies?: {[K in keyof T]?: Readonly<(keyof T)[]> | UncheckedPartialSchema<T>}\n          dependentRequired?: {[K in keyof T]?: Readonly<(keyof T)[]>}\n          dependentSchemas?: {[K in keyof T]?: UncheckedPartialSchema<T>}\n          minProperties?: number\n          maxProperties?: number\n        } & (IsPartial extends true // \"required\" is not necessary if it's a non-partial type with no required keys // are listed it only asserts that optional cannot be listed. // \"required\" type does not guarantee that all required properties\n          ? {required: Readonly<(keyof T)[]>}\n          : [UncheckedRequiredMembers<T>] extends [never]\n          ? {required?: Readonly<UncheckedRequiredMembers<T>[]>}\n          : {required: Readonly<UncheckedRequiredMembers<T>[]>})\n      : T extends null\n      ? {\n          type: JSONType<\"null\", IsPartial>\n          nullable: true\n        }\n      : never) & {\n      allOf?: Readonly<UncheckedPartialSchema<T>[]>\n      anyOf?: Readonly<UncheckedPartialSchema<T>[]>\n      oneOf?: Readonly<UncheckedPartialSchema<T>[]>\n      if?: UncheckedPartialSchema<T>\n      then?: UncheckedPartialSchema<T>\n      else?: UncheckedPartialSchema<T>\n      not?: UncheckedPartialSchema<T>\n    })\n) & {\n  [keyword: string]: any\n  $id?: string\n  $ref?: string\n  $defs?: Record<string, UncheckedJSONSchemaType<Known, true>>\n  definitions?: Record<string, UncheckedJSONSchemaType<Known, true>>\n}\n\nexport type JSONSchemaType<T> = StrictNullChecksWrapper<\n  \"JSONSchemaType\",\n  UncheckedJSONSchemaType<T, false>\n>\n\ntype Known =\n  | {[key: string]: Known}\n  | [Known, ...Known[]]\n  | Known[]\n  | number\n  | string\n  | boolean\n  | null\n\ntype UncheckedPropertiesSchema<T> = {\n  [K in keyof T]-?: (UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>) | {$ref: string}\n}\n\nexport type PropertiesSchema<T> = StrictNullChecksWrapper<\n  \"PropertiesSchema\",\n  UncheckedPropertiesSchema<T>\n>\n\ntype UncheckedRequiredMembers<T> = {\n  [K in keyof T]-?: undefined extends T[K] ? never : K\n}[keyof T]\n\nexport type RequiredMembers<T> = StrictNullChecksWrapper<\n  \"RequiredMembers\",\n  UncheckedRequiredMembers<T>\n>\n\ntype Nullable<T> = undefined extends T\n  ? {\n      nullable: true\n      const?: null // any non-null value would fail `const: null`, `null` would fail any other value in const\n      enum?: Readonly<(T | null)[]> // `null` must be explicitly included in \"enum\" for `null` to pass\n      default?: T | null\n    }\n  : {\n      nullable?: false\n      const?: T\n      enum?: Readonly<T[]>\n      default?: T\n    }\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}