{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst typescript_1 = require(\"typescript\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'consistent-type-exports',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce consistent usage of type exports',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      typeOverValue: 'All exports in the declaration are only used as types. Use `export type`.',\n      singleExportIsType: 'Type export {{exportNames}} is not a value and should be exported using `export type`.',\n      multipleExportsAreTypes: 'Type exports {{exportNames}} are not values and should be exported using `export type`.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        fixMixedExportsWithInlineTypeSpecifier: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code'\n  },\n  defaultOptions: [{\n    fixMixedExportsWithInlineTypeSpecifier: false\n  }],\n  create(context, [{\n    fixMixedExportsWithInlineTypeSpecifier\n  }]) {\n    const sourceCode = context.getSourceCode();\n    const sourceExportsMap = {};\n    const parserServices = util.getParserServices(context);\n    return {\n      ExportNamedDeclaration(node) {\n        var _a;\n        // Coerce the source into a string for use as a lookup entry.\n        const source = (_a = getSourceFromExport(node)) !== null && _a !== void 0 ? _a : 'undefined';\n        const sourceExports = sourceExportsMap[source] || (sourceExportsMap[source] = {\n          source,\n          reportValueExports: [],\n          typeOnlyNamedExport: null,\n          valueOnlyNamedExport: null\n        });\n        // Cache the first encountered exports for the package. We will need to come\n        // back to these later when fixing the problems.\n        if (node.exportKind === 'type') {\n          if (sourceExports.typeOnlyNamedExport == null) {\n            // The export is a type export\n            sourceExports.typeOnlyNamedExport = node;\n          }\n        } else if (sourceExports.valueOnlyNamedExport == null) {\n          // The export is a value export\n          sourceExports.valueOnlyNamedExport = node;\n        }\n        // Next for the current export, we will separate type/value specifiers.\n        const typeBasedSpecifiers = [];\n        const inlineTypeSpecifiers = [];\n        const valueSpecifiers = [];\n        // Note: it is valid to export values as types. We will avoid reporting errors\n        // when this is encountered.\n        if (node.exportKind !== 'type') {\n          for (const specifier of node.specifiers) {\n            if (specifier.exportKind === 'type') {\n              inlineTypeSpecifiers.push(specifier);\n              continue;\n            }\n            const isTypeBased = isSpecifierTypeBased(parserServices, specifier);\n            if (isTypeBased === true) {\n              typeBasedSpecifiers.push(specifier);\n            } else if (isTypeBased === false) {\n              // When isTypeBased is undefined, we should avoid reporting them.\n              valueSpecifiers.push(specifier);\n            }\n          }\n        }\n        if (node.exportKind === 'value' && typeBasedSpecifiers.length || node.exportKind === 'type' && valueSpecifiers.length) {\n          sourceExports.reportValueExports.push({\n            node,\n            typeBasedSpecifiers,\n            valueSpecifiers,\n            inlineTypeSpecifiers\n          });\n        }\n      },\n      'Program:exit'() {\n        for (const sourceExports of Object.values(sourceExportsMap)) {\n          // If this export has no issues, move on.\n          if (sourceExports.reportValueExports.length === 0) {\n            continue;\n          }\n          for (const report of sourceExports.reportValueExports) {\n            if (report.valueSpecifiers.length === 0) {\n              // Export is all type-only with no type specifiers; convert the entire export to `export type`.\n              context.report({\n                node: report.node,\n                messageId: 'typeOverValue',\n                *fix(fixer) {\n                  yield* fixExportInsertType(fixer, sourceCode, report.node);\n                }\n              });\n              continue;\n            }\n            // We have both type and value violations.\n            const allExportNames = report.typeBasedSpecifiers.map(specifier => `${specifier.local.name}`);\n            if (allExportNames.length === 1) {\n              const exportNames = allExportNames[0];\n              context.report({\n                node: report.node,\n                messageId: 'singleExportIsType',\n                data: {\n                  exportNames\n                },\n                *fix(fixer) {\n                  if (fixMixedExportsWithInlineTypeSpecifier) {\n                    yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                  } else {\n                    yield* fixSeparateNamedExports(fixer, sourceCode, report);\n                  }\n                }\n              });\n            } else {\n              const exportNames = util.formatWordList(allExportNames);\n              context.report({\n                node: report.node,\n                messageId: 'multipleExportsAreTypes',\n                data: {\n                  exportNames\n                },\n                *fix(fixer) {\n                  if (fixMixedExportsWithInlineTypeSpecifier) {\n                    yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                  } else {\n                    yield* fixSeparateNamedExports(fixer, sourceCode, report);\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n    };\n  }\n});\n/**\n * Helper for identifying if an export specifier resolves to a\n * JavaScript value or a TypeScript type.\n *\n * @returns True/false if is a type or not, or undefined if the specifier\n * can't be resolved.\n */\nfunction isSpecifierTypeBased(parserServices, specifier) {\n  const checker = parserServices.program.getTypeChecker();\n  const node = parserServices.esTreeNodeToTSNodeMap.get(specifier.exported);\n  const symbol = checker.getSymbolAtLocation(node);\n  const aliasedSymbol = checker.getAliasedSymbol(symbol);\n  if (!aliasedSymbol || aliasedSymbol.escapedName === 'unknown') {\n    return undefined;\n  }\n  return !(aliasedSymbol.flags & typescript_1.SymbolFlags.Value);\n}\n/**\n * Inserts \"type\" into an export.\n *\n * Example:\n *\n * export type { Foo } from 'foo';\n *        ^^^^\n */\nfunction* fixExportInsertType(fixer, sourceCode, node) {\n  const exportToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('export', node.type));\n  yield fixer.insertTextAfter(exportToken, ' type');\n  for (const specifier of node.specifiers) {\n    if (specifier.exportKind === 'type') {\n      const kindToken = util.nullThrows(sourceCode.getFirstToken(specifier), util.NullThrowsReasons.MissingToken('export', specifier.type));\n      const firstTokenAfter = util.nullThrows(sourceCode.getTokenAfter(kindToken, {\n        includeComments: true\n      }), 'Missing token following the export kind.');\n      yield fixer.removeRange([kindToken.range[0], firstTokenAfter.range[0]]);\n    }\n  }\n}\n/**\n * Separates the exports which mismatch the kind of export the given\n * node represents. For example, a type export's named specifiers which\n * represent values will be inserted in a separate `export` statement.\n */\nfunction* fixSeparateNamedExports(fixer, sourceCode, report) {\n  const {\n    node,\n    typeBasedSpecifiers,\n    inlineTypeSpecifiers,\n    valueSpecifiers\n  } = report;\n  const typeSpecifiers = typeBasedSpecifiers.concat(inlineTypeSpecifiers);\n  const source = getSourceFromExport(node);\n  const specifierNames = typeSpecifiers.map(getSpecifierText).join(', ');\n  const exportToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('export', node.type));\n  // Filter the bad exports from the current line.\n  const filteredSpecifierNames = valueSpecifiers.map(getSpecifierText).join(', ');\n  const openToken = util.nullThrows(sourceCode.getFirstToken(node, util.isOpeningBraceToken), util.NullThrowsReasons.MissingToken('{', node.type));\n  const closeToken = util.nullThrows(sourceCode.getLastToken(node, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type));\n  // Remove exports from the current line which we're going to re-insert.\n  yield fixer.replaceTextRange([openToken.range[1], closeToken.range[0]], ` ${filteredSpecifierNames} `);\n  // Insert the bad exports into a new export line above.\n  yield fixer.insertTextBefore(exportToken, `export type { ${specifierNames} }${source ? ` from '${source}'` : ''};\\n`);\n}\nfunction* fixAddTypeSpecifierToNamedExports(fixer, report) {\n  if (report.node.exportKind === 'type') {\n    return;\n  }\n  for (const specifier of report.typeBasedSpecifiers) {\n    yield fixer.insertTextBefore(specifier, 'type ');\n  }\n}\n/**\n * Returns the source of the export, or undefined if the named export has no source.\n */\nfunction getSourceFromExport(node) {\n  var _a;\n  if (((_a = node.source) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Literal && typeof node.source.value === 'string') {\n    return node.source.value;\n  }\n  return undefined;\n}\n/**\n * Returns the specifier text for the export. If it is aliased, we take care to return\n * the proper formatting.\n */\nfunction getSpecifierText(specifier) {\n  return `${specifier.local.name}${specifier.exported.name !== specifier.local.name ? ` as ${specifier.exported.name}` : ''}`;\n}","map":{"version":3,"names":["utils_1","require","typescript_1","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","typeOverValue","singleExportIsType","multipleExportsAreTypes","schema","properties","fixMixedExportsWithInlineTypeSpecifier","additionalProperties","fixable","defaultOptions","create","context","sourceCode","getSourceCode","sourceExportsMap","parserServices","getParserServices","ExportNamedDeclaration","node","source","_a","getSourceFromExport","sourceExports","reportValueExports","typeOnlyNamedExport","valueOnlyNamedExport","exportKind","typeBasedSpecifiers","inlineTypeSpecifiers","valueSpecifiers","specifier","specifiers","push","isTypeBased","isSpecifierTypeBased","length","Program:exit","Object","values","report","messageId","fix","fixer","fixExportInsertType","allExportNames","map","local","exportNames","data","fixAddTypeSpecifierToNamedExports","fixSeparateNamedExports","formatWordList","checker","program","getTypeChecker","esTreeNodeToTSNodeMap","get","exported","symbol","getSymbolAtLocation","aliasedSymbol","getAliasedSymbol","escapedName","undefined","flags","SymbolFlags","Value","exportToken","nullThrows","getFirstToken","NullThrowsReasons","MissingToken","insertTextAfter","kindToken","firstTokenAfter","getTokenAfter","includeComments","removeRange","range","typeSpecifiers","concat","specifierNames","getSpecifierText","join","filteredSpecifierNames","openToken","isOpeningBraceToken","closeToken","getLastToken","isClosingBraceToken","replaceTextRange","insertTextBefore","AST_NODE_TYPES","Literal","value"],"sources":["../../src/rules/consistent-type-exports.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}