{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generatePatchedLinterJsFileIfDoesNotExist = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Dynamically generate file to properly patch many versions of ESLint\n * @param inputFilePath - Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js\n * @param outputFilePath - Some small changes to linter.js\n */\nfunction generatePatchedLinterJsFileIfDoesNotExist(inputFilePath, outputFilePath) {\n  const generateEnvVarValue = process.env[constants_1.ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME];\n  if (generateEnvVarValue !== 'true' && generateEnvVarValue !== '1' && fs_1.default.existsSync(outputFilePath)) {\n    return;\n  }\n  const inputFile = fs_1.default.readFileSync(inputFilePath).toString();\n  let inputIndex = 0;\n  /**\n   * Extract from the stream until marker is reached.  When matching marker,\n   * ignore whitespace in the stream and in the marker.  Return the extracted text.\n   */\n  function scanUntilMarker(marker) {\n    const trimmedMarker = marker.replace(/\\s/g, '');\n    let output = '';\n    let trimmed = '';\n    while (inputIndex < inputFile.length) {\n      const char = inputFile[inputIndex++];\n      output += char;\n      if (!/^\\s$/.test(char)) {\n        trimmed += char;\n      }\n      if (trimmed.endsWith(trimmedMarker)) {\n        return output;\n      }\n    }\n    throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));\n  }\n  function scanUntilNewline() {\n    let output = '';\n    while (inputIndex < inputFile.length) {\n      const char = inputFile[inputIndex++];\n      output += char;\n      if (char === '\\n') {\n        return output;\n      }\n    }\n    throw new Error('Unexpected end of input while looking for new line');\n  }\n  function scanUntilEnd() {\n    const output = inputFile.substring(inputIndex);\n    inputIndex = inputFile.length;\n    return output;\n  }\n  /**\n   * Returns index of next public method\n   * @param fromIndex - index of inputFile to search if public method still exists\n   * @returns -1 if public method does not exist or index of next public method\n   */\n  function getIndexOfNextPublicMethod(fromIndex) {\n    const rest = inputFile.substring(fromIndex);\n    const endOfClassIndex = rest.indexOf('\\n}');\n    const markerForStartOfClassMethod = '\\n     */\\n    ';\n    const startOfClassMethodIndex = rest.indexOf(markerForStartOfClassMethod);\n    if (startOfClassMethodIndex === -1 || startOfClassMethodIndex > endOfClassIndex) {\n      return -1;\n    }\n    const afterMarkerIndex = rest.indexOf(markerForStartOfClassMethod) + markerForStartOfClassMethod.length;\n    const isPublicMethod = rest[afterMarkerIndex] !== '_' && rest[afterMarkerIndex] !== '#' && !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('static') && !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('constructor');\n    if (isPublicMethod) {\n      return fromIndex + afterMarkerIndex;\n    }\n    return getIndexOfNextPublicMethod(fromIndex + afterMarkerIndex);\n  }\n  function scanUntilIndex(indexToScanTo) {\n    const output = inputFile.substring(inputIndex, indexToScanTo);\n    inputIndex = indexToScanTo;\n    return output;\n  }\n  let outputFile = '';\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Requirements\n  //    //------------------------------------------------------------------------------\n  outputFile += scanUntilMarker('// Requirements');\n  outputFile += scanUntilMarker('//--');\n  outputFile += scanUntilNewline();\n  outputFile += `\n// --- BEGIN MONKEY PATCH ---\nconst bulkSuppressionsPatch = require(process.env.${constants_1.ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME});\nconst requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;\n`;\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Typedefs\n  //    //------------------------------------------------------------------------------\n  const requireSection = scanUntilMarker('// Typedefs');\n  // Match something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = require('eslint-scope'),\n  //    evk = require('eslint-visitor-keys'),\n  //\n  // Convert to something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = requireFromPathToLinterJS('eslint-scope'),\n  //    evk = requireFromPathToLinterJS('eslint-visitor-keys'),\n  //\n  outputFile += requireSection.replace(/require\\s*\\((?:'([^']+)'|\"([^\"]+)\")\\)/g, (match, p1, p2) => {\n    var _a;\n    const importPath = (_a = p1 !== null && p1 !== void 0 ? p1 : p2) !== null && _a !== void 0 ? _a : '';\n    if (importPath !== 'path') {\n      if (p1) {\n        return `requireFromPathToLinterJS('${p1}')`;\n      }\n      if (p2) {\n        return `requireFromPathToLinterJS(\"${p2}\")`;\n      }\n    }\n    // Keep as-is\n    return match;\n  });\n  outputFile += `--- END MONKEY PATCH ---\n`;\n  // Match this:\n  // ```\n  //      if (reportTranslator === null) {\n  //        reportTranslator = createReportTranslator({\n  //            ruleId,\n  //            severity,\n  //            sourceCode,\n  //            messageIds,\n  //            disableFixes\n  //        });\n  //    }\n  //    const problem = reportTranslator(...args);\n  //\n  //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n  //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n  //    }\n  // ```\n  //\n  // Convert to something like this:\n  // ```\n  //      if (reportTranslator === null) {\n  //        reportTranslator = createReportTranslator({\n  //            ruleId,\n  //            severity,\n  //            sourceCode,\n  //            messageIds,\n  //            disableFixes\n  //        });\n  //    }\n  //    const problem = reportTranslator(...args);\n  //    // --- BEGIN MONKEY PATCH ---\n  //    if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;\n  //    // --- END MONKEY PATCH ---\n  //\n  //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n  //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n  //    }\n  // ```\n  outputFile += scanUntilMarker('const problem = reportTranslator(...args);');\n  outputFile += `\n                        // --- BEGIN MONKEY PATCH ---\n                        if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId, problem })) return;\n                        // --- END MONKEY PATCH ---\n`;\n  outputFile += scanUntilMarker('nodeQueue.forEach(traversalInfo => {');\n  outputFile += scanUntilMarker('});');\n  outputFile += scanUntilNewline();\n  outputFile += scanUntilMarker('class Linter {');\n  outputFile += scanUntilNewline();\n  outputFile += `\n    // --- BEGIN MONKEY PATCH ---\n    /**\n     * We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is\n     * initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all\n     * the patched methods refer to is not initialized. This method checks if the internalSlotsMap is\n     * initialized, and if not, initializes it.\n     */\n    _conditionallyReinitialize({ cwd, configType } = {}) {\n        if (internalSlotsMap.get(this) === undefined) {\n            internalSlotsMap.set(this, {\n              cwd: normalizeCwd(cwd),\n              lastConfigArray: null,\n              lastSourceCode: null,\n              lastSuppressedMessages: [],\n              configType, // TODO: Remove after flat config conversion\n              parserMap: new Map([['espree', espree]]),\n              ruleMap: new Rules()\n            });\n\n            this.version = pkg.version;\n        }\n    }\n    // --- END MONKEY PATCH ---\n`;\n  let indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n  while (indexOfNextPublicMethod !== -1) {\n    outputFile += scanUntilIndex(indexOfNextPublicMethod);\n    outputFile += scanUntilNewline();\n    outputFile += `        // --- BEGIN MONKEY PATCH ---\n        this._conditionallyReinitialize();\n        // --- END MONKEY PATCH ---\n`;\n    indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n  }\n  outputFile += scanUntilEnd();\n  fs_1.default.writeFileSync(outputFilePath, outputFile);\n}\nexports.generatePatchedLinterJsFileIfDoesNotExist = generatePatchedLinterJsFileIfDoesNotExist;","map":{"version":3,"names":["fs_1","__importDefault","require","constants_1","generatePatchedLinterJsFileIfDoesNotExist","inputFilePath","outputFilePath","generateEnvVarValue","process","env","ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME","default","existsSync","inputFile","readFileSync","toString","inputIndex","scanUntilMarker","marker","trimmedMarker","replace","output","trimmed","length","char","test","endsWith","Error","JSON","stringify","scanUntilNewline","scanUntilEnd","substring","getIndexOfNextPublicMethod","fromIndex","rest","endOfClassIndex","indexOf","markerForStartOfClassMethod","startOfClassMethodIndex","afterMarkerIndex","isPublicMethod","includes","scanUntilIndex","indexToScanTo","outputFile","ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME","requireSection","match","p1","p2","importPath","_a","indexOfNextPublicMethod","writeFileSync","exports"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@rushstack\\eslint-patch\\src\\eslint-bulk-suppressions\\generate-patched-file.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport fs from 'fs';\nimport {\n  ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME,\n  ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME\n} from './constants';\n\n/**\n * Dynamically generate file to properly patch many versions of ESLint\n * @param inputFilePath - Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js\n * @param outputFilePath - Some small changes to linter.js\n */\nexport function generatePatchedLinterJsFileIfDoesNotExist(\n  inputFilePath: string,\n  outputFilePath: string\n): void {\n  const generateEnvVarValue: string | undefined =\n    process.env[ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME];\n  if (generateEnvVarValue !== 'true' && generateEnvVarValue !== '1' && fs.existsSync(outputFilePath)) {\n    return;\n  }\n\n  const inputFile: string = fs.readFileSync(inputFilePath).toString();\n\n  let inputIndex: number = 0;\n\n  /**\n   * Extract from the stream until marker is reached.  When matching marker,\n   * ignore whitespace in the stream and in the marker.  Return the extracted text.\n   */\n  function scanUntilMarker(marker: string): string {\n    const trimmedMarker: string = marker.replace(/\\s/g, '');\n\n    let output: string = '';\n    let trimmed: string = '';\n\n    while (inputIndex < inputFile.length) {\n      const char: string = inputFile[inputIndex++];\n      output += char;\n      if (!/^\\s$/.test(char)) {\n        trimmed += char;\n      }\n      if (trimmed.endsWith(trimmedMarker)) {\n        return output;\n      }\n    }\n\n    throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));\n  }\n\n  function scanUntilNewline(): string {\n    let output: string = '';\n\n    while (inputIndex < inputFile.length) {\n      const char: string = inputFile[inputIndex++];\n      output += char;\n      if (char === '\\n') {\n        return output;\n      }\n    }\n\n    throw new Error('Unexpected end of input while looking for new line');\n  }\n\n  function scanUntilEnd(): string {\n    const output: string = inputFile.substring(inputIndex);\n    inputIndex = inputFile.length;\n    return output;\n  }\n\n  /**\n   * Returns index of next public method\n   * @param fromIndex - index of inputFile to search if public method still exists\n   * @returns -1 if public method does not exist or index of next public method\n   */\n  function getIndexOfNextPublicMethod(fromIndex: number): number {\n    const rest: string = inputFile.substring(fromIndex);\n\n    const endOfClassIndex: number = rest.indexOf('\\n}');\n\n    const markerForStartOfClassMethod: string = '\\n     */\\n    ';\n\n    const startOfClassMethodIndex: number = rest.indexOf(markerForStartOfClassMethod);\n\n    if (startOfClassMethodIndex === -1 || startOfClassMethodIndex > endOfClassIndex) {\n      return -1;\n    }\n\n    const afterMarkerIndex: number =\n      rest.indexOf(markerForStartOfClassMethod) + markerForStartOfClassMethod.length;\n\n    const isPublicMethod: boolean =\n      rest[afterMarkerIndex] !== '_' &&\n      rest[afterMarkerIndex] !== '#' &&\n      !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('static') &&\n      !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('constructor');\n\n    if (isPublicMethod) {\n      return fromIndex + afterMarkerIndex;\n    }\n\n    return getIndexOfNextPublicMethod(fromIndex + afterMarkerIndex);\n  }\n\n  function scanUntilIndex(indexToScanTo: number): string {\n    const output: string = inputFile.substring(inputIndex, indexToScanTo);\n    inputIndex = indexToScanTo;\n    return output;\n  }\n\n  let outputFile: string = '';\n\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Requirements\n  //    //------------------------------------------------------------------------------\n  outputFile += scanUntilMarker('// Requirements');\n  outputFile += scanUntilMarker('//--');\n  outputFile += scanUntilNewline();\n\n  outputFile += `\n// --- BEGIN MONKEY PATCH ---\nconst bulkSuppressionsPatch = require(process.env.${ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME});\nconst requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;\n`;\n\n  // Match this:\n  //    //------------------------------------------------------------------------------\n  //    // Typedefs\n  //    //------------------------------------------------------------------------------\n  const requireSection: string = scanUntilMarker('// Typedefs');\n\n  // Match something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = require('eslint-scope'),\n  //    evk = require('eslint-visitor-keys'),\n  //\n  // Convert to something like this:\n  //\n  //    const path = require('path'),\n  //    eslintScope = requireFromPathToLinterJS('eslint-scope'),\n  //    evk = requireFromPathToLinterJS('eslint-visitor-keys'),\n  //\n  outputFile += requireSection.replace(/require\\s*\\((?:'([^']+)'|\"([^\"]+)\")\\)/g, (match, p1, p2) => {\n    const importPath: string = p1 ?? p2 ?? '';\n\n    if (importPath !== 'path') {\n      if (p1) {\n        return `requireFromPathToLinterJS('${p1}')`;\n      }\n      if (p2) {\n        return `requireFromPathToLinterJS(\"${p2}\")`;\n      }\n    }\n\n    // Keep as-is\n    return match;\n  });\n  outputFile += `--- END MONKEY PATCH ---\n`;\n\n  // Match this:\n  // ```\n  //      if (reportTranslator === null) {\n  //        reportTranslator = createReportTranslator({\n  //            ruleId,\n  //            severity,\n  //            sourceCode,\n  //            messageIds,\n  //            disableFixes\n  //        });\n  //    }\n  //    const problem = reportTranslator(...args);\n  //\n  //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n  //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n  //    }\n  // ```\n  //\n  // Convert to something like this:\n  // ```\n  //      if (reportTranslator === null) {\n  //        reportTranslator = createReportTranslator({\n  //            ruleId,\n  //            severity,\n  //            sourceCode,\n  //            messageIds,\n  //            disableFixes\n  //        });\n  //    }\n  //    const problem = reportTranslator(...args);\n  //    // --- BEGIN MONKEY PATCH ---\n  //    if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;\n  //    // --- END MONKEY PATCH ---\n  //\n  //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n  //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n  //    }\n  // ```\n  outputFile += scanUntilMarker('const problem = reportTranslator(...args);');\n  outputFile += `\n                        // --- BEGIN MONKEY PATCH ---\n                        if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId, problem })) return;\n                        // --- END MONKEY PATCH ---\n`;\n\n  outputFile += scanUntilMarker('nodeQueue.forEach(traversalInfo => {');\n  outputFile += scanUntilMarker('});');\n  outputFile += scanUntilNewline();\n  outputFile += scanUntilMarker('class Linter {');\n  outputFile += scanUntilNewline();\n  outputFile += `\n    // --- BEGIN MONKEY PATCH ---\n    /**\n     * We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is\n     * initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all\n     * the patched methods refer to is not initialized. This method checks if the internalSlotsMap is\n     * initialized, and if not, initializes it.\n     */\n    _conditionallyReinitialize({ cwd, configType } = {}) {\n        if (internalSlotsMap.get(this) === undefined) {\n            internalSlotsMap.set(this, {\n              cwd: normalizeCwd(cwd),\n              lastConfigArray: null,\n              lastSourceCode: null,\n              lastSuppressedMessages: [],\n              configType, // TODO: Remove after flat config conversion\n              parserMap: new Map([['espree', espree]]),\n              ruleMap: new Rules()\n            });\n\n            this.version = pkg.version;\n        }\n    }\n    // --- END MONKEY PATCH ---\n`;\n\n  let indexOfNextPublicMethod: number = getIndexOfNextPublicMethod(inputIndex);\n  while (indexOfNextPublicMethod !== -1) {\n    outputFile += scanUntilIndex(indexOfNextPublicMethod);\n    outputFile += scanUntilNewline();\n    outputFile += `        // --- BEGIN MONKEY PATCH ---\n        this._conditionallyReinitialize();\n        // --- END MONKEY PATCH ---\n`;\n    indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n  }\n\n  outputFile += scanUntilEnd();\n\n  fs.writeFileSync(outputFilePath, outputFile);\n}\n"],"mappings":";;AAAA;AACA;;;;;;;;;;AAEA,MAAAA,IAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,WAAA,GAAAD,OAAA;AAKA;;;;;AAKA,SAAgBE,yCAAyCA,CACvDC,aAAqB,EACrBC,cAAsB;EAEtB,MAAMC,mBAAmB,GACvBC,OAAO,CAACC,GAAG,CAACN,WAAA,CAAAO,+CAA+C,CAAC;EAC9D,IAAIH,mBAAmB,KAAK,MAAM,IAAIA,mBAAmB,KAAK,GAAG,IAAIP,IAAA,CAAAW,OAAE,CAACC,UAAU,CAACN,cAAc,CAAC,EAAE;IAClG;EACF;EAEA,MAAMO,SAAS,GAAWb,IAAA,CAAAW,OAAE,CAACG,YAAY,CAACT,aAAa,CAAC,CAACU,QAAQ,EAAE;EAEnE,IAAIC,UAAU,GAAW,CAAC;EAE1B;;;;EAIA,SAASC,eAAeA,CAACC,MAAc;IACrC,MAAMC,aAAa,GAAWD,MAAM,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IAEvD,IAAIC,MAAM,GAAW,EAAE;IACvB,IAAIC,OAAO,GAAW,EAAE;IAExB,OAAON,UAAU,GAAGH,SAAS,CAACU,MAAM,EAAE;MACpC,MAAMC,IAAI,GAAWX,SAAS,CAACG,UAAU,EAAE,CAAC;MAC5CK,MAAM,IAAIG,IAAI;MACd,IAAI,CAAC,MAAM,CAACC,IAAI,CAACD,IAAI,CAAC,EAAE;QACtBF,OAAO,IAAIE,IAAI;MACjB;MACA,IAAIF,OAAO,CAACI,QAAQ,CAACP,aAAa,CAAC,EAAE;QACnC,OAAOE,MAAM;MACf;IACF;IAEA,MAAM,IAAIM,KAAK,CAAC,4CAA4C,GAAGC,IAAI,CAACC,SAAS,CAACX,MAAM,CAAC,CAAC;EACxF;EAEA,SAASY,gBAAgBA,CAAA;IACvB,IAAIT,MAAM,GAAW,EAAE;IAEvB,OAAOL,UAAU,GAAGH,SAAS,CAACU,MAAM,EAAE;MACpC,MAAMC,IAAI,GAAWX,SAAS,CAACG,UAAU,EAAE,CAAC;MAC5CK,MAAM,IAAIG,IAAI;MACd,IAAIA,IAAI,KAAK,IAAI,EAAE;QACjB,OAAOH,MAAM;MACf;IACF;IAEA,MAAM,IAAIM,KAAK,CAAC,oDAAoD,CAAC;EACvE;EAEA,SAASI,YAAYA,CAAA;IACnB,MAAMV,MAAM,GAAWR,SAAS,CAACmB,SAAS,CAAChB,UAAU,CAAC;IACtDA,UAAU,GAAGH,SAAS,CAACU,MAAM;IAC7B,OAAOF,MAAM;EACf;EAEA;;;;;EAKA,SAASY,0BAA0BA,CAACC,SAAiB;IACnD,MAAMC,IAAI,GAAWtB,SAAS,CAACmB,SAAS,CAACE,SAAS,CAAC;IAEnD,MAAME,eAAe,GAAWD,IAAI,CAACE,OAAO,CAAC,KAAK,CAAC;IAEnD,MAAMC,2BAA2B,GAAW,iBAAiB;IAE7D,MAAMC,uBAAuB,GAAWJ,IAAI,CAACE,OAAO,CAACC,2BAA2B,CAAC;IAEjF,IAAIC,uBAAuB,KAAK,CAAC,CAAC,IAAIA,uBAAuB,GAAGH,eAAe,EAAE;MAC/E,OAAO,CAAC,CAAC;IACX;IAEA,MAAMI,gBAAgB,GACpBL,IAAI,CAACE,OAAO,CAACC,2BAA2B,CAAC,GAAGA,2BAA2B,CAACf,MAAM;IAEhF,MAAMkB,cAAc,GAClBN,IAAI,CAACK,gBAAgB,CAAC,KAAK,GAAG,IAC9BL,IAAI,CAACK,gBAAgB,CAAC,KAAK,GAAG,IAC9B,CAACL,IAAI,CAACH,SAAS,CAACQ,gBAAgB,EAAEL,IAAI,CAACE,OAAO,CAAC,IAAI,EAAEG,gBAAgB,CAAC,CAAC,CAACE,QAAQ,CAAC,QAAQ,CAAC,IAC1F,CAACP,IAAI,CAACH,SAAS,CAACQ,gBAAgB,EAAEL,IAAI,CAACE,OAAO,CAAC,IAAI,EAAEG,gBAAgB,CAAC,CAAC,CAACE,QAAQ,CAAC,aAAa,CAAC;IAEjG,IAAID,cAAc,EAAE;MAClB,OAAOP,SAAS,GAAGM,gBAAgB;IACrC;IAEA,OAAOP,0BAA0B,CAACC,SAAS,GAAGM,gBAAgB,CAAC;EACjE;EAEA,SAASG,cAAcA,CAACC,aAAqB;IAC3C,MAAMvB,MAAM,GAAWR,SAAS,CAACmB,SAAS,CAAChB,UAAU,EAAE4B,aAAa,CAAC;IACrE5B,UAAU,GAAG4B,aAAa;IAC1B,OAAOvB,MAAM;EACf;EAEA,IAAIwB,UAAU,GAAW,EAAE;EAE3B;EACA;EACA;EACA;EACAA,UAAU,IAAI5B,eAAe,CAAC,iBAAiB,CAAC;EAChD4B,UAAU,IAAI5B,eAAe,CAAC,MAAM,CAAC;EACrC4B,UAAU,IAAIf,gBAAgB,EAAE;EAEhCe,UAAU,IAAI;;oDAEoC1C,WAAA,CAAA2C,mCAAmC;;CAEtF;EAEC;EACA;EACA;EACA;EACA,MAAMC,cAAc,GAAW9B,eAAe,CAAC,aAAa,CAAC;EAE7D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA4B,UAAU,IAAIE,cAAc,CAAC3B,OAAO,CAAC,wCAAwC,EAAE,CAAC4B,KAAK,EAAEC,EAAE,EAAEC,EAAE,KAAI;;IAC/F,MAAMC,UAAU,GAAW,CAAAC,EAAA,GAAAH,EAAE,aAAFA,EAAE,cAAFA,EAAE,GAAIC,EAAE,cAAAE,EAAA,cAAAA,EAAA,GAAI,EAAE;IAEzC,IAAID,UAAU,KAAK,MAAM,EAAE;MACzB,IAAIF,EAAE,EAAE;QACN,OAAO,8BAA8BA,EAAE,IAAI;MAC7C;MACA,IAAIC,EAAE,EAAE;QACN,OAAO,8BAA8BA,EAAE,IAAI;MAC7C;IACF;IAEA;IACA,OAAOF,KAAK;EACd,CAAC,CAAC;EACFH,UAAU,IAAI;CACf;EAEC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAA,UAAU,IAAI5B,eAAe,CAAC,4CAA4C,CAAC;EAC3E4B,UAAU,IAAI;;;;CAIf;EAECA,UAAU,IAAI5B,eAAe,CAAC,sCAAsC,CAAC;EACrE4B,UAAU,IAAI5B,eAAe,CAAC,KAAK,CAAC;EACpC4B,UAAU,IAAIf,gBAAgB,EAAE;EAChCe,UAAU,IAAI5B,eAAe,CAAC,gBAAgB,CAAC;EAC/C4B,UAAU,IAAIf,gBAAgB,EAAE;EAChCe,UAAU,IAAI;;;;;;;;;;;;;;;;;;;;;;;;CAwBf;EAEC,IAAIQ,uBAAuB,GAAWpB,0BAA0B,CAACjB,UAAU,CAAC;EAC5E,OAAOqC,uBAAuB,KAAK,CAAC,CAAC,EAAE;IACrCR,UAAU,IAAIF,cAAc,CAACU,uBAAuB,CAAC;IACrDR,UAAU,IAAIf,gBAAgB,EAAE;IAChCe,UAAU,IAAI;;;CAGjB;IACGQ,uBAAuB,GAAGpB,0BAA0B,CAACjB,UAAU,CAAC;EAClE;EAEA6B,UAAU,IAAId,YAAY,EAAE;EAE5B/B,IAAA,CAAAW,OAAE,CAAC2C,aAAa,CAAChD,cAAc,EAAEuC,UAAU,CAAC;AAC9C;AAhPAU,OAAA,CAAAnD,yCAAA,GAAAA,yCAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}