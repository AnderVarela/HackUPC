{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'triple-slash-reference',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow certain triple slash directives in favor of ES6-style import declarations',\n      recommended: 'error'\n    },\n    messages: {\n      tripleSlashReference: 'Do not use a triple slash reference for {{module}}, use `import` style instead.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        lib: {\n          enum: ['always', 'never']\n        },\n        path: {\n          enum: ['always', 'never']\n        },\n        types: {\n          enum: ['always', 'never', 'prefer-import']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    lib: 'always',\n    path: 'never',\n    types: 'prefer-import'\n  }],\n  create(context, [{\n    lib,\n    path,\n    types\n  }]) {\n    let programNode;\n    const sourceCode = context.getSourceCode();\n    const references = [];\n    function hasMatchingReference(source) {\n      references.forEach(reference => {\n        if (reference.importName === source.value) {\n          context.report({\n            node: reference.comment,\n            messageId: 'tripleSlashReference',\n            data: {\n              module: reference.importName\n            }\n          });\n        }\n      });\n    }\n    return {\n      ImportDeclaration(node) {\n        if (programNode) {\n          hasMatchingReference(node.source);\n        }\n      },\n      TSImportEqualsDeclaration(node) {\n        if (programNode) {\n          const reference = node.moduleReference;\n          if (reference.type === utils_1.AST_NODE_TYPES.TSExternalModuleReference) {\n            hasMatchingReference(reference.expression);\n          }\n        }\n      },\n      Program(node) {\n        if (lib === 'always' && path === 'always' && types === 'always') {\n          return;\n        }\n        programNode = node;\n        const referenceRegExp = /^\\/\\s*<reference\\s*(types|path|lib)\\s*=\\s*[\"|'](.*)[\"|']/;\n        const commentsBefore = sourceCode.getCommentsBefore(programNode);\n        commentsBefore.forEach(comment => {\n          if (comment.type !== utils_1.AST_TOKEN_TYPES.Line) {\n            return;\n          }\n          const referenceResult = referenceRegExp.exec(comment.value);\n          if (referenceResult) {\n            if (referenceResult[1] === 'types' && types === 'never' || referenceResult[1] === 'path' && path === 'never' || referenceResult[1] === 'lib' && lib === 'never') {\n              context.report({\n                node: comment,\n                messageId: 'tripleSlashReference',\n                data: {\n                  module: referenceResult[2]\n                }\n              });\n              return;\n            }\n            if (referenceResult[1] === 'types' && types === 'prefer-import') {\n              references.push({\n                comment,\n                importName: referenceResult[2]\n              });\n            }\n          }\n        });\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","exports","default","createRule","name","meta","type","docs","description","recommended","messages","tripleSlashReference","schema","properties","lib","enum","path","types","additionalProperties","defaultOptions","create","context","programNode","sourceCode","getSourceCode","references","hasMatchingReference","source","forEach","reference","importName","value","report","node","comment","messageId","data","module","ImportDeclaration","TSImportEqualsDeclaration","moduleReference","AST_NODE_TYPES","TSExternalModuleReference","expression","Program","referenceRegExp","commentsBefore","getCommentsBefore","AST_TOKEN_TYPES","Line","referenceResult","exec","push"],"sources":["../../src/rules/triple-slash-reference.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAEA,MAAAC,IAAA,GAAAC,YAAA,CAAAF,OAAA;AAWAG,OAAA,CAAAC,OAAA,GAAeH,IAAI,CAACI,UAAU,CAAsB;EAClDC,IAAI,EAAE,wBAAwB;EAC9BC,IAAI,EAAE;IACJC,IAAI,EAAE,YAAY;IAClBC,IAAI,EAAE;MACJC,WAAW,EACT,oFAAoF;MACtFC,WAAW,EAAE;KACd;IACDC,QAAQ,EAAE;MACRC,oBAAoB,EAClB;KACH;IACDC,MAAM,EAAE,CACN;MACEN,IAAI,EAAE,QAAQ;MACdO,UAAU,EAAE;QACVC,GAAG,EAAE;UACHC,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO;SACzB;QACDC,IAAI,EAAE;UACJD,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO;SACzB;QACDE,KAAK,EAAE;UACLF,IAAI,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,eAAe;;OAE5C;MACDG,oBAAoB,EAAE;KACvB;GAEJ;EACDC,cAAc,EAAE,CACd;IACEL,GAAG,EAAE,QAAQ;IACbE,IAAI,EAAE,OAAO;IACbC,KAAK,EAAE;GACR,CACF;EACDG,MAAMA,CAACC,OAAO,EAAE,CAAC;IAAEP,GAAG;IAAEE,IAAI;IAAEC;EAAK,CAAE,CAAC;IACpC,IAAIK,WAA0B;IAC9B,MAAMC,UAAU,GAAGF,OAAO,CAACG,aAAa,EAAE;IAC1C,MAAMC,UAAU,GAGV,EAAE;IAER,SAASC,oBAAoBA,CAACC,MAAwB;MACpDF,UAAU,CAACG,OAAO,CAACC,SAAS,IAAG;QAC7B,IAAIA,SAAS,CAACC,UAAU,KAAKH,MAAM,CAACI,KAAK,EAAE;UACzCV,OAAO,CAACW,MAAM,CAAC;YACbC,IAAI,EAAEJ,SAAS,CAACK,OAAO;YACvBC,SAAS,EAAE,sBAAsB;YACjCC,IAAI,EAAE;cACJC,MAAM,EAAER,SAAS,CAACC;;WAErB,CAAC;;MAEN,CAAC,CAAC;IACJ;IACA,OAAO;MACLQ,iBAAiBA,CAACL,IAAI;QACpB,IAAIX,WAAW,EAAE;UACfI,oBAAoB,CAACO,IAAI,CAACN,MAAM,CAAC;;MAErC,CAAC;MACDY,yBAAyBA,CAACN,IAAI;QAC5B,IAAIX,WAAW,EAAE;UACf,MAAMO,SAAS,GAAGI,IAAI,CAACO,eAAe;UAEtC,IAAIX,SAAS,CAACvB,IAAI,KAAKT,OAAA,CAAA4C,cAAc,CAACC,yBAAyB,EAAE;YAC/DhB,oBAAoB,CAACG,SAAS,CAACc,UAA8B,CAAC;;;MAGpE,CAAC;MACDC,OAAOA,CAACX,IAAI;QACV,IAAInB,GAAG,KAAK,QAAQ,IAAIE,IAAI,KAAK,QAAQ,IAAIC,KAAK,KAAK,QAAQ,EAAE;UAC/D;;QAEFK,WAAW,GAAGW,IAAI;QAClB,MAAMY,eAAe,GACnB,0DAA0D;QAC5D,MAAMC,cAAc,GAAGvB,UAAU,CAACwB,iBAAiB,CAACzB,WAAW,CAAC;QAEhEwB,cAAc,CAAClB,OAAO,CAACM,OAAO,IAAG;UAC/B,IAAIA,OAAO,CAAC5B,IAAI,KAAKT,OAAA,CAAAmD,eAAe,CAACC,IAAI,EAAE;YACzC;;UAEF,MAAMC,eAAe,GAAGL,eAAe,CAACM,IAAI,CAACjB,OAAO,CAACH,KAAK,CAAC;UAE3D,IAAImB,eAAe,EAAE;YACnB,IACGA,eAAe,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIjC,KAAK,KAAK,OAAO,IACnDiC,eAAe,CAAC,CAAC,CAAC,KAAK,MAAM,IAAIlC,IAAI,KAAK,OAAQ,IAClDkC,eAAe,CAAC,CAAC,CAAC,KAAK,KAAK,IAAIpC,GAAG,KAAK,OAAQ,EACjD;cACAO,OAAO,CAACW,MAAM,CAAC;gBACbC,IAAI,EAAEC,OAAO;gBACbC,SAAS,EAAE,sBAAsB;gBACjCC,IAAI,EAAE;kBACJC,MAAM,EAAEa,eAAe,CAAC,CAAC;;eAE5B,CAAC;cACF;;YAEF,IAAIA,eAAe,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIjC,KAAK,KAAK,eAAe,EAAE;cAC/DQ,UAAU,CAAC2B,IAAI,CAAC;gBAAElB,OAAO;gBAAEJ,UAAU,EAAEoB,eAAe,CAAC,CAAC;cAAC,CAAE,CAAC;;;QAGlE,CAAC,CAAC;MACJ;KACD;EACH;CACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}