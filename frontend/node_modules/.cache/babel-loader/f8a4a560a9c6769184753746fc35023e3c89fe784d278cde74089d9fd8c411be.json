{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst util_1 = require(\"../util\");\nvar ArgumentType;\n(function (ArgumentType) {\n  ArgumentType[ArgumentType[\"Other\"] = 0] = \"Other\";\n  ArgumentType[ArgumentType[\"String\"] = 1] = \"String\";\n  ArgumentType[ArgumentType[\"RegExp\"] = 2] = \"RegExp\";\n  ArgumentType[ArgumentType[\"Both\"] = 3] = \"Both\";\n})(ArgumentType || (ArgumentType = {}));\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-regexp-exec',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Enforce `RegExp#exec` over `String#match` if no global flag is provided',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      regExpExecOverStringMatch: 'Use the `RegExp#exec()` method instead.'\n    },\n    schema: []\n  },\n  create(context) {\n    const globalScope = context.getScope();\n    const parserServices = (0, util_1.getParserServices)(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check if a given node type is a string.\n     * @param node The node type to check.\n     */\n    function isStringType(type) {\n      return (0, util_1.getTypeName)(typeChecker, type) === 'string';\n    }\n    /**\n     * Check if a given node type is a RegExp.\n     * @param node The node type to check.\n     */\n    function isRegExpType(type) {\n      return (0, util_1.getTypeName)(typeChecker, type) === 'RegExp';\n    }\n    function collectArgumentTypes(types) {\n      let result = ArgumentType.Other;\n      for (const type of types) {\n        if (isRegExpType(type)) {\n          result |= ArgumentType.RegExp;\n        } else if (isStringType(type)) {\n          result |= ArgumentType.String;\n        }\n      }\n      return result;\n    }\n    function isLikelyToContainGlobalFlag(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression || node.type === utils_1.AST_NODE_TYPES.NewExpression) {\n        const [, flags] = node.arguments;\n        return flags && flags.type === utils_1.AST_NODE_TYPES.Literal && typeof flags.value === 'string' && flags.value.includes('g');\n      }\n      return node.type === utils_1.AST_NODE_TYPES.Identifier;\n    }\n    return {\n      \"CallExpression[arguments.length=1] > MemberExpression.callee[property.name='match'][computed=false]\"(memberNode) {\n        const objectNode = memberNode.object;\n        const callNode = memberNode.parent;\n        const [argumentNode] = callNode.arguments;\n        const argumentValue = (0, util_1.getStaticValue)(argumentNode, globalScope);\n        if (!isStringType(typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(objectNode)))) {\n          return;\n        }\n        // Don't report regular expressions with global flag.\n        if (!argumentValue && isLikelyToContainGlobalFlag(argumentNode) || argumentValue && argumentValue.value instanceof RegExp && argumentValue.value.flags.includes('g')) {\n          return;\n        }\n        if (argumentNode.type === utils_1.AST_NODE_TYPES.Literal && typeof argumentNode.value === 'string') {\n          let regExp;\n          try {\n            regExp = RegExp(argumentNode.value);\n          } catch (_a) {\n            return;\n          }\n          return context.report({\n            node: memberNode.property,\n            messageId: 'regExpExecOverStringMatch',\n            fix: (0, util_1.getWrappingFixer)({\n              sourceCode,\n              node: callNode,\n              innerNode: [objectNode],\n              wrap: objectCode => `${regExp.toString()}.exec(${objectCode})`\n            })\n          });\n        }\n        const argumentType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(argumentNode));\n        const argumentTypes = collectArgumentTypes(tsutils.unionTypeParts(argumentType));\n        switch (argumentTypes) {\n          case ArgumentType.RegExp:\n            return context.report({\n              node: memberNode.property,\n              messageId: 'regExpExecOverStringMatch',\n              fix: (0, util_1.getWrappingFixer)({\n                sourceCode,\n                node: callNode,\n                innerNode: [objectNode, argumentNode],\n                wrap: (objectCode, argumentCode) => `${argumentCode}.exec(${objectCode})`\n              })\n            });\n          case ArgumentType.String:\n            return context.report({\n              node: memberNode.property,\n              messageId: 'regExpExecOverStringMatch',\n              fix: (0, util_1.getWrappingFixer)({\n                sourceCode,\n                node: callNode,\n                innerNode: [objectNode, argumentNode],\n                wrap: (objectCode, argumentCode) => `RegExp(${argumentCode}).exec(${objectCode})`\n              })\n            });\n        }\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","util_1","ArgumentType","exports","default","createRule","name","defaultOptions","meta","type","fixable","docs","description","recommended","requiresTypeChecking","messages","regExpExecOverStringMatch","schema","create","context","globalScope","getScope","parserServices","getParserServices","typeChecker","program","getTypeChecker","sourceCode","getSourceCode","isStringType","getTypeName","isRegExpType","collectArgumentTypes","types","result","Other","RegExp","String","isLikelyToContainGlobalFlag","node","AST_NODE_TYPES","CallExpression","NewExpression","flags","arguments","Literal","value","includes","Identifier","CallExpression[arguments.length=1] > MemberExpression.callee[property.name='match'][computed=false]","memberNode","objectNode","object","callNode","parent","argumentNode","argumentValue","getStaticValue","getTypeAtLocation","esTreeNodeToTSNodeMap","get","regExp","_a","report","property","messageId","fix","getWrappingFixer","innerNode","wrap","objectCode","toString","argumentType","argumentTypes","unionTypeParts","argumentCode"],"sources":["../../src/rules/prefer-regexp-exec.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}