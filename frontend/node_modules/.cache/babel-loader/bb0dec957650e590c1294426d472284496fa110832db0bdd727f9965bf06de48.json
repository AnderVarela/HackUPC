{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nexports.default = util.createRule({\n  name: 'no-confusing-void-expression',\n  meta: {\n    docs: {\n      description: 'Require expressions of type void to appear in statement position',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      invalidVoidExpr: 'Placing a void expression inside another expression is forbidden. ' + 'Move it to its own statement instead.',\n      invalidVoidExprWrapVoid: 'Void expressions used inside another expression ' + 'must be moved to its own statement ' + 'or marked explicitly with the `void` operator.',\n      invalidVoidExprArrow: 'Returning a void expression from an arrow function shorthand is forbidden. ' + 'Please add braces to the arrow function.',\n      invalidVoidExprArrowWrapVoid: 'Void expressions returned from an arrow function shorthand ' + 'must be marked explicitly with the `void` operator.',\n      invalidVoidExprReturn: 'Returning a void expression from a function is forbidden. ' + 'Please move it before the `return` statement.',\n      invalidVoidExprReturnLast: 'Returning a void expression from a function is forbidden. ' + 'Please remove the `return` statement.',\n      invalidVoidExprReturnWrapVoid: 'Void expressions returned from a function ' + 'must be marked explicitly with the `void` operator.',\n      voidExprWrapVoid: 'Mark with an explicit `void` operator.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreArrowShorthand: {\n          type: 'boolean'\n        },\n        ignoreVoidOperator: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem',\n    fixable: 'code',\n    hasSuggestions: true\n  },\n  defaultOptions: [{}],\n  create(context, [options]) {\n    return {\n      'AwaitExpression, CallExpression, TaggedTemplateExpression'(node) {\n        const parserServices = util.getParserServices(context);\n        const checker = parserServices.program.getTypeChecker();\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = util.getConstrainedTypeAtLocation(checker, tsNode);\n        if (!tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike)) {\n          // not a void expression\n          return;\n        }\n        const invalidAncestor = findInvalidAncestor(node);\n        if (invalidAncestor == null) {\n          // void expression is in valid position\n          return;\n        }\n        const sourceCode = context.getSourceCode();\n        const wrapVoidFix = fixer => {\n          const nodeText = sourceCode.getText(node);\n          const newNodeText = `void ${nodeText}`;\n          return fixer.replaceText(node, newNodeText);\n        };\n        if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n          // handle arrow function shorthand\n          if (options.ignoreVoidOperator) {\n            // handle wrapping with `void`\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprArrowWrapVoid',\n              fix: wrapVoidFix\n            });\n          }\n          // handle wrapping with braces\n          const arrowFunction = invalidAncestor;\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprArrow',\n            fix(fixer) {\n              const arrowBody = arrowFunction.body;\n              const arrowBodyText = sourceCode.getText(arrowBody);\n              const newArrowBodyText = `{ ${arrowBodyText}; }`;\n              if (util.isParenthesized(arrowBody, sourceCode)) {\n                const bodyOpeningParen = sourceCode.getTokenBefore(arrowBody, util.isOpeningParenToken);\n                const bodyClosingParen = sourceCode.getTokenAfter(arrowBody, util.isClosingParenToken);\n                return fixer.replaceTextRange([bodyOpeningParen.range[0], bodyClosingParen.range[1]], newArrowBodyText);\n              }\n              return fixer.replaceText(arrowBody, newArrowBodyText);\n            }\n          });\n        }\n        if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ReturnStatement) {\n          // handle return statement\n          if (options.ignoreVoidOperator) {\n            // handle wrapping with `void`\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprReturnWrapVoid',\n              fix: wrapVoidFix\n            });\n          }\n          const returnStmt = invalidAncestor;\n          if (isFinalReturn(returnStmt)) {\n            // remove the `return` keyword\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprReturnLast',\n              fix(fixer) {\n                const returnValue = returnStmt.argument;\n                const returnValueText = sourceCode.getText(returnValue);\n                let newReturnStmtText = `${returnValueText};`;\n                if (isPreventingASI(returnValue, sourceCode)) {\n                  // put a semicolon at the beginning of the line\n                  newReturnStmtText = `;${newReturnStmtText}`;\n                }\n                return fixer.replaceText(returnStmt, newReturnStmtText);\n              }\n            });\n          }\n          // move before the `return` keyword\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprReturn',\n            fix(fixer) {\n              var _a;\n              const returnValue = returnStmt.argument;\n              const returnValueText = sourceCode.getText(returnValue);\n              let newReturnStmtText = `${returnValueText}; return;`;\n              if (isPreventingASI(returnValue, sourceCode)) {\n                // put a semicolon at the beginning of the line\n                newReturnStmtText = `;${newReturnStmtText}`;\n              }\n              if (((_a = returnStmt.parent) === null || _a === void 0 ? void 0 : _a.type) !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                // e.g. `if (cond) return console.error();`\n                // add braces if not inside a block\n                newReturnStmtText = `{ ${newReturnStmtText} }`;\n              }\n              return fixer.replaceText(returnStmt, newReturnStmtText);\n            }\n          });\n        }\n        // handle generic case\n        if (options.ignoreVoidOperator) {\n          // this would be reported by this rule btw. such irony\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprWrapVoid',\n            suggest: [{\n              messageId: 'voidExprWrapVoid',\n              fix: wrapVoidFix\n            }]\n          });\n        }\n        context.report({\n          node,\n          messageId: 'invalidVoidExpr'\n        });\n      }\n    };\n    /**\n     * Inspects the void expression's ancestors and finds closest invalid one.\n     * By default anything other than an ExpressionStatement is invalid.\n     * Parent expressions which can be used for their short-circuiting behavior\n     * are ignored and their parents are checked instead.\n     * @param node The void expression node to check.\n     * @returns Invalid ancestor node if it was found. `null` otherwise.\n     */\n    function findInvalidAncestor(node) {\n      const parent = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n      if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n        if (node !== parent.expressions[parent.expressions.length - 1]) {\n          return null;\n        }\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n        // e.g. `{ console.log(\"foo\"); }`\n        // this is always valid\n        return null;\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n        if (parent.right === node) {\n          // e.g. `x && console.log(x)`\n          // this is valid only if the next ancestor is valid\n          return findInvalidAncestor(parent);\n        }\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        if (parent.consequent === node || parent.alternate === node) {\n          // e.g. `cond ? console.log(true) : console.log(false)`\n          // this is valid only if the next ancestor is valid\n          return findInvalidAncestor(parent);\n        }\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n        // e.g. `() => console.log(\"foo\")`\n        // this is valid with an appropriate option\n        if (options.ignoreArrowShorthand) {\n          return null;\n        }\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.UnaryExpression) {\n        if (parent.operator === 'void') {\n          // e.g. `void console.log(\"foo\")`\n          // this is valid with an appropriate option\n          if (options.ignoreVoidOperator) {\n            return null;\n          }\n        }\n      }\n      if (parent.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        // e.g. `console?.log('foo')`\n        return findInvalidAncestor(parent);\n      }\n      // any other parent is invalid\n      return parent;\n    }\n    /** Checks whether the return statement is the last statement in a function body. */\n    function isFinalReturn(node) {\n      // the parent must be a block\n      const block = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n      if (block.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n        // e.g. `if (cond) return;` (not in a block)\n        return false;\n      }\n      // the block's parent must be a function\n      const blockParent = util.nullThrows(block.parent, util.NullThrowsReasons.MissingParent);\n      if (![utils_1.AST_NODE_TYPES.FunctionDeclaration, utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.ArrowFunctionExpression].includes(blockParent.type)) {\n        // e.g. `if (cond) { return; }`\n        // not in a top-level function block\n        return false;\n      }\n      // must be the last child of the block\n      if (block.body.indexOf(node) < block.body.length - 1) {\n        // not the last statement in the block\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Checks whether the given node, if placed on its own line,\n     * would prevent automatic semicolon insertion on the line before.\n     *\n     * This happens if the line begins with `(`, `[` or `` ` ``\n     */\n    function isPreventingASI(node, sourceCode) {\n      const startToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('first token', node.type));\n      return ['(', '[', '`'].includes(startToken.value);\n    }\n  }\n});","map":{"version":3,"names":["utils_1","require","tsutils","__importStar","ts","util","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","invalidVoidExpr","invalidVoidExprWrapVoid","invalidVoidExprArrow","invalidVoidExprArrowWrapVoid","invalidVoidExprReturn","invalidVoidExprReturnLast","invalidVoidExprReturnWrapVoid","voidExprWrapVoid","schema","type","properties","ignoreArrowShorthand","ignoreVoidOperator","additionalProperties","fixable","hasSuggestions","defaultOptions","create","context","options","AwaitExpression, CallExpression, TaggedTemplateExpression","node","parserServices","getParserServices","checker","program","getTypeChecker","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","isTypeFlagSet","TypeFlags","VoidLike","invalidAncestor","findInvalidAncestor","sourceCode","getSourceCode","wrapVoidFix","fixer","nodeText","getText","newNodeText","replaceText","AST_NODE_TYPES","ArrowFunctionExpression","report","messageId","fix","arrowFunction","arrowBody","body","arrowBodyText","newArrowBodyText","isParenthesized","bodyOpeningParen","getTokenBefore","isOpeningParenToken","bodyClosingParen","getTokenAfter","isClosingParenToken","replaceTextRange","range","ReturnStatement","returnStmt","isFinalReturn","returnValue","argument","returnValueText","newReturnStmtText","isPreventingASI","_a","parent","BlockStatement","suggest","nullThrows","NullThrowsReasons","MissingParent","SequenceExpression","expressions","length","ExpressionStatement","LogicalExpression","right","ConditionalExpression","consequent","alternate","UnaryExpression","operator","ChainExpression","block","blockParent","FunctionDeclaration","FunctionExpression","includes","indexOf","startToken","getFirstToken","MissingToken","value"],"sources":["../../src/rules/no-confusing-void-expression.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}