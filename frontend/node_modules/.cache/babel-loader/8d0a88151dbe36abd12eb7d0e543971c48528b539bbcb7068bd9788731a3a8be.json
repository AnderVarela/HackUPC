{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\nconst arrify = item => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n  return string => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n  const path = normalizePath(_path, false);\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG).map(matcher => createPattern(matcher, opts));\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":{"version":3,"names":["Object","defineProperty","exports","value","picomatch","require","normalizePath","BANG","DEFAULT_OPTIONS","returnIndex","arrify","item","Array","isArray","createPattern","matcher","options","glob","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","TypeError","prototype","toString","call","path","index","length","nglob","applied","concat","slice","pattern","anymatch","matchers","testString","opts","mtchers","negatedGlobs","filter","charAt","map","ri","default","module"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/anymatch/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}