{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-return-this-type',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce that `this` is used when only `this` type is returned',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      useThisType: 'Use `this` type instead.'\n    },\n    schema: [],\n    fixable: 'code'\n  },\n  create(context) {\n    const parserServices = (0, util_1.getParserServices)(context);\n    const checker = parserServices.program.getTypeChecker();\n    function tryGetNameInType(name, typeNode) {\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSTypeReference && typeNode.typeName.type === utils_1.AST_NODE_TYPES.Identifier && typeNode.typeName.name === name) {\n        return typeNode;\n      }\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n        for (const type of typeNode.types) {\n          const found = tryGetNameInType(name, type);\n          if (found) {\n            return found;\n          }\n        }\n      }\n      return undefined;\n    }\n    function isThisSpecifiedInParameters(originalFunc) {\n      const firstArg = originalFunc.params[0];\n      return firstArg && firstArg.type === utils_1.AST_NODE_TYPES.Identifier && firstArg.name === 'this';\n    }\n    function isFunctionReturningThis(originalFunc, originalClass) {\n      if (isThisSpecifiedInParameters(originalFunc)) {\n        return false;\n      }\n      const func = parserServices.esTreeNodeToTSNodeMap.get(originalFunc);\n      if (!func.body) {\n        return false;\n      }\n      const classType = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(originalClass));\n      if (func.body.kind !== ts.SyntaxKind.Block) {\n        const type = checker.getTypeAtLocation(func.body);\n        return classType.thisType === type;\n      }\n      let hasReturnThis = false;\n      let hasReturnClassType = false;\n      (0, util_1.forEachReturnStatement)(func.body, stmt => {\n        const expr = stmt.expression;\n        if (!expr) {\n          return;\n        }\n        // fast check\n        if (expr.kind === ts.SyntaxKind.ThisKeyword) {\n          hasReturnThis = true;\n          return;\n        }\n        const type = checker.getTypeAtLocation(expr);\n        if (classType === type) {\n          hasReturnClassType = true;\n          return true;\n        }\n        if (classType.thisType === type) {\n          hasReturnThis = true;\n          return;\n        }\n        return;\n      });\n      return !hasReturnClassType && hasReturnThis;\n    }\n    function checkFunction(originalFunc, originalClass) {\n      var _a;\n      const className = (_a = originalClass.id) === null || _a === void 0 ? void 0 : _a.name;\n      if (!className || !originalFunc.returnType) {\n        return;\n      }\n      const node = tryGetNameInType(className, originalFunc.returnType.typeAnnotation);\n      if (!node) {\n        return;\n      }\n      if (isFunctionReturningThis(originalFunc, originalClass)) {\n        context.report({\n          node,\n          messageId: 'useThisType',\n          fix: fixer => fixer.replaceText(node, 'this')\n        });\n      }\n    }\n    return {\n      'ClassBody > MethodDefinition'(node) {\n        checkFunction(node.value, node.parent.parent);\n      },\n      'ClassBody > PropertyDefinition'(node) {\n        var _a, _b;\n        if (!(((_a = node.value) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.FunctionExpression || ((_b = node.value) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {\n          return;\n        }\n        checkFunction(node.value, node.parent.parent);\n      }\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","ts","__importStar","util_1","exports","default","createRule","name","defaultOptions","meta","type","docs","description","recommended","requiresTypeChecking","messages","useThisType","schema","fixable","create","context","parserServices","getParserServices","checker","program","getTypeChecker","tryGetNameInType","typeNode","AST_NODE_TYPES","TSTypeReference","typeName","Identifier","TSUnionType","types","found","undefined","isThisSpecifiedInParameters","originalFunc","firstArg","params","isFunctionReturningThis","originalClass","func","esTreeNodeToTSNodeMap","get","body","classType","getTypeAtLocation","kind","SyntaxKind","Block","thisType","hasReturnThis","hasReturnClassType","forEachReturnStatement","stmt","expr","expression","ThisKeyword","checkFunction","className","_a","id","returnType","node","typeAnnotation","report","messageId","fix","fixer","replaceText","ClassBody > MethodDefinition","value","parent","ClassBody > PropertyDefinition","FunctionExpression","_b","ArrowFunctionExpression"],"sources":["../../src/rules/prefer-return-this-type.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}