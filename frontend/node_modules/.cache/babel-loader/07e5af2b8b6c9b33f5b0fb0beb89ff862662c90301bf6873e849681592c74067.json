{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  traverse,\n  assertVersion\n}) => {\n  assertVersion(7);\n  const containsClassExpressionVisitor = {\n    ClassExpression(path, state) {\n      state.found = true;\n      path.stop();\n    },\n    Function(path) {\n      path.skip();\n    }\n  };\n  const containsYieldOrAwaitVisitor = traverse.visitors.merge([{\n    YieldExpression(path, state) {\n      state.yield = true;\n      if (state.await) path.stop();\n    },\n    AwaitExpression(path, state) {\n      state.await = true;\n      if (state.yield) path.stop();\n    }\n  }, _helperEnvironmentVisitor.default]);\n  function containsClassExpression(path) {\n    if (t.isClassExpression(path.node)) return true;\n    if (t.isFunction(path.node)) return false;\n    const state = {\n      found: false\n    };\n    path.traverse(containsClassExpressionVisitor, state);\n    return state.found;\n  }\n  function wrap(path) {\n    const context = {\n      yield: t.isYieldExpression(path.node),\n      await: t.isAwaitExpression(path.node)\n    };\n    path.traverse(containsYieldOrAwaitVisitor, context);\n    let replacement;\n    if (context.yield) {\n      const fn = t.functionExpression(null, [], t.blockStatement([t.returnStatement(path.node)]), true, context.await);\n      replacement = t.yieldExpression(t.callExpression(t.memberExpression(fn, t.identifier(\"call\")), [t.thisExpression(), t.identifier(\"arguments\")]), true);\n    } else {\n      const fn = t.arrowFunctionExpression([], path.node, context.await);\n      replacement = t.callExpression(fn, []);\n      if (context.await) replacement = t.awaitExpression(replacement);\n    }\n    path.replaceWith(replacement);\n  }\n  return {\n    name: \"bugfix-firefox-class-in-computed-class-key\",\n    visitor: {\n      Class(path) {\n        const hasPrivateElement = path.node.body.body.some(node => t.isPrivate(node));\n        if (!hasPrivateElement) return;\n        for (const elem of path.get(\"body.body\")) {\n          if (\"computed\" in elem.node && elem.node.computed && containsClassExpression(elem.get(\"key\"))) {\n            wrap(elem.get(\"key\"));\n          }\n        }\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperEnvironmentVisitor","_default","exports","default","declare","types","t","traverse","assertVersion","containsClassExpressionVisitor","ClassExpression","path","state","found","stop","Function","skip","containsYieldOrAwaitVisitor","visitors","merge","YieldExpression","yield","await","AwaitExpression","containsClassExpression","isClassExpression","node","isFunction","wrap","context","isYieldExpression","isAwaitExpression","replacement","fn","functionExpression","blockStatement","returnStatement","yieldExpression","callExpression","memberExpression","identifier","thisExpression","arrowFunctionExpression","awaitExpression","replaceWith","name","visitor","Class","hasPrivateElement","body","some","isPrivate","elem","get","computed"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-bugfix-firefox-class-in-computed-class-key\\src\\index.ts"],"sourcesContent":["import type { NodePath, Visitor } from \"@babel/traverse\";\nimport type { types as t } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\n\nexport default declare(({ types: t, traverse, assertVersion }) => {\n  assertVersion(REQUIRED_VERSION(7));\n\n  const containsClassExpressionVisitor: Visitor<{ found: boolean }> = {\n    ClassExpression(path, state) {\n      state.found = true;\n      path.stop();\n    },\n    Function(path) {\n      path.skip();\n    },\n  };\n\n  const containsYieldOrAwaitVisitor = traverse.visitors.merge([\n    {\n      YieldExpression(path, state) {\n        state.yield = true;\n        if (state.await) path.stop();\n      },\n      AwaitExpression(path, state) {\n        state.await = true;\n        if (state.yield) path.stop();\n      },\n    } satisfies Visitor<{ yield: boolean; await: boolean }>,\n    environmentVisitor,\n  ]);\n\n  function containsClassExpression(path: NodePath<t.Node>) {\n    if (t.isClassExpression(path.node)) return true;\n    if (t.isFunction(path.node)) return false;\n    const state = { found: false };\n    path.traverse(containsClassExpressionVisitor, state);\n    return state.found;\n  }\n\n  function wrap(path: NodePath<t.Expression>) {\n    const context = {\n      yield: t.isYieldExpression(path.node),\n      await: t.isAwaitExpression(path.node),\n    };\n    path.traverse(containsYieldOrAwaitVisitor, context);\n\n    let replacement;\n\n    if (context.yield) {\n      const fn = t.functionExpression(\n        null,\n        [],\n        t.blockStatement([t.returnStatement(path.node)]),\n        /* generator */ true,\n        /* async */ context.await,\n      );\n\n      replacement = t.yieldExpression(\n        t.callExpression(t.memberExpression(fn, t.identifier(\"call\")), [\n          t.thisExpression(),\n          // NOTE: In some context arguments is invalid (it might not be defined\n          // in the top-level scope, or it's a syntax error in static class blocks).\n          // However, `yield` is also invalid in those contexts, so we can safely\n          // inject a reference to arguments.\n          t.identifier(\"arguments\"),\n        ]),\n        true,\n      );\n    } else {\n      const fn = t.arrowFunctionExpression([], path.node, context.await);\n\n      replacement = t.callExpression(fn, []);\n      if (context.await) replacement = t.awaitExpression(replacement);\n    }\n\n    path.replaceWith(replacement);\n  }\n\n  return {\n    name: \"bugfix-firefox-class-in-computed-class-key\",\n\n    visitor: {\n      Class(path) {\n        const hasPrivateElement = path.node.body.body.some(node =>\n          t.isPrivate(node),\n        );\n        if (!hasPrivateElement) return;\n\n        for (const elem of path.get(\"body.body\")) {\n          if (\n            \"computed\" in elem.node &&\n            elem.node.computed &&\n            containsClassExpression(elem.get(\"key\"))\n          ) {\n            wrap(\n              // @ts-expect-error .key also includes t.PrivateName\n              elem.get(\"key\") satisfies NodePath<t.Expression>,\n            );\n          }\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}