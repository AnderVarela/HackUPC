{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidator = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../../util\"));\nconst enums_1 = require(\"./enums\");\nconst format_1 = require(\"./format\");\nconst shared_1 = require(\"./shared\");\nfunction createValidator(type, context, allConfigs) {\n  // make sure the \"highest priority\" configs are checked first\n  const selectorType = enums_1.Selectors[type];\n  const configs = allConfigs\n  // gather all of the applicable selectors\n  .filter(c => (c.selector & selectorType) !== 0 || c.selector === enums_1.MetaSelectors.default).sort((a, b) => {\n    if (a.selector === b.selector) {\n      // in the event of the same selector, order by modifier weight\n      // sort descending - the type modifiers are \"more important\"\n      return b.modifierWeight - a.modifierWeight;\n    }\n    const aIsMeta = (0, shared_1.isMetaSelector)(a.selector);\n    const bIsMeta = (0, shared_1.isMetaSelector)(b.selector);\n    // non-meta selectors should go ahead of meta selectors\n    if (aIsMeta && !bIsMeta) {\n      return 1;\n    }\n    if (!aIsMeta && bIsMeta) {\n      return -1;\n    }\n    const aIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(a.selector);\n    const bIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(b.selector);\n    // for backward compatibility, method and property have higher precedence than other meta selectors\n    if (aIsMethodOrProperty && !bIsMethodOrProperty) {\n      return -1;\n    }\n    if (!aIsMethodOrProperty && bIsMethodOrProperty) {\n      return 1;\n    }\n    // both aren't meta selectors\n    // sort descending - the meta selectors are \"least important\"\n    return b.selector - a.selector;\n  });\n  return (node, modifiers = new Set()) => {\n    var _a, _b, _c;\n    const originalName = node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier ? node.name : `${node.value}`;\n    // return will break the loop and stop checking configs\n    // it is only used when the name is known to have failed or succeeded a config.\n    for (const config of configs) {\n      if (((_a = config.filter) === null || _a === void 0 ? void 0 : _a.regex.test(originalName)) !== ((_b = config.filter) === null || _b === void 0 ? void 0 : _b.match)) {\n        // name does not match the filter\n        continue;\n      }\n      if ((_c = config.modifiers) === null || _c === void 0 ? void 0 : _c.some(modifier => !modifiers.has(modifier))) {\n        // does not have the required modifiers\n        continue;\n      }\n      if (!isCorrectType(node, config, context, selectorType)) {\n        // is not the correct type\n        continue;\n      }\n      let name = originalName;\n      name = validateUnderscore('leading', config, name, node, originalName);\n      if (name == null) {\n        // fail\n        return;\n      }\n      name = validateUnderscore('trailing', config, name, node, originalName);\n      if (name == null) {\n        // fail\n        return;\n      }\n      name = validateAffix('prefix', config, name, node, originalName);\n      if (name == null) {\n        // fail\n        return;\n      }\n      name = validateAffix('suffix', config, name, node, originalName);\n      if (name == null) {\n        // fail\n        return;\n      }\n      if (!validateCustom(config, name, node, originalName)) {\n        // fail\n        return;\n      }\n      if (!validatePredefinedFormat(config, name, node, originalName, modifiers)) {\n        // fail\n        return;\n      }\n      // it's valid for this config, so we don't need to check any more configs\n      return;\n    }\n  };\n  // centralizes the logic for formatting the report data\n  function formatReportData({\n    affixes,\n    formats,\n    originalName,\n    processedName,\n    position,\n    custom,\n    count\n  }) {\n    var _a;\n    return {\n      type: (0, shared_1.selectorTypeToMessageString)(type),\n      name: originalName,\n      processedName,\n      position,\n      count,\n      affixes: affixes === null || affixes === void 0 ? void 0 : affixes.join(', '),\n      formats: formats === null || formats === void 0 ? void 0 : formats.map(f => enums_1.PredefinedFormats[f]).join(', '),\n      regex: (_a = custom === null || custom === void 0 ? void 0 : custom.regex) === null || _a === void 0 ? void 0 : _a.toString(),\n      regexMatch: (custom === null || custom === void 0 ? void 0 : custom.match) === true ? 'match' : (custom === null || custom === void 0 ? void 0 : custom.match) === false ? 'not match' : null\n    };\n  }\n  /**\n   * @returns the name with the underscore removed, if it is valid according to the specified underscore option, null otherwise\n   */\n  function validateUnderscore(position, config, name, node, originalName) {\n    const option = position === 'leading' ? config.leadingUnderscore : config.trailingUnderscore;\n    if (!option) {\n      return name;\n    }\n    const hasSingleUnderscore = position === 'leading' ? () => name.startsWith('_') : () => name.endsWith('_');\n    const trimSingleUnderscore = position === 'leading' ? () => name.slice(1) : () => name.slice(0, -1);\n    const hasDoubleUnderscore = position === 'leading' ? () => name.startsWith('__') : () => name.endsWith('__');\n    const trimDoubleUnderscore = position === 'leading' ? () => name.slice(2) : () => name.slice(0, -2);\n    switch (option) {\n      // ALLOW - no conditions as the user doesn't care if it's there or not\n      case enums_1.UnderscoreOptions.allow:\n        {\n          if (hasSingleUnderscore()) {\n            return trimSingleUnderscore();\n          }\n          return name;\n        }\n      case enums_1.UnderscoreOptions.allowDouble:\n        {\n          if (hasDoubleUnderscore()) {\n            return trimDoubleUnderscore();\n          }\n          return name;\n        }\n      case enums_1.UnderscoreOptions.allowSingleOrDouble:\n        {\n          if (hasDoubleUnderscore()) {\n            return trimDoubleUnderscore();\n          }\n          if (hasSingleUnderscore()) {\n            return trimSingleUnderscore();\n          }\n          return name;\n        }\n      // FORBID\n      case enums_1.UnderscoreOptions.forbid:\n        {\n          if (hasSingleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'unexpectedUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'one'\n              })\n            });\n            return null;\n          }\n          return name;\n        }\n      // REQUIRE\n      case enums_1.UnderscoreOptions.require:\n        {\n          if (!hasSingleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'missingUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'one'\n              })\n            });\n            return null;\n          }\n          return trimSingleUnderscore();\n        }\n      case enums_1.UnderscoreOptions.requireDouble:\n        {\n          if (!hasDoubleUnderscore()) {\n            context.report({\n              node,\n              messageId: 'missingUnderscore',\n              data: formatReportData({\n                originalName,\n                position,\n                count: 'two'\n              })\n            });\n            return null;\n          }\n          return trimDoubleUnderscore();\n        }\n    }\n  }\n  /**\n   * @returns the name with the affix removed, if it is valid according to the specified affix option, null otherwise\n   */\n  function validateAffix(position, config, name, node, originalName) {\n    const affixes = config[position];\n    if (!affixes || affixes.length === 0) {\n      return name;\n    }\n    for (const affix of affixes) {\n      const hasAffix = position === 'prefix' ? name.startsWith(affix) : name.endsWith(affix);\n      const trimAffix = position === 'prefix' ? () => name.slice(affix.length) : () => name.slice(0, -affix.length);\n      if (hasAffix) {\n        // matches, so trim it and return\n        return trimAffix();\n      }\n    }\n    context.report({\n      node,\n      messageId: 'missingAffix',\n      data: formatReportData({\n        originalName,\n        position,\n        affixes\n      })\n    });\n    return null;\n  }\n  /**\n   * @returns true if the name is valid according to the `regex` option, false otherwise\n   */\n  function validateCustom(config, name, node, originalName) {\n    const custom = config.custom;\n    if (!custom) {\n      return true;\n    }\n    const result = custom.regex.test(name);\n    if (custom.match && result) {\n      return true;\n    }\n    if (!custom.match && !result) {\n      return true;\n    }\n    context.report({\n      node,\n      messageId: 'satisfyCustom',\n      data: formatReportData({\n        originalName,\n        custom\n      })\n    });\n    return false;\n  }\n  /**\n   * @returns true if the name is valid according to the `format` option, false otherwise\n   */\n  function validatePredefinedFormat(config, name, node, originalName, modifiers) {\n    const formats = config.format;\n    if (!(formats === null || formats === void 0 ? void 0 : formats.length)) {\n      return true;\n    }\n    if (!modifiers.has(enums_1.Modifiers.requiresQuotes)) {\n      for (const format of formats) {\n        const checker = format_1.PredefinedFormatToCheckFunction[format];\n        if (checker(name)) {\n          return true;\n        }\n      }\n    }\n    context.report({\n      node,\n      messageId: originalName === name ? 'doesNotMatchFormat' : 'doesNotMatchFormatTrimmed',\n      data: formatReportData({\n        originalName,\n        processedName: name,\n        formats\n      })\n    });\n    return false;\n  }\n}\nexports.createValidator = createValidator;\nconst SelectorsAllowedToHaveTypes = enums_1.Selectors.variable | enums_1.Selectors.parameter | enums_1.Selectors.classProperty | enums_1.Selectors.objectLiteralProperty | enums_1.Selectors.typeProperty | enums_1.Selectors.parameterProperty | enums_1.Selectors.accessor;\nfunction isCorrectType(node, config, context, selector) {\n  if (config.types == null) {\n    return true;\n  }\n  if ((SelectorsAllowedToHaveTypes & selector) === 0) {\n    return true;\n  }\n  const {\n    esTreeNodeToTSNodeMap,\n    program\n  } = util.getParserServices(context);\n  const checker = program.getTypeChecker();\n  const tsNode = esTreeNodeToTSNodeMap.get(node);\n  const type = checker.getTypeAtLocation(tsNode)\n  // remove null and undefined from the type, as we don't care about it here\n  .getNonNullableType();\n  for (const allowedType of config.types) {\n    switch (allowedType) {\n      case enums_1.TypeModifiers.array:\n        if (isAllTypesMatch(type, t => checker.isArrayType(t) || checker.isTupleType(t))) {\n          return true;\n        }\n        break;\n      case enums_1.TypeModifiers.function:\n        if (isAllTypesMatch(type, t => t.getCallSignatures().length > 0)) {\n          return true;\n        }\n        break;\n      case enums_1.TypeModifiers.boolean:\n      case enums_1.TypeModifiers.number:\n      case enums_1.TypeModifiers.string:\n        {\n          const typeString = checker.typeToString(\n          // this will resolve things like true => boolean, 'a' => string and 1 => number\n          checker.getWidenedType(checker.getBaseTypeOfLiteralType(type)));\n          const allowedTypeString = enums_1.TypeModifiers[allowedType];\n          if (typeString === allowedTypeString) {\n            return true;\n          }\n          break;\n        }\n    }\n  }\n  return false;\n}\n/**\n * @returns `true` if the type (or all union types) in the given type return true for the callback\n */\nfunction isAllTypesMatch(type, cb) {\n  if (type.isUnion()) {\n    return type.types.every(t => cb(t));\n  }\n  return cb(type);\n}","map":{"version":3,"names":["utils_1","require","util","__importStar","enums_1","format_1","shared_1","createValidator","type","context","allConfigs","selectorType","Selectors","configs","filter","c","selector","MetaSelectors","default","sort","a","b","modifierWeight","aIsMeta","isMetaSelector","bIsMeta","aIsMethodOrProperty","isMethodOrPropertySelector","bIsMethodOrProperty","node","modifiers","Set","originalName","AST_NODE_TYPES","Identifier","PrivateIdentifier","name","value","config","_a","regex","test","_b","match","_c","some","modifier","has","isCorrectType","validateUnderscore","validateAffix","validateCustom","validatePredefinedFormat","formatReportData","affixes","formats","processedName","position","custom","count","selectorTypeToMessageString","join","map","f","PredefinedFormats","toString","regexMatch","option","leadingUnderscore","trailingUnderscore","hasSingleUnderscore","startsWith","endsWith","trimSingleUnderscore","slice","hasDoubleUnderscore","trimDoubleUnderscore","UnderscoreOptions","allow","allowDouble","allowSingleOrDouble","forbid","report","messageId","data","requireDouble","length","affix","hasAffix","trimAffix","result","format","Modifiers","requiresQuotes","checker","PredefinedFormatToCheckFunction","exports","SelectorsAllowedToHaveTypes","variable","parameter","classProperty","objectLiteralProperty","typeProperty","parameterProperty","accessor","types","esTreeNodeToTSNodeMap","program","getParserServices","getTypeChecker","tsNode","get","getTypeAtLocation","getNonNullableType","allowedType","TypeModifiers","array","isAllTypesMatch","t","isArrayType","isTupleType","function","getCallSignatures","boolean","number","string","typeString","typeToString","getWidenedType","getBaseTypeOfLiteralType","allowedTypeString","cb","isUnion","every"],"sources":["../../../src/rules/naming-convention-utils/validator.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}