{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { isBlock, isFunc, isIdentifier, numberLiteralFromRaw, traverse } from \"../../index\";\nimport { moduleContextFromModuleAST } from \"../ast-module-to-module-context\"; // FIXME(sven): do the same with all block instructions, must be more generic here\n\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\nexport function transform(ast) {\n  var module = null;\n  traverse(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n      Module.toString = function () {\n        return _Module.toString();\n      };\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  if (module == null) {\n    throw new Error(\"Module not foudn in program\");\n  }\n  var moduleContext = moduleContextFromModuleAST(module); // Transform the actual instruction in function bodies\n\n  traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n      Func.toString = function () {\n        return _Func.toString();\n      };\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n      Start.toString = function () {\n        return _Start.toString();\n      };\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n        path.node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  traverse(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n          firstArg = _instrNode$args[0];\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n          _firstArg = _instrNode$args2[0];\n        if (isIdentifier(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier(\n          // $FlowIgnore: reference?\n          _firstArg.value);\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n          _firstArg2 = _instrNode$args3[0];\n        if (isIdentifier(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n            if (isBlock(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n            if (isFunc(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(relativeBlockCount);\n        }\n      }\n    }),\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n        node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","isBlock","isFunc","isIdentifier","numberLiteralFromRaw","traverse","moduleContextFromModuleAST","newUnexpectedFunction","Error","transform","ast","module","Module","_Module","_x","apply","arguments","path","node","moduleContext","Func","_Func","_x2","transformFuncPath","Start","_Start","_x3","index","offsetInModule","getFunctionOffsetByIdentifier","funcPath","funcNode","signature","type","params","forEach","p","addLocal","valtype","Instr","_Instr","_x4","instrPath","instrNode","id","_instrNode$args","args","firstArg","offsetInParams","findIndex","_ref","concat","_instrNode$args2","_firstArg","globalOffset","getGlobalOffsetByIdentifier","_instrNode$args3","_firstArg2","relativeBlockCount","findParent","_ref2","label","CallInstruction","_CallInstruction","_x5","_ref3"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@webassemblyjs/ast/esm/transform/wast-identifier-to-index/index.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { isBlock, isFunc, isIdentifier, numberLiteralFromRaw, traverse } from \"../../index\";\nimport { moduleContextFromModuleAST } from \"../ast-module-to-module-context\"; // FIXME(sven): do the same with all block instructions, must be more generic here\n\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nexport function transform(ast) {\n  var module = null;\n  traverse(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n\n  if (module == null) {\n    throw new Error(\"Module not foudn in program\");\n  }\n\n  var moduleContext = moduleContextFromModuleAST(module); // Transform the actual instruction in function bodies\n\n  traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  traverse(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if (isIdentifier(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if (isIdentifier(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if (isBlock(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if (isFunc(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}