{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst LT = `[${Array.from(new Set(['\\r\\n', '\\r', '\\n', '\\u2028', '\\u2029'])).join('')}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, 'u');\n/**\n * Creates tester which check if a node starts with specific keyword with the\n * appropriate AST_NODE_TYPES.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\nfunction newKeywordTester(type, keyword) {\n  return {\n    test(node, sourceCode) {\n      var _a;\n      const isSameKeyword = ((_a = sourceCode.getFirstToken(node)) === null || _a === void 0 ? void 0 : _a.value) === keyword;\n      const isSameType = Array.isArray(type) ? type.some(val => val === node.type) : type === node.type;\n      return isSameKeyword && isSameType;\n    }\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test(node, sourceCode) {\n      return node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword;\n    }\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test(node, sourceCode) {\n      return node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword;\n    }\n  };\n}\n/**\n * Creates tester which check if a node is specific type.\n * @param type The node type to test.\n * @returns the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n/**\n * Skips a chain expression node\n * @param node The node to test\n * @returnsA non-chain expression\n * @private\n */\nfunction skipChainExpression(node) {\n  return node && node.type === utils_1.AST_NODE_TYPES.ChainExpression ? node.expression : node;\n}\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param node The node to check.\n * @returns `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n    let expression = skipChainExpression(node.expression);\n    if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression) {\n      expression = skipChainExpression(expression.argument);\n    }\n    if (expression.type === utils_1.AST_NODE_TYPES.CallExpression) {\n      let node = expression.callee;\n      while (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n        node = node.expressions[node.expressions.length - 1];\n      }\n      return util.isFunction(node);\n    }\n  }\n  return false;\n}\n/**\n * Checks the given node is a CommonJS require statement\n * @param node The node to check.\n * @returns `true` if the node is a CommonJS require statement.\n * @private\n */\nfunction isCJSRequire(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n    const declaration = node.declarations[0];\n    if (declaration === null || declaration === void 0 ? void 0 : declaration.init) {\n      let call = declaration === null || declaration === void 0 ? void 0 : declaration.init;\n      while (call.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        call = call.object;\n      }\n      if (call.type === utils_1.AST_NODE_TYPES.CallExpression && call.callee.type === utils_1.AST_NODE_TYPES.Identifier) {\n        return call.callee.name === 'require';\n      }\n    }\n  }\n  return false;\n}\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param sourceCode The source code to get tokens.\n * @param node The node to check.\n * @returns `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(node, sourceCode) {\n  // do-while with a block is a block-like statement.\n  if (node.type === utils_1.AST_NODE_TYPES.DoWhileStatement && node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n    return true;\n  }\n  /**\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n  if (isIIFEStatement(node)) {\n    return true;\n  }\n  // Checks the last token is a closing brace of blocks.\n  const lastToken = sourceCode.getLastToken(node, util.isNotSemicolonToken);\n  const belongingNode = lastToken && util.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return !!belongingNode && (belongingNode.type === utils_1.AST_NODE_TYPES.BlockStatement || belongingNode.type === utils_1.AST_NODE_TYPES.SwitchStatement);\n}\n/**\n * Check whether the given node is a directive or not.\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n  var _a, _b;\n  return node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Program || ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.BlockStatement && util.isFunction(node.parent.parent)) && node.expression.type === utils_1.AST_NODE_TYPES.Literal && typeof node.expression.value === 'string' && !util.isParenthesized(node.expression, sourceCode);\n}\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode) && node.parent && 'body' in node.parent && Array.isArray(node.parent.body)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Checks the given node is a CommonJS export statement\n * @param node The node to check.\n * @returns `true` if the node is a CommonJS export statement.\n * @private\n */\nfunction isCJSExport(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n    const expression = node.expression;\n    if (expression.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {\n      let left = expression.left;\n      if (left.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        while (left.object.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n          left = left.object;\n        }\n        return left.object.type === utils_1.AST_NODE_TYPES.Identifier && (left.object.name === 'exports' || left.object.name === 'module' && left.property.type === utils_1.AST_NODE_TYPES.Identifier && left.property.name === 'exports');\n      }\n    }\n  }\n  return false;\n}\n/**\n * Check whether the given node is an expression\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is an expression\n */\nfunction isExpression(node, sourceCode) {\n  return node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && !isDirectivePrologue(node, sourceCode);\n}\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param sourceCode The source code to get tokens.\n * @param node The node to get.\n * @returns The actual last token.\n * @private\n */\nfunction getActualLastToken(node, sourceCode) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = prevToken && nextToken && prevToken.range[0] >= node.range[0] && util.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line;\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param _ Unused. Whole matched string.\n * @param trailingSpaces The trailing spaces of the first line.\n * @param indentSpaces The indentation spaces of the last line.\n * @returns The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n *\n * @private\n */\nfunction verifyForAny() {\n  // Empty\n}\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param context The rule context to report.\n * @param _ Unused. The previous node to check.\n * @param nextNode The next node to check.\n * @param paddingLines The array of token pairs that blank\n * lines exist between the pair.\n *\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: 'unexpectedBlankLine',\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n  });\n}\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param context The rule context to report.\n * @param prevNode The previous node to check.\n * @param nextNode The next node to check.\n * @param paddingLines The array of token pairs that blank\n * lines exist between the pair.\n *\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n  context.report({\n    node: nextNode,\n    messageId: 'expectedBlankLine',\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(prevNode, sourceCode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param token The token to check.\n         * @returns `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (util.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n          return true;\n        }\n      }) || nextNode;\n      const insertText = util.isTokenOnSameLine(prevToken, nextToken) ? '\\n\\n' : '\\n';\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n  });\n}\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n  '*': {\n    test: () => true\n  },\n  'block-like': {\n    test: isBlockLikeStatement\n  },\n  exports: {\n    test: isCJSExport\n  },\n  require: {\n    test: isCJSRequire\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: isExpression\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  'multiline-block-like': {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(node, sourceCode)\n  },\n  'multiline-expression': {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && !isDirectivePrologue(node, sourceCode)\n  },\n  'multiline-const': newMultilineKeywordTester('const'),\n  'multiline-let': newMultilineKeywordTester('let'),\n  'multiline-var': newMultilineKeywordTester('var'),\n  'singleline-const': newSinglelineKeywordTester('const'),\n  'singleline-let': newSinglelineKeywordTester('let'),\n  'singleline-var': newSinglelineKeywordTester('var'),\n  block: newNodeTypeTester(utils_1.AST_NODE_TYPES.BlockStatement),\n  empty: newNodeTypeTester(utils_1.AST_NODE_TYPES.EmptyStatement),\n  function: newNodeTypeTester(utils_1.AST_NODE_TYPES.FunctionDeclaration),\n  break: newKeywordTester(utils_1.AST_NODE_TYPES.BreakStatement, 'break'),\n  case: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchCase, 'case'),\n  class: newKeywordTester(utils_1.AST_NODE_TYPES.ClassDeclaration, 'class'),\n  const: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'const'),\n  continue: newKeywordTester(utils_1.AST_NODE_TYPES.ContinueStatement, 'continue'),\n  debugger: newKeywordTester(utils_1.AST_NODE_TYPES.DebuggerStatement, 'debugger'),\n  default: newKeywordTester([utils_1.AST_NODE_TYPES.SwitchCase, utils_1.AST_NODE_TYPES.ExportDefaultDeclaration], 'default'),\n  do: newKeywordTester(utils_1.AST_NODE_TYPES.DoWhileStatement, 'do'),\n  export: newKeywordTester([utils_1.AST_NODE_TYPES.ExportDefaultDeclaration, utils_1.AST_NODE_TYPES.ExportNamedDeclaration], 'export'),\n  for: newKeywordTester([utils_1.AST_NODE_TYPES.ForStatement, utils_1.AST_NODE_TYPES.ForInStatement, utils_1.AST_NODE_TYPES.ForOfStatement], 'for'),\n  if: newKeywordTester(utils_1.AST_NODE_TYPES.IfStatement, 'if'),\n  import: newKeywordTester(utils_1.AST_NODE_TYPES.ImportDeclaration, 'import'),\n  let: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'let'),\n  return: newKeywordTester(utils_1.AST_NODE_TYPES.ReturnStatement, 'return'),\n  switch: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchStatement, 'switch'),\n  throw: newKeywordTester(utils_1.AST_NODE_TYPES.ThrowStatement, 'throw'),\n  try: newKeywordTester(utils_1.AST_NODE_TYPES.TryStatement, 'try'),\n  var: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'var'),\n  while: newKeywordTester([utils_1.AST_NODE_TYPES.WhileStatement, utils_1.AST_NODE_TYPES.DoWhileStatement], 'while'),\n  with: newKeywordTester(utils_1.AST_NODE_TYPES.WithStatement, 'with'),\n  // Additional Typescript constructs\n  interface: newKeywordTester(utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, 'interface'),\n  type: newKeywordTester(utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration, 'type')\n};\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nexports.default = util.createRule({\n  name: 'padding-line-between-statements',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require or disallow padding lines between statements',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'whitespace',\n    hasSuggestions: false,\n    schema: {\n      $defs: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: 'array',\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          blankLine: {\n            $ref: '#/$defs/paddingType'\n          },\n          prev: {\n            $ref: '#/$defs/statementType'\n          },\n          next: {\n            $ref: '#/$defs/statementType'\n          }\n        },\n        additionalProperties: false,\n        required: ['blankLine', 'prev', 'next']\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: 'Unexpected blank line before this statement.',\n      expectedBlankLine: 'Expected blank line before this statement.'\n    }\n  },\n  defaultOptions: [],\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    // eslint-disable-next-line no-restricted-syntax -- We need all raw options.\n    const configureList = context.options || [];\n    let scopeInfo = null;\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     *\n     * @private\n     */\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n    /**\n     * Processes to exit from the current scope.\n     *\n     * @private\n     */\n    function exitScope() {\n      if (scopeInfo) {\n        scopeInfo = scopeInfo.upper;\n      }\n    }\n    /**\n     * Checks whether the given node matches the given type.\n     * @param node The statement node to check.\n     * @param type The statement type to check.\n     * @returns `true` if the statement node matched the type.\n     * @private\n     */\n    function match(node, type) {\n      let innerStatementNode = node;\n      while (innerStatementNode.type === utils_1.AST_NODE_TYPES.LabeledStatement) {\n        innerStatementNode = innerStatementNode.body;\n      }\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n    /**\n     * Finds the last matched configure from configureList.\n     * @paramprevNode The previous statement to match.\n     * @paramnextNode The current statement to match.\n     * @returns The tester of the last matched configure.\n     * @private\n     */\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        if (match(prevNode, configure.prev) && match(nextNode, configure.next)) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n      return PaddingTypes.any;\n    }\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @paramprevNode The previous statement to count.\n     * @paramnextNode The current statement to count.\n     * @returns The array of token pairs.\n     * @private\n     */\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(prevNode, sourceCode);\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n      return pairs;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param node The node to verify.\n     *\n     * @private\n     */\n    function verify(node) {\n      if (!node.parent || ![utils_1.AST_NODE_TYPES.BlockStatement, utils_1.AST_NODE_TYPES.Program, utils_1.AST_NODE_TYPES.SwitchCase, utils_1.AST_NODE_TYPES.SwitchStatement, utils_1.AST_NODE_TYPES.TSModuleBlock].includes(node.parent.type)) {\n        return;\n      }\n      // Save this node as the current previous statement.\n      const prevNode = scopeInfo.prevNode;\n      // Verify.\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n      scopeInfo.prevNode = node;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param node The node to verify.\n     *\n     * @private\n     */\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      TSModuleBlock: enterScope,\n      'Program:exit': exitScope,\n      'BlockStatement:exit': exitScope,\n      'SwitchStatement:exit': exitScope,\n      'TSModuleBlock:exit': exitScope,\n      ':statement': verify,\n      SwitchCase: verifyThenEnterScope,\n      TSDeclareFunction: verifyThenEnterScope,\n      'SwitchCase:exit': exitScope,\n      'TSDeclareFunction:exit': exitScope\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","LT","Array","from","Set","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","newKeywordTester","type","keyword","test","node","sourceCode","isSameKeyword","_a","getFirstToken","value","isSameType","isArray","some","val","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","skipChainExpression","AST_NODE_TYPES","ChainExpression","expression","isIIFEStatement","ExpressionStatement","UnaryExpression","argument","CallExpression","callee","SequenceExpression","expressions","length","isFunction","isCJSRequire","VariableDeclaration","declaration","declarations","init","call","MemberExpression","object","Identifier","name","isBlockLikeStatement","DoWhileStatement","body","BlockStatement","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","SwitchStatement","isDirective","parent","Program","_b","Literal","isParenthesized","isDirectivePrologue","sibling","isCJSExport","AssignmentExpression","left","property","isExpression","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","report","messageId","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","exports","directive","iife","block","empty","EmptyStatement","function","FunctionDeclaration","break","BreakStatement","case","SwitchCase","class","ClassDeclaration","const","continue","ContinueStatement","debugger","DebuggerStatement","default","ExportDefaultDeclaration","do","export","ExportNamedDeclaration","for","ForStatement","ForInStatement","ForOfStatement","if","IfStatement","import","ImportDeclaration","let","return","ReturnStatement","switch","throw","ThrowStatement","try","TryStatement","var","while","WhileStatement","with","WithStatement","interface","TSInterfaceDeclaration","TSTypeAliasDeclaration","createRule","meta","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","$defs","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","defaultOptions","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","LabeledStatement","bind","getPaddingType","i","configure","getPaddingLineSequences","pairs","push","TSModuleBlock","includes","verifyThenEnterScope","TSDeclareFunction"],"sources":["../../src/rules/padding-line-between-statements.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}