{"ast":null,"code":"'use strict';\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n  constructor(opts) {\n    var _a;\n    this.width = opts.width;\n    /* c8 ignore start */\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    /* c8 ignore stop */\n    this.rows = [];\n  }\n  span(...args) {\n    const cols = this.div(...args);\n    cols.span = true;\n  }\n  resetOutput() {\n    this.rows = [];\n  }\n  div(...args) {\n    if (args.length === 0) {\n      this.div('');\n    }\n    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n      return this.applyLayoutDSL(args[0]);\n    }\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.colFromString(arg);\n      }\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n  shouldApplyLayoutDSL(...args) {\n    return args.length === 1 && typeof args[0] === 'string' && /[\\t\\n]/.test(args[0]);\n  }\n  applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0;\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n      }\n    });\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this.measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n  colFromString(text) {\n    return {\n      text,\n      padding: this.measurePadding(text)\n    };\n  }\n  measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = mixin.stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    });\n    // don't display any lines with the\n    // hidden flag set.\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n  rowToString(row, lines) {\n    this.rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n        const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n        let ts = col; // temporary string used during alignment/padding.\n        if (wrapWidth > mixin.stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n        }\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          const fn = align[row[c].align];\n          ts = fn(ts, wrapWidth);\n          if (mixin.stringWidth(ts) < wrapWidth) {\n            /* c8 ignore start */\n            const w = width || 0;\n            /* c8 ignore stop */\n            ts += ' '.repeat(w - mixin.stringWidth(ts) - 1);\n          }\n        }\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0];\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        }\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this.renderInline(str, lines[lines.length - 1]);\n        }\n      });\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n    return lines;\n  }\n  // if the full 'source' can render in\n  // the target line, do so.\n  renderInline(source, previousLine) {\n    const match = source.match(/^ */);\n    /* c8 ignore start */\n    const leadingWhitespace = match ? match[0].length : 0;\n    /* c8 ignore stop */\n    const target = previousLine.text;\n    const targetTextWidth = mixin.stringWidth(target.trimEnd());\n    if (!previousLine.span) {\n      return source;\n    }\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n    previousLine.hidden = true;\n    return target.trimEnd() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimStart();\n  }\n  rasterize(row) {\n    const rrows = [];\n    const widths = this.columnWidths(row);\n    let wrapped;\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n      if (this.wrap) {\n        wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n      }\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n        const rrow = rrows[r];\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n  negatePadding(col) {\n    /* c8 ignore start */\n    let wrapWidth = col.width || 0;\n    /* c8 ignore stop */\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n    return wrapWidth;\n  }\n  columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || mixin.stringWidth(col.text);\n      });\n    }\n    let unset = row.length;\n    let remainingWidth = this.width;\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n      return undefined;\n    });\n    // any unset widths should be calculated.\n    /* c8 ignore start */\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    /* c8 ignore stop */\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n      return w;\n    });\n  }\n}\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n    return '  ';\n  }\n  return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n  if (col.border) {\n    return minWidth + 4;\n  }\n  return minWidth;\n}\nfunction getWindowWidth() {\n  /* c8 ignore start */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n  return 80;\n}\n/* c8 ignore stop */\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n  return str;\n}\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  /* c8 ignore start */\n  if (strWidth >= width) {\n    return str;\n  }\n  /* c8 ignore stop */\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    /* c8 ignore start */\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    /* c8 ignore stop */\n  });\n}","map":{"version":3,"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","_a","width","wrap","rows","span","args","cols","div","resetOutput","length","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","undefined","noAnsi","stripAnsi","match","toString","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","w","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimEnd","trimStart","rrows","widths","columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@isaacs/cliui/build/lib/index.js"],"sourcesContent":["'use strict';\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        /* c8 ignore start */\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        /* c8 ignore stop */\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        /* c8 ignore start */\n                        const w = width || 0;\n                        /* c8 ignore stop */\n                        ts += ' '.repeat(w - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        /* c8 ignore start */\n        const leadingWhitespace = match ? match[0].length : 0;\n        /* c8 ignore stop */\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimEnd());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimEnd() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimStart();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        /* c8 ignore start */\n        let wrapWidth = col.width || 0;\n        /* c8 ignore stop */\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        /* c8 ignore start */\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        /* c8 ignore stop */\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* c8 ignore start */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\n/* c8 ignore stop */\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* c8 ignore start */\n    if (strWidth >= width) {\n        return str;\n    }\n    /* c8 ignore stop */\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        /* c8 ignore start */\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n        /* c8 ignore stop */\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}