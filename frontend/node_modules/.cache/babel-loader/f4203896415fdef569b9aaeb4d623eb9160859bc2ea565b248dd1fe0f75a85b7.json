{"ast":null,"code":"import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(S_UNICODE_REGEX.source));\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n  var sign = numberResult.sign,\n    exponent = numberResult.exponent,\n    magnitude = numberResult.magnitude;\n  var notation = options.notation,\n    style = options.style,\n    numberingSystem = options.numberingSystem;\n  var defaultNumberingSystem = data.numbers.nu[0];\n  // #region Part 1: partition and interpolate the CLDR number pattern.\n  // ----------------------------------------------------------\n  var compactNumberPattern = null;\n  if (notation === 'compact' && magnitude) {\n    compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n  }\n  // This is used multiple times\n  var nonNameCurrencyPart;\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var byCurrencyDisplay = data.currencies[options.currency];\n    if (byCurrencyDisplay) {\n      switch (options.currencyDisplay) {\n        case 'code':\n          nonNameCurrencyPart = options.currency;\n          break;\n        case 'symbol':\n          nonNameCurrencyPart = byCurrencyDisplay.symbol;\n          break;\n        default:\n          nonNameCurrencyPart = byCurrencyDisplay.narrow;\n          break;\n      }\n    } else {\n      // Fallback for unknown currency\n      nonNameCurrencyPart = options.currency;\n    }\n  }\n  var numberPattern;\n  if (!compactNumberPattern) {\n    // Note: if the style is unit, or is currency and the currency display is name,\n    // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n    if (style === 'decimal' || style === 'unit' || style === 'currency' && options.currencyDisplay === 'name') {\n      // Shortcut for decimal\n      var decimalData = data.numbers.decimal[numberingSystem] || data.numbers.decimal[defaultNumberingSystem];\n      numberPattern = getPatternForSign(decimalData.standard, sign);\n    } else if (style === 'currency') {\n      var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n      // We replace number pattern part with `0` for easier postprocessing.\n      numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n    } else {\n      // percent\n      var percentPattern = data.numbers.percent[numberingSystem] || data.numbers.percent[defaultNumberingSystem];\n      numberPattern = getPatternForSign(percentPattern, sign);\n    }\n  } else {\n    numberPattern = compactNumberPattern;\n  }\n  // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n  // used to infer decimal group sizes.\n  var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n  // Now we start to substitute patterns\n  // 1. replace strings like `0` and `#,##0.00` with `{0}`\n  // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n  numberPattern = numberPattern.replace(CLDR_NUMBER_PATTERN, '{0}').replace(/'(.)'/g, '$1');\n  // Handle currency spacing (both compact and non-compact).\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n    // See `currencySpacing` substitution rule in TR-35.\n    // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n    //\n    // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n    // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n    // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n    //\n    // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n    // and number, because `$` does not match \"[:^S:]\".\n    //\n    // Implementation note: here we do the best effort to infer the insertion.\n    // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n    var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n    if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\".concat(afterCurrency, \"{0}\"));\n    }\n    var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n    if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\u00A4\"));\n    }\n  }\n  // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n  var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n  var numberParts = [];\n  var symbols = data.numbers.symbols[numberingSystem] || data.numbers.symbols[defaultNumberingSystem];\n  for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n    var part = numberPatternParts_1[_i];\n    if (!part) {\n      continue;\n    }\n    switch (part) {\n      case '{0}':\n        {\n          // We only need to handle scientific and engineering notation here.\n          numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem,\n          // If compact number pattern exists, do not insert group separators.\n          !compactNumberPattern && Boolean(options.useGrouping), decimalNumberPattern));\n          break;\n        }\n      case '-':\n        numberParts.push({\n          type: 'minusSign',\n          value: symbols.minusSign\n        });\n        break;\n      case '+':\n        numberParts.push({\n          type: 'plusSign',\n          value: symbols.plusSign\n        });\n        break;\n      case '%':\n        numberParts.push({\n          type: 'percentSign',\n          value: symbols.percentSign\n        });\n        break;\n      case '¤':\n        // Computed above when handling currency spacing.\n        numberParts.push({\n          type: 'currency',\n          value: nonNameCurrencyPart\n        });\n        break;\n      default:\n        if (/^\\{c:/.test(part)) {\n          numberParts.push({\n            type: 'compact',\n            value: part.substring(3, part.length - 1)\n          });\n        } else {\n          // literal\n          numberParts.push({\n            type: 'literal',\n            value: part\n          });\n        }\n        break;\n    }\n  }\n  // #endregion\n  // #region Part 2: interpolate unit pattern if necessary.\n  // ----------------------------------------------\n  switch (style) {\n    case 'currency':\n      {\n        // `currencyDisplay: 'name'` has similar pattern handling as units.\n        if (options.currencyDisplay === 'name') {\n          var unitPattern = (data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]).unitPattern;\n          // Select plural\n          var unitName = void 0;\n          var currencyNameData = data.currencies[options.currency];\n          if (currencyNameData) {\n            unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n          } else {\n            // Fallback for unknown currency\n            unitName = options.currency;\n          }\n          // Do {0} and {1} substitution\n          var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n          var result = [];\n          for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n            var part = unitPatternParts_1[_a];\n            switch (part) {\n              case '{0}':\n                result.push.apply(result, numberParts);\n                break;\n              case '{1}':\n                result.push({\n                  type: 'currency',\n                  value: unitName\n                });\n                break;\n              default:\n                if (part) {\n                  result.push({\n                    type: 'literal',\n                    value: part\n                  });\n                }\n                break;\n            }\n          }\n          return result;\n        } else {\n          return numberParts;\n        }\n      }\n    case 'unit':\n      {\n        var unit = options.unit,\n          unitDisplay = options.unitDisplay;\n        var unitData = data.units.simple[unit];\n        var unitPattern = void 0;\n        if (unitData) {\n          // Simple unit pattern\n          unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n        } else {\n          // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n          // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n          // Implementation note: we are not following TR-35 here because we need to format to parts!\n          var _b = unit.split('-per-'),\n            numeratorUnit = _b[0],\n            denominatorUnit = _b[1];\n          unitData = data.units.simple[numeratorUnit];\n          var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n          var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n          if (perUnitPattern) {\n            // perUnitPattern exists, combine it with numeratorUnitPattern\n            unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n          } else {\n            // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n            // the denominator pattern in singular form.\n            var perPattern = data.units.compound.per[unitDisplay];\n            var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n            unitPattern = unitPattern = perPattern.replace('{0}', numeratorUnitPattern).replace('{1}', denominatorPattern.replace('{0}', ''));\n          }\n        }\n        var result = [];\n        // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n        for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n          var part = _d[_c];\n          var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n          if (interpolateMatch) {\n            // Space before \"{0}\"\n            if (interpolateMatch[1]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[1]\n              });\n            }\n            // \"{0}\" itself\n            result.push.apply(result, numberParts);\n            // Space after \"{0}\"\n            if (interpolateMatch[2]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[2]\n              });\n            }\n          } else if (part) {\n            result.push({\n              type: 'unit',\n              value: part\n            });\n          }\n        }\n        return result;\n      }\n    default:\n      return numberParts;\n  }\n  // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping,\n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n  var result = [];\n  // eslint-disable-next-line prefer-const\n  var n = numberResult.formattedString,\n    x = numberResult.roundedNumber;\n  if (isNaN(x)) {\n    return [{\n      type: 'nan',\n      value: n\n    }];\n  } else if (!isFinite(x)) {\n    return [{\n      type: 'infinity',\n      value: n\n    }];\n  }\n  var digitReplacementTable = digitMapping[numberingSystem];\n  if (digitReplacementTable) {\n    n = n.replace(/\\d/g, function (digit) {\n      return digitReplacementTable[+digit] || digit;\n    });\n  }\n  // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n  // representation of n in the given numbering system.\n  var decimalSepIndex = n.indexOf('.');\n  var integer;\n  var fraction;\n  if (decimalSepIndex > 0) {\n    integer = n.slice(0, decimalSepIndex);\n    fraction = n.slice(decimalSepIndex + 1);\n  } else {\n    integer = n;\n  }\n  // #region Grouping integer digits\n  // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n  // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n  // unless the rounded number is greater than 10000:\n  //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n  //   NumberFormat('de').format(1234) //=> \"1.234\"\n  if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n    var groupSepSymbol = symbols.group;\n    var groups = [];\n    // > There may be two different grouping sizes: The primary grouping size used for the least\n    // > significant integer group, and the secondary grouping size used for more significant groups.\n    // > If a pattern contains multiple grouping separators, the interval between the last one and the\n    // > end of the integer defines the primary grouping size, and the interval between the last two\n    // > defines the secondary grouping size. All others are ignored.\n    var integerNumberPattern = decimalNumberPattern.split('.')[0];\n    var patternGroups = integerNumberPattern.split(',');\n    var primaryGroupingSize = 3;\n    var secondaryGroupingSize = 3;\n    if (patternGroups.length > 1) {\n      primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n    }\n    if (patternGroups.length > 2) {\n      secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n    }\n    var i = integer.length - primaryGroupingSize;\n    if (i > 0) {\n      // Slice the least significant integer group\n      groups.push(integer.slice(i, i + primaryGroupingSize));\n      // Then iteratively push the more signicant groups\n      // TODO: handle surrogate pairs in some numbering system digits\n      for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n        groups.push(integer.slice(i, i + secondaryGroupingSize));\n      }\n      groups.push(integer.slice(0, i + secondaryGroupingSize));\n    } else {\n      groups.push(integer);\n    }\n    while (groups.length > 0) {\n      var integerGroup = groups.pop();\n      result.push({\n        type: 'integer',\n        value: integerGroup\n      });\n      if (groups.length > 0) {\n        result.push({\n          type: 'group',\n          value: groupSepSymbol\n        });\n      }\n    }\n  } else {\n    result.push({\n      type: 'integer',\n      value: integer\n    });\n  }\n  // #endregion\n  if (fraction !== undefined) {\n    result.push({\n      type: 'decimal',\n      value: symbols.decimal\n    }, {\n      type: 'fraction',\n      value: fraction\n    });\n  }\n  if ((notation === 'scientific' || notation === 'engineering') && isFinite(x)) {\n    result.push({\n      type: 'exponentSeparator',\n      value: symbols.exponential\n    });\n    if (exponent < 0) {\n      result.push({\n        type: 'exponentMinusSign',\n        value: symbols.minusSign\n      });\n      exponent = -exponent;\n    }\n    var exponentResult = ToRawFixed(exponent, 0, 0);\n    result.push({\n      type: 'exponentInteger',\n      value: exponentResult.formattedString\n    });\n  }\n  return result;\n}\nfunction getPatternForSign(pattern, sign) {\n  if (pattern.indexOf(';') < 0) {\n    pattern = \"\".concat(pattern, \";-\").concat(pattern);\n  }\n  var _a = pattern.split(';'),\n    zeroPattern = _a[0],\n    negativePattern = _a[1];\n  switch (sign) {\n    case 0:\n      return zeroPattern;\n    case -1:\n      return negativePattern;\n    default:\n      return negativePattern.indexOf('-') >= 0 ? negativePattern.replace(/-/g, '+') : \"+\".concat(zeroPattern);\n  }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n  var _a;\n  var roundedNumber = numberResult.roundedNumber,\n    sign = numberResult.sign,\n    magnitude = numberResult.magnitude;\n  var magnitudeKey = String(Math.pow(10, magnitude));\n  var defaultNumberingSystem = data.numbers.nu[0];\n  var pattern;\n  if (style === 'currency' && currencyDisplay !== 'name') {\n    var byNumberingSystem = data.numbers.currency;\n    var currencyData = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    // NOTE: compact notation ignores currencySign!\n    var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n    if (!compactPluralRules) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n  } else {\n    var byNumberingSystem = data.numbers.decimal;\n    var byCompactDisplay = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n    if (!compactPlaralRule) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n  }\n  // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n  // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n  // > pattern for that sort of object is supplied.\n  if (pattern === '0') {\n    return null;\n  }\n  pattern = getPatternForSign(pattern, sign)\n  // Extract compact literal from the pattern\n  .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n  // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n  .replace(/0+/, '0');\n  return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n  return rules[pl.select(x)] || rules.other;\n}","map":{"version":3,"names":["ToRawFixed","digitMapping","S_UNICODE_REGEX","CARET_S_UNICODE_REGEX","RegExp","concat","source","S_DOLLAR_UNICODE_REGEX","CLDR_NUMBER_PATTERN","formatToParts","numberResult","data","pl","options","sign","exponent","magnitude","notation","style","numberingSystem","defaultNumberingSystem","numbers","nu","compactNumberPattern","getCompactDisplayPattern","compactDisplay","currencyDisplay","nonNameCurrencyPart","byCurrencyDisplay","currencies","currency","symbol","narrow","numberPattern","decimalData","decimal","getPatternForSign","standard","currencyData","currencySign","percentPattern","percent","decimalNumberPattern","exec","replace","afterCurrency","currencySpacing","afterInsertBetween","test","beforeCurrency","beforeInsertBetween","numberPatternParts","split","numberParts","symbols","_i","numberPatternParts_1","length","part","push","apply","paritionNumberIntoParts","Boolean","useGrouping","type","value","minusSign","plusSign","percentSign","substring","unitPattern","unitName","currencyNameData","selectPlural","roundedNumber","Math","pow","displayName","unitPatternParts","result","_a","unitPatternParts_1","unit","unitDisplay","unitData","units","simple","_b","numeratorUnit","denominatorUnit","numeratorUnitPattern","perUnitPattern","perUnit","perPattern","compound","per","denominatorPattern","_c","_d","interpolateMatch","n","formattedString","x","isNaN","isFinite","digitReplacementTable","digit","decimalSepIndex","indexOf","integer","fraction","slice","groupSepSymbol","group","groups","integerNumberPattern","patternGroups","primaryGroupingSize","secondaryGroupingSize","i","integerGroup","pop","undefined","exponential","exponentResult","pattern","zeroPattern","negativePattern","magnitudeKey","String","byNumberingSystem","compactPluralRules","short","byCompactDisplay","compactPlaralRule","rules","select","other"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/format_to_parts.js"],"sourcesContent":["import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(S_UNICODE_REGEX.source));\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;\n    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;\n    var defaultNumberingSystem = data.numbers.nu[0];\n    // #region Part 1: partition and interpolate the CLDR number pattern.\n    // ----------------------------------------------------------\n    var compactNumberPattern = null;\n    if (notation === 'compact' && magnitude) {\n        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n    }\n    // This is used multiple times\n    var nonNameCurrencyPart;\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var byCurrencyDisplay = data.currencies[options.currency];\n        if (byCurrencyDisplay) {\n            switch (options.currencyDisplay) {\n                case 'code':\n                    nonNameCurrencyPart = options.currency;\n                    break;\n                case 'symbol':\n                    nonNameCurrencyPart = byCurrencyDisplay.symbol;\n                    break;\n                default:\n                    nonNameCurrencyPart = byCurrencyDisplay.narrow;\n                    break;\n            }\n        }\n        else {\n            // Fallback for unknown currency\n            nonNameCurrencyPart = options.currency;\n        }\n    }\n    var numberPattern;\n    if (!compactNumberPattern) {\n        // Note: if the style is unit, or is currency and the currency display is name,\n        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n        if (style === 'decimal' ||\n            style === 'unit' ||\n            (style === 'currency' && options.currencyDisplay === 'name')) {\n            // Shortcut for decimal\n            var decimalData = data.numbers.decimal[numberingSystem] ||\n                data.numbers.decimal[defaultNumberingSystem];\n            numberPattern = getPatternForSign(decimalData.standard, sign);\n        }\n        else if (style === 'currency') {\n            var currencyData = data.numbers.currency[numberingSystem] ||\n                data.numbers.currency[defaultNumberingSystem];\n            // We replace number pattern part with `0` for easier postprocessing.\n            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n        }\n        else {\n            // percent\n            var percentPattern = data.numbers.percent[numberingSystem] ||\n                data.numbers.percent[defaultNumberingSystem];\n            numberPattern = getPatternForSign(percentPattern, sign);\n        }\n    }\n    else {\n        numberPattern = compactNumberPattern;\n    }\n    // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n    // used to infer decimal group sizes.\n    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n    // Now we start to substitute patterns\n    // 1. replace strings like `0` and `#,##0.00` with `{0}`\n    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n    numberPattern = numberPattern\n        .replace(CLDR_NUMBER_PATTERN, '{0}')\n        .replace(/'(.)'/g, '$1');\n    // Handle currency spacing (both compact and non-compact).\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var currencyData = data.numbers.currency[numberingSystem] ||\n            data.numbers.currency[defaultNumberingSystem];\n        // See `currencySpacing` substitution rule in TR-35.\n        // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n        //\n        // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n        // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n        // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n        //\n        // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n        // and number, because `$` does not match \"[:^S:]\".\n        //\n        // Implementation note: here we do the best effort to infer the insertion.\n        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\".concat(afterCurrency, \"{0}\"));\n        }\n        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\u00A4\"));\n        }\n    }\n    // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n    var numberParts = [];\n    var symbols = data.numbers.symbols[numberingSystem] ||\n        data.numbers.symbols[defaultNumberingSystem];\n    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n        var part = numberPatternParts_1[_i];\n        if (!part) {\n            continue;\n        }\n        switch (part) {\n            case '{0}': {\n                // We only need to handle scientific and engineering notation here.\n                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, \n                // If compact number pattern exists, do not insert group separators.\n                !compactNumberPattern && Boolean(options.useGrouping), decimalNumberPattern));\n                break;\n            }\n            case '-':\n                numberParts.push({ type: 'minusSign', value: symbols.minusSign });\n                break;\n            case '+':\n                numberParts.push({ type: 'plusSign', value: symbols.plusSign });\n                break;\n            case '%':\n                numberParts.push({ type: 'percentSign', value: symbols.percentSign });\n                break;\n            case '¤':\n                // Computed above when handling currency spacing.\n                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });\n                break;\n            default:\n                if (/^\\{c:/.test(part)) {\n                    numberParts.push({\n                        type: 'compact',\n                        value: part.substring(3, part.length - 1),\n                    });\n                }\n                else {\n                    // literal\n                    numberParts.push({ type: 'literal', value: part });\n                }\n                break;\n        }\n    }\n    // #endregion\n    // #region Part 2: interpolate unit pattern if necessary.\n    // ----------------------------------------------\n    switch (style) {\n        case 'currency': {\n            // `currencyDisplay: 'name'` has similar pattern handling as units.\n            if (options.currencyDisplay === 'name') {\n                var unitPattern = (data.numbers.currency[numberingSystem] ||\n                    data.numbers.currency[defaultNumberingSystem]).unitPattern;\n                // Select plural\n                var unitName = void 0;\n                var currencyNameData = data.currencies[options.currency];\n                if (currencyNameData) {\n                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n                }\n                else {\n                    // Fallback for unknown currency\n                    unitName = options.currency;\n                }\n                // Do {0} and {1} substitution\n                var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n                var result = [];\n                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n                    var part = unitPatternParts_1[_a];\n                    switch (part) {\n                        case '{0}':\n                            result.push.apply(result, numberParts);\n                            break;\n                        case '{1}':\n                            result.push({ type: 'currency', value: unitName });\n                            break;\n                        default:\n                            if (part) {\n                                result.push({ type: 'literal', value: part });\n                            }\n                            break;\n                    }\n                }\n                return result;\n            }\n            else {\n                return numberParts;\n            }\n        }\n        case 'unit': {\n            var unit = options.unit, unitDisplay = options.unitDisplay;\n            var unitData = data.units.simple[unit];\n            var unitPattern = void 0;\n            if (unitData) {\n                // Simple unit pattern\n                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n            }\n            else {\n                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n                // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n                // Implementation note: we are not following TR-35 here because we need to format to parts!\n                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];\n                unitData = data.units.simple[numeratorUnit];\n                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n                if (perUnitPattern) {\n                    // perUnitPattern exists, combine it with numeratorUnitPattern\n                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n                }\n                else {\n                    // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n                    // the denominator pattern in singular form.\n                    var perPattern = data.units.compound.per[unitDisplay];\n                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n                    unitPattern = unitPattern = perPattern\n                        .replace('{0}', numeratorUnitPattern)\n                        .replace('{1}', denominatorPattern.replace('{0}', ''));\n                }\n            }\n            var result = [];\n            // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n            for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n                var part = _d[_c];\n                var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n                if (interpolateMatch) {\n                    // Space before \"{0}\"\n                    if (interpolateMatch[1]) {\n                        result.push({ type: 'literal', value: interpolateMatch[1] });\n                    }\n                    // \"{0}\" itself\n                    result.push.apply(result, numberParts);\n                    // Space after \"{0}\"\n                    if (interpolateMatch[2]) {\n                        result.push({ type: 'literal', value: interpolateMatch[2] });\n                    }\n                }\n                else if (part) {\n                    result.push({ type: 'unit', value: part });\n                }\n            }\n            return result;\n        }\n        default:\n            return numberParts;\n    }\n    // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, \n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n    var result = [];\n    // eslint-disable-next-line prefer-const\n    var n = numberResult.formattedString, x = numberResult.roundedNumber;\n    if (isNaN(x)) {\n        return [{ type: 'nan', value: n }];\n    }\n    else if (!isFinite(x)) {\n        return [{ type: 'infinity', value: n }];\n    }\n    var digitReplacementTable = digitMapping[numberingSystem];\n    if (digitReplacementTable) {\n        n = n.replace(/\\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });\n    }\n    // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n    // representation of n in the given numbering system.\n    var decimalSepIndex = n.indexOf('.');\n    var integer;\n    var fraction;\n    if (decimalSepIndex > 0) {\n        integer = n.slice(0, decimalSepIndex);\n        fraction = n.slice(decimalSepIndex + 1);\n    }\n    else {\n        integer = n;\n    }\n    // #region Grouping integer digits\n    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n    // unless the rounded number is greater than 10000:\n    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n    //   NumberFormat('de').format(1234) //=> \"1.234\"\n    if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n        var groupSepSymbol = symbols.group;\n        var groups = [];\n        // > There may be two different grouping sizes: The primary grouping size used for the least\n        // > significant integer group, and the secondary grouping size used for more significant groups.\n        // > If a pattern contains multiple grouping separators, the interval between the last one and the\n        // > end of the integer defines the primary grouping size, and the interval between the last two\n        // > defines the secondary grouping size. All others are ignored.\n        var integerNumberPattern = decimalNumberPattern.split('.')[0];\n        var patternGroups = integerNumberPattern.split(',');\n        var primaryGroupingSize = 3;\n        var secondaryGroupingSize = 3;\n        if (patternGroups.length > 1) {\n            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n        }\n        if (patternGroups.length > 2) {\n            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n        }\n        var i = integer.length - primaryGroupingSize;\n        if (i > 0) {\n            // Slice the least significant integer group\n            groups.push(integer.slice(i, i + primaryGroupingSize));\n            // Then iteratively push the more signicant groups\n            // TODO: handle surrogate pairs in some numbering system digits\n            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n                groups.push(integer.slice(i, i + secondaryGroupingSize));\n            }\n            groups.push(integer.slice(0, i + secondaryGroupingSize));\n        }\n        else {\n            groups.push(integer);\n        }\n        while (groups.length > 0) {\n            var integerGroup = groups.pop();\n            result.push({ type: 'integer', value: integerGroup });\n            if (groups.length > 0) {\n                result.push({ type: 'group', value: groupSepSymbol });\n            }\n        }\n    }\n    else {\n        result.push({ type: 'integer', value: integer });\n    }\n    // #endregion\n    if (fraction !== undefined) {\n        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });\n    }\n    if ((notation === 'scientific' || notation === 'engineering') &&\n        isFinite(x)) {\n        result.push({ type: 'exponentSeparator', value: symbols.exponential });\n        if (exponent < 0) {\n            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });\n            exponent = -exponent;\n        }\n        var exponentResult = ToRawFixed(exponent, 0, 0);\n        result.push({\n            type: 'exponentInteger',\n            value: exponentResult.formattedString,\n        });\n    }\n    return result;\n}\nfunction getPatternForSign(pattern, sign) {\n    if (pattern.indexOf(';') < 0) {\n        pattern = \"\".concat(pattern, \";-\").concat(pattern);\n    }\n    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];\n    switch (sign) {\n        case 0:\n            return zeroPattern;\n        case -1:\n            return negativePattern;\n        default:\n            return negativePattern.indexOf('-') >= 0\n                ? negativePattern.replace(/-/g, '+')\n                : \"+\".concat(zeroPattern);\n    }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n    var _a;\n    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;\n    var magnitudeKey = String(Math.pow(10, magnitude));\n    var defaultNumberingSystem = data.numbers.nu[0];\n    var pattern;\n    if (style === 'currency' && currencyDisplay !== 'name') {\n        var byNumberingSystem = data.numbers.currency;\n        var currencyData = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        // NOTE: compact notation ignores currencySign!\n        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n        if (!compactPluralRules) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n    }\n    else {\n        var byNumberingSystem = data.numbers.decimal;\n        var byCompactDisplay = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n        if (!compactPlaralRule) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n    }\n    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n    // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n    // > pattern for that sort of object is supplied.\n    if (pattern === '0') {\n        return null;\n    }\n    pattern = getPatternForSign(pattern, sign)\n        // Extract compact literal from the pattern\n        .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n        .replace(/0+/, '0');\n    return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n    return rules[pl.select(x)] || rules.other;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}