{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _memorize = _interopRequireDefault(require(\"./util/memorize\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n/** @enum {number} */\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n\n/**\n * @param {string} value\n * @returns {value is number}\n */\nfunction isNumeric(value) {\n  return /^-?\\d+$/.test(value);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.instancePath ? error.instancePath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[/** @type {keyof typeof SPECIFICITY} */error.keyword] || 2);\n  return newChildren;\n}\n\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n  return i + 1;\n}\n\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n  while (i > 0) {\n    const child = children[i];\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n    i -= 1;\n  }\n  if (i === 0) {\n    result.push(children[i]);\n  }\n  return result.reverse();\n}\n\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n  return schema;\n}\n\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n\n/**\n * @param {string} type\n * @returns {string}\n */\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n  return \"a\";\n}\n\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n  return \"\";\n}\n\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\nconst getUtilHints = (0, _memorize.default)(() =>\n// eslint-disable-next-line global-require\nrequire(\"./util/hints\"));\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    const util = getUtilHints();\n    return util.numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    const util = getUtilHints();\n    return util.stringHints(schema, logic);\n  }\n  return [];\n}\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n\n    /** @type {string} */\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n    this.errors = errors;\n    /** @type {Schema} */\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n\n    /** @type {string} */\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n\n    /** @type {PostFormatter | null} */\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n\n    /** @type {string} */\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[/** @type {keyof Schema} */newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  }\n\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n    if ( /** @type {Schema & {instanceof: string | Array<string>}} */schema.instanceof) {\n      const {\n        instanceof: value\n      } = /** @type {Schema & {instanceof: string | Array<string>}} */schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n    if (schema.enum) {\n      const enumValues = /** @type {Array<any>} */schema.enum.map(item => {\n        if (item === null && schema.undefinedAsNull) {\n          return `${JSON.stringify(item)} | undefined`;\n        }\n        return JSON.stringify(item);\n      }).join(\" | \");\n      return `${enumValues}`;\n    }\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n    if (schema.oneOf) {\n      return /** @type {Array<Schema>} */schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \");\n    }\n    if (schema.anyOf) {\n      return /** @type {Array<Schema>} */schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \");\n    }\n    if (schema.allOf) {\n      return /** @type {Array<Schema>} */schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \");\n    }\n    if ( /** @type {JSONSchema7} */schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } = /** @type {JSONSchema7} */schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      /** @type {Array<string>} */\n      // @ts-ignore\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set( /** @type {Array<string>} */[].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property);\n\n        // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"â€¦\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } = /** @type {Schema & {patternRequired?: Array<string>;}} */schema;\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    }\n\n    // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n    /* istanbul ignore next */\n    return JSON.stringify(schema, null, 2);\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[/** @type {keyof Schema} */additionalPath[i]];\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = \"\";\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n  formatValidationError(error) {\n    const {\n      keyword,\n      instancePath: errorInstancePath\n    } = error;\n    const splittedInstancePath = errorInstancePath.split(\"/\");\n    /**\n     * @type {Array<string>}\n     */\n    const defaultValue = [];\n    const prettyInstancePath = splittedInstancePath.reduce((acc, val) => {\n      if (val.length > 0) {\n        if (isNumeric(val)) {\n          acc.push(`[${val}]`);\n        } else if (/^\\[/.test(val)) {\n          acc.push(val);\n        } else {\n          acc.push(`.${val}`);\n        }\n      }\n      return acc;\n    }, defaultValue).join(\"\");\n    const instancePath = `${this.baseDataPath}${prettyInstancePath}`;\n\n    // const { keyword, instancePath: errorInstancePath } = error;\n    // const instancePath = `${this.baseDataPath}${errorInstancePath.replace(/\\//g, '.')}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          switch (params.type) {\n            case \"number\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"integer\":\n              return `${instancePath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"string\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"boolean\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"array\":\n              return `${instancePath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"object\":\n              return `${instancePath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"null\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            default:\n              return `${instancePath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } = params;\n          return `${instancePath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } = params;\n          return `${instancePath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"formatMinimum\":\n      case \"formatExclusiveMinimum\":\n      case \"formatMaximum\":\n      case \"formatExclusiveMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          return `${instancePath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          const [, ...hints] = getHints( /** @type {Schema} */parentSchema, true);\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n          return `${instancePath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } = params;\n          return `${instancePath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } = params;\n          return `${instancePath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          const length = limit - 1;\n          return `${instancePath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          const max = limit + 1;\n          return `${instancePath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } = params;\n          return `${instancePath} should not contain the item '${\n          /** @type {{ data: Array<any> }} **/error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty = params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean( /** @type {Schema} */\n          parentSchema.properties && /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${instancePath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } = params;\n          return `${instancePath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } = params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${instancePath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } = params;\n          return `${instancePath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n          if (parentSchema && /** @type {Schema} */\n          parentSchema.enum && /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${instancePath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"not\":\n        {\n          const postfix = likeObject( /** @type {Schema} */error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n          if (canApplyNot(error.schema)) {\n            return `${instancePath} should be any ${schemaOutput}${postfix}.`;\n          }\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${instancePath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n            let filteredChildren = filterChildren(children);\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } = params;\n          return `${instancePath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${instancePath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      /* istanbul ignore next */\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2);\n\n          // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n          return `${instancePath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n}\nvar _default = ValidationError;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_memorize","_interopRequireDefault","require","obj","__esModule","SPECIFICITY","type","not","oneOf","anyOf","if","enum","const","instanceof","required","pattern","patternRequired","format","formatMinimum","formatMaximum","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","uniqueItems","contains","minLength","maxLength","minItems","maxItems","minProperties","maxProperties","dependencies","propertyNames","additionalItems","additionalProperties","absolutePath","isNumeric","test","filterMax","array","fn","evaluatedMax","reduce","max","item","Math","filter","filterChildren","children","newChildren","error","instancePath","length","keyword","findAllChildren","schemaPaths","i","predicate","schemaPath","indexOf","every","refs","extractRefs","childrenStart","slice","concat","schema","Array","isArray","map","$ref","s","groupChildrenByFirstChild","result","child","push","assign","reverse","indent","str","prefix","replace","hasNotInSchema","findFirstTypedSchema","canApplyNot","typedSchema","likeNumber","likeInteger","likeString","likeNull","likeBoolean","isObject","maybeObj","likeArray","items","likeObject","properties","patternProperties","getArticle","getSchemaNonTypes","formatHints","hints","join","getUtilHints","getHints","logic","util","numberHints","stringHints","ValidationError","Error","constructor","errors","configuration","name","headerNameFromSchema","baseDataPathFromSchema","title","baseDataPath","splittedTitleFromSchema","match","headerName","postFormatter","header","message","formatValidationErrors","captureStackTrace","getSchemaPart","path","newPath","split","schemaPart","inner","formatSchema","prevSchemas","newLogic","formatInnerSchema","innerSchema","addSelf","includes","needApplyLogicHere","values","enumValues","undefinedAsNull","JSON","stringify","allOf","ifValue","then","thenValue","else","elseValue","hasAdditionalItems","Boolean","keys","allProperties","Set","objectStructure","property","isRequired","forEach","dependencyName","dependency","dep","getSchemaPartText","additionalPath","needDot","schemaText","description","link","getSchemaPartDescription","formatValidationError","errorInstancePath","splittedInstancePath","defaultValue","prettyInstancePath","acc","val","parentSchema","params","comparison","limit","missingPattern","data","missingProperty","hasProperty","additionalProperty","deps","trim","propertyName","postfix","schemaOutput","lastChild","remainingChildren","filteredChildren","nestedError","failingKeyword","ErrorInJSON","formattedError","_default"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/css-minimizer-webpack-plugin/node_modules/schema-utils/dist/ValidationError.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _memorize = _interopRequireDefault(require(\"./util/memorize\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n/** @enum {number} */\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n\n/**\n * @param {string} value\n * @returns {value is number}\n */\nfunction isNumeric(value) {\n  return /^-?\\d+$/.test(value);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.instancePath ? error.instancePath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[/** @type {keyof typeof SPECIFICITY} */error.keyword] || 2);\n  return newChildren;\n}\n\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n  return i + 1;\n}\n\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n  while (i > 0) {\n    const child = children[i];\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n    i -= 1;\n  }\n  if (i === 0) {\n    result.push(children[i]);\n  }\n  return result.reverse();\n}\n\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n  return schema;\n}\n\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n\n/**\n * @param {string} type\n * @returns {string}\n */\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n  return \"a\";\n}\n\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n  return \"\";\n}\n\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\nconst getUtilHints = (0, _memorize.default)(() =>\n// eslint-disable-next-line global-require\nrequire(\"./util/hints\"));\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    const util = getUtilHints();\n    return util.numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    const util = getUtilHints();\n    return util.stringHints(schema, logic);\n  }\n  return [];\n}\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n\n    /** @type {string} */\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n    this.errors = errors;\n    /** @type {Schema} */\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n\n    /** @type {string} */\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n\n    /** @type {PostFormatter | null} */\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n\n    /** @type {string} */\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[/** @type {keyof Schema} */newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  }\n\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n    if ( /** @type {Schema & {instanceof: string | Array<string>}} */schema.instanceof) {\n      const {\n        instanceof: value\n      } = /** @type {Schema & {instanceof: string | Array<string>}} */schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n    if (schema.enum) {\n      const enumValues = /** @type {Array<any>} */schema.enum.map(item => {\n        if (item === null && schema.undefinedAsNull) {\n          return `${JSON.stringify(item)} | undefined`;\n        }\n        return JSON.stringify(item);\n      }).join(\" | \");\n      return `${enumValues}`;\n    }\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n    if (schema.oneOf) {\n      return (/** @type {Array<Schema>} */schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.anyOf) {\n      return (/** @type {Array<Schema>} */schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.allOf) {\n      return (/** @type {Array<Schema>} */schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \")\n      );\n    }\n    if ( /** @type {JSONSchema7} */schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } = /** @type {JSONSchema7} */schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      /** @type {Array<string>} */\n      // @ts-ignore\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set( /** @type {Array<string>} */[].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property);\n\n        // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"â€¦\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } = /** @type {Schema & {patternRequired?: Array<string>;}} */schema;\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    }\n\n    // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n    /* istanbul ignore next */\n    return JSON.stringify(schema, null, 2);\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[/** @type {keyof Schema} */additionalPath[i]];\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = \"\";\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n  formatValidationError(error) {\n    const {\n      keyword,\n      instancePath: errorInstancePath\n    } = error;\n    const splittedInstancePath = errorInstancePath.split(\"/\");\n    /**\n     * @type {Array<string>}\n     */\n    const defaultValue = [];\n    const prettyInstancePath = splittedInstancePath.reduce((acc, val) => {\n      if (val.length > 0) {\n        if (isNumeric(val)) {\n          acc.push(`[${val}]`);\n        } else if (/^\\[/.test(val)) {\n          acc.push(val);\n        } else {\n          acc.push(`.${val}`);\n        }\n      }\n      return acc;\n    }, defaultValue).join(\"\");\n    const instancePath = `${this.baseDataPath}${prettyInstancePath}`;\n\n    // const { keyword, instancePath: errorInstancePath } = error;\n    // const instancePath = `${this.baseDataPath}${errorInstancePath.replace(/\\//g, '.')}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          switch (params.type) {\n            case \"number\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"integer\":\n              return `${instancePath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"string\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"boolean\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"array\":\n              return `${instancePath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"object\":\n              return `${instancePath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"null\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            default:\n              return `${instancePath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } = params;\n          return `${instancePath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } = params;\n          return `${instancePath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"formatMinimum\":\n      case \"formatExclusiveMinimum\":\n      case \"formatMaximum\":\n      case \"formatExclusiveMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          return `${instancePath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          const [, ...hints] = getHints( /** @type {Schema} */parentSchema, true);\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n          return `${instancePath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } = params;\n          return `${instancePath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } = params;\n          return `${instancePath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          const length = limit - 1;\n          return `${instancePath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          const max = limit + 1;\n          return `${instancePath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } = params;\n          return `${instancePath} should not contain the item '${\n          /** @type {{ data: Array<any> }} **/error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty = params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean( /** @type {Schema} */\n          parentSchema.properties && /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${instancePath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } = params;\n          return `${instancePath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } = params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${instancePath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } = params;\n          return `${instancePath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n          if (parentSchema && /** @type {Schema} */\n          parentSchema.enum && /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${instancePath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"not\":\n        {\n          const postfix = likeObject( /** @type {Schema} */error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n          if (canApplyNot(error.schema)) {\n            return `${instancePath} should be any ${schemaOutput}${postfix}.`;\n          }\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${instancePath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n            let filteredChildren = filterChildren(children);\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } = params;\n          return `${instancePath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${instancePath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      /* istanbul ignore next */\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2);\n\n          // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n          return `${instancePath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n}\nvar _default = ValidationError;\nexports.default = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}