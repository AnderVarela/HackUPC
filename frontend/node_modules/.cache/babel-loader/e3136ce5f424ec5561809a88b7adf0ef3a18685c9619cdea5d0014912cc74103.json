{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperRemapAsyncToGenerator = require(\"@babel/helper-remap-async-to-generator\");\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\nvar _core = require(\"@babel/core\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    method,\n    module\n  } = options;\n  const noNewArrows = (_api$assumption = api.assumption(\"noNewArrows\")) != null ? _api$assumption : true;\n  const ignoreFunctionLength = (_api$assumption2 = api.assumption(\"ignoreFunctionLength\")) != null ? _api$assumption2 : false;\n  if (method && module) {\n    return {\n      name: \"transform-async-to-generator\",\n      visitor: {\n        Function(path, state) {\n          if (!path.node.async || path.node.generator) return;\n          let wrapAsync = state.methodWrapper;\n          if (wrapAsync) {\n            wrapAsync = _core.types.cloneNode(wrapAsync);\n          } else {\n            wrapAsync = state.methodWrapper = (0, _helperModuleImports.addNamed)(path, method, module);\n          }\n          (0, _helperRemapAsyncToGenerator.default)(path, {\n            wrapAsync\n          }, noNewArrows, ignoreFunctionLength);\n        }\n      }\n    };\n  }\n  return {\n    name: \"transform-async-to-generator\",\n    visitor: {\n      Function(path, state) {\n        if (!path.node.async || path.node.generator) return;\n        (0, _helperRemapAsyncToGenerator.default)(path, {\n          wrapAsync: state.addHelper(\"asyncToGenerator\")\n        }, noNewArrows, ignoreFunctionLength);\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_helperRemapAsyncToGenerator","_helperModuleImports","_core","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","method","module","noNewArrows","assumption","ignoreFunctionLength","name","visitor","Function","path","state","node","async","generator","wrapAsync","methodWrapper","types","cloneNode","addNamed","addHelper"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-async-to-generator\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport remapAsyncToGenerator from \"@babel/helper-remap-async-to-generator\";\nimport { addNamed } from \"@babel/helper-module-imports\";\nimport { types as t } from \"@babel/core\";\n\nexport interface Options {\n  method?: string;\n  module?: string;\n}\n\ntype State = {\n  methodWrapper?: t.Identifier | t.SequenceExpression;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { method, module } = options;\n  // Todo(BABEL 8): Consider default it to false\n  const noNewArrows = api.assumption(\"noNewArrows\") ?? true;\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? false;\n\n  if (method && module) {\n    return {\n      name: \"transform-async-to-generator\",\n\n      visitor: {\n        Function(path, state) {\n          if (!path.node.async || path.node.generator) return;\n\n          let wrapAsync = state.methodWrapper;\n          if (wrapAsync) {\n            wrapAsync = t.cloneNode(wrapAsync);\n          } else {\n            wrapAsync = state.methodWrapper = addNamed(path, method, module);\n          }\n\n          remapAsyncToGenerator(\n            path,\n            { wrapAsync },\n            noNewArrows,\n            ignoreFunctionLength,\n          );\n        },\n      },\n    };\n  }\n\n  return {\n    name: \"transform-async-to-generator\",\n\n    visitor: {\n      Function(path, state) {\n        if (!path.node.async || path.node.generator) return;\n\n        remapAsyncToGenerator(\n          path,\n          { wrapAsync: state.addHelper(\"asyncToGenerator\") },\n          noNewArrows,\n          ignoreFunctionLength,\n        );\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,4BAAA,GAAAD,OAAA;AACA,IAAAE,oBAAA,GAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AAAyC,IAAAI,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAW1B,IAAAP,kBAAA,CAAAQ,OAAO,EAAQ,CAACC,GAAG,EAAEC,OAAgB,KAAK;EAAA,IAAAC,eAAA,EAAAC,gBAAA;EACvDH,GAAG,CAACI,aAAa,CAAkB,CAAE,CAAC;EAEtC,MAAM;IAAEC,MAAM;IAAEC;EAAO,CAAC,GAAGL,OAAO;EAElC,MAAMM,WAAW,IAAAL,eAAA,GAAGF,GAAG,CAACQ,UAAU,CAAC,aAAa,CAAC,YAAAN,eAAA,GAAI,IAAI;EACzD,MAAMO,oBAAoB,IAAAN,gBAAA,GAAGH,GAAG,CAACQ,UAAU,CAAC,sBAAsB,CAAC,YAAAL,gBAAA,GAAI,KAAK;EAE5E,IAAIE,MAAM,IAAIC,MAAM,EAAE;IACpB,OAAO;MACLI,IAAI,EAAE,8BAA8B;MAEpCC,OAAO,EAAE;QACPC,QAAQA,CAACC,IAAI,EAAEC,KAAK,EAAE;UACpB,IAAI,CAACD,IAAI,CAACE,IAAI,CAACC,KAAK,IAAIH,IAAI,CAACE,IAAI,CAACE,SAAS,EAAE;UAE7C,IAAIC,SAAS,GAAGJ,KAAK,CAACK,aAAa;UACnC,IAAID,SAAS,EAAE;YACbA,SAAS,GAAGvB,KAAA,CAAAyB,KAAC,CAACC,SAAS,CAACH,SAAS,CAAC;UACpC,CAAC,MAAM;YACLA,SAAS,GAAGJ,KAAK,CAACK,aAAa,GAAG,IAAAzB,oBAAA,CAAA4B,QAAQ,EAACT,IAAI,EAAER,MAAM,EAAEC,MAAM,CAAC;UAClE;UAEA,IAAAb,4BAAA,CAAAK,OAAqB,EACnBe,IAAI,EACJ;YAAEK;UAAU,CAAC,EACbX,WAAW,EACXE,oBACF,CAAC;QACH;MACF;IACF,CAAC;EACH;EAEA,OAAO;IACLC,IAAI,EAAE,8BAA8B;IAEpCC,OAAO,EAAE;MACPC,QAAQA,CAACC,IAAI,EAAEC,KAAK,EAAE;QACpB,IAAI,CAACD,IAAI,CAACE,IAAI,CAACC,KAAK,IAAIH,IAAI,CAACE,IAAI,CAACE,SAAS,EAAE;QAE7C,IAAAxB,4BAAA,CAAAK,OAAqB,EACnBe,IAAI,EACJ;UAAEK,SAAS,EAAEJ,KAAK,CAACS,SAAS,CAAC,kBAAkB;QAAE,CAAC,EAClDhB,WAAW,EACXE,oBACF,CAAC;MACH;IACF;EACF,CAAC;AACH,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}