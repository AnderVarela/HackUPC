{"ast":null,"code":"/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n'use strict';\n\nvar util = require('util');\nvar format = require('util').format;\nvar Path = require('path');\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('./const');\nvar $$ = require('./utils');\nvar ActionContainer = require('./action_container');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\nvar HelpFormatter = require('./help/formatter');\nvar Namespace = require('./namespace');\n\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n  var self = this;\n  options = options || {};\n  options.description = options.description || null;\n  options.argumentDefault = options.argumentDefault || null;\n  options.prefixChars = options.prefixChars || '-';\n  options.conflictHandler = options.conflictHandler || 'error';\n  ActionContainer.call(this, options);\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || [];\n  // default program name\n  options.prog = options.prog || Path.basename(process.argv[1]);\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n  this.debug = options.debug === true;\n  this.formatterClass = options.formatterClass || HelpFormatter;\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({\n    title: 'Positional arguments'\n  });\n  this._optionals = this.addArgumentGroup({\n    title: 'Optional arguments'\n  });\n  this._subparsers = null;\n\n  // register types\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  });\n\n  // add help and version arguments if necessary\n  var defaultPrefix = this.prefixChars.indexOf('-') > -1 ? '-' : this.prefixChars[0];\n  if (options.addHelp) {\n    this.addArgument([defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help'], {\n      action: 'help',\n      defaultValue: c.SUPPRESS,\n      help: 'Show this help message and exit.'\n    });\n  }\n  if (typeof this.version !== 'undefined') {\n    this.addArgument([defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version'], {\n      action: 'version',\n      version: this.version,\n      defaultValue: c.SUPPRESS,\n      help: \"Show program's version number and exit.\"\n    });\n  }\n\n  // add parent arguments and defaults\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\nutil.inherits(ArgumentParser, ActionContainer);\n\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n  options = options || {};\n  options.debug = this.debug === true;\n  options.optionStrings = [];\n  options.parserClass = options.parserClass || ArgumentParser;\n  if (!!options.title || !!options.description) {\n    this._subparsers = this.addArgumentGroup({\n      title: options.title || 'subcommands',\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n  } else {\n    this._subparsers = this._positionals;\n  }\n\n  // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n    var positionals = this._getPositionalActions();\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  }\n\n  // create the parsers action and add it to the positionals list\n  var ParsersClass = this._popActionClass(options, 'parsers');\n  var action = new ParsersClass(options);\n  this._subparsers._addAction(action);\n\n  // return the created parsers action\n  return action;\n};\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n  return action;\n};\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n  args = result[0];\n  argv = result[1];\n  if (argv && argv.length > 0) {\n    this.error(format('Unrecognized arguments: %s.', argv.join(' ')));\n  }\n  return args;\n};\n\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this;\n\n  // args default to the system args\n  args = args || process.argv.slice(2);\n\n  // default Namespace built from parser defaults\n  namespace = namespace || new Namespace();\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  });\n\n  // parse the arguments and exit if there are any errors\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n    namespace = res[0];\n    args = res[1];\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n    return [namespace, args];\n  } catch (e) {\n    this.error(e);\n  }\n};\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n  var extras = [];\n\n  // replace arg strings that are file references\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  }\n  // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n  var conflicts, key;\n  var actionConflicts = {};\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  });\n\n  // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n  var optionStringIndices = {};\n  var argStringPatternParts = [];\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n      var optionTuple = self._parseOptional(argString);\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n    var argumentValues = self._getValues(action, argumentStrings);\n\n    // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(action, format('Not allowed with argument \"%s\".', actionConflict.getName()));\n          }\n        });\n      }\n    }\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2];\n\n    // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n    var actionTuples = [];\n    var args, argCount, start, stop;\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A');\n\n        // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n        var chars = self.prefixChars;\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([action, [], optionString]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [explicitArg];\n          actionTuples.push([action, args, optionString]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n        args = argStrings.slice(start, stop);\n        actionTuples.push([action, args, optionString]);\n        break;\n      }\n    }\n\n    // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n    return stop;\n  }\n\n  // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n  var positionals = self._getPositionalActions();\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);\n\n    // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n      startIndex += argCount;\n      takeAction(action, args);\n    }\n\n    // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  }\n\n  // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n  var startIndex = 0;\n  var position;\n  var maxOptionStringIndex = -1;\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n  var positionalsEndIndex, nextOptionStringIndex;\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) {\n        continue;\n      }\n      position = parseInt(position, 10);\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex);\n      // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    }\n\n    // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    }\n    // consume the next optional and any arguments for it\n    startIndex = consumeOptional(startIndex);\n  }\n\n  // consume any positionals following the last Optional\n  var stopIndex = consumePositionals(startIndex);\n\n  // if we didn't consume all the argument strings, there were extras\n  extras = extras.concat(argStrings.slice(stopIndex));\n\n  // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  }\n\n  // make sure all required actions were present\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  });\n\n  // make sure all required groups have one option present\n  var actionUsed = false;\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      });\n\n      // if no actions were used, report the error\n      if (!actionUsed) {\n        var names = [];\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  });\n\n  // return the updated namespace and the extra arguments\n  return [namespace, extras];\n};\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n  var fs = require('fs');\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [argLine];\n};\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message;\n\n  // throw an exception if we weren't able to find a match\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n      default:\n        message = 'Expected %s argument(s)';\n    }\n    throw argumentErrorHelper(action, format(message, action.nargs));\n  }\n  // return the number of arguments matched\n  return matches[1].length;\n};\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n  function getLength(string) {\n    return string.length;\n  }\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  }\n\n  // return the list of arg string counts\n  return result;\n};\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples;\n\n  // if it's an empty string, it was meant to be a positional\n  if (!argString) {\n    return null;\n  }\n\n  // if it doesn't start with a prefix, it was meant to be positional\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  }\n\n  // if the option string is present in the parser, return the action\n  if (this._optionStringActions[argString]) {\n    return [this._optionStringActions[argString], argString, null];\n  }\n\n  // if it's just a single character, it was meant to be positional\n  if (argString.length === 1) {\n    return null;\n  }\n\n  // if the option string before the \"=\" is present, return the action\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [action, optionString, argExplicit];\n    }\n  }\n\n  // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n  optionTuples = this._getOptionTuples(argString);\n\n  // if multiple actions match, the option string was ambiguous\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format('Ambiguous option: \"%s\" could match %s.', argString, optionStrings.join(', ')));\n    // if exactly one action matched, this segmentation is good,\n    // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  }\n\n  // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  }\n  // if it contains a space, it was meant to be a positional\n  if (argString.search(' ') >= 0) {\n    return null;\n  }\n\n  // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n  return [null, argString, null];\n};\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString;\n\n  // option strings starting with two prefix characters are only split at\n  // the '='\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([action, actionOptionString, argExplicit]);\n      }\n    }\n\n    // single character options can be concatenated with their arguments\n    // but multiple character options always have to have their argument\n    // separate\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n      action = this._optionStringActions[actionOptionString];\n      if (actionOptionString === optionPrefixShort) {\n        result.push([action, actionOptionString, argExplicitShort]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([action, actionOptionString, argExplicit]);\n      }\n    }\n\n    // shouldn't ever get here\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  }\n  // return the collected option tuples\n  return result;\n};\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  }\n\n  // if this is an optional action, -- is not allowed\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  }\n\n  // return the pattern\n  return regexpNargs;\n};\n\n//\n// Value conversion methods\n//\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this;\n\n  // for everything but PARSER args, strip out '--'\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n  var value, argString;\n\n  // optional argument produces a default when not present\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n    value = action.isOptional() ? action.constant : action.defaultValue;\n    if (typeof value === 'string') {\n      value = this._getValue(action, value);\n      this._checkValue(action, value);\n    }\n\n    // when nargs='*' on a positional, if there were no command-line\n    // args, use the default if it is anything other than None\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE && action.optionStrings.length === 0) {\n    value = action.defaultValue || argStrings;\n    this._checkValue(action, value);\n\n    // single argument or optional argument produces a single value\n  } else if (argStrings.length === 1 && (!action.nargs || action.nargs === c.OPTIONAL)) {\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n    this._checkValue(action, value);\n\n    // REMAINDER arguments convert all values, checking none\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n    // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    this._checkValue(action, value[0]);\n\n    // all other types of nargs produce a list\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  }\n\n  // return the converted value\n  return value;\n};\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  }\n\n  // convert the value to the appropriate type\n  try {\n    result = typeFunction(argString);\n\n    // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n    var msg = format('Invalid %s value: %s', name, argString);\n    if (name === '<function>') {\n      msg += '\\n' + e.message;\n    }\n    throw argumentErrorHelper(action, msg);\n  }\n  // return the converted value\n  return result;\n};\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) && choices.indexOf(value) !== -1) {\n      return;\n    }\n    // choise for subparsers can by only hash\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices = choices.join(', ');\n    } else {\n      choices = Object.keys(choices).join(', ');\n    }\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n};\n\n//\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter();\n\n  // usage\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n\n  // description\n  formatter.addText(this.description);\n\n  // positionals, optionals and user-defined groups\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  });\n\n  // epilog\n  formatter.addText(this.epilog);\n\n  // determine help from format above\n  return formatter.formatHelp();\n};\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({\n    prog: this.prog\n  });\n  return formatter;\n};\n\n//\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n  if (message) {\n    stream.write('' + message);\n  }\n};\n\n//\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n  process.exit(status);\n};\n\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\nArgumentParser.prototype.error = function (err) {\n  var message;\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n    message = err.message;\n  } else {\n    message = err;\n  }\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n  this.printUsage(process.stderr);\n  return this.exit(2, msg);\n};\nmodule.exports = ArgumentParser;","map":{"version":3,"names":["util","require","format","Path","sprintf","c","$$","ActionContainer","argumentErrorHelper","HelpFormatter","Namespace","ArgumentParser","options","self","description","argumentDefault","prefixChars","conflictHandler","call","addHelp","parents","prog","basename","process","argv","usage","epilog","version","debug","formatterClass","fromfilePrefixChars","_positionals","addArgumentGroup","title","_optionals","_subparsers","FUNCTION_IDENTITY","o","register","x","result","parseInt","isNaN","Error","parseFloat","defaultPrefix","indexOf","addArgument","action","defaultValue","SUPPRESS","help","forEach","parent","_addContainerActions","_defaults","defaultKey","hasOwnProperty","inherits","prototype","addSubparsers","error","optionStrings","parserClass","formatter","_getFormatter","positionals","_getPositionalActions","groups","_mutuallyExclusiveGroups","addUsage","formatHelp","trim","ParsersClass","_popActionClass","_addAction","isOptional","_getOptionalActions","_actions","filter","isPositional","parseArgs","args","namespace","parseKnownArgs","length","join","slice","dest","has","_getValue","Object","keys","res","_parseKnownArgs","_UNRECOGNIZED_ARGS_ATTR","arrayUnion","e","argStrings","extras","_readArgsFromFiles","actionHash","getName","conflicts","key","actionConflicts","mutexGroup","_groupActions","mutexAction","i","groupActions","push","apply","optionStringIndices","argStringPatternParts","argString","argStringIndex","pattern","optionTuple","_parseOptional","argStringsPattern","seenActions","seenNonDefaultActions","takeAction","argumentStrings","optionString","argumentValues","_getValues","actionConflict","consumeOptional","startIndex","explicitArg","actionTuples","argCount","start","stop","_matchArgument","chars","newExplicitArg","optionalsMap","_optionStringActions","selectedPatterns","substr","consumePositionals","selectedPattern","argCounts","_matchArgumentsPartial","position","maxOptionStringIndex","Math","max","positionalsEndIndex","nextOptionStringIndex","min","strings","concat","stopIndex","required","actionUsed","group","some","names","msg","fs","newArgStrings","argstrs","filename","content","readFileSync","split","argLine","convertArgLineToArgs","arg","message","regexpArgStrings","regexpNargs","RegExp","_getNargsPattern","matches","match","nargs","undefined","OPTIONAL","ONE_OR_MORE","actions","actionSlice","j","getLength","string","splice","map","argExplicit","optionTuples","_getOptionTuples","_regexpNegativeNumber","_hasNegativeNumberOptionals","Boolean","search","optionPrefix","actionOptionString","optionStringSplit","optionPrefixShort","argExplicitShort","ZERO_OR_MORE","REMAINDER","PARSER","repeat","replace","arrayElement","value","constant","_checkValue","v","typeFunction","_registryGet","type","name","displayName","choices","Array","isArray","formatUsage","addText","_actionGroups","actionGroup","startSection","addArguments","endSection","FormatterClass","printUsage","_printMessage","printHelp","stream","stdout","write","exit","status","stderr","err","EOL","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/argparse/lib/argument_parser.js"],"sourcesContent":["/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n'use strict';\n\nvar util    = require('util');\nvar format  = require('util').format;\nvar Path    = require('path');\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\nvar ActionContainer = require('./action_container');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\n\nvar HelpFormatter = require('./help/formatter');\n\nvar Namespace = require('./namespace');\n\n\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n  var self = this;\n  options = options || {};\n\n  options.description = (options.description || null);\n  options.argumentDefault = (options.argumentDefault || null);\n  options.prefixChars = (options.prefixChars || '-');\n  options.conflictHandler = (options.conflictHandler || 'error');\n  ActionContainer.call(this, options);\n\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || [];\n  // default program name\n  options.prog = (options.prog || Path.basename(process.argv[1]));\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n\n  this.debug = (options.debug === true);\n\n  this.formatterClass = (options.formatterClass || HelpFormatter);\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });\n  this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });\n  this._subparsers = null;\n\n  // register types\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  });\n\n  // add help and version arguments if necessary\n  var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];\n  if (options.addHelp) {\n    this.addArgument(\n      [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],\n      {\n        action: 'help',\n        defaultValue: c.SUPPRESS,\n        help: 'Show this help message and exit.'\n      }\n    );\n  }\n  if (typeof this.version !== 'undefined') {\n    this.addArgument(\n      [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],\n      {\n        action: 'version',\n        version: this.version,\n        defaultValue: c.SUPPRESS,\n        help: \"Show program's version number and exit.\"\n      }\n    );\n  }\n\n  // add parent arguments and defaults\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\n\nutil.inherits(ArgumentParser, ActionContainer);\n\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n\n  options = options || {};\n  options.debug = (this.debug === true);\n  options.optionStrings = [];\n  options.parserClass = (options.parserClass || ArgumentParser);\n\n\n  if (!!options.title || !!options.description) {\n\n    this._subparsers = this.addArgumentGroup({\n      title: (options.title || 'subcommands'),\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n\n  } else {\n    this._subparsers = this._positionals;\n  }\n\n  // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n    var positionals = this._getPositionalActions();\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  }\n\n  // create the parsers action and add it to the positionals list\n  var ParsersClass = this._popActionClass(options, 'parsers');\n  var action = new ParsersClass(options);\n  this._subparsers._addAction(action);\n\n  // return the created parsers action\n  return action;\n};\n\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n  return action;\n};\n\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\n\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n\n\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n\n  args = result[0];\n  argv = result[1];\n  if (argv && argv.length > 0) {\n    this.error(\n      format('Unrecognized arguments: %s.', argv.join(' '))\n    );\n  }\n  return args;\n};\n\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this;\n\n  // args default to the system args\n  args = args || process.argv.slice(2);\n\n  // default Namespace built from parser defaults\n  namespace = namespace || new Namespace();\n\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  });\n\n  // parse the arguments and exit if there are any errors\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n\n    namespace = res[0];\n    args = res[1];\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n    return [ namespace, args ];\n  } catch (e) {\n    this.error(e);\n  }\n};\n\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n\n  var extras = [];\n\n  // replace arg strings that are file references\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  }\n  // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n\n  var conflicts, key;\n  var actionConflicts = {};\n\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  });\n\n  // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n  var optionStringIndices = {};\n\n  var argStringPatternParts = [];\n\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n      var optionTuple = self._parseOptional(argString);\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n\n\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n    var argumentValues = self._getValues(action, argumentStrings);\n\n    // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(\n              action,\n              format('Not allowed with argument \"%s\".', actionConflict.getName())\n            );\n          }\n        });\n      }\n    }\n\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2];\n\n    // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n    var actionTuples = [];\n\n    var args, argCount, start, stop;\n\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A');\n\n        // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n        var chars = self.prefixChars;\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([ action, [], optionString ]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [ explicitArg ];\n          actionTuples.push([ action, args, optionString ]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n\n\n        args = argStrings.slice(start, stop);\n\n        actionTuples.push([ action, args, optionString ]);\n        break;\n      }\n\n    }\n\n    // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n    return stop;\n  }\n\n  // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n  var positionals = self._getPositionalActions();\n\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);\n\n    // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n\n      startIndex += argCount;\n      takeAction(action, args);\n    }\n\n    // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  }\n\n  // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n  var startIndex = 0;\n  var position;\n\n  var maxOptionStringIndex = -1;\n\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n\n  var positionalsEndIndex, nextOptionStringIndex;\n\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) { continue; }\n\n      position = parseInt(position, 10);\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex);\n      // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    }\n\n    // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    }\n    // consume the next optional and any arguments for it\n    startIndex = consumeOptional(startIndex);\n  }\n\n  // consume any positionals following the last Optional\n  var stopIndex = consumePositionals(startIndex);\n\n  // if we didn't consume all the argument strings, there were extras\n  extras = extras.concat(argStrings.slice(stopIndex));\n\n  // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  }\n\n  // make sure all required actions were present\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  });\n\n  // make sure all required groups have one option present\n  var actionUsed = false;\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      });\n\n      // if no actions were used, report the error\n      if (!actionUsed) {\n        var names = [];\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  });\n\n  // return the updated namespace and the extra arguments\n  return [ namespace, extras ];\n};\n\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n  var fs = require('fs');\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\n\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [ argLine ];\n};\n\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message;\n\n  // throw an exception if we weren't able to find a match\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n      default:\n        message = 'Expected %s argument(s)';\n    }\n\n    throw argumentErrorHelper(\n      action,\n      format(message, action.nargs)\n    );\n  }\n  // return the number of arguments matched\n  return matches[1].length;\n};\n\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n\n  function getLength(string) {\n    return string.length;\n  }\n\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  }\n\n  // return the list of arg string counts\n  return result;\n};\n\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples;\n\n  // if it's an empty string, it was meant to be a positional\n  if (!argString) {\n    return null;\n  }\n\n  // if it doesn't start with a prefix, it was meant to be positional\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  }\n\n  // if the option string is present in the parser, return the action\n  if (this._optionStringActions[argString]) {\n    return [ this._optionStringActions[argString], argString, null ];\n  }\n\n  // if it's just a single character, it was meant to be positional\n  if (argString.length === 1) {\n    return null;\n  }\n\n  // if the option string before the \"=\" is present, return the action\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [ action, optionString, argExplicit ];\n    }\n  }\n\n  // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n  optionTuples = this._getOptionTuples(argString);\n\n  // if multiple actions match, the option string was ambiguous\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format(\n          'Ambiguous option: \"%s\" could match %s.',\n          argString, optionStrings.join(', ')\n    ));\n  // if exactly one action matched, this segmentation is good,\n  // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  }\n\n  // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  }\n  // if it contains a space, it was meant to be a positional\n  if (argString.search(' ') >= 0) {\n    return null;\n  }\n\n  // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n  return [ null, argString, null ];\n};\n\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString;\n\n  // option strings starting with two prefix characters are only split at\n  // the '='\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // single character options can be concatenated with their arguments\n  // but multiple character options always have to have their argument\n  // separate\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n\n      action = this._optionStringActions[actionOptionString];\n      if (actionOptionString === optionPrefixShort) {\n        result.push([ action, actionOptionString, argExplicitShort ]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // shouldn't ever get here\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  }\n  // return the collected option tuples\n  return result;\n};\n\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  }\n\n  // if this is an optional action, -- is not allowed\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  }\n\n  // return the pattern\n  return regexpNargs;\n};\n\n//\n// Value conversion methods\n//\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this;\n\n  // for everything but PARSER args, strip out '--'\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n\n  var value, argString;\n\n  // optional argument produces a default when not present\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n\n    value = (action.isOptional()) ? action.constant : action.defaultValue;\n\n    if (typeof (value) === 'string') {\n      value = this._getValue(action, value);\n      this._checkValue(action, value);\n    }\n\n  // when nargs='*' on a positional, if there were no command-line\n  // args, use the default if it is anything other than None\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE &&\n    action.optionStrings.length === 0) {\n\n    value = (action.defaultValue || argStrings);\n    this._checkValue(action, value);\n\n  // single argument or optional argument produces a single value\n  } else if (argStrings.length === 1 &&\n        (!action.nargs || action.nargs === c.OPTIONAL)) {\n\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n    this._checkValue(action, value);\n\n  // REMAINDER arguments convert all values, checking none\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n  // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    this._checkValue(action, value[0]);\n\n  // all other types of nargs produce a list\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  }\n\n  // return the converted value\n  return value;\n};\n\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  }\n\n  // convert the value to the appropriate type\n  try {\n    result = typeFunction(argString);\n\n    // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n    var msg = format('Invalid %s value: %s', name, argString);\n    if (name === '<function>') { msg += '\\n' + e.message; }\n    throw argumentErrorHelper(action, msg);\n  }\n  // return the converted value\n  return result;\n};\n\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) &&\n        choices.indexOf(value) !== -1) {\n      return;\n    }\n    // choise for subparsers can by only hash\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices =  choices.join(', ');\n    } else {\n      choices =  Object.keys(choices).join(', ');\n    }\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n};\n\n//\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter();\n\n  // usage\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n\n  // description\n  formatter.addText(this.description);\n\n  // positionals, optionals and user-defined groups\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  });\n\n  // epilog\n  formatter.addText(this.epilog);\n\n  // determine help from format above\n  return formatter.formatHelp();\n};\n\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({ prog: this.prog });\n  return formatter;\n};\n\n//\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\n\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n  if (message) {\n    stream.write('' + message);\n  }\n};\n\n//\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n\n  process.exit(status);\n};\n\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\nArgumentParser.prototype.error = function (err) {\n  var message;\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n    message = err.message;\n  } else {\n    message = err;\n  }\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n\n  this.printUsage(process.stderr);\n\n  return this.exit(2, msg);\n};\n\nmodule.exports = ArgumentParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}