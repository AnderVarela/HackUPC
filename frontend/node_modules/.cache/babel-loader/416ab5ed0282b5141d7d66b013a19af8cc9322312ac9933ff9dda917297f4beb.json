{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tsutils = __importStar(require(\"tsutils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util = __importStar(require(\"../util\"));\nconst util_1 = require(\"../util\");\nexports.default = util.createRule({\n  name: 'no-unnecessary-type-arguments',\n  meta: {\n    docs: {\n      description: 'Disallow type arguments that are equal to the default',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryTypeParameter: 'This is the default value for this type parameter, so it can be omitted.'\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    function getTypeForComparison(type) {\n      if (util.isTypeReferenceType(type)) {\n        return {\n          type: type.target,\n          typeArguments: util.getTypeArguments(type, checker)\n        };\n      }\n      return {\n        type,\n        typeArguments: []\n      };\n    }\n    function checkTSArgsAndParameters(esParameters, typeParameters) {\n      // Just check the last one. Must specify previous type parameters if the last one is specified.\n      const i = esParameters.params.length - 1;\n      const arg = esParameters.params[i];\n      const param = typeParameters[i];\n      if (!(param === null || param === void 0 ? void 0 : param.default)) {\n        return;\n      }\n      // TODO: would like checker.areTypesEquivalent. https://github.com/Microsoft/TypeScript/issues/13502\n      const defaultType = checker.getTypeAtLocation(param.default);\n      const argTsNode = parserServices.esTreeNodeToTSNodeMap.get(arg);\n      const argType = checker.getTypeAtLocation(argTsNode);\n      // this check should handle some of the most simple cases of like strings, numbers, etc\n      if (defaultType !== argType) {\n        // For more complex types (like aliases to generic object types) - TS won't always create a\n        // global shared type object for the type - so we need to resort to manually comparing the\n        // reference type and the passed type arguments.\n        // Also - in case there are aliases - we need to resolve them before we do checks\n        const defaultTypeResolved = getTypeForComparison(defaultType);\n        const argTypeResolved = getTypeForComparison(argType);\n        if (\n        // ensure the resolved type AND all the parameters are the same\n        defaultTypeResolved.type !== argTypeResolved.type || defaultTypeResolved.typeArguments.length !== argTypeResolved.typeArguments.length || defaultTypeResolved.typeArguments.some((t, i) => t !== argTypeResolved.typeArguments[i])) {\n          return;\n        }\n      }\n      context.report({\n        node: arg,\n        messageId: 'unnecessaryTypeParameter',\n        fix: fixer => fixer.removeRange(i === 0 ? esParameters.range : [esParameters.params[i - 1].range[1], arg.range[1]])\n      });\n    }\n    return {\n      TSTypeParameterInstantiation(node) {\n        const expression = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const typeParameters = getTypeParametersFromNode(expression, checker);\n        if (typeParameters) {\n          checkTSArgsAndParameters(node, typeParameters);\n        }\n      }\n    };\n  }\n});\nfunction getTypeParametersFromNode(node, checker) {\n  if (ts.isExpressionWithTypeArguments(node)) {\n    return getTypeParametersFromType(node.expression, checker);\n  }\n  if (ts.isTypeReferenceNode(node)) {\n    return getTypeParametersFromType(node.typeName, checker);\n  }\n  if (ts.isCallExpression(node) || ts.isNewExpression(node)) {\n    return getTypeParametersFromCall(node, checker);\n  }\n  return undefined;\n}\nfunction getTypeParametersFromType(type, checker) {\n  const symAtLocation = checker.getSymbolAtLocation(type);\n  if (!symAtLocation) {\n    return undefined;\n  }\n  const sym = getAliasedSymbol(symAtLocation, checker);\n  const declarations = sym.getDeclarations();\n  if (!declarations) {\n    return undefined;\n  }\n  return (0, util_1.findFirstResult)(declarations, decl => ts.isClassLike(decl) || ts.isTypeAliasDeclaration(decl) || ts.isInterfaceDeclaration(decl) ? decl.typeParameters : undefined);\n}\nfunction getTypeParametersFromCall(node, checker) {\n  const sig = checker.getResolvedSignature(node);\n  const sigDecl = sig === null || sig === void 0 ? void 0 : sig.getDeclaration();\n  if (!sigDecl) {\n    return ts.isNewExpression(node) ? getTypeParametersFromType(node.expression, checker) : undefined;\n  }\n  return sigDecl.typeParameters;\n}\nfunction getAliasedSymbol(symbol, checker) {\n  return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : symbol;\n}","map":{"version":3,"names":["tsutils","__importStar","require","ts","util","util_1","exports","default","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryTypeParameter","schema","type","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","getTypeForComparison","isTypeReferenceType","target","typeArguments","getTypeArguments","checkTSArgsAndParameters","esParameters","typeParameters","i","params","length","arg","param","defaultType","getTypeAtLocation","argTsNode","esTreeNodeToTSNodeMap","get","argType","defaultTypeResolved","argTypeResolved","some","t","report","node","messageId","fix","fixer","removeRange","range","TSTypeParameterInstantiation","expression","getTypeParametersFromNode","isExpressionWithTypeArguments","getTypeParametersFromType","isTypeReferenceNode","typeName","isCallExpression","isNewExpression","getTypeParametersFromCall","undefined","symAtLocation","getSymbolAtLocation","sym","getAliasedSymbol","declarations","getDeclarations","findFirstResult","decl","isClassLike","isTypeAliasDeclaration","isInterfaceDeclaration","sig","getResolvedSignature","sigDecl","getDeclaration","symbol","isSymbolFlagSet","SymbolFlags","Alias"],"sources":["../../src/rules/no-unnecessary-type-arguments.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}