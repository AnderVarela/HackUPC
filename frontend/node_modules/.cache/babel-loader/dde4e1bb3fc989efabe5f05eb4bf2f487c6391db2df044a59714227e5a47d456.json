{"ast":null,"code":"'use strict';\n\nvar global = require('../internals/global');\nvar tryNodeRequire = require('../internals/try-node-require');\nvar PROPER_STRUCTURED_CLONE_TRANSFER = require('../internals/structured-clone-proper-transfer');\nvar structuredClone = global.structuredClone;\nvar $ArrayBuffer = global.ArrayBuffer;\nvar $MessageChannel = global.MessageChannel;\nvar detach = false;\nvar WorkerThreads, channel, buffer, $detach;\nif (PROPER_STRUCTURED_CLONE_TRANSFER) {\n  detach = function (transferable) {\n    structuredClone(transferable, {\n      transfer: [transferable]\n    });\n  };\n} else if ($ArrayBuffer) try {\n  if (!$MessageChannel) {\n    WorkerThreads = tryNodeRequire('worker_threads');\n    if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;\n  }\n  if ($MessageChannel) {\n    channel = new $MessageChannel();\n    buffer = new $ArrayBuffer(2);\n    $detach = function (transferable) {\n      channel.port1.postMessage(null, [transferable]);\n    };\n    if (buffer.byteLength === 2) {\n      $detach(buffer);\n      if (buffer.byteLength === 0) detach = $detach;\n    }\n  }\n} catch (error) {/* empty */}\nmodule.exports = detach;","map":{"version":3,"names":["global","require","tryNodeRequire","PROPER_STRUCTURED_CLONE_TRANSFER","structuredClone","$ArrayBuffer","ArrayBuffer","$MessageChannel","MessageChannel","detach","WorkerThreads","channel","buffer","$detach","transferable","transfer","port1","postMessage","byteLength","error","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/core-js-pure/internals/detach-transferable.js"],"sourcesContent":["'use strict';\nvar global = require('../internals/global');\nvar tryNodeRequire = require('../internals/try-node-require');\nvar PROPER_STRUCTURED_CLONE_TRANSFER = require('../internals/structured-clone-proper-transfer');\n\nvar structuredClone = global.structuredClone;\nvar $ArrayBuffer = global.ArrayBuffer;\nvar $MessageChannel = global.MessageChannel;\nvar detach = false;\nvar WorkerThreads, channel, buffer, $detach;\n\nif (PROPER_STRUCTURED_CLONE_TRANSFER) {\n  detach = function (transferable) {\n    structuredClone(transferable, { transfer: [transferable] });\n  };\n} else if ($ArrayBuffer) try {\n  if (!$MessageChannel) {\n    WorkerThreads = tryNodeRequire('worker_threads');\n    if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;\n  }\n\n  if ($MessageChannel) {\n    channel = new $MessageChannel();\n    buffer = new $ArrayBuffer(2);\n\n    $detach = function (transferable) {\n      channel.port1.postMessage(null, [transferable]);\n    };\n\n    if (buffer.byteLength === 2) {\n      $detach(buffer);\n      if (buffer.byteLength === 0) detach = $detach;\n    }\n  }\n} catch (error) { /* empty */ }\n\nmodule.exports = detach;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC3C,IAAIC,cAAc,GAAGD,OAAO,CAAC,+BAA+B,CAAC;AAC7D,IAAIE,gCAAgC,GAAGF,OAAO,CAAC,+CAA+C,CAAC;AAE/F,IAAIG,eAAe,GAAGJ,MAAM,CAACI,eAAe;AAC5C,IAAIC,YAAY,GAAGL,MAAM,CAACM,WAAW;AACrC,IAAIC,eAAe,GAAGP,MAAM,CAACQ,cAAc;AAC3C,IAAIC,MAAM,GAAG,KAAK;AAClB,IAAIC,aAAa,EAAEC,OAAO,EAAEC,MAAM,EAAEC,OAAO;AAE3C,IAAIV,gCAAgC,EAAE;EACpCM,MAAM,GAAG,SAAAA,CAAUK,YAAY,EAAE;IAC/BV,eAAe,CAACU,YAAY,EAAE;MAAEC,QAAQ,EAAE,CAACD,YAAY;IAAE,CAAC,CAAC;EAC7D,CAAC;AACH,CAAC,MAAM,IAAIT,YAAY,EAAE,IAAI;EAC3B,IAAI,CAACE,eAAe,EAAE;IACpBG,aAAa,GAAGR,cAAc,CAAC,gBAAgB,CAAC;IAChD,IAAIQ,aAAa,EAAEH,eAAe,GAAGG,aAAa,CAACF,cAAc;EACnE;EAEA,IAAID,eAAe,EAAE;IACnBI,OAAO,GAAG,IAAIJ,eAAe,CAAC,CAAC;IAC/BK,MAAM,GAAG,IAAIP,YAAY,CAAC,CAAC,CAAC;IAE5BQ,OAAO,GAAG,SAAAA,CAAUC,YAAY,EAAE;MAChCH,OAAO,CAACK,KAAK,CAACC,WAAW,CAAC,IAAI,EAAE,CAACH,YAAY,CAAC,CAAC;IACjD,CAAC;IAED,IAAIF,MAAM,CAACM,UAAU,KAAK,CAAC,EAAE;MAC3BL,OAAO,CAACD,MAAM,CAAC;MACf,IAAIA,MAAM,CAACM,UAAU,KAAK,CAAC,EAAET,MAAM,GAAGI,OAAO;IAC/C;EACF;AACF,CAAC,CAAC,OAAOM,KAAK,EAAE,CAAE;AAElBC,MAAM,CAACC,OAAO,GAAGZ,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}