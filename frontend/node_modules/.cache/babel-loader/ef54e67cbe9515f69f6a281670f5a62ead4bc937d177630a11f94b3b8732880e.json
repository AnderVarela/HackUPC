{"ast":null,"code":"const {\n  promises: fsPromises\n} = require('fs');\nconst path = require('path');\n\n/** @type {Map<string, string | undefined>} */\nlet packageJsonTypeMap = new Map();\n\n/**\n * Infers the current active module system from loader context and options.\n * @this {import('webpack').loader.LoaderContext}\n * @param {import('webpack').ModuleFilenameHelpers} ModuleFilenameHelpers Webpack's module filename helpers.\n * @param {import('../types').NormalizedLoaderOptions} options The normalized loader options.\n * @return {Promise<'esm' | 'cjs'>} The inferred module system.\n */\nasync function getModuleSystem(ModuleFilenameHelpers, options) {\n  // Check loader options -\n  // if `esModule` is set we don't have to do extra guess work.\n  switch (typeof options.esModule) {\n    case 'boolean':\n      {\n        return options.esModule ? 'esm' : 'cjs';\n      }\n    case 'object':\n      {\n        if (options.esModule.include && ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.include)) {\n          return 'esm';\n        }\n        if (options.esModule.exclude && ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.exclude)) {\n          return 'cjs';\n        }\n        break;\n      }\n    default: // Do nothing\n  }\n\n  // Check current resource's extension\n  if (/\\.mjs$/.test(this.resourcePath)) return 'esm';\n  if (/\\.cjs$/.test(this.resourcePath)) return 'cjs';\n  if (typeof this.addMissingDependency !== 'function') {\n    // This is Webpack 4 which does not support `import.meta`.\n    // We assume `.js` files are CommonJS because the output cannot be ESM anyway.\n    return 'cjs';\n  }\n\n  // We will assume CommonJS if we cannot determine otherwise\n  let packageJsonType = '';\n\n  // We begin our search for relevant `package.json` files,\n  // at the directory of the resource being loaded.\n  // These paths should already be resolved,\n  // but we resolve them again to ensure we are dealing with an aboslute path.\n  const resourceContext = path.dirname(this.resourcePath);\n  let searchPath = resourceContext;\n  let previousSearchPath = '';\n  // We start our search just above the root context of the webpack compilation\n  const stopPath = path.dirname(this.rootContext);\n\n  // If the module context is a resolved symlink outside the `rootContext` path,\n  // then we will never find the `stopPath` - so we also halt when we hit the root.\n  // Note that there is a potential that the wrong `package.json` is found in some pathalogical cases,\n  // such as a folder that is conceptually a package + does not have an ancestor `package.json`,\n  // but there exists a `package.json` higher up.\n  // This might happen if you have a folder of utility JS files that you symlink but did not organize as a package.\n  // We consider this an unsupported edge case for now.\n  while (searchPath !== stopPath && searchPath !== previousSearchPath) {\n    // If we have already determined the `package.json` type for this path we can stop searching.\n    // We do however still need to cache the found value,\n    // from the `resourcePath` folder up to the matching `searchPath`,\n    // to avoid retracing these steps when processing sibling resources.\n    if (packageJsonTypeMap.has(searchPath)) {\n      packageJsonType = packageJsonTypeMap.get(searchPath);\n      let currentPath = resourceContext;\n      while (currentPath !== searchPath) {\n        // We set the found type at least level from `resourcePath` folder up to the matching `searchPath`\n        packageJsonTypeMap.set(currentPath, packageJsonType);\n        currentPath = path.dirname(currentPath);\n      }\n      break;\n    }\n    let packageJsonPath = path.join(searchPath, 'package.json');\n    try {\n      const packageSource = await fsPromises.readFile(packageJsonPath, 'utf-8');\n      try {\n        const packageObject = JSON.parse(packageSource);\n\n        // Any package.json is sufficient as long as it can be parsed.\n        // If it does not explicitly have a `type: \"module\"` it will be assumed to be CommonJS.\n        packageJsonType = typeof packageObject.type === 'string' ? packageObject.type : '';\n        packageJsonTypeMap.set(searchPath, packageJsonType);\n\n        // We set the type in the cache for all paths from the `resourcePath` folder,\n        // up to the matching `searchPath` to avoid retracing these steps when processing sibling resources.\n        let currentPath = resourceContext;\n        while (currentPath !== searchPath) {\n          packageJsonTypeMap.set(currentPath, packageJsonType);\n          currentPath = path.dirname(currentPath);\n        }\n      } catch (e) {\n        // `package.json` exists but could not be parsed.\n        // We track it as a dependency so we can reload if this file changes.\n      }\n      this.addDependency(packageJsonPath);\n      break;\n    } catch (e) {\n      // `package.json` does not exist.\n      // We track it as a missing dependency so we can reload if this file is added.\n      this.addMissingDependency(packageJsonPath);\n    }\n\n    // Try again at the next level up\n    previousSearchPath = searchPath;\n    searchPath = path.dirname(searchPath);\n  }\n\n  // Check `package.json` for the `type` field -\n  // fallback to use `cjs` for anything ambiguous.\n  return packageJsonType === 'module' ? 'esm' : 'cjs';\n}\nmodule.exports = getModuleSystem;","map":{"version":3,"names":["promises","fsPromises","require","path","packageJsonTypeMap","Map","getModuleSystem","ModuleFilenameHelpers","options","esModule","include","matchPart","resourcePath","exclude","test","addMissingDependency","packageJsonType","resourceContext","dirname","searchPath","previousSearchPath","stopPath","rootContext","has","get","currentPath","set","packageJsonPath","join","packageSource","readFile","packageObject","JSON","parse","type","e","addDependency","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/utils/getModuleSystem.js"],"sourcesContent":["const { promises: fsPromises } = require('fs');\nconst path = require('path');\n\n/** @type {Map<string, string | undefined>} */\nlet packageJsonTypeMap = new Map();\n\n/**\n * Infers the current active module system from loader context and options.\n * @this {import('webpack').loader.LoaderContext}\n * @param {import('webpack').ModuleFilenameHelpers} ModuleFilenameHelpers Webpack's module filename helpers.\n * @param {import('../types').NormalizedLoaderOptions} options The normalized loader options.\n * @return {Promise<'esm' | 'cjs'>} The inferred module system.\n */\nasync function getModuleSystem(ModuleFilenameHelpers, options) {\n  // Check loader options -\n  // if `esModule` is set we don't have to do extra guess work.\n  switch (typeof options.esModule) {\n    case 'boolean': {\n      return options.esModule ? 'esm' : 'cjs';\n    }\n    case 'object': {\n      if (\n        options.esModule.include &&\n        ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.include)\n      ) {\n        return 'esm';\n      }\n      if (\n        options.esModule.exclude &&\n        ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.exclude)\n      ) {\n        return 'cjs';\n      }\n\n      break;\n    }\n    default: // Do nothing\n  }\n\n  // Check current resource's extension\n  if (/\\.mjs$/.test(this.resourcePath)) return 'esm';\n  if (/\\.cjs$/.test(this.resourcePath)) return 'cjs';\n\n  if (typeof this.addMissingDependency !== 'function') {\n    // This is Webpack 4 which does not support `import.meta`.\n    // We assume `.js` files are CommonJS because the output cannot be ESM anyway.\n    return 'cjs';\n  }\n\n  // We will assume CommonJS if we cannot determine otherwise\n  let packageJsonType = '';\n\n  // We begin our search for relevant `package.json` files,\n  // at the directory of the resource being loaded.\n  // These paths should already be resolved,\n  // but we resolve them again to ensure we are dealing with an aboslute path.\n  const resourceContext = path.dirname(this.resourcePath);\n  let searchPath = resourceContext;\n  let previousSearchPath = '';\n  // We start our search just above the root context of the webpack compilation\n  const stopPath = path.dirname(this.rootContext);\n\n  // If the module context is a resolved symlink outside the `rootContext` path,\n  // then we will never find the `stopPath` - so we also halt when we hit the root.\n  // Note that there is a potential that the wrong `package.json` is found in some pathalogical cases,\n  // such as a folder that is conceptually a package + does not have an ancestor `package.json`,\n  // but there exists a `package.json` higher up.\n  // This might happen if you have a folder of utility JS files that you symlink but did not organize as a package.\n  // We consider this an unsupported edge case for now.\n  while (searchPath !== stopPath && searchPath !== previousSearchPath) {\n    // If we have already determined the `package.json` type for this path we can stop searching.\n    // We do however still need to cache the found value,\n    // from the `resourcePath` folder up to the matching `searchPath`,\n    // to avoid retracing these steps when processing sibling resources.\n    if (packageJsonTypeMap.has(searchPath)) {\n      packageJsonType = packageJsonTypeMap.get(searchPath);\n\n      let currentPath = resourceContext;\n      while (currentPath !== searchPath) {\n        // We set the found type at least level from `resourcePath` folder up to the matching `searchPath`\n        packageJsonTypeMap.set(currentPath, packageJsonType);\n        currentPath = path.dirname(currentPath);\n      }\n      break;\n    }\n\n    let packageJsonPath = path.join(searchPath, 'package.json');\n    try {\n      const packageSource = await fsPromises.readFile(packageJsonPath, 'utf-8');\n      try {\n        const packageObject = JSON.parse(packageSource);\n\n        // Any package.json is sufficient as long as it can be parsed.\n        // If it does not explicitly have a `type: \"module\"` it will be assumed to be CommonJS.\n        packageJsonType = typeof packageObject.type === 'string' ? packageObject.type : '';\n        packageJsonTypeMap.set(searchPath, packageJsonType);\n\n        // We set the type in the cache for all paths from the `resourcePath` folder,\n        // up to the matching `searchPath` to avoid retracing these steps when processing sibling resources.\n        let currentPath = resourceContext;\n        while (currentPath !== searchPath) {\n          packageJsonTypeMap.set(currentPath, packageJsonType);\n          currentPath = path.dirname(currentPath);\n        }\n      } catch (e) {\n        // `package.json` exists but could not be parsed.\n        // We track it as a dependency so we can reload if this file changes.\n      }\n\n      this.addDependency(packageJsonPath);\n      break;\n    } catch (e) {\n      // `package.json` does not exist.\n      // We track it as a missing dependency so we can reload if this file is added.\n      this.addMissingDependency(packageJsonPath);\n    }\n\n    // Try again at the next level up\n    previousSearchPath = searchPath;\n    searchPath = path.dirname(searchPath);\n  }\n\n  // Check `package.json` for the `type` field -\n  // fallback to use `cjs` for anything ambiguous.\n  return packageJsonType === 'module' ? 'esm' : 'cjs';\n}\n\nmodule.exports = getModuleSystem;\n"],"mappings":"AAAA,MAAM;EAAEA,QAAQ,EAAEC;AAAW,CAAC,GAAGC,OAAO,CAAC,IAAI,CAAC;AAC9C,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;;AAE5B;AACA,IAAIE,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,eAAeA,CAACC,qBAAqB,EAAEC,OAAO,EAAE;EAC7D;EACA;EACA,QAAQ,OAAOA,OAAO,CAACC,QAAQ;IAC7B,KAAK,SAAS;MAAE;QACd,OAAOD,OAAO,CAACC,QAAQ,GAAG,KAAK,GAAG,KAAK;MACzC;IACA,KAAK,QAAQ;MAAE;QACb,IACED,OAAO,CAACC,QAAQ,CAACC,OAAO,IACxBH,qBAAqB,CAACI,SAAS,CAAC,IAAI,CAACC,YAAY,EAAEJ,OAAO,CAACC,QAAQ,CAACC,OAAO,CAAC,EAC5E;UACA,OAAO,KAAK;QACd;QACA,IACEF,OAAO,CAACC,QAAQ,CAACI,OAAO,IACxBN,qBAAqB,CAACI,SAAS,CAAC,IAAI,CAACC,YAAY,EAAEJ,OAAO,CAACC,QAAQ,CAACI,OAAO,CAAC,EAC5E;UACA,OAAO,KAAK;QACd;QAEA;MACF;IACA,QAAQ,CAAC;EACX;;EAEA;EACA,IAAI,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACF,YAAY,CAAC,EAAE,OAAO,KAAK;EAClD,IAAI,QAAQ,CAACE,IAAI,CAAC,IAAI,CAACF,YAAY,CAAC,EAAE,OAAO,KAAK;EAElD,IAAI,OAAO,IAAI,CAACG,oBAAoB,KAAK,UAAU,EAAE;IACnD;IACA;IACA,OAAO,KAAK;EACd;;EAEA;EACA,IAAIC,eAAe,GAAG,EAAE;;EAExB;EACA;EACA;EACA;EACA,MAAMC,eAAe,GAAGd,IAAI,CAACe,OAAO,CAAC,IAAI,CAACN,YAAY,CAAC;EACvD,IAAIO,UAAU,GAAGF,eAAe;EAChC,IAAIG,kBAAkB,GAAG,EAAE;EAC3B;EACA,MAAMC,QAAQ,GAAGlB,IAAI,CAACe,OAAO,CAAC,IAAI,CAACI,WAAW,CAAC;;EAE/C;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAOH,UAAU,KAAKE,QAAQ,IAAIF,UAAU,KAAKC,kBAAkB,EAAE;IACnE;IACA;IACA;IACA;IACA,IAAIhB,kBAAkB,CAACmB,GAAG,CAACJ,UAAU,CAAC,EAAE;MACtCH,eAAe,GAAGZ,kBAAkB,CAACoB,GAAG,CAACL,UAAU,CAAC;MAEpD,IAAIM,WAAW,GAAGR,eAAe;MACjC,OAAOQ,WAAW,KAAKN,UAAU,EAAE;QACjC;QACAf,kBAAkB,CAACsB,GAAG,CAACD,WAAW,EAAET,eAAe,CAAC;QACpDS,WAAW,GAAGtB,IAAI,CAACe,OAAO,CAACO,WAAW,CAAC;MACzC;MACA;IACF;IAEA,IAAIE,eAAe,GAAGxB,IAAI,CAACyB,IAAI,CAACT,UAAU,EAAE,cAAc,CAAC;IAC3D,IAAI;MACF,MAAMU,aAAa,GAAG,MAAM5B,UAAU,CAAC6B,QAAQ,CAACH,eAAe,EAAE,OAAO,CAAC;MACzE,IAAI;QACF,MAAMI,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACJ,aAAa,CAAC;;QAE/C;QACA;QACAb,eAAe,GAAG,OAAOe,aAAa,CAACG,IAAI,KAAK,QAAQ,GAAGH,aAAa,CAACG,IAAI,GAAG,EAAE;QAClF9B,kBAAkB,CAACsB,GAAG,CAACP,UAAU,EAAEH,eAAe,CAAC;;QAEnD;QACA;QACA,IAAIS,WAAW,GAAGR,eAAe;QACjC,OAAOQ,WAAW,KAAKN,UAAU,EAAE;UACjCf,kBAAkB,CAACsB,GAAG,CAACD,WAAW,EAAET,eAAe,CAAC;UACpDS,WAAW,GAAGtB,IAAI,CAACe,OAAO,CAACO,WAAW,CAAC;QACzC;MACF,CAAC,CAAC,OAAOU,CAAC,EAAE;QACV;QACA;MAAA;MAGF,IAAI,CAACC,aAAa,CAACT,eAAe,CAAC;MACnC;IACF,CAAC,CAAC,OAAOQ,CAAC,EAAE;MACV;MACA;MACA,IAAI,CAACpB,oBAAoB,CAACY,eAAe,CAAC;IAC5C;;IAEA;IACAP,kBAAkB,GAAGD,UAAU;IAC/BA,UAAU,GAAGhB,IAAI,CAACe,OAAO,CAACC,UAAU,CAAC;EACvC;;EAEA;EACA;EACA,OAAOH,eAAe,KAAK,QAAQ,GAAG,KAAK,GAAG,KAAK;AACrD;AAEAqB,MAAM,CAACC,OAAO,GAAGhC,eAAe","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}