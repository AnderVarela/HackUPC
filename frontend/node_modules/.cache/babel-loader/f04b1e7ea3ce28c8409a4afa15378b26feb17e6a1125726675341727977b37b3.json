{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxFlow = require(\"@babel/plugin-syntax-flow\");\nvar _core = require(\"@babel/core\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n  let skipStrip = false;\n  const {\n    requireDirective = false\n  } = opts;\n  {\n    var {\n      allowDeclareFields = false\n    } = opts;\n  }\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: _pluginSyntaxFlow.default,\n    visitor: {\n      Program(path, {\n        file: {\n          ast: {\n            comments\n          }\n        }\n      }) {\n        skipStrip = false;\n        let directiveFound = false;\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({\n          importKind\n        }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n      Flow(path) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\"A @flow directive is required when using Flow annotations with \" + \"the `requireDirective` option.\");\n        }\n        path.remove();\n      },\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const {\n              node\n            } = child;\n            {\n              if (!allowDeclareFields && node.declare) {\n                throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);\n              }\n            }\n            if (node.declare) {\n              child.remove();\n            } else {\n              {\n                if (!allowDeclareFields && !node.value && !node.decorators) {\n                  child.remove();\n                  return;\n                }\n              }\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n      AssignmentPattern({\n        node\n      }) {\n        if (skipStrip) return;\n        if (node.left.optional) {\n          node.left.optional = false;\n        }\n      },\n      Function({\n        node\n      }) {\n        if (skipStrip) return;\n        if (node.params.length > 0 && node.params[0].type === \"Identifier\" && node.params[0].name === \"this\") {\n          node.params.shift();\n        }\n        for (let i = 0; i < node.params.length; i++) {\n          let param = node.params[i];\n          if (param.type === \"AssignmentPattern\") {\n            param = param.left;\n          }\n          if (param.optional) {\n            param.optional = false;\n          }\n        }\n        if (!_core.types.isMethod(node)) {\n          node.predicate = null;\n        }\n      },\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let {\n          node\n        } = path;\n        do {\n          node = node.expression;\n        } while (_core.types.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n      CallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n      OptionalCallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n      NewExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      }\n    }\n  };\n});","map":{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxFlow","_core","_default","exports","default","declare","api","opts","assertVersion","FLOW_DIRECTIVE","skipStrip","requireDirective","allowDeclareFields","name","inherits","visitor","Program","path","file","ast","comments","directiveFound","comment","test","value","replace","trim","ignore","ImportDeclaration","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","buildCodeFrameError","ClassPrivateProperty","typeAnnotation","Class","implements","get","child","isClassProperty","decorators","variance","AssignmentPattern","left","optional","Function","params","type","shift","i","param","types","isMethod","predicate","TypeCastExpression","expression","isTypeCastExpression","replaceWith","CallExpression","typeArguments","OptionalCallExpression","NewExpression"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\plugin-transform-flow-strip-types\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxFlow from \"@babel/plugin-syntax-flow\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface Options {\n  requireDirective?: boolean;\n  allowDeclareFields?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n\n  let skipStrip = false;\n\n  const { requireDirective = false } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: syntaxFlow,\n\n    visitor: {\n      Program(\n        path,\n        {\n          file: {\n            ast: { comments },\n          },\n        },\n      ) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n\n              // remove flow directive\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              // remove the comment completely if it only consists of whitespace and/or stars\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n\n        let typeCount = 0;\n\n        // @ts-expect-error importKind is only in importSpecifier\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(\n        path: NodePath<\n          t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier\n        >,\n      ) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\n            \"A @flow directive is required when using Flow annotations with \" +\n              \"the `requireDirective` option.\",\n          );\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n\n        // We do this here instead of in a `ClassProperty` visitor because the class transform\n        // would transform the class before we reached the class property.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const { node } = child;\n\n            if (!process.env.BABEL_8_BREAKING) {\n              if (!allowDeclareFields && node.declare) {\n                throw child.buildCodeFrameError(\n                  `The 'declare' modifier is only allowed when the ` +\n                    `'allowDeclareFields' option of ` +\n                    `@babel/plugin-transform-flow-strip-types or ` +\n                    `@babel/preset-flow is enabled.`,\n                );\n              }\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (!allowDeclareFields && !node.value && !node.decorators) {\n                  child.remove();\n                  return;\n                }\n              }\n\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({ node }) {\n        if (skipStrip) return;\n        // @ts-expect-error optional is not in TSAsExpression\n        if (node.left.optional) {\n          // @ts-expect-error optional is not in TSAsExpression\n          node.left.optional = false;\n        }\n      },\n\n      Function({ node }) {\n        if (skipStrip) return;\n        if (\n          node.params.length > 0 &&\n          node.params[0].type === \"Identifier\" &&\n          node.params[0].name === \"this\"\n        ) {\n          node.params.shift();\n        }\n        for (let i = 0; i < node.params.length; i++) {\n          let param = node.params[i];\n          if (param.type === \"AssignmentPattern\") {\n            // @ts-expect-error: refine AST types, the left of an assignment pattern as a binding\n            // must not be a MemberExpression\n            param = param.left;\n          }\n          // @ts-expect-error optional is not in TSAsExpression\n          if (param.optional) {\n            // @ts-expect-error optional is not in TSAsExpression\n            param.optional = false;\n          }\n        }\n\n        if (!t.isMethod(node)) {\n          node.predicate = null;\n        }\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let { node } = path;\n        do {\n          // @ts-expect-error node is a search pointer\n          node = node.expression;\n        } while (t.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n\n      CallExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression({ node }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n    },\n  };\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,iBAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAAyC,IAAAG,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAQ1B,IAAAN,kBAAA,CAAAO,OAAO,EAAC,CAACC,GAAG,EAAEC,IAAa,KAAK;EAC7CD,GAAG,CAACE,aAAa,CAAkB,CAAE,CAAC;EAEtC,MAAMC,cAAc,GAAG,6CAA6C;EAEpE,IAAIC,SAAS,GAAG,KAAK;EAErB,MAAM;IAAEC,gBAAgB,GAAG;EAAM,CAAC,GAAGJ,IAAI;EAEN;IAEjC,IAAI;MAAEK,kBAAkB,GAAG;IAAM,CAAC,GAAGL,IAAI;EAC3C;EAEA,OAAO;IACLM,IAAI,EAAE,4BAA4B;IAClCC,QAAQ,EAAEd,iBAAA,CAAAI,OAAU;IAEpBW,OAAO,EAAE;MACPC,OAAOA,CACLC,IAAI,EACJ;QACEC,IAAI,EAAE;UACJC,GAAG,EAAE;YAAEC;UAAS;QAClB;MACF,CAAC,EACD;QACAV,SAAS,GAAG,KAAK;QACjB,IAAIW,cAAc,GAAG,KAAK;QAE1B,IAAID,QAAQ,EAAE;UACZ,KAAK,MAAME,OAAO,IAAIF,QAAQ,EAAE;YAC9B,IAAIX,cAAc,CAACc,IAAI,CAACD,OAAO,CAACE,KAAK,CAAC,EAAE;cACtCH,cAAc,GAAG,IAAI;cAGrBC,OAAO,CAACE,KAAK,GAAGF,OAAO,CAACE,KAAK,CAACC,OAAO,CAAChB,cAAc,EAAE,EAAE,CAAC;cAGzD,IAAI,CAACa,OAAO,CAACE,KAAK,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,EAAE;gBAC5CJ,OAAO,CAACK,MAAM,GAAG,IAAI;cACvB;YACF;UACF;QACF;QAEA,IAAI,CAACN,cAAc,IAAIV,gBAAgB,EAAE;UACvCD,SAAS,GAAG,IAAI;QAClB;MACF,CAAC;MACDkB,iBAAiBA,CAACX,IAAI,EAAE;QACtB,IAAIP,SAAS,EAAE;QACf,IAAI,CAACO,IAAI,CAACY,IAAI,CAACC,UAAU,CAACC,MAAM,EAAE;QAElC,IAAIC,SAAS,GAAG,CAAC;QAGjBf,IAAI,CAACY,IAAI,CAACC,UAAU,CAACG,OAAO,CAAC,CAAC;UAAEC;QAAW,CAAC,KAAK;UAC/C,IAAIA,UAAU,KAAK,MAAM,IAAIA,UAAU,KAAK,QAAQ,EAAE;YACpDF,SAAS,EAAE;UACb;QACF,CAAC,CAAC;QAEF,IAAIA,SAAS,KAAKf,IAAI,CAACY,IAAI,CAACC,UAAU,CAACC,MAAM,EAAE;UAC7Cd,IAAI,CAACkB,MAAM,CAAC,CAAC;QACf;MACF,CAAC;MAEDC,IAAIA,CACFnB,IAEC,EACD;QACA,IAAIP,SAAS,EAAE;UACb,MAAMO,IAAI,CAACoB,mBAAmB,CAC5B,iEAAiE,GAC/D,gCACJ,CAAC;QACH;QAEApB,IAAI,CAACkB,MAAM,CAAC,CAAC;MACf,CAAC;MAEDG,oBAAoBA,CAACrB,IAAI,EAAE;QACzB,IAAIP,SAAS,EAAE;QACfO,IAAI,CAACY,IAAI,CAACU,cAAc,GAAG,IAAI;MACjC,CAAC;MAEDC,KAAKA,CAACvB,IAAI,EAAE;QACV,IAAIP,SAAS,EAAE;QACfO,IAAI,CAACY,IAAI,CAACY,UAAU,GAAG,IAAI;QAI3BxB,IAAI,CAACyB,GAAG,CAAC,WAAW,CAAC,CAACT,OAAO,CAACU,KAAK,IAAI;UACrC,IAAIA,KAAK,CAACC,eAAe,CAAC,CAAC,EAAE;YAC3B,MAAM;cAAEf;YAAK,CAAC,GAAGc,KAAK;YAEa;cACjC,IAAI,CAAC/B,kBAAkB,IAAIiB,IAAI,CAACxB,OAAO,EAAE;gBACvC,MAAMsC,KAAK,CAACN,mBAAmB,CAC5B,kDAAiD,GAC/C,iCAAgC,GAChC,8CAA6C,GAC7C,gCACL,CAAC;cACH;YACF;YAEA,IAAIR,IAAI,CAACxB,OAAO,EAAE;cAChBsC,KAAK,CAACR,MAAM,CAAC,CAAC;YAChB,CAAC,MAAM;cAC8B;gBACjC,IAAI,CAACvB,kBAAkB,IAAI,CAACiB,IAAI,CAACL,KAAK,IAAI,CAACK,IAAI,CAACgB,UAAU,EAAE;kBAC1DF,KAAK,CAACR,MAAM,CAAC,CAAC;kBACd;gBACF;cACF;cAEAN,IAAI,CAACiB,QAAQ,GAAG,IAAI;cACpBjB,IAAI,CAACU,cAAc,GAAG,IAAI;YAC5B;UACF;QACF,CAAC,CAAC;MACJ,CAAC;MAEDQ,iBAAiBA,CAAC;QAAElB;MAAK,CAAC,EAAE;QAC1B,IAAInB,SAAS,EAAE;QAEf,IAAImB,IAAI,CAACmB,IAAI,CAACC,QAAQ,EAAE;UAEtBpB,IAAI,CAACmB,IAAI,CAACC,QAAQ,GAAG,KAAK;QAC5B;MACF,CAAC;MAEDC,QAAQA,CAAC;QAAErB;MAAK,CAAC,EAAE;QACjB,IAAInB,SAAS,EAAE;QACf,IACEmB,IAAI,CAACsB,MAAM,CAACpB,MAAM,GAAG,CAAC,IACtBF,IAAI,CAACsB,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,KAAK,YAAY,IACpCvB,IAAI,CAACsB,MAAM,CAAC,CAAC,CAAC,CAACtC,IAAI,KAAK,MAAM,EAC9B;UACAgB,IAAI,CAACsB,MAAM,CAACE,KAAK,CAAC,CAAC;QACrB;QACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,IAAI,CAACsB,MAAM,CAACpB,MAAM,EAAEuB,CAAC,EAAE,EAAE;UAC3C,IAAIC,KAAK,GAAG1B,IAAI,CAACsB,MAAM,CAACG,CAAC,CAAC;UAC1B,IAAIC,KAAK,CAACH,IAAI,KAAK,mBAAmB,EAAE;YAGtCG,KAAK,GAAGA,KAAK,CAACP,IAAI;UACpB;UAEA,IAAIO,KAAK,CAACN,QAAQ,EAAE;YAElBM,KAAK,CAACN,QAAQ,GAAG,KAAK;UACxB;QACF;QAEA,IAAI,CAAChD,KAAA,CAAAuD,KAAC,CAACC,QAAQ,CAAC5B,IAAI,CAAC,EAAE;UACrBA,IAAI,CAAC6B,SAAS,GAAG,IAAI;QACvB;MACF,CAAC;MAEDC,kBAAkBA,CAAC1C,IAAI,EAAE;QACvB,IAAIP,SAAS,EAAE;QACf,IAAI;UAAEmB;QAAK,CAAC,GAAGZ,IAAI;QACnB,GAAG;UAEDY,IAAI,GAAGA,IAAI,CAAC+B,UAAU;QACxB,CAAC,QAAQ3D,KAAA,CAAAuD,KAAC,CAACK,oBAAoB,CAAChC,IAAI,CAAC;QACrCZ,IAAI,CAAC6C,WAAW,CAACjC,IAAI,CAAC;MACxB,CAAC;MAEDkC,cAAcA,CAAC;QAAElC;MAAK,CAAC,EAAE;QACvB,IAAInB,SAAS,EAAE;QACfmB,IAAI,CAACmC,aAAa,GAAG,IAAI;MAC3B,CAAC;MAEDC,sBAAsBA,CAAC;QAAEpC;MAAK,CAAC,EAAE;QAC/B,IAAInB,SAAS,EAAE;QACfmB,IAAI,CAACmC,aAAa,GAAG,IAAI;MAC3B,CAAC;MAEDE,aAAaA,CAAC;QAAErC;MAAK,CAAC,EAAE;QACtB,IAAInB,SAAS,EAAE;QACfmB,IAAI,CAACmC,aAAa,GAAG,IAAI;MAC3B;IACF;EACF,CAAC;AACH,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}