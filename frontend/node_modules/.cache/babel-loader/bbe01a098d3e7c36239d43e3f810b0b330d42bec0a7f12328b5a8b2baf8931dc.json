{"ast":null,"code":"const getCurrentScriptSource = require('./getCurrentScriptSource.js');\n\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} hostname\n * @property {string} [protocol]\n * @property {string} pathname\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @param {import('./getWDSMetadata').WDSMetaObj} [metadata] The parsed WDS metadata object.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\nfunction getSocketUrlParts(resourceQuery, metadata) {\n  if (typeof metadata === 'undefined') {\n    metadata = {};\n  }\n\n  /** @type {SocketUrlParts} */\n  let urlParts = {};\n\n  // If the resource query is available,\n  // parse it and ignore everything we received from the script host.\n  if (resourceQuery) {\n    const parsedQuery = {};\n    const searchParams = new URLSearchParams(resourceQuery.slice(1));\n    searchParams.forEach(function (value, key) {\n      parsedQuery[key] = value;\n    });\n    urlParts.hostname = parsedQuery.sockHost;\n    urlParts.pathname = parsedQuery.sockPath;\n    urlParts.port = parsedQuery.sockPort;\n\n    // Make sure the protocol from resource query has a trailing colon\n    if (parsedQuery.sockProtocol) {\n      urlParts.protocol = parsedQuery.sockProtocol + ':';\n    }\n  } else {\n    const scriptSource = getCurrentScriptSource();\n    let url = {};\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      url = new URL(scriptSource, window.location.href);\n    } catch (e) {\n      // URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n\n    // Parse authentication credentials in case we need them\n    if (url.username) {\n      // Since HTTP basic authentication does not allow empty username,\n      // we only include password if the username is not empty.\n      // Result: <username> or <username>:<password>\n      urlParts.auth = url.username;\n      if (url.password) {\n        urlParts.auth += ':' + url.password;\n      }\n    }\n\n    // `file://` URLs has `'null'` origin\n    if (url.origin !== 'null') {\n      urlParts.hostname = url.hostname;\n    }\n    urlParts.protocol = url.protocol;\n    urlParts.port = url.port;\n  }\n  if (!urlParts.pathname) {\n    if (metadata.version === 4) {\n      // This is hard-coded in WDS v4\n      urlParts.pathname = '/ws';\n    } else {\n      // This is hard-coded in WDS v3\n      urlParts.pathname = '/sockjs-node';\n    }\n  }\n\n  // Check for IPv4 and IPv6 host addresses that correspond to any/empty.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as 'about:blank' or 'file://' URLs.\n  const isEmptyHostname = urlParts.hostname === '0.0.0.0' || urlParts.hostname === '[::]' || !urlParts.hostname;\n  // We only re-assign the hostname if it is empty,\n  // and if we are using HTTP/HTTPS protocols.\n  if (isEmptyHostname && window.location.hostname && window.location.protocol.indexOf('http') === 0) {\n    urlParts.hostname = window.location.hostname;\n  }\n\n  // We only re-assign `protocol` when `protocol` is unavailable,\n  // or if `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when no sockProtocol was passed to the config and 'https' is used,\n  // as it mandates the use of secure sockets.\n  if (!urlParts.protocol || urlParts.hostname && (isEmptyHostname || !resourceQuery && window.location.protocol === 'https:')) {\n    urlParts.protocol = window.location.protocol;\n  }\n\n  // We only re-assign port when it is not available\n  if (!urlParts.port) {\n    urlParts.port = window.location.port;\n  }\n  if (!urlParts.hostname || !urlParts.pathname) {\n    throw new Error(['[React Refresh] Failed to get an URL for the socket connection.', \"This usually means that the current executed script doesn't have a `src` attribute set.\", 'You should either specify the socket path parameters under the `devServer` key in your Webpack config, or use the `overlay` option.', 'https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md#overlay'].join('\\n'));\n  }\n  return {\n    auth: urlParts.auth,\n    hostname: urlParts.hostname,\n    pathname: urlParts.pathname,\n    protocol: urlParts.protocol,\n    port: urlParts.port || undefined\n  };\n}\nmodule.exports = getSocketUrlParts;","map":{"version":3,"names":["getCurrentScriptSource","require","getSocketUrlParts","resourceQuery","metadata","urlParts","parsedQuery","searchParams","URLSearchParams","slice","forEach","value","key","hostname","sockHost","pathname","sockPath","port","sockPort","sockProtocol","protocol","scriptSource","url","URL","window","location","href","e","username","auth","password","origin","version","isEmptyHostname","indexOf","Error","join","undefined","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/sockets/utils/getSocketUrlParts.js"],"sourcesContent":["const getCurrentScriptSource = require('./getCurrentScriptSource.js');\n\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} hostname\n * @property {string} [protocol]\n * @property {string} pathname\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @param {import('./getWDSMetadata').WDSMetaObj} [metadata] The parsed WDS metadata object.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\nfunction getSocketUrlParts(resourceQuery, metadata) {\n  if (typeof metadata === 'undefined') {\n    metadata = {};\n  }\n\n  /** @type {SocketUrlParts} */\n  let urlParts = {};\n\n  // If the resource query is available,\n  // parse it and ignore everything we received from the script host.\n  if (resourceQuery) {\n    const parsedQuery = {};\n    const searchParams = new URLSearchParams(resourceQuery.slice(1));\n    searchParams.forEach(function (value, key) {\n      parsedQuery[key] = value;\n    });\n\n    urlParts.hostname = parsedQuery.sockHost;\n    urlParts.pathname = parsedQuery.sockPath;\n    urlParts.port = parsedQuery.sockPort;\n\n    // Make sure the protocol from resource query has a trailing colon\n    if (parsedQuery.sockProtocol) {\n      urlParts.protocol = parsedQuery.sockProtocol + ':';\n    }\n  } else {\n    const scriptSource = getCurrentScriptSource();\n\n    let url = {};\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      url = new URL(scriptSource, window.location.href);\n    } catch (e) {\n      // URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n\n    // Parse authentication credentials in case we need them\n    if (url.username) {\n      // Since HTTP basic authentication does not allow empty username,\n      // we only include password if the username is not empty.\n      // Result: <username> or <username>:<password>\n      urlParts.auth = url.username;\n      if (url.password) {\n        urlParts.auth += ':' + url.password;\n      }\n    }\n\n    // `file://` URLs has `'null'` origin\n    if (url.origin !== 'null') {\n      urlParts.hostname = url.hostname;\n    }\n\n    urlParts.protocol = url.protocol;\n    urlParts.port = url.port;\n  }\n\n  if (!urlParts.pathname) {\n    if (metadata.version === 4) {\n      // This is hard-coded in WDS v4\n      urlParts.pathname = '/ws';\n    } else {\n      // This is hard-coded in WDS v3\n      urlParts.pathname = '/sockjs-node';\n    }\n  }\n\n  // Check for IPv4 and IPv6 host addresses that correspond to any/empty.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as 'about:blank' or 'file://' URLs.\n  const isEmptyHostname =\n    urlParts.hostname === '0.0.0.0' || urlParts.hostname === '[::]' || !urlParts.hostname;\n  // We only re-assign the hostname if it is empty,\n  // and if we are using HTTP/HTTPS protocols.\n  if (\n    isEmptyHostname &&\n    window.location.hostname &&\n    window.location.protocol.indexOf('http') === 0\n  ) {\n    urlParts.hostname = window.location.hostname;\n  }\n\n  // We only re-assign `protocol` when `protocol` is unavailable,\n  // or if `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when no sockProtocol was passed to the config and 'https' is used,\n  // as it mandates the use of secure sockets.\n  if (\n    !urlParts.protocol ||\n    (urlParts.hostname &&\n      (isEmptyHostname || (!resourceQuery && window.location.protocol === 'https:')))\n  ) {\n    urlParts.protocol = window.location.protocol;\n  }\n\n  // We only re-assign port when it is not available\n  if (!urlParts.port) {\n    urlParts.port = window.location.port;\n  }\n\n  if (!urlParts.hostname || !urlParts.pathname) {\n    throw new Error(\n      [\n        '[React Refresh] Failed to get an URL for the socket connection.',\n        \"This usually means that the current executed script doesn't have a `src` attribute set.\",\n        'You should either specify the socket path parameters under the `devServer` key in your Webpack config, or use the `overlay` option.',\n        'https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md#overlay',\n      ].join('\\n')\n    );\n  }\n\n  return {\n    auth: urlParts.auth,\n    hostname: urlParts.hostname,\n    pathname: urlParts.pathname,\n    protocol: urlParts.protocol,\n    port: urlParts.port || undefined,\n  };\n}\n\nmodule.exports = getSocketUrlParts;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}