{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourceMap = {}));\n})(this, function (exports) {\n  'use strict';\n\n  const comma = ','.charCodeAt(0);\n  const semicolon = ';'.charCodeAt(0);\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const intToChar = new Uint8Array(64); // 64 possible chars.\n  const charToInt = new Uint8Array(128); // z is 122 in ASCII\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  }\n  // Provide a fallback for older environments.\n  const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode(buf) {\n      let out = '';\n      for (let i = 0; i < buf.length; i++) {\n        out += String.fromCharCode(buf[i]);\n      }\n      return out;\n    }\n  };\n  function decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n      const semi = indexOf(mappings, index);\n      const line = [];\n      let sorted = true;\n      let lastCol = 0;\n      state[0] = 0;\n      for (let i = index; i < semi; i++) {\n        let seg;\n        i = decodeInteger(mappings, i, state, 0); // genColumn\n        const col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n          i = decodeInteger(mappings, i, state, 2); // sourceLine\n          i = decodeInteger(mappings, i, state, 3); // sourceColumn\n          if (hasMoreVlq(mappings, i, semi)) {\n            i = decodeInteger(mappings, i, state, 4); // namesIndex\n            seg = [col, state[1], state[2], state[3], state[4]];\n          } else {\n            seg = [col, state[1], state[2], state[3]];\n          }\n        } else {\n          seg = [col];\n        }\n        line.push(seg);\n      }\n      if (!sorted) sort(line);\n      decoded.push(line);\n      index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n  }\n  function indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n  }\n  function decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n      const c = mappings.charCodeAt(pos++);\n      integer = charToInt[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n  }\n  function hasMoreVlq(mappings, i, length) {\n    if (i >= length) return false;\n    return mappings.charCodeAt(i) !== comma;\n  }\n  function sort(line) {\n    line.sort(sortComparator$1);\n  }\n  function sortComparator$1(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      if (i > 0) {\n        if (pos === bufLength) {\n          out += td.decode(buf);\n          pos = 0;\n        }\n        buf[pos++] = semicolon;\n      }\n      if (line.length === 0) continue;\n      state[0] = 0;\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j];\n        // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n        if (pos > subLength) {\n          out += td.decode(sub);\n          buf.copyWithin(0, subLength, pos);\n          pos -= subLength;\n        }\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n      }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n  }\n  function encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n    do {\n      let clamped = num & 0b011111;\n      num >>>= 5;\n      if (num > 0) clamped |= 0b100000;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n  }\n\n  // Matches the scheme of a URL, eg \"http://\"\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: 7 /* Absolute */\n    };\n  }\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = 6 /* SchemeRelative */;\n      return url;\n    }\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = 5 /* AbsolutePath */;\n      return url;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? 3 /* Query */ : input.startsWith('#') ? 2 /* Hash */ : 4 /* RelativePath */ : 1 /* Empty */;\n    return url;\n  }\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  function mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n  function normalizePath(url, type) {\n    const rel = type <= 4 /* RelativePath */;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i];\n      // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      }\n      // If we encounter a real directory, then we don't need to append anymore.\n      addTrailingSlash = false;\n      // A current directory, which we can always drop.\n      if (piece === '.') continue;\n      // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n        continue;\n      }\n      // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n      pieces[pointer++] = piece;\n      positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n  function resolve$1(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== 7 /* Absolute */) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n      switch (inputType) {\n        case 1 /* Empty */:\n          url.hash = baseUrl.hash;\n        // fall through\n        case 2 /* Hash */:\n          url.query = baseUrl.query;\n        // fall through\n        case 3 /* Query */:\n        case 4 /* RelativePath */:\n          mergePaths(url, baseUrl);\n        // fall through\n        case 5 /* AbsolutePath */:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n        case 6 /* SchemeRelative */:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n      if (baseType > inputType) inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case 2 /* Hash */:\n      case 3 /* Query */:\n        return queryHash;\n      case 4 /* RelativePath */:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n          return path + queryHash;\n        }\n      case 5 /* AbsolutePath */:\n        return url.path + queryHash;\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolve$1(input, base);\n  }\n\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n  function stripFilename(path) {\n    if (!path) return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  const COLUMN$1 = 0;\n  const SOURCES_INDEX$1 = 1;\n  const SOURCE_LINE$1 = 2;\n  const SOURCE_COLUMN$1 = 3;\n  const NAMES_INDEX$1 = 4;\n  const REV_GENERATED_LINE = 1;\n  const REV_GENERATED_COLUMN = 2;\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned) mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n  }\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n    return mappings.length;\n  }\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n      if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[COLUMN$1] - b[COLUMN$1];\n  }\n  let found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][COLUMN$1] - needle;\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    found = false;\n    return low - 1;\n  }\n  function upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n      if (haystack[i][COLUMN$1] !== needle) break;\n    }\n    return index;\n  }\n  function lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n      if (haystack[i][COLUMN$1] !== needle) break;\n    }\n    return index;\n  }\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      lastKey,\n      lastNeedle,\n      lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;\n        return lastIndex;\n      }\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n\n  // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n  // of generated line/column.\n  function buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        if (seg.length === 1) continue;\n        const sourceIndex = seg[SOURCES_INDEX$1];\n        const sourceLine = seg[SOURCE_LINE$1];\n        const sourceColumn = seg[SOURCE_COLUMN$1];\n        const originalSource = sources[sourceIndex];\n        const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n        const memo = memos[sourceIndex];\n        // The binary search either found a match, or it found the left-index just before where the\n        // segment should go. Either way, we want to insert after that. And there may be multiple\n        // generated segments associated with an original location, so there may need to move several\n        // indexes before we find where we need to insert.\n        let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n        memo.lastIndex = ++index;\n        insert$1(originalLine, index, [sourceColumn, i, seg[COLUMN$1]]);\n      }\n    }\n    return sources;\n  }\n  function insert$1(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n  // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n  // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n  // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n  // order when iterating with for-in.\n  function buildNullArray() {\n    return {\n      __proto__: null\n    };\n  }\n  const AnyMap = function (map, mapUrl) {\n    const parsed = parse(map);\n    if (!('sections' in parsed)) {\n      return new TraceMap(parsed, mapUrl);\n    }\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const ignoreList = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n    const joined = {\n      version: 3,\n      file: parsed.file,\n      names,\n      sources,\n      sourcesContent,\n      mappings,\n      ignoreList\n    };\n    return presortedDecodedMap(joined);\n  };\n  function parse(map) {\n    return typeof map === 'string' ? JSON.parse(map) : map;\n  }\n  function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const {\n      sections\n    } = input;\n    for (let i = 0; i < sections.length; i++) {\n      const {\n        map,\n        offset\n      } = sections[i];\n      let sl = stopLine;\n      let sc = stopColumn;\n      if (i + 1 < sections.length) {\n        const nextOffset = sections[i + 1].offset;\n        sl = Math.min(stopLine, lineOffset + nextOffset.line);\n        if (sl === stopLine) {\n          sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n        } else if (sl < stopLine) {\n          sc = columnOffset + nextOffset.column;\n        }\n      }\n      addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n  }\n  function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const parsed = parse(input);\n    if ('sections' in parsed) return recurse(...arguments);\n    const map = new TraceMap(parsed, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const {\n      resolvedSources,\n      sourcesContent: contents,\n      ignoreList: ignores\n    } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n    if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n    for (let i = 0; i < decoded.length; i++) {\n      const lineI = lineOffset + i;\n      // We can only add so many lines before we step into the range that the next section's map\n      // controls. When we get to the last line, then we'll start checking the segments to see if\n      // they've crossed into the column range. But it may not have any columns that overstep, so we\n      // still need to check that we don't overstep lines, too.\n      if (lineI > stopLine) return;\n      // The out line may already exist in mappings (if we're continuing the line started by a\n      // previous section). Or, we may have jumped ahead several lines to start this section.\n      const out = getLine$1(mappings, lineI);\n      // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n      const cOffset = i === 0 ? columnOffset : 0;\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const column = cOffset + seg[COLUMN$1];\n        // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n        if (lineI === stopLine && column >= stopColumn) return;\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n        const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX$1];\n        const sourceLine = seg[SOURCE_LINE$1];\n        const sourceColumn = seg[SOURCE_COLUMN$1];\n        out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX$1]]);\n      }\n    }\n  }\n  function append(arr, other) {\n    for (let i = 0; i < other.length; i++) arr.push(other[i]);\n  }\n  function getLine$1(arr, index) {\n    for (let i = arr.length; i <= index; i++) arr[i] = [];\n    return arr[index];\n  }\n  const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  const LEAST_UPPER_BOUND = -1;\n  const GREATEST_LOWER_BOUND = 1;\n  class TraceMap {\n    constructor(map, mapUrl) {\n      const isString = typeof map === 'string';\n      if (!isString && map._decodedMemo) return map;\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        version,\n        file,\n        names,\n        sourceRoot,\n        sources,\n        sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names || [];\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n      this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n      const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n      this.resolvedSources = sources.map(s => resolve(s || '', from));\n      const {\n        mappings\n      } = parsed;\n      if (typeof mappings === 'string') {\n        this._encoded = mappings;\n        this._decoded = undefined;\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n      this._decodedMemo = memoizedState();\n      this._bySources = undefined;\n      this._bySourceMemos = undefined;\n    }\n  }\n  /**\n   * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n   * with public access modifiers.\n   */\n  function cast$2(map) {\n    return map;\n  }\n  /**\n   * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n   */\n  function encodedMappings(map) {\n    var _a;\n    var _b;\n    return (_a = (_b = cast$2(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = encode(cast$2(map)._decoded);\n  }\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n  function decodedMappings(map) {\n    var _a;\n    return (_a = cast$2(map))._decoded || (_a._decoded = decode(cast$2(map)._encoded));\n  }\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n  function originalPositionFor(map, needle) {\n    let {\n      line,\n      column,\n      bias\n    } = needle;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length) return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast$2(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1) return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1) return OMapping(null, null, null, null);\n    const {\n      names,\n      resolvedSources\n    } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);\n  }\n  /**\n   * Finds the generated line/column position of the provided source/line/column source position.\n   */\n  function generatedPositionFor(map, needle) {\n    const {\n      source,\n      line,\n      column,\n      bias\n    } = needle;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n  }\n  /**\n   * Finds all generated line/column positions of the provided source/line/column source position.\n   */\n  function allGeneratedPositionsFor(map, needle) {\n    const {\n      source,\n      line,\n      column,\n      bias\n    } = needle;\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n  }\n  /**\n   * Iterates each mapping in generated position order.\n   */\n  function eachMapping(map, cb) {\n    const decoded = decodedMappings(map);\n    const {\n      names,\n      resolvedSources\n    } = map;\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generatedLine = i + 1;\n        const generatedColumn = seg[0];\n        let source = null;\n        let originalLine = null;\n        let originalColumn = null;\n        let name = null;\n        if (seg.length !== 1) {\n          source = resolvedSources[seg[1]];\n          originalLine = seg[2] + 1;\n          originalColumn = seg[3];\n        }\n        if (seg.length === 5) name = names[seg[4]];\n        cb({\n          generatedLine,\n          generatedColumn,\n          source,\n          originalLine,\n          originalColumn,\n          name\n        });\n      }\n    }\n  }\n  function sourceIndex(map, source) {\n    const {\n      sources,\n      resolvedSources\n    } = map;\n    let index = sources.indexOf(source);\n    if (index === -1) index = resolvedSources.indexOf(source);\n    return index;\n  }\n  /**\n   * Retrieves the source content for a particular source, if its found. Returns null if not.\n   */\n  function sourceContentFor(map, source) {\n    const {\n      sourcesContent\n    } = map;\n    if (sourcesContent == null) return null;\n    const index = sourceIndex(map, source);\n    return index === -1 ? null : sourcesContent[index];\n  }\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n  function presortedDecodedMap(map, mapUrl) {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    cast$2(tracer)._decoded = map.mappings;\n    return tracer;\n  }\n  function clone(map, mappings) {\n    return {\n      version: map.version,\n      file: map.file,\n      names: map.names,\n      sourceRoot: map.sourceRoot,\n      sources: map.sources,\n      sourcesContent: map.sourcesContent,\n      mappings,\n      ignoreList: map.ignoreList || map.x_google_ignoreList\n    };\n  }\n  function OMapping(source, line, column, name) {\n    return {\n      source,\n      line,\n      column,\n      name\n    };\n  }\n  function GMapping(line, column) {\n    return {\n      line,\n      column\n    };\n  }\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n    if (index === -1 || index === segments.length) return -1;\n    return index;\n  }\n  function sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND) min++;\n    if (min === -1 || min === segments.length) return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN$1];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found) min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n      const segment = segments[min];\n      result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n  }\n  function generatedPosition(map, source, line, column, bias, all) {\n    var _a;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const {\n      sources,\n      resolvedSources\n    } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n    const generated = (_a = cast$2(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast$2(map)._bySourceMemos = sources.map(memoizedState)));\n    const segments = generated[sourceIndex][line];\n    if (segments == null) return all ? [] : GMapping(null, null);\n    const memo = cast$2(map)._bySourceMemos[sourceIndex];\n    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1) return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n  }\n\n  /**\n   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n   * index of the `key` in the backing array.\n   *\n   * This is designed to allow synchronizing a second array with the contents of the backing array,\n   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n   * and there are never duplicates.\n   */\n  class SetArray {\n    constructor() {\n      this._indexes = {\n        __proto__: null\n      };\n      this.array = [];\n    }\n  }\n  /**\n   * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n   * with public access modifiers.\n   */\n  function cast$1(set) {\n    return set;\n  }\n  /**\n   * Gets the index associated with `key` in the backing array, if it is already present.\n   */\n  function get(setarr, key) {\n    return cast$1(setarr)._indexes[key];\n  }\n  /**\n   * Puts `key` into the backing array, if it is not already present. Returns\n   * the index of the `key` in the backing array.\n   */\n  function put(setarr, key) {\n    // The key may or may not be present. If it is present, it's a number.\n    const index = get(setarr, key);\n    if (index !== undefined) return index;\n    const {\n      array,\n      _indexes: indexes\n    } = cast$1(setarr);\n    const length = array.push(key);\n    return indexes[key] = length - 1;\n  }\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const NO_NAME = -1;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n  class GenMapping {\n    constructor({\n      file,\n      sourceRoot\n    } = {}) {\n      this._names = new SetArray();\n      this._sources = new SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n      this._ignoreList = new SetArray();\n    }\n  }\n  /**\n   * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n   * with public access modifiers.\n   */\n  function cast(map) {\n    return map;\n  }\n  /**\n   * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n   * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n   * not add a mapping with a lower generated line/column than one that came before.\n   */\n  const maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n  };\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n  function setSourceContent(map, source, content) {\n    const {\n      _sources: sources,\n      _sourcesContent: sourcesContent\n    } = cast(map);\n    const index = put(sources, source);\n    sourcesContent[index] = content;\n  }\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  function toDecodedMap(map) {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names,\n      _ignoreList: ignoreList\n    } = cast(map);\n    removeEmptyFinalLines(mappings);\n    return {\n      version: 3,\n      file: map.file || undefined,\n      names: names.array,\n      sourceRoot: map.sourceRoot || undefined,\n      sources: sources.array,\n      sourcesContent,\n      mappings,\n      ignoreList: ignoreList.array\n    };\n  }\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  function toEncodedMap(map) {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      mappings: encode(decoded.mappings)\n    });\n  }\n  /**\n   * Constructs a new GenMapping, using the already present mappings of the input.\n   */\n  function fromMap(input) {\n    const map = new TraceMap(input);\n    const gen = new GenMapping({\n      file: map.file,\n      sourceRoot: map.sourceRoot\n    });\n    putAll(cast(gen)._names, map.names);\n    putAll(cast(gen)._sources, map.sources);\n    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    cast(gen)._mappings = decodedMappings(map);\n    if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n    return gen;\n  }\n  // This split declaration is only so that terser can elminiate the static initialization block.\n  function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = cast(map);\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n    if (!source) {\n      if (skipable && skipSourceless(line, index)) return;\n      return insert(line, index, [genColumn]);\n    }\n    const sourcesIndex = put(sources, source);\n    const namesIndex = name ? put(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n      return;\n    }\n    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n  }\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n      mappings[i] = [];\n    }\n    return mappings[index];\n  }\n  function getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n      const current = line[i];\n      if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n  }\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  function removeEmptyFinalLines(mappings) {\n    const {\n      length\n    } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n      if (mappings[i].length > 0) break;\n    }\n    if (len < length) mappings.length = len;\n  }\n  function putAll(setarr, array) {\n    for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n  }\n  function skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n  }\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1) return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n  function addMappingInternal(skipable, map, mapping) {\n    const {\n      generated,\n      source,\n      original,\n      name,\n      content\n    } = mapping;\n    if (!source) {\n      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n  }\n  class SourceMapConsumer {\n    constructor(map, mapUrl) {\n      const trace = this._map = new AnyMap(map, mapUrl);\n      this.file = trace.file;\n      this.names = trace.names;\n      this.sourceRoot = trace.sourceRoot;\n      this.sources = trace.resolvedSources;\n      this.sourcesContent = trace.sourcesContent;\n      this.version = trace.version;\n    }\n    static fromSourceMap(map, mapUrl) {\n      // This is more performant if we receive\n      // a @jridgewell/source-map SourceMapGenerator\n      if (map.toDecodedMap) {\n        return new SourceMapConsumer(map.toDecodedMap(), mapUrl);\n      }\n      // This is a fallback for `source-map` and `source-map-js`\n      return new SourceMapConsumer(map.toJSON(), mapUrl);\n    }\n    get mappings() {\n      return encodedMappings(this._map);\n    }\n    originalPositionFor(needle) {\n      return originalPositionFor(this._map, needle);\n    }\n    generatedPositionFor(originalPosition) {\n      return generatedPositionFor(this._map, originalPosition);\n    }\n    allGeneratedPositionsFor(originalPosition) {\n      return allGeneratedPositionsFor(this._map, originalPosition);\n    }\n    hasContentsOfAllSources() {\n      if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {\n        return false;\n      }\n      for (const content of this.sourcesContent) {\n        if (content == null) {\n          return false;\n        }\n      }\n      return true;\n    }\n    sourceContentFor(source, nullOnMissing) {\n      const sourceContent = sourceContentFor(this._map, source);\n      if (sourceContent != null) {\n        return sourceContent;\n      }\n      if (nullOnMissing) {\n        return null;\n      }\n      throw new Error(`\"${source}\" is not in the SourceMap.`);\n    }\n    eachMapping(callback, context /*, order?: number*/) {\n      // order is ignored as @jridgewell/trace-map doesn't implement it\n      eachMapping(this._map, context ? callback.bind(context) : callback);\n    }\n    destroy() {\n      // noop.\n    }\n  }\n  class SourceMapGenerator {\n    constructor(opts) {\n      // TODO :: should this be duck-typed ?\n      this._map = opts instanceof GenMapping ? opts : new GenMapping(opts);\n    }\n    static fromSourceMap(consumer) {\n      return new SourceMapGenerator(fromMap(consumer));\n    }\n    addMapping(mapping) {\n      maybeAddMapping(this._map, mapping);\n    }\n    setSourceContent(source, content) {\n      setSourceContent(this._map, source, content);\n    }\n    toJSON() {\n      return toEncodedMap(this._map);\n    }\n    toString() {\n      return JSON.stringify(this.toJSON());\n    }\n    toDecodedMap() {\n      return toDecodedMap(this._map);\n    }\n  }\n  exports.SourceMapConsumer = SourceMapConsumer;\n  exports.SourceMapGenerator = SourceMapGenerator;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInt","i","length","c","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","mappings","state","Int32Array","decoded","index","semi","indexOf","line","sorted","lastCol","seg","decodeInteger","col","hasMoreVlq","push","sort","idx","pos","j","value","shift","integer","shouldNegate","sortComparator$1","sortComparator","a","b","encode","bufLength","subLength","sub","subarray","segment","copyWithin","encodeInteger","next","num","clamped","schemeRegex","urlRegex","fileRegex","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","parseUrl","url","stripPathFilename","endsWith","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","piece","resolve$1","resolve","inputType","baseUrl","baseType","queryHash","stripFilename","COLUMN$1","SOURCES_INDEX$1","SOURCE_LINE$1","SOURCE_COLUMN$1","NAMES_INDEX$1","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","owned","unsortedIndex","nextUnsortedSegmentLine","sortSegments","start","isSorted","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","key","buildBySources","memos","sources","map","buildNullArray","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert$1","insert","array","__proto__","AnyMap","mapUrl","parsed","parse","TraceMap","sourcesContent","names","ignoreList","recurse","Infinity","joined","version","file","presortedDecodedMap","JSON","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","ignores","append","lineI","getLine$1","cOffset","sourcesIndex","arr","other","getLine","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","constructor","isString","_decodedMemo","sourceRoot","x_google_ignoreList","undefined","s","_encoded","_decoded","_bySources","_bySourceMemos","cast$2","cast","encodedMappings","_a","_b","originalPositionFor","bias","Error","OMapping","segments","traceSegmentInternal","generatedPositionFor","source","generatedPosition","allGeneratedPositionsFor","eachMapping","cb","generatedLine","generatedColumn","originalColumn","name","sourceContentFor","tracer","clone","GMapping","sliceGeneratedPositions","matchedColumn","max","result","all","generated","SetArray","_indexes","cast$1","set","get","setarr","put","indexes","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","NO_NAME","GenMapping","_names","_sources","_sourcesContent","_mappings","_ignoreList","maybeAddMapping","mapping","addMappingInternal","setSourceContent","content","toDecodedMap","removeEmptyFinalLines","toEncodedMap","Object","assign","fromMap","gen","putAll","addSegmentInternal","skipable","genLine","genColumn","getColumnIndex","skipSourceless","namesIndex","skipSource","current","len","prev","original","SourceMapConsumer","trace","_map","fromSourceMap","toJSON","originalPosition","hasContentsOfAllSources","nullOnMissing","sourceContent","callback","context","bind","destroy","SourceMapGenerator","opts","consumer","addMapping","stringify"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\source-map\\node_modules\\@jridgewell\\sourcemap-codec\\dist\\sourcemap-codec.mjs","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\source-map\\node_modules\\@jridgewell\\resolve-uri\\dist\\resolve-uri.mjs","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\source-map\\node_modules\\@jridgewell\\trace-mapping\\dist\\trace-mapping.mjs","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\source-map\\node_modules\\@jridgewell\\set-array\\dist\\set-array.mjs","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\source-map\\node_modules\\@jridgewell\\gen-mapping\\dist\\gen-mapping.mjs","C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@jridgewell\\src\\source-map.ts"],"sourcesContent":["const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n        }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: 7 /* Absolute */,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = 6 /* SchemeRelative */;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = 5 /* AbsolutePath */;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? 3 /* Query */\n            : input.startsWith('#')\n                ? 2 /* Hash */\n                : 4 /* RelativePath */\n        : 1 /* Empty */;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= 4 /* RelativePath */;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== 7 /* Absolute */) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case 1 /* Empty */:\n                url.hash = baseUrl.hash;\n            // fall through\n            case 2 /* Hash */:\n                url.query = baseUrl.query;\n            // fall through\n            case 3 /* Query */:\n            case 4 /* RelativePath */:\n                mergePaths(url, baseUrl);\n            // fall through\n            case 5 /* AbsolutePath */:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case 6 /* SchemeRelative */:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case 2 /* Hash */:\n        case 3 /* Query */:\n            return queryHash;\n        case 4 /* RelativePath */: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case 5 /* AbsolutePath */:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\nexport { resolve as default };\n//# sourceMappingURL=resolve-uri.mjs.map\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            memo.lastIndex = ++index;\n            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = parse(map);\n    if (!('sections' in parsed)) {\n        return new TraceMap(parsed, mapUrl);\n    }\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const ignoreList = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n        ignoreList,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction parse(map) {\n    return typeof map === 'string' ? JSON.parse(map) : map;\n}\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for (let i = 0; i < sections.length; i++) {\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) {\n                sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            }\n            else if (sl < stopLine) {\n                sc = columnOffset + nextOffset.column;\n            }\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const parsed = parse(input);\n    if ('sections' in parsed)\n        return recurse(...arguments);\n    const map = new TraceMap(parsed, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents)\n        append(sourcesContent, contents);\n    else\n        for (let i = 0; i < resolvedSources.length; i++)\n            sourcesContent.push(null);\n    if (ignores)\n        for (let i = 0; i < ignores.length; i++)\n            ignoreList.push(ignores[i] + sourcesOffset);\n    for (let i = 0; i < decoded.length; i++) {\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine)\n            return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn)\n                return;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4\n                ? [column, sourcesIndex, sourceLine, sourceColumn]\n                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++)\n        arr[i] = [];\n    return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n    return map;\n}\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nfunction encodedMappings(map) {\n    var _a;\n    var _b;\n    return ((_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = encode(cast(map)._decoded)));\n}\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nfunction decodedMappings(map) {\n    var _a;\n    return ((_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded)));\n}\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nfunction traceSegment(map, line, column) {\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return null;\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n}\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nfunction originalPositionFor(map, needle) {\n    let { line, column, bias } = needle;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1)\n        return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1)\n        return OMapping(null, null, null, null);\n    const { names, resolvedSources } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nfunction generatedPositionFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nfunction allGeneratedPositionsFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n/**\n * Iterates each mapping in generated position order.\n */\nfunction eachMapping(map, cb) {\n    const decoded = decodedMappings(map);\n    const { names, resolvedSources } = map;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const generatedLine = i + 1;\n            const generatedColumn = seg[0];\n            let source = null;\n            let originalLine = null;\n            let originalColumn = null;\n            let name = null;\n            if (seg.length !== 1) {\n                source = resolvedSources[seg[1]];\n                originalLine = seg[2] + 1;\n                originalColumn = seg[3];\n            }\n            if (seg.length === 5)\n                name = names[seg[4]];\n            cb({\n                generatedLine,\n                generatedColumn,\n                source,\n                originalLine,\n                originalColumn,\n                name,\n            });\n        }\n    }\n}\nfunction sourceIndex(map, source) {\n    const { sources, resolvedSources } = map;\n    let index = sources.indexOf(source);\n    if (index === -1)\n        index = resolvedSources.indexOf(source);\n    return index;\n}\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nfunction sourceContentFor(map, source) {\n    const { sourcesContent } = map;\n    if (sourcesContent == null)\n        return null;\n    const index = sourceIndex(map, source);\n    return index === -1 ? null : sourcesContent[index];\n}\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nfunction isIgnored(map, source) {\n    const { ignoreList } = map;\n    if (ignoreList == null)\n        return false;\n    const index = sourceIndex(map, source);\n    return index === -1 ? false : ignoreList.includes(index);\n}\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nfunction presortedDecodedMap(map, mapUrl) {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    cast(tracer)._decoded = map.mappings;\n    return tracer;\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction decodedMap(map) {\n    return clone(map, decodedMappings(map));\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction encodedMap(map) {\n    return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings,\n        ignoreList: map.ignoreList || map.x_google_ignoreList,\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n    var _a;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const { sources, resolvedSources } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1)\n        sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1)\n        return all ? [] : GMapping(null, null);\n    const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));\n    const segments = generated[sourceIndex][line];\n    if (segments == null)\n        return all ? [] : GMapping(null, null);\n    const memo = cast(map)._bySourceMemos[sourceIndex];\n    if (all)\n        return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1)\n        return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, isIgnored, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };\n//# sourceMappingURL=trace-mapping.mjs.map\n","/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n    constructor() {\n        this._indexes = { __proto__: null };\n        this.array = [];\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast(set) {\n    return set;\n}\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nfunction get(setarr, key) {\n    return cast(setarr)._indexes[key];\n}\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nfunction put(setarr, key) {\n    // The key may or may not be present. If it is present, it's a number.\n    const index = get(setarr, key);\n    if (index !== undefined)\n        return index;\n    const { array, _indexes: indexes } = cast(setarr);\n    const length = array.push(key);\n    return (indexes[key] = length - 1);\n}\n/**\n * Pops the last added item out of the SetArray.\n */\nfunction pop(setarr) {\n    const { array, _indexes: indexes } = cast(setarr);\n    if (array.length === 0)\n        return;\n    const last = array.pop();\n    indexes[last] = undefined;\n}\n/**\n * Removes the key, if it exists in the set.\n */\nfunction remove(setarr, key) {\n    const index = get(setarr, key);\n    if (index === undefined)\n        return;\n    const { array, _indexes: indexes } = cast(setarr);\n    for (let i = index + 1; i < array.length; i++) {\n        const k = array[i];\n        array[i - 1] = k;\n        indexes[k]--;\n    }\n    indexes[key] = undefined;\n    array.pop();\n}\n\nexport { SetArray, get, pop, put, remove };\n//# sourceMappingURL=set-array.mjs.map\n","import { SetArray, put, remove } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nconst NO_NAME = -1;\n/**\n * Provides the state to generate a sourcemap.\n */\nclass GenMapping {\n    constructor({ file, sourceRoot } = {}) {\n        this._names = new SetArray();\n        this._sources = new SetArray();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n        this._ignoreList = new SetArray();\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n    return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n}\nfunction addMapping(map, mapping) {\n    return addMappingInternal(false, map, mapping);\n}\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nconst maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n};\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nconst maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n};\n/**\n * Adds/removes the content of the source file to the source map.\n */\nfunction setSourceContent(map, source, content) {\n    const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n    const index = put(sources, source);\n    sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n    const index = put(sources, source);\n    if (index === sourcesContent.length)\n        sourcesContent[index] = null;\n    if (ignore)\n        put(ignoreList, index);\n    else\n        remove(ignoreList, index);\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction toDecodedMap(map) {\n    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);\n    removeEmptyFinalLines(mappings);\n    return {\n        version: 3,\n        file: map.file || undefined,\n        names: names.array,\n        sourceRoot: map.sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n        ignoreList: ignoreList.array,\n    };\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction toEncodedMap(map) {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });\n}\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nfunction fromMap(input) {\n    const map = new TraceMap(input);\n    const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n    putAll(cast(gen)._names, map.names);\n    putAll(cast(gen)._sources, map.sources);\n    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    cast(gen)._mappings = decodedMappings(map);\n    if (map.ignoreList)\n        putAll(cast(gen)._ignoreList, map.ignoreList);\n    return gen;\n}\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nfunction allMappings(map) {\n    const out = [];\n    const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n    for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const generated = { line: i + 1, column: seg[COLUMN] };\n            let source = undefined;\n            let original = undefined;\n            let name = undefined;\n            if (seg.length !== 1) {\n                source = sources.array[seg[SOURCES_INDEX]];\n                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                if (seg.length === 5)\n                    name = names.array[seg[NAMES_INDEX]];\n            }\n            out.push({ generated, source, original, name });\n        }\n    }\n    return out;\n}\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n    if (!source) {\n        if (skipable && skipSourceless(line, index))\n            return;\n        return insert(line, index, [genColumn]);\n    }\n    const sourcesIndex = put(sources, source);\n    const namesIndex = name ? put(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length)\n        sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n    }\n    return insert(line, index, name\n        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n        : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n}\nfunction getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n        mappings[i] = [];\n    }\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n        const current = line[i];\n        if (genColumn >= current[COLUMN])\n            break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n        if (mappings[i].length > 0)\n            break;\n    }\n    if (len < length)\n        mappings.length = len;\n}\nfunction putAll(setarr, array) {\n    for (let i = 0; i < array.length; i++)\n        put(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0)\n        return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0)\n        return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1)\n        return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return (sourcesIndex === prev[SOURCES_INDEX] &&\n        sourceLine === prev[SOURCE_LINE] &&\n        sourceColumn === prev[SOURCE_COLUMN] &&\n        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name, content } = mapping;\n    if (!source) {\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setIgnore, setSourceContent, toDecodedMap, toEncodedMap };\n//# sourceMappingURL=gen-mapping.mjs.map\n","import {\n  AnyMap,\n  originalPositionFor,\n  generatedPositionFor,\n  allGeneratedPositionsFor,\n  eachMapping,\n  encodedMappings,\n  sourceContentFor,\n} from '@jridgewell/trace-mapping';\nimport {\n  GenMapping,\n  maybeAddMapping,\n  toDecodedMap,\n  toEncodedMap,\n  setSourceContent,\n  fromMap,\n} from '@jridgewell/gen-mapping';\n\nimport type {\n  TraceMap,\n  SourceMapInput,\n  SectionedSourceMapInput,\n  DecodedSourceMap,\n} from '@jridgewell/trace-mapping';\nexport type { TraceMap, SourceMapInput, SectionedSourceMapInput, DecodedSourceMap };\n\nimport type { Mapping, EncodedSourceMap } from '@jridgewell/gen-mapping';\nexport type { Mapping, EncodedSourceMap };\n\nexport class SourceMapConsumer {\n  private declare _map: TraceMap;\n  declare file: TraceMap['file'];\n  declare names: TraceMap['names'];\n  declare sourceRoot: TraceMap['sourceRoot'];\n  declare sources: TraceMap['sources'];\n  declare sourcesContent: TraceMap['sourcesContent'];\n  declare version: TraceMap['version'];\n\n  constructor(map: ConstructorParameters<typeof AnyMap>[0], mapUrl: Parameters<typeof AnyMap>[1]) {\n    const trace = (this._map = new AnyMap(map, mapUrl));\n\n    this.file = trace.file;\n    this.names = trace.names;\n    this.sourceRoot = trace.sourceRoot;\n    this.sources = trace.resolvedSources;\n    this.sourcesContent = trace.sourcesContent;\n    this.version = trace.version;\n  }\n\n  static fromSourceMap(map: SourceMapGenerator, mapUrl: Parameters<typeof AnyMap>[1]) {\n    // This is more performant if we receive\n    // a @jridgewell/source-map SourceMapGenerator\n    if (map.toDecodedMap) {\n      return new SourceMapConsumer(map.toDecodedMap() as SectionedSourceMapInput, mapUrl);\n    }\n\n    // This is a fallback for `source-map` and `source-map-js`\n    return new SourceMapConsumer(map.toJSON() as SectionedSourceMapInput, mapUrl);\n  }\n\n  get mappings(): string {\n    return encodedMappings(this._map);\n  }\n\n  originalPositionFor(\n    needle: Parameters<typeof originalPositionFor>[1],\n  ): ReturnType<typeof originalPositionFor> {\n    return originalPositionFor(this._map, needle);\n  }\n\n  generatedPositionFor(\n    originalPosition: Parameters<typeof generatedPositionFor>[1],\n  ): ReturnType<typeof generatedPositionFor> {\n    return generatedPositionFor(this._map, originalPosition);\n  }\n\n  allGeneratedPositionsFor(\n    originalPosition: Parameters<typeof generatedPositionFor>[1],\n  ): ReturnType<typeof generatedPositionFor>[] {\n    return allGeneratedPositionsFor(this._map, originalPosition);\n  }\n\n  hasContentsOfAllSources(): boolean {\n    if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {\n      return false;\n    }\n\n    for (const content of this.sourcesContent) {\n      if (content == null) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  sourceContentFor(source: string, nullOnMissing?: boolean): string | null {\n    const sourceContent = sourceContentFor(this._map, source);\n    if (sourceContent != null) {\n      return sourceContent;\n    }\n\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error(`\"${source}\" is not in the SourceMap.`);\n  }\n\n  eachMapping(\n    callback: Parameters<typeof eachMapping>[1],\n    context?: any /*, order?: number*/,\n  ): void {\n    // order is ignored as @jridgewell/trace-map doesn't implement it\n    eachMapping(this._map, context ? callback.bind(context) : callback);\n  }\n\n  destroy() {\n    // noop.\n  }\n}\n\nexport class SourceMapGenerator {\n  private declare _map: GenMapping;\n\n  constructor(opts: ConstructorParameters<typeof GenMapping>[0] | GenMapping) {\n    // TODO :: should this be duck-typed ?\n    this._map = opts instanceof GenMapping ? opts : new GenMapping(opts);\n  }\n\n  static fromSourceMap(consumer: SourceMapConsumer) {\n    return new SourceMapGenerator(fromMap(consumer));\n  }\n\n  addMapping(mapping: Parameters<typeof maybeAddMapping>[1]): ReturnType<typeof maybeAddMapping> {\n    maybeAddMapping(this._map, mapping);\n  }\n\n  setSourceContent(\n    source: Parameters<typeof setSourceContent>[1],\n    content: Parameters<typeof setSourceContent>[2],\n  ): ReturnType<typeof setSourceContent> {\n    setSourceContent(this._map, source, content);\n  }\n\n  toJSON(): ReturnType<typeof toEncodedMap> {\n    return toEncodedMap(this._map);\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n\n  toDecodedMap(): ReturnType<typeof toDecodedMap> {\n    return toDecodedMap(this._map);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}