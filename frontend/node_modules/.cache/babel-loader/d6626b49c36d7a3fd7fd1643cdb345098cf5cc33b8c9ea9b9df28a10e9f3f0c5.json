{"ast":null,"code":"'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n  const env = parsed.options.env || process.env;\n  const cwd = process.cwd();\n  const hasCustomCwd = parsed.options.cwd != null;\n  // Worker threads do not have process.chdir()\n  const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n  // If a custom `cwd` was specified, we need to change the process cwd\n  // because `which` will do stat calls but does not support a custom cwd\n  if (shouldSwitchCwd) {\n    try {\n      process.chdir(parsed.options.cwd);\n    } catch (err) {\n      /* Empty */\n    }\n  }\n  let resolved;\n  try {\n    resolved = which.sync(parsed.command, {\n      path: env[getPathKey({\n        env\n      })],\n      pathExt: withoutPathExt ? path.delimiter : undefined\n    });\n  } catch (e) {\n    /* Empty */\n  } finally {\n    if (shouldSwitchCwd) {\n      process.chdir(cwd);\n    }\n  }\n\n  // If we successfully resolved, ensure that an absolute path is returned\n  // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n  if (resolved) {\n    resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n  }\n  return resolved;\n}\nfunction resolveCommand(parsed) {\n  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\nmodule.exports = resolveCommand;","map":{"version":3,"names":["path","require","which","getPathKey","resolveCommandAttempt","parsed","withoutPathExt","env","options","process","cwd","hasCustomCwd","shouldSwitchCwd","chdir","undefined","disabled","err","resolved","sync","command","pathExt","delimiter","e","resolve","resolveCommand","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/cross-spawn/lib/util/resolveCommand.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAME,UAAU,GAAGF,OAAO,CAAC,UAAU,CAAC;AAEtC,SAASG,qBAAqBA,CAACC,MAAM,EAAEC,cAAc,EAAE;EACnD,MAAMC,GAAG,GAAGF,MAAM,CAACG,OAAO,CAACD,GAAG,IAAIE,OAAO,CAACF,GAAG;EAC7C,MAAMG,GAAG,GAAGD,OAAO,CAACC,GAAG,CAAC,CAAC;EACzB,MAAMC,YAAY,GAAGN,MAAM,CAACG,OAAO,CAACE,GAAG,IAAI,IAAI;EAC/C;EACA,MAAME,eAAe,GAAGD,YAAY,IAAIF,OAAO,CAACI,KAAK,KAAKC,SAAS,IAAI,CAACL,OAAO,CAACI,KAAK,CAACE,QAAQ;;EAE9F;EACA;EACA,IAAIH,eAAe,EAAE;IACjB,IAAI;MACAH,OAAO,CAACI,KAAK,CAACR,MAAM,CAACG,OAAO,CAACE,GAAG,CAAC;IACrC,CAAC,CAAC,OAAOM,GAAG,EAAE;MACV;IAAA;EAER;EAEA,IAAIC,QAAQ;EAEZ,IAAI;IACAA,QAAQ,GAAGf,KAAK,CAACgB,IAAI,CAACb,MAAM,CAACc,OAAO,EAAE;MAClCnB,IAAI,EAAEO,GAAG,CAACJ,UAAU,CAAC;QAAEI;MAAI,CAAC,CAAC,CAAC;MAC9Ba,OAAO,EAAEd,cAAc,GAAGN,IAAI,CAACqB,SAAS,GAAGP;IAC/C,CAAC,CAAC;EACN,CAAC,CAAC,OAAOQ,CAAC,EAAE;IACR;EAAA,CACH,SAAS;IACN,IAAIV,eAAe,EAAE;MACjBH,OAAO,CAACI,KAAK,CAACH,GAAG,CAAC;IACtB;EACJ;;EAEA;EACA;EACA,IAAIO,QAAQ,EAAE;IACVA,QAAQ,GAAGjB,IAAI,CAACuB,OAAO,CAACZ,YAAY,GAAGN,MAAM,CAACG,OAAO,CAACE,GAAG,GAAG,EAAE,EAAEO,QAAQ,CAAC;EAC7E;EAEA,OAAOA,QAAQ;AACnB;AAEA,SAASO,cAAcA,CAACnB,MAAM,EAAE;EAC5B,OAAOD,qBAAqB,CAACC,MAAM,CAAC,IAAID,qBAAqB,CAACC,MAAM,EAAE,IAAI,CAAC;AAC/E;AAEAoB,MAAM,CAACC,OAAO,GAAGF,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}