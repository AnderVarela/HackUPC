{"ast":null,"code":"const tests = {\n  // ECMAScript 2018\n  \"object-rest-spread\": [\"({ ...{} })\", \"({ ...x } = {})\"],\n  // Babel 7.2.0\n  \"async-generators\": [\"async function* f() {}\"],\n  //  Babel 7.2.0\n\n  // ECMAScript 2019\n  \"optional-catch-binding\": [\"try {} catch {}\"],\n  // Babel 7.2.0\n  \"json-strings\": [\"'\\\\u2028'\"],\n  // Babel 7.2.0\n\n  // ECMAScript 2020\n  \"bigint\": [\"1n\"],\n  // Babel 7.8.0\n  \"optional-chaining\": [\"a?.b\"],\n  // Babel 7.9.0\n  \"nullish-coalescing-operator\": [\"a ?? b\"],\n  // Babel 7.9.0\n  // import.meta is handled manually\n\n  // Stage 3\n  \"numeric-separator\": [\"1_2\"],\n  \"class-properties\": [\"(class { x = 1 })\", \"(class { #x = 1 })\", \"(class { #x() {} })\"],\n  \"logical-assignment-operators\": [\"a ||= b\", \"a &&= b\", \"a ??= c\"]\n};\nconst plugins = [];\nconst works = test => {\n  try {\n    // Wrap the test in a function to only test the syntax, without executing it\n    (0, eval)(`(() => { ${test} })`);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n};\nfor (const [name, cases] of Object.entries(tests)) {\n  if (cases.some(works)) {\n    plugins.push(require.resolve(`@babel/plugin-syntax-${name}`));\n  }\n}\n\n// import.meta is only allowed in modules, and modules can only be evaluated\n// synchronously. For this reason, we cannot detect import.meta support at\n// runtime. It is supported starting from 10.4, so we can check the version.\nconst major = parseInt(process.versions.node, 10);\nconst minor = parseInt(process.versions.node.match(/^\\d+\\.(\\d+)/)[1], 10);\nif (major > 10 || major === 10 && minor >= 4) {\n  plugins.push(require.resolve(\"@babel/plugin-syntax-import-meta\"));\n}\n// Same for top level await - it is only supported in modules. It is supported\n// from 14.3.0\nif (major > 14 || major === 14 && minor >= 3) {\n  plugins.push(require.resolve(\"@babel/plugin-syntax-top-level-await\"));\n}\nmodule.exports = () => ({\n  plugins\n});","map":{"version":3,"names":["tests","plugins","works","test","eval","_error","name","cases","Object","entries","some","push","require","resolve","major","parseInt","process","versions","node","minor","match","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/babel-preset-current-node-syntax/src/index.js"],"sourcesContent":["const tests = {\n  // ECMAScript 2018\n  \"object-rest-spread\": [\"({ ...{} })\", \"({ ...x } = {})\"], // Babel 7.2.0\n  \"async-generators\": [\"async function* f() {}\"], //  Babel 7.2.0\n\n  // ECMAScript 2019\n  \"optional-catch-binding\": [\"try {} catch {}\"], // Babel 7.2.0\n  \"json-strings\": [\"'\\\\u2028'\"], // Babel 7.2.0\n\n  // ECMAScript 2020\n  \"bigint\": [\"1n\"], // Babel 7.8.0\n  \"optional-chaining\": [\"a?.b\"], // Babel 7.9.0\n  \"nullish-coalescing-operator\": [\"a ?? b\"], // Babel 7.9.0\n  // import.meta is handled manually\n\n  // Stage 3\n  \"numeric-separator\": [\"1_2\"],\n  \"class-properties\": [\n    \"(class { x = 1 })\",\n    \"(class { #x = 1 })\",\n    \"(class { #x() {} })\",\n  ],\n  \"logical-assignment-operators\": [\"a ||= b\", \"a &&= b\", \"a ??= c\"],\n};\n\nconst plugins = [];\nconst works = (test) => {\n  try {\n    // Wrap the test in a function to only test the syntax, without executing it\n    (0, eval)(`(() => { ${test} })`);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n};\n\nfor (const [name, cases] of Object.entries(tests)) {\n  if (cases.some(works)) {\n    plugins.push(require.resolve(`@babel/plugin-syntax-${name}`));\n  }\n}\n\n// import.meta is only allowed in modules, and modules can only be evaluated\n// synchronously. For this reason, we cannot detect import.meta support at\n// runtime. It is supported starting from 10.4, so we can check the version.\nconst major = parseInt(process.versions.node, 10);\nconst minor = parseInt(process.versions.node.match(/^\\d+\\.(\\d+)/)[1], 10);\nif (major > 10 || (major === 10 && minor >= 4)) {\n  plugins.push(require.resolve(\"@babel/plugin-syntax-import-meta\"));\n}\n// Same for top level await - it is only supported in modules. It is supported\n// from 14.3.0\nif (major > 14 || (major === 14 && minor >= 3)) {\n  plugins.push(require.resolve(\"@babel/plugin-syntax-top-level-await\"));\n}\n\nmodule.exports = () => ({ plugins });\n"],"mappings":"AAAA,MAAMA,KAAK,GAAG;EACZ;EACA,oBAAoB,EAAE,CAAC,aAAa,EAAE,iBAAiB,CAAC;EAAE;EAC1D,kBAAkB,EAAE,CAAC,wBAAwB,CAAC;EAAE;;EAEhD;EACA,wBAAwB,EAAE,CAAC,iBAAiB,CAAC;EAAE;EAC/C,cAAc,EAAE,CAAC,WAAW,CAAC;EAAE;;EAE/B;EACA,QAAQ,EAAE,CAAC,IAAI,CAAC;EAAE;EAClB,mBAAmB,EAAE,CAAC,MAAM,CAAC;EAAE;EAC/B,6BAA6B,EAAE,CAAC,QAAQ,CAAC;EAAE;EAC3C;;EAEA;EACA,mBAAmB,EAAE,CAAC,KAAK,CAAC;EAC5B,kBAAkB,EAAE,CAClB,mBAAmB,EACnB,oBAAoB,EACpB,qBAAqB,CACtB;EACD,8BAA8B,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS;AAClE,CAAC;AAED,MAAMC,OAAO,GAAG,EAAE;AAClB,MAAMC,KAAK,GAAIC,IAAI,IAAK;EACtB,IAAI;IACF;IACA,CAAC,CAAC,EAAEC,IAAI,EAAG,YAAWD,IAAK,KAAI,CAAC;IAChC,OAAO,IAAI;EACb,CAAC,CAAC,OAAOE,MAAM,EAAE;IACf,OAAO,KAAK;EACd;AACF,CAAC;AAED,KAAK,MAAM,CAACC,IAAI,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACT,KAAK,CAAC,EAAE;EACjD,IAAIO,KAAK,CAACG,IAAI,CAACR,KAAK,CAAC,EAAE;IACrBD,OAAO,CAACU,IAAI,CAACC,OAAO,CAACC,OAAO,CAAE,wBAAuBP,IAAK,EAAC,CAAC,CAAC;EAC/D;AACF;;AAEA;AACA;AACA;AACA,MAAMQ,KAAK,GAAGC,QAAQ,CAACC,OAAO,CAACC,QAAQ,CAACC,IAAI,EAAE,EAAE,CAAC;AACjD,MAAMC,KAAK,GAAGJ,QAAQ,CAACC,OAAO,CAACC,QAAQ,CAACC,IAAI,CAACE,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;AACzE,IAAIN,KAAK,GAAG,EAAE,IAAKA,KAAK,KAAK,EAAE,IAAIK,KAAK,IAAI,CAAE,EAAE;EAC9ClB,OAAO,CAACU,IAAI,CAACC,OAAO,CAACC,OAAO,CAAC,kCAAkC,CAAC,CAAC;AACnE;AACA;AACA;AACA,IAAIC,KAAK,GAAG,EAAE,IAAKA,KAAK,KAAK,EAAE,IAAIK,KAAK,IAAI,CAAE,EAAE;EAC9ClB,OAAO,CAACU,IAAI,CAACC,OAAO,CAACC,OAAO,CAAC,sCAAsC,CAAC,CAAC;AACvE;AAEAQ,MAAM,CAACC,OAAO,GAAG,OAAO;EAAErB;AAAQ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}