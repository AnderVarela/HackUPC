{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _helperWrapFunction = require(\"@babel/helper-wrap-function\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _core = require(\"@babel/core\");\nconst {\n  callExpression,\n  cloneNode,\n  isIdentifier,\n  isThisExpression,\n  yieldExpression\n} = _core.types;\nconst awaitVisitor = _core.traverse.visitors.merge([{\n  ArrowFunctionExpression(path) {\n    path.skip();\n  },\n  AwaitExpression(path, {\n    wrapAwait\n  }) {\n    const argument = path.get(\"argument\");\n    path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));\n  }\n}, _helperEnvironmentVisitor.default]);\nfunction _default(path, helpers, noNewArrows, ignoreFunctionLength) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait\n  });\n  const isIIFE = checkIsIIFE(path);\n  path.node.async = false;\n  path.node.generator = true;\n  (0, _helperWrapFunction.default)(path, cloneNode(helpers.wrapAsync), noNewArrows, ignoreFunctionLength);\n  const isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    (0, _helperAnnotateAsPure.default)(path);\n  }\n  function checkIsIIFE(path) {\n    if (path.parentPath.isCallExpression({\n      callee: path.node\n    })) {\n      return true;\n    }\n    const {\n      parentPath\n    } = path;\n    if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {\n      name: \"bind\"\n    })) {\n      const {\n        parentPath: bindCall\n      } = parentPath;\n      return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({\n        callee: bindCall.node\n      });\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["_helperWrapFunction","require","_helperAnnotateAsPure","_helperEnvironmentVisitor","_core","callExpression","cloneNode","isIdentifier","isThisExpression","yieldExpression","types","awaitVisitor","traverse","visitors","merge","ArrowFunctionExpression","path","skip","AwaitExpression","wrapAwait","argument","get","replaceWith","node","default","_default","helpers","noNewArrows","ignoreFunctionLength","isIIFE","checkIsIIFE","async","generator","wrapAsync","isProperty","isObjectMethod","isClassMethod","parentPath","isObjectProperty","isClassProperty","isExpression","isCallExpression","callee","isMemberExpression","property","name","bindCall","arguments","length"],"sources":["C:\\Users\\chest\\OneDrive\\Documentos\\GitHub\\HackUPC\\frontend\\node_modules\\@babel\\helper-remap-async-to-generator\\src\\index.ts"],"sourcesContent":["/* @noflow */\n\nimport type { NodePath } from \"@babel/traverse\";\nimport wrapFunction from \"@babel/helper-wrap-function\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport { traverse, types as t } from \"@babel/core\";\nconst {\n  callExpression,\n  cloneNode,\n  isIdentifier,\n  isThisExpression,\n  yieldExpression,\n} = t;\n\nconst awaitVisitor = traverse.visitors.merge<{ wrapAwait: t.Expression }>([\n  {\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    AwaitExpression(path, { wrapAwait }) {\n      const argument = path.get(\"argument\");\n\n      path.replaceWith(\n        yieldExpression(\n          wrapAwait\n            ? callExpression(cloneNode(wrapAwait), [argument.node])\n            : argument.node,\n        ),\n      );\n    },\n  },\n  environmentVisitor,\n]);\n\nexport default function (\n  path: NodePath<t.Function>,\n  helpers: {\n    wrapAsync: t.Expression;\n    wrapAwait?: t.Expression;\n  },\n  noNewArrows?: boolean,\n  ignoreFunctionLength?: boolean,\n) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait,\n  });\n\n  const isIIFE = checkIsIIFE(path);\n\n  path.node.async = false;\n  path.node.generator = true;\n\n  wrapFunction(\n    path,\n    cloneNode(helpers.wrapAsync),\n    noNewArrows,\n    ignoreFunctionLength,\n  );\n\n  const isProperty =\n    path.isObjectMethod() ||\n    path.isClassMethod() ||\n    path.parentPath.isObjectProperty() ||\n    path.parentPath.isClassProperty();\n\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    annotateAsPure(path);\n  }\n\n  function checkIsIIFE(path: NodePath) {\n    if (path.parentPath.isCallExpression({ callee: path.node })) {\n      return true;\n    }\n\n    // try to catch calls to Function#bind, as emitted by arrowFunctionToExpression in spec mode\n    // this may also catch .bind(this) written by users, but does it matter? ðŸ¤”\n    const { parentPath } = path;\n    if (\n      parentPath.isMemberExpression() &&\n      isIdentifier(parentPath.node.property, { name: \"bind\" })\n    ) {\n      const { parentPath: bindCall } = parentPath;\n\n      // (function () { ... }).bind(this)()\n\n      return (\n        // first, check if the .bind is actually being called\n        bindCall.isCallExpression() &&\n        // and whether its sole argument is 'this'\n        bindCall.node.arguments.length === 1 &&\n        isThisExpression(bindCall.node.arguments[0]) &&\n        // and whether the result of the .bind(this) is being called\n        bindCall.parentPath.isCallExpression({ callee: bindCall.node })\n      );\n    }\n\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}