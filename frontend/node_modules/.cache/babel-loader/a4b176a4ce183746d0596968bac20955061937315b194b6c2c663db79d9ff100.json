{"ast":null,"code":"import path, { dirname, resolve, extname, normalize, sep } from 'path';\nimport builtinList from 'builtin-modules';\nimport deepMerge from 'deepmerge';\nimport isModule from 'is-module';\nimport fs, { realpathSync } from 'fs';\nimport { promisify } from 'util';\nimport { pathToFileURL, fileURLToPath } from 'url';\nimport resolve$1 from 'resolve';\nimport { createFilter } from '@rollup/pluginutils';\nconst access = promisify(fs.access);\nconst readFile = promisify(fs.readFile);\nconst realpath = promisify(fs.realpath);\nconst stat = promisify(fs.stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\nconst onError = error => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\nconst makeCache = fn => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(param, fn(param).catch(err => {\n        cache.delete(param);\n        throw err;\n      }));\n    }\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n  wrapped.clear = () => cache.clear();\n  return wrapped;\n};\nconst isDirCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst isFileCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({\n      mainFields\n    } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let {\n    pkgPath\n  } = options;\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = realpathSync(pkgPath);\n  }\n  const pkgRoot = dirname(pkgPath);\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: {\n      ...pkg\n    },\n    // path to package.json file\n    packageJsonPath: pkgPath,\n    // directory containing the package.json\n    root: pkgRoot,\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField: useBrowserOverrides && typeof pkg.browser === 'object' && Object.keys(pkg.browser).reduce((browser, key) => {\n      let resolved = pkg.browser[key];\n      if (resolved && resolved[0] === '.') {\n        resolved = resolve(pkgRoot, resolved);\n      }\n      /* eslint-disable no-param-reassign */\n      browser[key] = resolved;\n      if (key[0] === '.') {\n        const absoluteKey = resolve(pkgRoot, key);\n        browser[absoluteKey] = resolved;\n        if (!extname(key)) {\n          extensions.reduce((subBrowser, ext) => {\n            subBrowser[absoluteKey + ext] = subBrowser[key];\n            return subBrowser;\n          }, browser);\n        }\n      }\n      return browser;\n    }, {}),\n    packageInfo\n  };\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (useBrowserOverrides && typeof pkg.browser === 'object' &&\n  // eslint-disable-next-line no-prototype-builtins\n  browserMap.hasOwnProperty(pkg.main)) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = promisify(fs.exists);\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some(dir => current.endsWith(dir));\n}\nasync function findPackageJson(base, moduleDirs) {\n  const {\n    root\n  } = path.parse(base);\n  let current = base;\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path.join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs.readFileSync(pkgJsonPath, 'utf-8');\n      return {\n        pkgJson: JSON.parse(pkgJsonString),\n        pkgPath: current,\n        pkgJsonPath\n      };\n    }\n    current = path.resolve(current, '..');\n  }\n  return null;\n}\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every(k => !k.startsWith('.'));\n}\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some(k => k.startsWith('.')) && keys.some(k => !k.startsWith('.'));\n}\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\nfunction createErrorMsg(context, reason, internal) {\n  const {\n    importSpecifier,\n    importer,\n    pkgJsonPath\n  } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\nclass ResolveError extends Error {}\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments.split('/').slice(1).some(t => ['.', '..', ...moduleDirs].includes(t));\n}\nasync function resolvePackageTarget(context, {\n  target,\n  subpath,\n  pattern,\n  internal\n}) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some(p => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(target.replace(/\\*/g, subpath), context.pkgURL.href);\n          return result ? pathToFileURL(result.location) : null;\n        }\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(context, `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`);\n    }\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n  if (target === null) {\n    return null;\n  }\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, {\n  matchKey,\n  matchObj,\n  internal\n}) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, {\n      target,\n      subpath: '',\n      internal\n    });\n    return resolved;\n  }\n  const expansionKeys = Object.keys(matchObj).filter(k => k.endsWith('/') || k.endsWith('*')).sort((a, b) => b.length - a.length);\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        internal\n      });\n      return resolved;\n    }\n  }\n  throw new InvalidModuleSpecifierError(context, internal);\n}\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(context, 'All keys must either start with ./, or without one.');\n  }\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, {\n        target: mainExport,\n        subpath: ''\n      });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n  throw new InvalidModuleSpecifierError(context);\n}\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n  const {\n    pkgPath,\n    pkgJsonPath,\n    pkgJson\n  } = result;\n  const pkgURL = pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n  const {\n    imports\n  } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\nconst resolveImportPath = promisify(resolve$1);\nconst readFile$1 = promisify(fs.readFile);\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return {\n      pkgJsonPath,\n      pkgJson\n    };\n  } catch (_) {\n    return null;\n  }\n}\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    ({\n      packageInfo,\n      hasModuleSideEffects,\n      hasPackageEntry,\n      packageBrowserField\n    } = info);\n    return info.cachedPkg;\n  };\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n  let location;\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n    if (result && result.pkgJson.exports) {\n      const {\n        pkgJson,\n        pkgJsonPath\n      } = result;\n      try {\n        const subpath = pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = pathToFileURL(pkgDr);\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(context, subpath, pkgJson.exports);\n        location = fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n  if (opts.customResolveOptions) {\n    const {\n      customResolveOptions\n    } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];\n      warnings.push('node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.');\n    }\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error('node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.');\n    }\n    ['basedir', 'package', 'extensions', 'includeCoreModules', 'readFile', 'isFile', 'isDirectory', 'realpath', 'packageFilter', 'pathFilter', 'paths', 'packageIterator'].forEach(resolveOption => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(`node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`);\n      }\n    });\n  }\n  return {\n    warnings\n  };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = object => {\n  Object.freeze(object);\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n  return object;\n};\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge({}, defaults));\nfunction nodeResolve(opts = {}) {\n  const {\n    warnings\n  } = handleDeprecatedOptions(opts);\n  const options = {\n    ...defaults,\n    ...opts\n  };\n  const {\n    extensions,\n    jail,\n    moduleDirectories,\n    ignoreSideEffectsForRoot\n  } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = resolve(options.rootDir || process.cwd());\n  let {\n    dedupe\n  } = options;\n  let rollupOptions;\n  if (typeof dedupe !== 'function') {\n    dedupe = importee => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n  const resolveOnly = options.resolveOnly.map(pattern => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n  return {\n    name: 'node-resolve',\n    buildStart(options) {\n      rollupOptions = options;\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n      ({\n        preserveSymlinks\n      } = options);\n    },\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n      const baseDir = !importer || dedupe(importee) ? rootDir : dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee = browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n      if (!isRelativeImport && resolveOnly.length && !resolveOnly.some(pattern => pattern.test(id))) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n      const importSpecifierList = [];\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n      const importeeIsBuiltin = builtins.has(importee);\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n      importSpecifierList.push(importee);\n      const warn = (...args) => this.warn(...args);\n      const isRequire = opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n      const resolved = importeeIsBuiltin && preferBuiltins ? {\n        packageInfo: undefined,\n        hasModuleSideEffects: () => null,\n        hasPackageEntry: true,\n        packageBrowserField: false\n      } : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n      const {\n        packageInfo,\n        hasModuleSideEffects,\n        hasPackageEntry,\n        packageBrowserField\n      } = resolved;\n      let {\n        location\n      } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n      idToPackageInfo.set(location, packageInfo);\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(`preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`);\n          }\n          return false;\n        } else if (jail && location.indexOf(normalize(jail.trim(sep))) !== 0) {\n          return null;\n        }\n      }\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule(code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\nexport default nodeResolve;\nexport { DEFAULTS, nodeResolve };","map":{"version":3,"names":["path","dirname","resolve","extname","normalize","sep","builtinList","deepMerge","isModule","fs","realpathSync","promisify","pathToFileURL","fileURLToPath","resolve$1","createFilter","access","readFile","realpath","stat","exists","filePath","onError","error","code","makeCache","fn","cache","Map","wrapped","param","done","has","set","catch","err","delete","result","get","value","clear","isDirCached","file","stats","isDirectory","isFileCached","isFile","readCachedFile","getPackageName","id","startsWith","split","getMainFields","options","mainFields","browser","indexOf","concat","length","Error","getPackageInfo","extensions","pkg","preserveSymlinks","useBrowserOverrides","rootDir","ignoreSideEffectsForRoot","pkgPath","pkgRoot","packageInfo","packageJson","packageJsonPath","root","resolvedMainField","browserMappedMain","resolvedEntryPoint","overriddenMain","i","field","main","internalPackageInfo","cachedPkg","hasModuleSideEffects","hasPackageEntry","packageBrowserField","Object","keys","reduce","key","resolved","absoluteKey","subBrowser","ext","browserMap","hasOwnProperty","packageSideEffects","sideEffects","Array","isArray","normalizeInput","input","values","fileExists","isModuleDir","current","moduleDirs","some","dir","endsWith","findPackageJson","base","parse","pkgJsonPath","join","pkgJsonString","readFileSync","pkgJson","JSON","isUrl","str","URL","_","isConditions","exports","every","k","isMappings","isMixedExports","createBaseErrorMsg","importSpecifier","importer","createErrorMsg","context","reason","internal","ResolveError","InvalidConfigurationError","constructor","InvalidModuleSpecifierError","InvalidPackageTargetError","includesInvalidSegments","pathSegments","slice","t","includes","resolvePackageTarget","target","subpath","pattern","p","resolveId","replace","pkgURL","href","location","resolvedTarget","lastError","item","undefined","entries","conditions","resolvePackageImportsExports","matchKey","matchObj","expansionKeys","filter","sort","a","b","expansionKey","prefix","substring","resolvePackageExports","mainExport","resolvedMatch","resolvePackageImports","imports","resolveImportPath","readFile$1","getPackageJson","pkgName","resolveOptions","moduleDirectories","selfPackageJsonResult","name","exportConditions","warn","packageInfoCache","baseDir","info","basedir","includeCoreModules","moduleDirectory","packageFilter","resolveResult","parent","pkgDr","resolvedPackageExport","resolveImportSpecifiers","importSpecifierList","lastResolveError","handleDeprecatedOptions","opts","warnings","customResolveOptions","push","forEach","resolveOption","builtins","Set","ES6_BROWSER_EMPTY","deepFreeze","object","freeze","isFrozen","baseConditions","baseConditionsEsm","baseConditionsCjs","defaults","dedupe","resolveOnly","DEFAULTS","nodeResolve","jail","conditionsEsm","conditionsCjs","idToPackageInfo","isPreferBuiltinsSet","preferBuiltins","process","cwd","rollupOptions","importee","map","RegExp","normalized","browserMapCache","buildStart","warning","generateBundle","test","importPath","params","importSuffix","resolvedImportee","browserImportee","parts","shift","isRelativeImport","match","importeeIsBuiltin","args","isRequire","custom","resolvedWithoutBuiltins","prototype","call","trim","modulesOnly","moduleSideEffects","load","getPackageInfoForId"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@rollup/plugin-node-resolve/dist/es/index.js"],"sourcesContent":["import path, { dirname, resolve, extname, normalize, sep } from 'path';\nimport builtinList from 'builtin-modules';\nimport deepMerge from 'deepmerge';\nimport isModule from 'is-module';\nimport fs, { realpathSync } from 'fs';\nimport { promisify } from 'util';\nimport { pathToFileURL, fileURLToPath } from 'url';\nimport resolve$1 from 'resolve';\nimport { createFilter } from '@rollup/pluginutils';\n\nconst access = promisify(fs.access);\nconst readFile = promisify(fs.readFile);\nconst realpath = promisify(fs.realpath);\nconst stat = promisify(fs.stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = (error) => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\n\nconst makeCache = (fn) => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(\n        param,\n        fn(param).catch((err) => {\n          cache.delete(param);\n          throw err;\n        })\n      );\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst isFileCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({ mainFields } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let { pkgPath } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = realpathSync(pkgPath);\n  }\n\n  const pkgRoot = dirname(pkgPath);\n\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg },\n\n    // path to package.json file\n    packageJsonPath: pkgPath,\n\n    // directory containing the package.json\n    root: pkgRoot,\n\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField:\n      useBrowserOverrides &&\n      typeof pkg.browser === 'object' &&\n      Object.keys(pkg.browser).reduce((browser, key) => {\n        let resolved = pkg.browser[key];\n        if (resolved && resolved[0] === '.') {\n          resolved = resolve(pkgRoot, resolved);\n        }\n        /* eslint-disable no-param-reassign */\n        browser[key] = resolved;\n        if (key[0] === '.') {\n          const absoluteKey = resolve(pkgRoot, key);\n          browser[absoluteKey] = resolved;\n          if (!extname(key)) {\n            extensions.reduce((subBrowser, ext) => {\n              subBrowser[absoluteKey + ext] = subBrowser[key];\n              return subBrowser;\n            }, browser);\n          }\n        }\n        return browser;\n      }, {}),\n    packageInfo\n  };\n\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (\n    useBrowserOverrides &&\n    typeof pkg.browser === 'object' &&\n    // eslint-disable-next-line no-prototype-builtins\n    browserMap.hasOwnProperty(pkg.main)\n  ) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = promisify(fs.exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some((dir) => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const { root } = path.parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path.join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs.readFileSync(pkgJsonPath, 'utf-8');\n      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current, pkgJsonPath };\n    }\n    current = path.resolve(current, '..');\n  }\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every((k) => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some((k) => k.startsWith('.')) && keys.some((k) => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const { importSpecifier, importer, pkgJsonPath } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments\n    .split('/')\n    .slice(1)\n    .some((t) => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, { target, subpath, pattern, internal }) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some((p) => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(\n            target.replace(/\\*/g, subpath),\n            context.pkgURL.href\n          );\n          return result ? pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(\n        context,\n        `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`\n      );\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, { matchKey, matchObj, internal }) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, { target, subpath: '', internal });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj)\n    .filter((k) => k.endsWith('/') || k.endsWith('*'))\n    .sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n\n      const resolved = await resolvePackageTarget(context, { target, subpath, internal });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(\n      context,\n      'All keys must either start with ./, or without one.'\n    );\n  }\n\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, { target: mainExport, subpath: '' });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const { pkgPath, pkgJsonPath, pkgJson } = result;\n  const pkgURL = pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n\n  const { imports } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = promisify(resolve$1);\nconst readFile$1 = promisify(fs.readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return { pkgJsonPath, pkgJson };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);\n\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n\n  let location;\n\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const { pkgJson, pkgJsonPath } = result;\n      try {\n        const subpath =\n          pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = pathToFileURL(pkgDr);\n\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(\n          context,\n          subpath,\n          pkgJson.exports\n        );\n        location = fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const { customResolveOptions } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory)\n        ? customResolveOptions.moduleDirectory\n        : [customResolveOptions.moduleDirectory];\n\n      warnings.push(\n        'node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.'\n      );\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error(\n        'node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.'\n      );\n    }\n\n    [\n      'basedir',\n      'package',\n      'extensions',\n      'includeCoreModules',\n      'readFile',\n      'isFile',\n      'isDirectory',\n      'realpath',\n      'packageFilter',\n      'pathFilter',\n      'paths',\n      'packageIterator'\n    ].forEach((resolveOption) => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(\n          `node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`\n        );\n      }\n    });\n  }\n\n  return { warnings };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = (object) => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge({}, defaults));\n\nfunction nodeResolve(opts = {}) {\n  const { warnings } = handleDeprecatedOptions(opts);\n\n  const options = { ...defaults, ...opts };\n  const { extensions, jail, moduleDirectories, ignoreSideEffectsForRoot } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = resolve(options.rootDir || process.cwd());\n  let { dedupe } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = (importee) =>\n      options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map((pattern) => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({ preserveSymlinks } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n\n      const baseDir = !importer || dedupe(importee) ? rootDir : dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee =\n          browser[importee] ||\n          browser[resolvedImportee] ||\n          browser[`${resolvedImportee}.js`] ||\n          browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (\n        !isRelativeImport &&\n        resolveOnly.length &&\n        !resolveOnly.some((pattern) => pattern.test(id))\n      ) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = (...args) => this.warn(...args);\n      const isRequire =\n        opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n\n      const resolved =\n        importeeIsBuiltin && preferBuiltins\n          ? {\n              packageInfo: undefined,\n              hasModuleSideEffects: () => null,\n              hasPackageEntry: true,\n              packageBrowserField: false\n            }\n          : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n\n      const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;\n      let { location } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(\n              `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`\n            );\n          }\n          return false;\n        } else if (jail && location.indexOf(normalize(jail.trim(sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule(code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\n\nexport default nodeResolve;\nexport { DEFAULTS, nodeResolve };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}