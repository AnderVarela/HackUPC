{"ast":null,"code":"/**\n * @filedescription Object Schema\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\nconst {\n  MergeStrategy\n} = require(\"./merge-strategy\");\nconst {\n  ValidationStrategy\n} = require(\"./validation-strategy\");\n\n//-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {Object} strategy The strategy for the object key.\n * @param {boolean} [strategy.required=true] Whether the key is required.\n * @param {string[]} [strategy.requires] Other keys that are required when\n *      this key is present.\n * @param {Function} strategy.merge A method to call when merging two objects\n *      with the same key.\n * @param {Function} strategy.validate A method to call when validating an\n *      object with the key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\nfunction validateDefinition(name, strategy) {\n  let hasSchema = false;\n  if (strategy.schema) {\n    if (typeof strategy.schema === \"object\") {\n      hasSchema = true;\n    } else {\n      throw new TypeError(\"Schema must be an object.\");\n    }\n  }\n  if (typeof strategy.merge === \"string\") {\n    if (!(strategy.merge in MergeStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n  }\n  if (typeof strategy.validate === \"string\") {\n    if (!(strategy.validate in ValidationStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n  }\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Error when an unexpected key is found.\n */\nclass UnexpectedKeyError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {string} key The key that was unexpected. \n   */\n  constructor(key) {\n    super(`Unexpected key \"${key}\" found.`);\n  }\n}\n\n/**\n * Error when a required key is missing.\n */\nclass MissingKeyError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {string} key The key that was missing. \n   */\n  constructor(key) {\n    super(`Missing required key \"${key}\".`);\n  }\n}\n\n/**\n * Error when a key requires other keys that are missing.\n */\nclass MissingDependentKeysError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {string} key The key that was unexpected.\n   * @param {Array<string>} requiredKeys The keys that are required.\n   */\n  constructor(key, requiredKeys) {\n    super(`Key \"${key}\" requires keys \"${requiredKeys.join(\"\\\", \\\"\")}\".`);\n  }\n}\n\n/**\n * Wrapper error for errors occuring during a merge or validate operation.\n */\nclass WrapperError extends Error {\n  /**\n   * Creates a new instance.\n   * @param {string} key The object key causing the error. \n   * @param {Error} source The source error. \n   */\n  constructor(key, source) {\n    super(`Key \"${key}\": ${source.message}`, {\n      cause: source\n    });\n\n    // copy over custom properties that aren't represented\n    for (const key of Object.keys(source)) {\n      if (!(key in this)) {\n        this[key] = source[key];\n      }\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\nclass ObjectSchema {\n  /**\n   * Creates a new instance.\n   */\n  constructor(definitions) {\n    if (!definitions) {\n      throw new Error(\"Schema definitions missing.\");\n    }\n\n    /**\n     * Track all strategies in the schema by key.\n     * @type {Map}\n     * @property strategies\n     */\n    this[strategies] = new Map();\n\n    /**\n     * Separately track any keys that are required for faster validation.\n     * @type {Map}\n     * @property requiredKeys\n     */\n    this[requiredKeys] = new Map();\n\n    // add in all strategies\n    for (const key of Object.keys(definitions)) {\n      validateDefinition(key, definitions[key]);\n\n      // normalize merge and validate methods if subschema is present\n      if (typeof definitions[key].schema === \"object\") {\n        const schema = new ObjectSchema(definitions[key].schema);\n        definitions[key] = {\n          ...definitions[key],\n          merge(first = {}, second = {}) {\n            return schema.merge(first, second);\n          },\n          validate(value) {\n            ValidationStrategy.object(value);\n            schema.validate(value);\n          }\n        };\n      }\n\n      // normalize the merge method in case there's a string\n      if (typeof definitions[key].merge === \"string\") {\n        definitions[key] = {\n          ...definitions[key],\n          merge: MergeStrategy[definitions[key].merge]\n        };\n      }\n      ;\n\n      // normalize the validate method in case there's a string\n      if (typeof definitions[key].validate === \"string\") {\n        definitions[key] = {\n          ...definitions[key],\n          validate: ValidationStrategy[definitions[key].validate]\n        };\n      }\n      ;\n      this[strategies].set(key, definitions[key]);\n      if (definitions[key].required) {\n        this[requiredKeys].set(key, definitions[key]);\n      }\n    }\n  }\n\n  /**\n   * Determines if a strategy has been registered for the given object key.\n   * @param {string} key The object key to find a strategy for.\n   * @returns {boolean} True if the key has a strategy registered, false if not. \n   */\n  hasKey(key) {\n    return this[strategies].has(key);\n  }\n\n  /**\n   * Merges objects together to create a new object comprised of the keys\n   * of the all objects. Keys are merged based on the each key's merge\n   * strategy.\n   * @param {...Object} objects The objects to merge.\n   * @returns {Object} A new object with a mix of all objects' keys.\n   * @throws {Error} If any object is invalid.\n   */\n  merge(...objects) {\n    // double check arguments\n    if (objects.length < 2) {\n      throw new TypeError(\"merge() requires at least two arguments.\");\n    }\n    if (objects.some(object => object == null || typeof object !== \"object\")) {\n      throw new TypeError(\"All arguments must be objects.\");\n    }\n    return objects.reduce((result, object) => {\n      this.validate(object);\n      for (const [key, strategy] of this[strategies]) {\n        try {\n          if (key in result || key in object) {\n            const value = strategy.merge.call(this, result[key], object[key]);\n            if (value !== undefined) {\n              result[key] = value;\n            }\n          }\n        } catch (ex) {\n          throw new WrapperError(key, ex);\n        }\n      }\n      return result;\n    }, {});\n  }\n\n  /**\n   * Validates an object's keys based on the validate strategy for each key.\n   * @param {Object} object The object to validate.\n   * @returns {void}\n   * @throws {Error} When the object is invalid. \n   */\n  validate(object) {\n    // check existing keys first\n    for (const key of Object.keys(object)) {\n      // check to see if the key is defined\n      if (!this.hasKey(key)) {\n        throw new UnexpectedKeyError(key);\n      }\n\n      // validate existing keys\n      const strategy = this[strategies].get(key);\n\n      // first check to see if any other keys are required\n      if (Array.isArray(strategy.requires)) {\n        if (!strategy.requires.every(otherKey => otherKey in object)) {\n          throw new MissingDependentKeysError(key, strategy.requires);\n        }\n      }\n\n      // now apply remaining validation strategy\n      try {\n        strategy.validate.call(strategy, object[key]);\n      } catch (ex) {\n        throw new WrapperError(key, ex);\n      }\n    }\n\n    // ensure required keys aren't missing\n    for (const [key] of this[requiredKeys]) {\n      if (!(key in object)) {\n        throw new MissingKeyError(key);\n      }\n    }\n  }\n}\nexports.ObjectSchema = ObjectSchema;","map":{"version":3,"names":["MergeStrategy","require","ValidationStrategy","strategies","Symbol","requiredKeys","validateDefinition","name","strategy","hasSchema","schema","TypeError","merge","validate","UnexpectedKeyError","Error","constructor","key","MissingKeyError","MissingDependentKeysError","join","WrapperError","source","message","cause","Object","keys","ObjectSchema","definitions","Map","first","second","value","object","set","required","hasKey","has","objects","length","some","reduce","result","call","undefined","ex","get","Array","isArray","requires","every","otherKey","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@humanwhocodes/object-schema/src/object-schema.js"],"sourcesContent":["/**\n * @filedescription Object Schema\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { MergeStrategy } = require(\"./merge-strategy\");\nconst { ValidationStrategy } = require(\"./validation-strategy\");\n\n//-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {Object} strategy The strategy for the object key.\n * @param {boolean} [strategy.required=true] Whether the key is required.\n * @param {string[]} [strategy.requires] Other keys that are required when\n *      this key is present.\n * @param {Function} strategy.merge A method to call when merging two objects\n *      with the same key.\n * @param {Function} strategy.validate A method to call when validating an\n *      object with the key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\nfunction validateDefinition(name, strategy) {\n\n    let hasSchema = false;\n    if (strategy.schema) {\n        if (typeof strategy.schema === \"object\") {\n            hasSchema = true;\n        } else {\n            throw new TypeError(\"Schema must be an object.\");\n        }\n    }\n\n    if (typeof strategy.merge === \"string\") {\n        if (!(strategy.merge in MergeStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n    }\n\n    if (typeof strategy.validate === \"string\") {\n        if (!(strategy.validate in ValidationStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Error when an unexpected key is found.\n */\nclass UnexpectedKeyError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was unexpected. \n     */\n    constructor(key) {\n        super(`Unexpected key \"${key}\" found.`);\n    }\n}\n\n/**\n * Error when a required key is missing.\n */\nclass MissingKeyError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was missing. \n     */\n    constructor(key) {\n        super(`Missing required key \"${key}\".`);\n    }\n}\n\n/**\n * Error when a key requires other keys that are missing.\n */\nclass MissingDependentKeysError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The key that was unexpected.\n     * @param {Array<string>} requiredKeys The keys that are required.\n     */\n    constructor(key, requiredKeys) {\n        super(`Key \"${key}\" requires keys \"${requiredKeys.join(\"\\\", \\\"\")}\".`);\n    }\n}\n\n/**\n * Wrapper error for errors occuring during a merge or validate operation.\n */\nclass WrapperError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} key The object key causing the error. \n     * @param {Error} source The source error. \n     */\n    constructor(key, source) {\n        super(`Key \"${key}\": ${source.message}`, { cause: source });\n\n        // copy over custom properties that aren't represented\n        for (const key of Object.keys(source)) {\n            if (!(key in this)) {\n                this[key] = source[key];\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\nclass ObjectSchema {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor(definitions) {\n\n        if (!definitions) {\n            throw new Error(\"Schema definitions missing.\");\n        }\n\n        /**\n         * Track all strategies in the schema by key.\n         * @type {Map}\n         * @property strategies\n         */\n        this[strategies] = new Map();\n\n        /**\n         * Separately track any keys that are required for faster validation.\n         * @type {Map}\n         * @property requiredKeys\n         */\n        this[requiredKeys] = new Map();\n\n        // add in all strategies\n        for (const key of Object.keys(definitions)) {\n            validateDefinition(key, definitions[key]);\n\n            // normalize merge and validate methods if subschema is present\n            if (typeof definitions[key].schema === \"object\") {\n                const schema = new ObjectSchema(definitions[key].schema);\n                definitions[key] = {\n                    ...definitions[key],\n                    merge(first = {}, second = {}) {\n                        return schema.merge(first, second);\n                    },\n                    validate(value) {\n                        ValidationStrategy.object(value);\n                        schema.validate(value);\n                    }\n                };\n            }\n\n            // normalize the merge method in case there's a string\n            if (typeof definitions[key].merge === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    merge: MergeStrategy[definitions[key].merge]\n                };\n            };\n\n            // normalize the validate method in case there's a string\n            if (typeof definitions[key].validate === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    validate: ValidationStrategy[definitions[key].validate]\n                };\n            };\n\n            this[strategies].set(key, definitions[key]);\n\n            if (definitions[key].required) {\n                this[requiredKeys].set(key, definitions[key]);\n            }\n        }\n    }\n\n    /**\n     * Determines if a strategy has been registered for the given object key.\n     * @param {string} key The object key to find a strategy for.\n     * @returns {boolean} True if the key has a strategy registered, false if not. \n     */\n    hasKey(key) {\n        return this[strategies].has(key);\n    }\n\n    /**\n     * Merges objects together to create a new object comprised of the keys\n     * of the all objects. Keys are merged based on the each key's merge\n     * strategy.\n     * @param {...Object} objects The objects to merge.\n     * @returns {Object} A new object with a mix of all objects' keys.\n     * @throws {Error} If any object is invalid.\n     */\n    merge(...objects) {\n\n        // double check arguments\n        if (objects.length < 2) {\n            throw new TypeError(\"merge() requires at least two arguments.\");\n        }\n\n        if (objects.some(object => (object == null || typeof object !== \"object\"))) {\n            throw new TypeError(\"All arguments must be objects.\");\n        }\n\n        return objects.reduce((result, object) => {\n            \n            this.validate(object);\n            \n            for (const [key, strategy] of this[strategies]) {\n                try {\n                    if (key in result || key in object) {\n                        const value = strategy.merge.call(this, result[key], object[key]);\n                        if (value !== undefined) {\n                            result[key] = value;\n                        }\n                    }\n                } catch (ex) {\n                    throw new WrapperError(key, ex);\n                }\n            }\n            return result;\n        }, {});\n    }\n\n    /**\n     * Validates an object's keys based on the validate strategy for each key.\n     * @param {Object} object The object to validate.\n     * @returns {void}\n     * @throws {Error} When the object is invalid. \n     */\n    validate(object) {\n\n        // check existing keys first\n        for (const key of Object.keys(object)) {\n\n            // check to see if the key is defined\n            if (!this.hasKey(key)) {\n                throw new UnexpectedKeyError(key);\n            }\n\n            // validate existing keys\n            const strategy = this[strategies].get(key);\n\n            // first check to see if any other keys are required\n            if (Array.isArray(strategy.requires)) {\n                if (!strategy.requires.every(otherKey => otherKey in object)) {\n                    throw new MissingDependentKeysError(key, strategy.requires);\n                }\n            }\n\n            // now apply remaining validation strategy\n            try {\n                strategy.validate.call(strategy, object[key]);\n            } catch (ex) {\n                throw new WrapperError(key, ex);\n            }\n        }\n\n        // ensure required keys aren't missing\n        for (const [key] of this[requiredKeys]) {\n            if (!(key in object)) {\n                throw new MissingKeyError(key);\n            }\n        }\n\n    }\n}\n\nexports.ObjectSchema = ObjectSchema;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}