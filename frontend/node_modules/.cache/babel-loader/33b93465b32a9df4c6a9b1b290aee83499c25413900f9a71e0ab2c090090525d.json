{"ast":null,"code":"/**\n * Gets the source (i.e. host) of the script currently running.\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to get the current running script,\n  // but is not supported in all browsers (most notably, IE).\n  if ('currentScript' in document) {\n    // In some cases, `document.currentScript` would be `null` even if the browser supports it:\n    // e.g. asynchronous chunks on Firefox.\n    // We should not fallback to the list-approach as it would not be safe.\n    if (document.currentScript == null) return;\n    return document.currentScript.getAttribute('src');\n  }\n  // Fallback to getting all scripts running in the document,\n  // and finding the last one injected.\n  else {\n    const scriptElementsWithSrc = Array.prototype.filter.call(document.scripts || [], function (elem) {\n      return elem.getAttribute('src');\n    });\n    if (!scriptElementsWithSrc.length) return;\n    const currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute('src');\n  }\n}\nmodule.exports = getCurrentScriptSource;","map":{"version":3,"names":["getCurrentScriptSource","document","currentScript","getAttribute","scriptElementsWithSrc","Array","prototype","filter","call","scripts","elem","length","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/sockets/utils/getCurrentScriptSource.js"],"sourcesContent":["/**\n * Gets the source (i.e. host) of the script currently running.\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to get the current running script,\n  // but is not supported in all browsers (most notably, IE).\n  if ('currentScript' in document) {\n    // In some cases, `document.currentScript` would be `null` even if the browser supports it:\n    // e.g. asynchronous chunks on Firefox.\n    // We should not fallback to the list-approach as it would not be safe.\n    if (document.currentScript == null) return;\n    return document.currentScript.getAttribute('src');\n  }\n  // Fallback to getting all scripts running in the document,\n  // and finding the last one injected.\n  else {\n    const scriptElementsWithSrc = Array.prototype.filter.call(\n      document.scripts || [],\n      function (elem) {\n        return elem.getAttribute('src');\n      }\n    );\n    if (!scriptElementsWithSrc.length) return;\n    const currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute('src');\n  }\n}\n\nmodule.exports = getCurrentScriptSource;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,sBAAsBA,CAAA,EAAG;EAChC;EACA;EACA,IAAI,eAAe,IAAIC,QAAQ,EAAE;IAC/B;IACA;IACA;IACA,IAAIA,QAAQ,CAACC,aAAa,IAAI,IAAI,EAAE;IACpC,OAAOD,QAAQ,CAACC,aAAa,CAACC,YAAY,CAAC,KAAK,CAAC;EACnD;EACA;EACA;EAAA,KACK;IACH,MAAMC,qBAAqB,GAAGC,KAAK,CAACC,SAAS,CAACC,MAAM,CAACC,IAAI,CACvDP,QAAQ,CAACQ,OAAO,IAAI,EAAE,EACtB,UAAUC,IAAI,EAAE;MACd,OAAOA,IAAI,CAACP,YAAY,CAAC,KAAK,CAAC;IACjC,CACF,CAAC;IACD,IAAI,CAACC,qBAAqB,CAACO,MAAM,EAAE;IACnC,MAAMT,aAAa,GAAGE,qBAAqB,CAACA,qBAAqB,CAACO,MAAM,GAAG,CAAC,CAAC;IAC7E,OAAOT,aAAa,CAACC,YAAY,CAAC,KAAK,CAAC;EAC1C;AACF;AAEAS,MAAM,CAACC,OAAO,GAAGb,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}