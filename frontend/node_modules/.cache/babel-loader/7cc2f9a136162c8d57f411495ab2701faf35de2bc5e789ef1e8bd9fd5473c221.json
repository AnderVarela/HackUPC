{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\nconst error = require('./error');\nconst EventEmitter = require('events').EventEmitter;\nconst events = require('./events');\nconst promise = require('./promise');\nconst terminators = {\n  obj: '}',\n  arr: ']'\n};\nconst escapes = {\n  /* eslint-disable quote-props */\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  /* eslint-enable quote-props */\n};\nmodule.exports = initialise;\n\n/**\n * Public function `walk`.\n *\n * Returns an event emitter and asynchronously walks a stream of JSON data,\n * emitting events as it encounters tokens. The event emitter is decorated\n * with a `pause` method that can be called to pause processing.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON.\n **/\nfunction initialise(stream, options = {}) {\n  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument');\n  const currentPosition = {\n    line: 1,\n    column: 1\n  };\n  const emitter = new EventEmitter();\n  const handlers = {\n    arr: value,\n    obj: property\n  };\n  const json = [];\n  const lengths = [];\n  const previousPosition = {};\n  const Promise = promise(options);\n  const scopes = [];\n  const yieldRate = options.yieldRate || 16384;\n  const shouldHandleNdjson = !!options.ndjson;\n  let index = 0;\n  let isStreamEnded = false;\n  let isWalkBegun = false;\n  let isWalkEnded = false;\n  let isWalkingString = false;\n  let hasEndedLine = true;\n  let count = 0;\n  let resumeFn;\n  let pause;\n  let cachedCharacter;\n  stream.setEncoding('utf8');\n  stream.on('data', readStream);\n  stream.on('end', endStream);\n  stream.on('error', err => {\n    emitter.emit(events.error, err);\n    endStream();\n  });\n  emitter.pause = () => {\n    let resolve;\n    pause = new Promise(res => resolve = res);\n    return () => {\n      pause = null;\n      count = 0;\n      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {\n        emit(events.end);\n      } else {\n        resolve();\n      }\n    };\n  };\n  return emitter;\n  function readStream(chunk) {\n    addChunk(chunk);\n    if (isWalkBegun) {\n      return resume();\n    }\n    isWalkBegun = true;\n    value();\n  }\n  function addChunk(chunk) {\n    json.push(chunk);\n    const chunkLength = chunk.length;\n    lengths.push({\n      item: chunkLength,\n      aggregate: length() + chunkLength\n    });\n  }\n  function length() {\n    const chunkCount = lengths.length;\n    if (chunkCount === 0) {\n      return 0;\n    }\n    return lengths[chunkCount - 1].aggregate;\n  }\n  function value() {\n    /* eslint-disable no-underscore-dangle */\n    if (++count % yieldRate !== 0) {\n      return _do();\n    }\n    return new Promise(resolve => {\n      setImmediate(() => _do().then(resolve));\n    });\n    function _do() {\n      return awaitNonWhitespace().then(next).then(handleValue).catch(() => {});\n    }\n    /* eslint-enable no-underscore-dangle */\n  }\n  function awaitNonWhitespace() {\n    return wait();\n    function wait() {\n      return awaitCharacter().then(step);\n    }\n    function step() {\n      if (isWhitespace(character())) {\n        return next().then(wait);\n      }\n    }\n  }\n  function awaitCharacter() {\n    let resolve, reject;\n    if (index < length()) {\n      return Promise.resolve();\n    }\n    if (isStreamEnded) {\n      setImmediate(endWalk);\n      return Promise.reject();\n    }\n    resumeFn = after;\n    return new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    function after() {\n      if (index < length()) {\n        return resolve();\n      }\n      reject();\n      if (isStreamEnded) {\n        setImmediate(endWalk);\n      }\n    }\n  }\n  function character() {\n    if (cachedCharacter) {\n      return cachedCharacter;\n    }\n    if (lengths[0].item > index) {\n      return cachedCharacter = json[0][index];\n    }\n    const len = lengths.length;\n    for (let i = 1; i < len; ++i) {\n      const {\n        aggregate,\n        item\n      } = lengths[i];\n      if (aggregate > index) {\n        return cachedCharacter = json[i][index + item - aggregate];\n      }\n    }\n  }\n  function isWhitespace(char) {\n    switch (char) {\n      case '\\n':\n        if (shouldHandleNdjson && scopes.length === 0) {\n          return false;\n        }\n      case ' ':\n      case '\\t':\n      case '\\r':\n        return true;\n    }\n    return false;\n  }\n  function next() {\n    return awaitCharacter().then(after);\n    function after() {\n      const result = character();\n      cachedCharacter = null;\n      index += 1;\n      previousPosition.line = currentPosition.line;\n      previousPosition.column = currentPosition.column;\n      if (result === '\\n') {\n        currentPosition.line += 1;\n        currentPosition.column = 1;\n      } else {\n        currentPosition.column += 1;\n      }\n      if (index > lengths[0].aggregate) {\n        json.shift();\n        const difference = lengths.shift().item;\n        index -= difference;\n        lengths.forEach(len => len.aggregate -= difference);\n      }\n      return result;\n    }\n  }\n  function handleValue(char) {\n    if (shouldHandleNdjson && scopes.length === 0) {\n      if (char === '\\n') {\n        hasEndedLine = true;\n        return emit(events.endLine).then(value);\n      }\n      if (!hasEndedLine) {\n        return fail(char, '\\n', previousPosition).then(value);\n      }\n      hasEndedLine = false;\n    }\n    switch (char) {\n      case '[':\n        return array();\n      case '{':\n        return object();\n      case '\"':\n        return string();\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n      case '.':\n        return number(char);\n      case 'f':\n        return literalFalse();\n      case 'n':\n        return literalNull();\n      case 't':\n        return literalTrue();\n      default:\n        return fail(char, 'value', previousPosition).then(value);\n    }\n  }\n  function array() {\n    return scope(events.array, value);\n  }\n  function scope(event, contentHandler) {\n    return emit(event).then(() => {\n      scopes.push(event);\n      return endScope(event);\n    }).then(contentHandler);\n  }\n  function emit(...args) {\n    return (pause || Promise.resolve()).then(() => {\n      try {\n        emitter.emit(...args);\n      } catch (err) {\n        try {\n          emitter.emit(events.error, err);\n        } catch (_) {\n          // When calling user code, anything is possible\n        }\n      }\n    });\n  }\n  function endScope(scp) {\n    return awaitNonWhitespace().then(() => {\n      if (character() === terminators[scp]) {\n        return emit(events.endPrefix + scp).then(() => {\n          scopes.pop();\n          return next();\n        }).then(endValue);\n      }\n    }).catch(endWalk);\n  }\n  function endValue() {\n    return awaitNonWhitespace().then(after).catch(endWalk);\n    function after() {\n      if (scopes.length === 0) {\n        if (shouldHandleNdjson) {\n          return value();\n        }\n        return fail(character(), 'EOF', currentPosition).then(value);\n      }\n      return checkScope();\n    }\n    function checkScope() {\n      const scp = scopes[scopes.length - 1];\n      const handler = handlers[scp];\n      return endScope(scp).then(() => {\n        if (scopes.length > 0) {\n          return checkCharacter(character(), ',', currentPosition);\n        }\n      }).then(result => {\n        if (result) {\n          return next();\n        }\n      }).then(handler);\n    }\n  }\n  function fail(actual, expected, position) {\n    return emit(events.dataError, error.create(actual, expected, position.line, position.column));\n  }\n  function checkCharacter(char, expected, position) {\n    if (char === expected) {\n      return Promise.resolve(true);\n    }\n    return fail(char, expected, position).then(false);\n  }\n  function object() {\n    return scope(events.object, property);\n  }\n  function property() {\n    return awaitNonWhitespace().then(next).then(propertyName);\n  }\n  function propertyName(char) {\n    return checkCharacter(char, '\"', previousPosition).then(() => walkString(events.property)).then(awaitNonWhitespace).then(next).then(propertyValue);\n  }\n  function propertyValue(char) {\n    return checkCharacter(char, ':', previousPosition).then(value);\n  }\n  function walkString(event) {\n    let isEscaping = false;\n    const str = [];\n    isWalkingString = true;\n    return next().then(step);\n    function step(char) {\n      if (isEscaping) {\n        isEscaping = false;\n        return escape(char).then(escaped => {\n          str.push(escaped);\n          return next().then(step);\n        });\n      }\n      if (char === '\\\\') {\n        isEscaping = true;\n        return next().then(step);\n      }\n      if (char !== '\"') {\n        str.push(char);\n        return next().then(step);\n      }\n      isWalkingString = false;\n      return emit(event, str.join(''));\n    }\n  }\n  function escape(char) {\n    if (escapes[char]) {\n      return Promise.resolve(escapes[char]);\n    }\n    if (char === 'u') {\n      return escapeHex();\n    }\n    return fail(char, 'escape character', previousPosition).then(() => `\\\\${char}`);\n  }\n  function escapeHex() {\n    let hexits = [];\n    return next().then(step.bind(null, 0));\n    function step(idx, char) {\n      if (isHexit(char)) {\n        hexits.push(char);\n      }\n      if (idx < 3) {\n        return next().then(step.bind(null, idx + 1));\n      }\n      hexits = hexits.join('');\n      if (hexits.length === 4) {\n        return String.fromCharCode(parseInt(hexits, 16));\n      }\n      return fail(char, 'hex digit', previousPosition).then(() => `\\\\u${hexits}${char}`);\n    }\n  }\n  function string() {\n    return walkString(events.string).then(endValue);\n  }\n  function number(firstCharacter) {\n    let digits = [firstCharacter];\n    return walkDigits().then(addDigits.bind(null, checkDecimalPlace));\n    function addDigits(step, result) {\n      digits = digits.concat(result.digits);\n      if (result.atEnd) {\n        return endNumber();\n      }\n      return step();\n    }\n    function checkDecimalPlace() {\n      if (character() === '.') {\n        return next().then(char => {\n          digits.push(char);\n          return walkDigits();\n        }).then(addDigits.bind(null, checkExponent));\n      }\n      return checkExponent();\n    }\n    function checkExponent() {\n      if (character() === 'e' || character() === 'E') {\n        return next().then(char => {\n          digits.push(char);\n          return awaitCharacter();\n        }).then(checkSign).catch(fail.bind(null, 'EOF', 'exponent', currentPosition));\n      }\n      return endNumber();\n    }\n    function checkSign() {\n      if (character() === '+' || character() === '-') {\n        return next().then(char => {\n          digits.push(char);\n          return readExponent();\n        });\n      }\n      return readExponent();\n    }\n    function readExponent() {\n      return walkDigits().then(addDigits.bind(null, endNumber));\n    }\n    function endNumber() {\n      return emit(events.number, parseFloat(digits.join(''))).then(endValue);\n    }\n  }\n  function walkDigits() {\n    const digits = [];\n    return wait();\n    function wait() {\n      return awaitCharacter().then(step).catch(atEnd);\n    }\n    function step() {\n      if (isDigit(character())) {\n        return next().then(char => {\n          digits.push(char);\n          return wait();\n        });\n      }\n      return {\n        digits,\n        atEnd: false\n      };\n    }\n    function atEnd() {\n      return {\n        digits,\n        atEnd: true\n      };\n    }\n  }\n  function literalFalse() {\n    return literal(['a', 'l', 's', 'e'], false);\n  }\n  function literal(expectedCharacters, val) {\n    let actual, expected, invalid;\n    return wait();\n    function wait() {\n      return awaitCharacter().then(step).catch(atEnd);\n    }\n    function step() {\n      if (invalid || expectedCharacters.length === 0) {\n        return atEnd();\n      }\n      return next().then(afterNext);\n    }\n    function atEnd() {\n      return Promise.resolve().then(() => {\n        if (invalid) {\n          return fail(actual, expected, previousPosition);\n        }\n        if (expectedCharacters.length > 0) {\n          return fail('EOF', expectedCharacters.shift(), currentPosition);\n        }\n        return done();\n      }).then(endValue);\n    }\n    function afterNext(char) {\n      actual = char;\n      expected = expectedCharacters.shift();\n      if (actual !== expected) {\n        invalid = true;\n      }\n      return wait();\n    }\n    function done() {\n      return emit(events.literal, val);\n    }\n  }\n  function literalNull() {\n    return literal(['u', 'l', 'l'], null);\n  }\n  function literalTrue() {\n    return literal(['r', 'u', 'e'], true);\n  }\n  function endStream() {\n    isStreamEnded = true;\n    if (isWalkBegun) {\n      return resume();\n    }\n    endWalk();\n  }\n  function resume() {\n    if (resumeFn) {\n      resumeFn();\n      resumeFn = null;\n    }\n  }\n  function endWalk() {\n    if (isWalkEnded) {\n      return Promise.resolve();\n    }\n    isWalkEnded = true;\n    return Promise.resolve().then(() => {\n      if (isWalkingString) {\n        return fail('EOF', '\"', currentPosition);\n      }\n    }).then(popScopes).then(() => emit(events.end));\n  }\n  function popScopes() {\n    if (scopes.length === 0) {\n      return Promise.resolve();\n    }\n    return fail('EOF', terminators[scopes.pop()], currentPosition).then(popScopes);\n  }\n}\nfunction isHexit(character) {\n  return isDigit(character) || isInRange(character, 'A', 'F') || isInRange(character, 'a', 'f');\n}\nfunction isDigit(character) {\n  return isInRange(character, '0', '9');\n}\nfunction isInRange(character, lower, upper) {\n  const code = character.charCodeAt(0);\n  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0);\n}","map":{"version":3,"names":["check","require","error","EventEmitter","events","promise","terminators","obj","arr","escapes","module","exports","initialise","stream","options","assert","instanceStrict","Readable","currentPosition","line","column","emitter","handlers","value","property","json","lengths","previousPosition","Promise","scopes","yieldRate","shouldHandleNdjson","ndjson","index","isStreamEnded","isWalkBegun","isWalkEnded","isWalkingString","hasEndedLine","count","resumeFn","pause","cachedCharacter","setEncoding","on","readStream","endStream","err","emit","resolve","res","end","chunk","addChunk","resume","push","chunkLength","length","item","aggregate","chunkCount","_do","setImmediate","then","awaitNonWhitespace","next","handleValue","catch","wait","awaitCharacter","step","isWhitespace","character","reject","endWalk","after","rej","len","i","char","result","shift","difference","forEach","endLine","fail","array","object","string","number","literalFalse","literalNull","literalTrue","scope","event","contentHandler","endScope","args","_","scp","endPrefix","pop","endValue","checkScope","handler","checkCharacter","actual","expected","position","dataError","create","propertyName","walkString","propertyValue","isEscaping","str","escape","escaped","join","escapeHex","hexits","bind","idx","isHexit","String","fromCharCode","parseInt","firstCharacter","digits","walkDigits","addDigits","checkDecimalPlace","concat","atEnd","endNumber","checkExponent","checkSign","readExponent","parseFloat","isDigit","literal","expectedCharacters","val","invalid","afterNext","done","popScopes","isInRange","lower","upper","code","charCodeAt"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/bfj/src/walk.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst error = require('./error')\nconst EventEmitter = require('events').EventEmitter\nconst events = require('./events')\nconst promise = require('./promise')\n\nconst terminators = {\n  obj: '}',\n  arr: ']'\n}\n\nconst escapes = {\n  /* eslint-disable quote-props */\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  /* eslint-enable quote-props */\n}\n\nmodule.exports = initialise\n\n/**\n * Public function `walk`.\n *\n * Returns an event emitter and asynchronously walks a stream of JSON data,\n * emitting events as it encounters tokens. The event emitter is decorated\n * with a `pause` method that can be called to pause processing.\n *\n * @param stream:     Readable instance representing the incoming JSON.\n *\n * @option yieldRate: The number of data items to process per timeslice,\n *                    default is 16384.\n *\n * @option Promise:   The promise constructor to use, defaults to bluebird.\n *\n * @option ndjson:    Set this to true to parse newline-delimited JSON.\n **/\nfunction initialise (stream, options = {}) {\n  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument')\n\n  const currentPosition = {\n    line: 1,\n    column: 1\n  }\n  const emitter = new EventEmitter()\n  const handlers = {\n    arr: value,\n    obj: property\n  }\n  const json = []\n  const lengths = []\n  const previousPosition = {}\n  const Promise = promise(options)\n  const scopes = []\n  const yieldRate = options.yieldRate || 16384\n  const shouldHandleNdjson = !! options.ndjson\n\n  let index = 0\n  let isStreamEnded = false\n  let isWalkBegun = false\n  let isWalkEnded = false\n  let isWalkingString = false\n  let hasEndedLine = true\n  let count = 0\n  let resumeFn\n  let pause\n  let cachedCharacter\n\n  stream.setEncoding('utf8')\n  stream.on('data', readStream)\n  stream.on('end', endStream)\n  stream.on('error', err => {\n    emitter.emit(events.error, err)\n    endStream()\n  })\n\n  emitter.pause = () => {\n    let resolve\n    pause = new Promise(res => resolve = res)\n    return () => {\n      pause = null\n      count = 0\n\n      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {\n        emit(events.end)\n      } else {\n        resolve()\n      }\n    }\n  }\n\n  return emitter\n\n  function readStream (chunk) {\n    addChunk(chunk)\n\n    if (isWalkBegun) {\n      return resume()\n    }\n\n    isWalkBegun = true\n    value()\n  }\n\n  function addChunk (chunk) {\n    json.push(chunk)\n\n    const chunkLength = chunk.length\n    lengths.push({\n      item: chunkLength,\n      aggregate: length() + chunkLength\n    })\n  }\n\n  function length () {\n    const chunkCount = lengths.length\n\n    if (chunkCount === 0) {\n      return 0\n    }\n\n    return lengths[chunkCount - 1].aggregate\n  }\n\n  function value () {\n    /* eslint-disable no-underscore-dangle */\n    if (++count % yieldRate !== 0) {\n      return _do()\n    }\n\n    return new Promise(resolve => {\n      setImmediate(() => _do().then(resolve))\n    })\n\n    function _do () {\n      return awaitNonWhitespace()\n        .then(next)\n        .then(handleValue)\n        .catch(() => {})\n    }\n    /* eslint-enable no-underscore-dangle */\n  }\n\n  function awaitNonWhitespace () {\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n    }\n\n    function step () {\n      if (isWhitespace(character())) {\n        return next().then(wait)\n      }\n    }\n  }\n\n  function awaitCharacter () {\n    let resolve, reject\n\n    if (index < length()) {\n      return Promise.resolve()\n    }\n\n    if (isStreamEnded) {\n      setImmediate(endWalk)\n      return Promise.reject()\n    }\n\n    resumeFn = after\n\n    return new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    function after () {\n      if (index < length()) {\n        return resolve()\n      }\n\n      reject()\n\n      if (isStreamEnded) {\n        setImmediate(endWalk)\n      }\n    }\n  }\n\n  function character () {\n    if (cachedCharacter) {\n      return cachedCharacter\n    }\n\n    if (lengths[0].item > index) {\n      return cachedCharacter = json[0][index]\n    }\n\n    const len = lengths.length\n    for (let i = 1; i < len; ++i) {\n      const { aggregate, item } = lengths[i]\n      if (aggregate > index) {\n        return cachedCharacter = json[i][index + item - aggregate]\n      }\n    }\n  }\n\n  function isWhitespace (char) {\n    switch (char) {\n      case '\\n':\n        if (shouldHandleNdjson && scopes.length === 0) {\n          return false\n        }\n      case ' ':\n      case '\\t':\n      case '\\r':\n        return true\n    }\n\n    return false\n  }\n\n  function next () {\n    return awaitCharacter().then(after)\n\n    function after () {\n      const result = character()\n\n      cachedCharacter = null\n      index += 1\n      previousPosition.line = currentPosition.line\n      previousPosition.column = currentPosition.column\n\n      if (result === '\\n') {\n        currentPosition.line += 1\n        currentPosition.column = 1\n      } else {\n        currentPosition.column += 1\n      }\n\n      if (index > lengths[0].aggregate) {\n        json.shift()\n\n        const difference = lengths.shift().item\n        index -= difference\n\n        lengths.forEach(len => len.aggregate -= difference)\n      }\n\n      return result\n    }\n  }\n\n  function handleValue (char) {\n    if (shouldHandleNdjson && scopes.length === 0) {\n      if (char === '\\n') {\n        hasEndedLine = true\n        return emit(events.endLine)\n          .then(value)\n      }\n\n      if (! hasEndedLine) {\n        return fail(char, '\\n', previousPosition)\n          .then(value)\n      }\n\n      hasEndedLine = false\n    }\n\n    switch (char) {\n      case '[':\n        return array()\n      case '{':\n        return object()\n      case '\"':\n        return string()\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n      case '.':\n        return number(char)\n      case 'f':\n        return literalFalse()\n      case 'n':\n        return literalNull()\n      case 't':\n        return literalTrue()\n      default:\n        return fail(char, 'value', previousPosition)\n          .then(value)\n    }\n  }\n\n  function array () {\n    return scope(events.array, value)\n  }\n\n  function scope (event, contentHandler) {\n    return emit(event)\n      .then(() => {\n        scopes.push(event)\n        return endScope(event)\n      })\n      .then(contentHandler)\n  }\n\n  function emit (...args) {\n    return (pause || Promise.resolve())\n      .then(() => {\n        try {\n          emitter.emit(...args)\n        } catch (err) {\n          try {\n            emitter.emit(events.error, err)\n          } catch (_) {\n            // When calling user code, anything is possible\n          }\n        }\n      })\n  }\n\n  function endScope (scp) {\n    return awaitNonWhitespace()\n      .then(() => {\n        if (character() === terminators[scp]) {\n          return emit(events.endPrefix + scp)\n            .then(() => {\n              scopes.pop()\n              return next()\n            })\n            .then(endValue)\n        }\n      })\n      .catch(endWalk)\n  }\n\n  function endValue () {\n    return awaitNonWhitespace()\n      .then(after)\n      .catch(endWalk)\n\n    function after () {\n      if (scopes.length === 0) {\n        if (shouldHandleNdjson) {\n          return value()\n        }\n\n        return fail(character(), 'EOF', currentPosition)\n          .then(value)\n      }\n\n      return checkScope()\n    }\n\n    function checkScope () {\n      const scp = scopes[scopes.length - 1]\n      const handler = handlers[scp]\n\n      return endScope(scp)\n        .then(() => {\n          if (scopes.length > 0) {\n            return checkCharacter(character(), ',', currentPosition)\n          }\n        })\n        .then(result => {\n          if (result) {\n            return next()\n          }\n        })\n        .then(handler)\n    }\n  }\n\n  function fail (actual, expected, position) {\n    return emit(\n      events.dataError,\n      error.create(\n        actual,\n        expected,\n        position.line,\n        position.column\n      )\n    )\n  }\n\n  function checkCharacter (char, expected, position) {\n    if (char === expected) {\n      return Promise.resolve(true)\n    }\n\n    return fail(char, expected, position)\n      .then(false)\n  }\n\n  function object () {\n    return scope(events.object, property)\n  }\n\n  function property () {\n    return awaitNonWhitespace()\n      .then(next)\n      .then(propertyName)\n  }\n\n  function propertyName (char) {\n    return checkCharacter(char, '\"', previousPosition)\n      .then(() => walkString(events.property))\n      .then(awaitNonWhitespace)\n      .then(next)\n      .then(propertyValue)\n  }\n\n  function propertyValue (char) {\n    return checkCharacter(char, ':', previousPosition)\n      .then(value)\n  }\n\n  function walkString (event) {\n    let isEscaping = false\n    const str = []\n\n    isWalkingString = true\n\n    return next().then(step)\n\n    function step (char) {\n      if (isEscaping) {\n        isEscaping = false\n\n        return escape(char).then(escaped => {\n          str.push(escaped)\n          return next().then(step)\n        })\n      }\n\n      if (char === '\\\\') {\n        isEscaping = true\n        return next().then(step)\n      }\n\n      if (char !== '\"') {\n        str.push(char)\n        return next().then(step)\n      }\n\n      isWalkingString = false\n      return emit(event, str.join(''))\n    }\n  }\n\n  function escape (char) {\n    if (escapes[char]) {\n      return Promise.resolve(escapes[char])\n    }\n\n    if (char === 'u') {\n      return escapeHex()\n    }\n\n    return fail(char, 'escape character', previousPosition)\n      .then(() => `\\\\${char}`)\n  }\n\n  function escapeHex () {\n    let hexits = []\n\n    return next().then(step.bind(null, 0))\n\n    function step (idx, char) {\n      if (isHexit(char)) {\n        hexits.push(char)\n      }\n\n      if (idx < 3) {\n        return next().then(step.bind(null, idx + 1))\n      }\n\n      hexits = hexits.join('')\n\n      if (hexits.length === 4) {\n        return String.fromCharCode(parseInt(hexits, 16))\n      }\n\n      return fail(char, 'hex digit', previousPosition)\n        .then(() => `\\\\u${hexits}${char}`)\n    }\n  }\n\n  function string () {\n    return walkString(events.string).then(endValue)\n  }\n\n  function number (firstCharacter) {\n    let digits = [ firstCharacter ]\n\n    return walkDigits().then(addDigits.bind(null, checkDecimalPlace))\n\n    function addDigits (step, result) {\n      digits = digits.concat(result.digits)\n\n      if (result.atEnd) {\n        return endNumber()\n      }\n\n      return step()\n    }\n\n    function checkDecimalPlace () {\n      if (character() === '.') {\n        return next()\n          .then(char => {\n            digits.push(char)\n            return walkDigits()\n          })\n          .then(addDigits.bind(null, checkExponent))\n      }\n\n      return checkExponent()\n    }\n\n    function checkExponent () {\n      if (character() === 'e' || character() === 'E') {\n        return next()\n          .then(char => {\n            digits.push(char)\n            return awaitCharacter()\n          })\n          .then(checkSign)\n          .catch(fail.bind(null, 'EOF', 'exponent', currentPosition))\n      }\n\n      return endNumber()\n    }\n\n    function checkSign () {\n      if (character() === '+' || character() === '-') {\n        return next().then(char => {\n          digits.push(char)\n          return readExponent()\n        })\n      }\n\n      return readExponent()\n    }\n\n    function readExponent () {\n      return walkDigits().then(addDigits.bind(null, endNumber))\n    }\n\n    function endNumber () {\n      return emit(events.number, parseFloat(digits.join('')))\n        .then(endValue)\n    }\n  }\n\n  function walkDigits () {\n    const digits = []\n\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n        .catch(atEnd)\n    }\n\n    function step () {\n      if (isDigit(character())) {\n        return next().then(char => {\n          digits.push(char)\n          return wait()\n        })\n      }\n\n      return { digits, atEnd: false }\n    }\n\n    function atEnd () {\n      return { digits, atEnd: true }\n    }\n  }\n\n  function literalFalse () {\n    return literal([ 'a', 'l', 's', 'e' ], false)\n  }\n\n  function literal (expectedCharacters, val) {\n    let actual, expected, invalid\n\n    return wait()\n\n    function wait () {\n      return awaitCharacter()\n        .then(step)\n        .catch(atEnd)\n    }\n\n    function step () {\n      if (invalid || expectedCharacters.length === 0) {\n        return atEnd()\n      }\n\n      return next().then(afterNext)\n    }\n\n    function atEnd () {\n      return Promise.resolve()\n        .then(() => {\n          if (invalid) {\n            return fail(actual, expected, previousPosition)\n          }\n\n          if (expectedCharacters.length > 0) {\n            return fail('EOF', expectedCharacters.shift(), currentPosition)\n          }\n\n          return done()\n        })\n        .then(endValue)\n    }\n\n    function afterNext (char) {\n      actual = char\n      expected = expectedCharacters.shift()\n\n      if (actual !== expected) {\n        invalid = true\n      }\n\n      return wait()\n    }\n\n    function done () {\n      return emit(events.literal, val)\n    }\n  }\n\n  function literalNull () {\n    return literal([ 'u', 'l', 'l' ], null)\n  }\n\n  function literalTrue () {\n    return literal([ 'r', 'u', 'e' ], true)\n  }\n\n  function endStream () {\n    isStreamEnded = true\n\n    if (isWalkBegun) {\n      return resume()\n    }\n\n    endWalk()\n  }\n\n  function resume () {\n    if (resumeFn) {\n      resumeFn()\n      resumeFn = null\n    }\n  }\n\n  function endWalk () {\n    if (isWalkEnded) {\n      return Promise.resolve()\n    }\n\n    isWalkEnded = true\n\n    return Promise.resolve()\n      .then(() => {\n        if (isWalkingString) {\n          return fail('EOF', '\"', currentPosition)\n        }\n      })\n      .then(popScopes)\n      .then(() => emit(events.end))\n  }\n\n  function popScopes () {\n    if (scopes.length === 0) {\n      return Promise.resolve()\n    }\n\n    return fail('EOF', terminators[scopes.pop()], currentPosition)\n      .then(popScopes)\n  }\n}\n\nfunction isHexit (character) {\n  return isDigit(character) ||\n    isInRange(character, 'A', 'F') ||\n    isInRange(character, 'a', 'f')\n}\n\nfunction isDigit (character) {\n  return isInRange(character, '0', '9')\n}\n\nfunction isInRange (character, lower, upper) {\n  const code = character.charCodeAt(0)\n\n  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}