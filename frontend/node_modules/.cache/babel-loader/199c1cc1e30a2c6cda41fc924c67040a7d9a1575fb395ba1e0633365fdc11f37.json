{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util = __importStar(require(\"../util\"));\nconst definition = {\n  type: 'object',\n  properties: {\n    multiline: {\n      type: 'object',\n      properties: {\n        delimiter: {\n          enum: ['none', 'semi', 'comma']\n        },\n        requireLast: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    },\n    singleline: {\n      type: 'object',\n      properties: {\n        // note can't have \"none\" for single line delimiter as it's invalid syntax\n        delimiter: {\n          enum: ['semi', 'comma']\n        },\n        requireLast: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }\n  },\n  additionalProperties: false\n};\nconst isLastTokenEndOfLine = (token, line) => {\n  const positionInLine = token.loc.start.column;\n  return positionInLine === line.length - 1;\n};\nconst isCommentsEndOfLine = (token, comments, line) => {\n  if (!comments) {\n    return false;\n  }\n  if (comments.loc.end.line > token.loc.end.line) {\n    return true;\n  }\n  const positionInLine = comments.loc.end.column;\n  return positionInLine === line.length;\n};\nconst makeFixFunction = ({\n  optsNone,\n  optsSemi,\n  lastToken,\n  commentsAfterLastToken,\n  missingDelimiter,\n  lastTokenLine,\n  isSingleLine\n}) => {\n  // if removing is the action but last token is not the end of the line\n  if (optsNone && !isLastTokenEndOfLine(lastToken, lastTokenLine) && !isCommentsEndOfLine(lastToken, commentsAfterLastToken, lastTokenLine) && !isSingleLine) {\n    return null;\n  }\n  return fixer => {\n    if (optsNone) {\n      // remove the unneeded token\n      return fixer.remove(lastToken);\n    }\n    const token = optsSemi ? ';' : ',';\n    if (missingDelimiter) {\n      // add the missing delimiter\n      return fixer.insertTextAfter(lastToken, token);\n    }\n    // correct the current delimiter\n    return fixer.replaceText(lastToken, token);\n  };\n};\nexports.default = util.createRule({\n  name: 'member-delimiter-style',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require a specific member delimiter style for interfaces and type literals',\n      recommended: false\n    },\n    fixable: 'whitespace',\n    messages: {\n      unexpectedComma: 'Unexpected separator (,).',\n      unexpectedSemi: 'Unexpected separator (;).',\n      expectedComma: 'Expected a comma.',\n      expectedSemi: 'Expected a semicolon.'\n    },\n    schema: [{\n      type: 'object',\n      properties: Object.assign({}, definition.properties, {\n        overrides: {\n          type: 'object',\n          properties: {\n            interface: definition,\n            typeLiteral: definition\n          },\n          additionalProperties: false\n        },\n        multilineDetection: {\n          enum: ['brackets', 'last-member']\n        }\n      }),\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    multiline: {\n      delimiter: 'semi',\n      requireLast: true\n    },\n    singleline: {\n      delimiter: 'semi',\n      requireLast: false\n    },\n    multilineDetection: 'brackets'\n  }],\n  create(context, [options]) {\n    var _a;\n    const sourceCode = context.getSourceCode();\n    // use the base options as the defaults for the cases\n    const baseOptions = options;\n    const overrides = (_a = baseOptions.overrides) !== null && _a !== void 0 ? _a : {};\n    const interfaceOptions = util.deepMerge(baseOptions, overrides.interface);\n    const typeLiteralOptions = util.deepMerge(baseOptions, overrides.typeLiteral);\n    /**\n     * Check the last token in the given member.\n     * @param member the member to be evaluated.\n     * @param opts the options to be validated.\n     * @param isLast a flag indicating `member` is the last in the interface or type literal.\n     */\n    function checkLastToken(member, opts, isLast) {\n      /**\n       * Resolves the boolean value for the given setting enum value\n       * @param type the option name\n       */\n      function getOption(type) {\n        if (isLast && !opts.requireLast) {\n          // only turn the option on if its expecting no delimiter for the last member\n          return type === 'none';\n        }\n        return opts.delimiter === type;\n      }\n      let messageId = null;\n      let missingDelimiter = false;\n      const lastToken = sourceCode.getLastToken(member, {\n        includeComments: false\n      });\n      if (!lastToken) {\n        return;\n      }\n      const commentsAfterLastToken = sourceCode.getCommentsAfter(lastToken).pop();\n      const sourceCodeLines = sourceCode.getLines();\n      const lastTokenLine = sourceCodeLines[(lastToken === null || lastToken === void 0 ? void 0 : lastToken.loc.start.line) - 1];\n      const optsSemi = getOption('semi');\n      const optsComma = getOption('comma');\n      const optsNone = getOption('none');\n      if (lastToken.value === ';') {\n        if (optsComma) {\n          messageId = 'expectedComma';\n        } else if (optsNone) {\n          missingDelimiter = true;\n          messageId = 'unexpectedSemi';\n        }\n      } else if (lastToken.value === ',') {\n        if (optsSemi) {\n          messageId = 'expectedSemi';\n        } else if (optsNone) {\n          missingDelimiter = true;\n          messageId = 'unexpectedComma';\n        }\n      } else {\n        if (optsSemi) {\n          missingDelimiter = true;\n          messageId = 'expectedSemi';\n        } else if (optsComma) {\n          missingDelimiter = true;\n          messageId = 'expectedComma';\n        }\n      }\n      if (messageId) {\n        context.report({\n          node: lastToken,\n          loc: {\n            start: {\n              line: lastToken.loc.end.line,\n              column: lastToken.loc.end.column\n            },\n            end: {\n              line: lastToken.loc.end.line,\n              column: lastToken.loc.end.column\n            }\n          },\n          messageId,\n          fix: makeFixFunction({\n            optsNone,\n            optsSemi,\n            lastToken,\n            commentsAfterLastToken,\n            missingDelimiter,\n            lastTokenLine,\n            isSingleLine: opts.type === 'single-line'\n          })\n        });\n      }\n    }\n    /**\n     * Check the member separator being used matches the delimiter.\n     * @param {ASTNode} node the node to be evaluated.\n     */\n    function checkMemberSeparatorStyle(node) {\n      const members = node.type === utils_1.AST_NODE_TYPES.TSInterfaceBody ? node.body : node.members;\n      let isSingleLine = node.loc.start.line === node.loc.end.line;\n      if (options.multilineDetection === 'last-member' && !isSingleLine && members.length > 0) {\n        const lastMember = members[members.length - 1];\n        if (lastMember.loc.end.line === node.loc.end.line) {\n          isSingleLine = true;\n        }\n      }\n      const typeOpts = node.type === utils_1.AST_NODE_TYPES.TSInterfaceBody ? interfaceOptions : typeLiteralOptions;\n      const opts = isSingleLine ? Object.assign(Object.assign({}, typeOpts.singleline), {\n        type: 'single-line'\n      }) : Object.assign(Object.assign({}, typeOpts.multiline), {\n        type: 'multi-line'\n      });\n      members.forEach((member, index) => {\n        checkLastToken(member, opts !== null && opts !== void 0 ? opts : {}, index === members.length - 1);\n      });\n    }\n    return {\n      TSInterfaceBody: checkMemberSeparatorStyle,\n      TSTypeLiteral: checkMemberSeparatorStyle\n    };\n  }\n});","map":{"version":3,"names":["utils_1","require","util","__importStar","definition","type","properties","multiline","delimiter","enum","requireLast","additionalProperties","singleline","isLastTokenEndOfLine","token","line","positionInLine","loc","start","column","length","isCommentsEndOfLine","comments","end","makeFixFunction","optsNone","optsSemi","lastToken","commentsAfterLastToken","missingDelimiter","lastTokenLine","isSingleLine","fixer","remove","insertTextAfter","replaceText","exports","default","createRule","name","meta","docs","description","recommended","fixable","messages","unexpectedComma","unexpectedSemi","expectedComma","expectedSemi","schema","Object","assign","overrides","interface","typeLiteral","multilineDetection","defaultOptions","create","context","options","sourceCode","getSourceCode","baseOptions","_a","interfaceOptions","deepMerge","typeLiteralOptions","checkLastToken","member","opts","isLast","getOption","messageId","getLastToken","includeComments","getCommentsAfter","pop","sourceCodeLines","getLines","optsComma","value","report","node","fix","checkMemberSeparatorStyle","members","AST_NODE_TYPES","TSInterfaceBody","body","lastMember","typeOpts","forEach","index","TSTypeLiteral"],"sources":["../../src/rules/member-delimiter-style.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}