{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n  return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);\n}\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n  return applyContext.callback(applyContext.processedTokens);\n}\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n  return metadata[2];\n}\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  }\n  if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  }\n  // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n  // it is rebased to be consistent with rebasing other URIs\n  // however here we need to resolve it back to read it from disk\n  absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n  sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n  if (sourceMap) {\n    rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n    return whenSourceMapReady(rebasedMap);\n  }\n  return whenSourceMapReady(null);\n}\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n  var buffer = Buffer.from(data, encoding);\n  buffer.charset = charset;\n  return JSON.parse(buffer.toString());\n}\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  }\n  if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  }\n  if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n    whenLoaded(body);\n  });\n}\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  }\n  if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n  if (!fs.statSync(uri).size) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is empty.');\n    return null;\n  }\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n  return tokens;\n}\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n  token[2] = newMetadata;\n}\nmodule.exports = applySourceMaps;","map":{"version":3,"names":["fs","require","path","isAllowedResource","matchDataUri","rebaseLocalMap","rebaseRemoteMap","Token","hasProtocol","isDataUriResource","isRemoteResource","MAP_MARKER_PATTERN","applySourceMaps","tokens","context","callback","applyContext","fetch","options","index","inline","inlineRequest","inlineTimeout","inputSourceMapTracker","localOnly","processedTokens","rebaseTo","sourceTokens","warnings","sourceMap","length","doApplySourceMaps","singleSourceTokens","lastSource","findTokenSource","source","token","l","push","COMMENT","test","fetchAndApplySourceMap","scope","metadata","AT_RULE","RAW","sourceMapComment","extractInputSourceMapFrom","inputSourceMap","track","applySourceMapRecursively","whenSourceMapReady","uri","exec","absoluteUri","rebasedMap","extractInputSourceMapFromDataUri","loadInputSourceMapFromRemoteUri","parsedMap","JSON","parse","resolve","loadInputSourceMapFromLocalUri","dataUriMatch","charset","split","encoding","data","global","unescape","buffer","Buffer","from","toString","whenLoaded","isAllowed","isRuntimeResource","error","body","existsSync","statSync","isFile","size","readFileSync","i","applySourceMapTo","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY","PROPERTY_BLOCK","PROPERTY_NAME","PROPERTY_VALUE","RULE","RULE_SCOPE","value","newMetadata","originalPositionFor","module","exports"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/clean-css/lib/reader/apply-source-maps.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0\n    ? doApplySourceMaps(applyContext)\n    : callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function(inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function(sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  }\n  // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n  // it is rebased to be consistent with rebasing other URIs\n  // however here we need to resolve it back to read it from disk\n  absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n  sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n  if (sourceMap) {\n    rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n    return whenSourceMapReady(rebasedMap);\n  }\n  return whenSourceMapReady(null);\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = Buffer.from(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function(error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  } if (!fs.statSync(uri).size) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is empty.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n    case Token.AT_RULE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.AT_RULE_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.AT_RULE_BLOCK_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.NESTED_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.NESTED_BLOCK_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.COMMENT:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY:\n      applySourceMapRecursively(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_NAME:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_VALUE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.RULE:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.RULE_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}