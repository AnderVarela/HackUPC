{"ast":null,"code":"'use strict';\n\n/*eslint-disable no-bitwise*/\nvar Type = require('../type');\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n    idx,\n    bitlen = 0,\n    max = data.length,\n    map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n  var idx,\n    tailbits,\n    input = data.replace(/[\\r\\n=]/g, ''),\n    // remove CR/LF & padding to simplify scan\n    max = input.length,\n    map = BASE64_MAP,\n    bits = 0,\n    result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = max % 4 * 6;\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  }\n  return new Uint8Array(result);\n}\nfunction representYamlBinary(object /*, style*/) {\n  var result = '',\n    bits = 0,\n    idx,\n    tail,\n    max = object.length,\n    map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n  return result;\n}\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) === '[object Uint8Array]';\n}\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});","map":{"version":3,"names":["Type","require","BASE64_MAP","resolveYamlBinary","data","code","idx","bitlen","max","length","map","indexOf","charAt","constructYamlBinary","tailbits","input","replace","bits","result","push","Uint8Array","representYamlBinary","object","tail","isBinary","obj","Object","prototype","toString","call","module","exports","kind","resolve","construct","predicate","represent"],"sources":["C:/Users/chest/OneDrive/Documentos/GitHub/HackUPC/frontend/node_modules/@eslint/eslintrc/node_modules/js-yaml/lib/type/binary.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}